import {
  __commonJS
} from "./chunk-XNHBATJA.js";

// node_modules/percentile/lib/index.js
var require_lib = __commonJS({
  "node_modules/percentile/lib/index.js"(exports, module) {
    function lessThanZeroError(p) {
      return 'Expect percentile to be >= 0 but given "' + p + '" and its type is "' + typeof p + '".';
    }
    function greaterThanHundredError(p) {
      return 'Expect percentile to be <= 100 but given "' + p + '" and its type is "' + typeof p + '".';
    }
    function nanError(p) {
      return 'Expect percentile to be a number but given "' + p + '" and its type is "' + typeof p + '".';
    }
    function validateInput(ps) {
      return ps.reduce(function(errors, p) {
        if (isNaN(Number(p))) {
          errors.push(nanError(p));
        } else if (p < 0) {
          errors.push(lessThanZeroError(p));
        } else if (p > 100) {
          errors.push(greaterThanHundredError(p));
        }
        return errors;
      }, []);
    }
    function getPsValue(p, list) {
      if (p === 0)
        return list[0];
      var kIndex = Math.ceil(list.length * (p / 100)) - 1;
      return list[kIndex];
    }
    function percentile(pOrPs, list, fn) {
      var ps = Array.isArray(pOrPs) ? pOrPs : [pOrPs];
      var validationErrors = validateInput(ps);
      if (validationErrors.length) {
        throw new Error(validationErrors.join(" "));
      }
      list = list.slice().sort(function(a, b) {
        if (fn) {
          a = fn(a);
          b = fn(b);
        }
        a = Number.isNaN(a) ? Number.NEGATIVE_INFINITY : a;
        b = Number.isNaN(b) ? Number.NEGATIVE_INFINITY : b;
        if (a > b)
          return 1;
        if (a < b)
          return -1;
        return 0;
      });
      if (ps.length === 1) {
        return getPsValue(ps[0], list);
      }
      return ps.map(function(p) {
        return getPsValue(p, list);
      });
    }
    module.exports = percentile;
  }
});
export default require_lib();
//# sourceMappingURL=percentile.js.map
