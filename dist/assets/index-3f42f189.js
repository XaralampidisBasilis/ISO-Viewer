var dR=Object.defineProperty;var hR=(n,e,t)=>e in n?dR(n,e,{enumerable:!0,configurable:!0,writable:!0,value:t}):n[e]=t;var re=(n,e,t)=>(hR(n,typeof e!="symbol"?e+"":e,t),t);function pR(n,e){for(var t=0;t<e.length;t++){const r=e[t];if(typeof r!="string"&&!Array.isArray(r)){for(const i in r)if(i!=="default"&&!(i in n)){const s=Object.getOwnPropertyDescriptor(r,i);s&&Object.defineProperty(n,i,s.get?s:{enumerable:!0,get:()=>r[i]})}}}return Object.freeze(Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const a of s.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function t(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(i){if(i.ep)return;i.ep=!0;const s=t(i);fetch(i.href,s)}})();/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const jx="169",_i={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Cc={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},mR=0,Oy=1,vR=2,Yw=1,gR=2,Ds=3,Ws=0,Ir=1,$i=2,Sa=0,Lc=1,zy=2,Py=3,Fy=4,xR=5,co=100,bR=101,_R=102,yR=103,wR=104,ER=200,SR=201,TR=202,AR=203,ag=204,og=205,CR=206,IR=207,MR=208,RR=209,NR=210,kR=211,DR=212,LR=213,OR=214,cg=0,lg=1,ug=2,Gc=3,fg=4,dg=5,hg=6,pg=7,Zw=0,zR=1,PR=2,Ta=0,FR=1,$R=2,UR=3,BR=4,VR=5,GR=6,HR=7,$y="attached",WR="detached",Qw=300,Hc=301,Wc=302,mg=303,vg=304,pp=306,qc=1e3,Fs=1001,Eh=1002,cn=1003,Jw=1004,ou=1005,Rn=1006,uh=1007,$s=1008,yi=1009,eE=1010,tE=1011,wo=1012,Yx=1013,Eo=1014,pi=1015,Us=1016,Zx=1017,Qx=1018,Xc=1020,nE=35902,rE=1021,iE=1022,Jr=1023,sE=1024,aE=1025,Oc=1026,Kc=1027,mp=1028,po=1029,Jx=1030,e0=1031,t0=1033,fh=33776,dh=33777,hh=33778,ph=33779,gg=35840,xg=35841,bg=35842,_g=35843,yg=36196,wg=37492,Eg=37496,Sg=37808,Tg=37809,Ag=37810,Cg=37811,Ig=37812,Mg=37813,Rg=37814,Ng=37815,kg=37816,Dg=37817,Lg=37818,Og=37819,zg=37820,Pg=37821,mh=36492,Fg=36494,$g=36495,oE=36283,Ug=36284,Bg=36285,Vg=36286,_u=2300,yu=2301,Zm=2302,Uy=2400,By=2401,Vy=2402,qR=2500,XR=0,cE=1,Gg=2,KR=3200,jR=3201,lE=0,YR=1,ga="",Xn="srgb",rr="srgb-linear",n0="display-p3",vp="display-p3-linear",Sh="linear",on="srgb",Th="rec709",Ah="p3",rc=7680,Gy=519,ZR=512,QR=513,JR=514,uE=515,eN=516,tN=517,nN=518,rN=519,Hg=35044,Wg="300 es",Bs=2e3,Ch=2001;class Bo{addEventListener(e,t){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[e]===void 0&&(r[e]=[]),r[e].indexOf(t)===-1&&r[e].push(t)}hasEventListener(e,t){if(this._listeners===void 0)return!1;const r=this._listeners;return r[e]!==void 0&&r[e].indexOf(t)!==-1}removeEventListener(e,t){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(t);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const r=this._listeners[e.type];if(r!==void 0){e.target=this;const i=r.slice(0);for(let s=0,a=i.length;s<a;s++)i[s].call(this,e);e.target=null}}}const ur=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let Hy=1234567;const mu=Math.PI/180,jc=180/Math.PI;function Gi(){const n=Math.random()*4294967295|0,e=Math.random()*4294967295|0,t=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(ur[n&255]+ur[n>>8&255]+ur[n>>16&255]+ur[n>>24&255]+"-"+ur[e&255]+ur[e>>8&255]+"-"+ur[e>>16&15|64]+ur[e>>24&255]+"-"+ur[t&63|128]+ur[t>>8&255]+"-"+ur[t>>16&255]+ur[t>>24&255]+ur[r&255]+ur[r>>8&255]+ur[r>>16&255]+ur[r>>24&255]).toLowerCase()}function tr(n,e,t){return Math.max(e,Math.min(t,n))}function r0(n,e){return(n%e+e)%e}function iN(n,e,t,r,i){return r+(n-e)*(i-r)/(t-e)}function sN(n,e,t){return n!==e?(t-n)/(e-n):0}function vu(n,e,t){return(1-t)*n+t*e}function aN(n,e,t,r){return vu(n,e,1-Math.exp(-t*r))}function oN(n,e=1){return e-Math.abs(r0(n,e*2)-e)}function cN(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*(3-2*n))}function lN(n,e,t){return n<=e?0:n>=t?1:(n=(n-e)/(t-e),n*n*n*(n*(n*6-15)+10))}function uN(n,e){return n+Math.floor(Math.random()*(e-n+1))}function fN(n,e){return n+Math.random()*(e-n)}function dN(n){return n*(.5-Math.random())}function hN(n){n!==void 0&&(Hy=n);let e=Hy+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function pN(n){return n*mu}function mN(n){return n*jc}function vN(n){return(n&n-1)===0&&n!==0}function gN(n){return Math.pow(2,Math.ceil(Math.log(n)/Math.LN2))}function xN(n){return Math.pow(2,Math.floor(Math.log(n)/Math.LN2))}function bN(n,e,t,r,i){const s=Math.cos,a=Math.sin,o=s(t/2),c=a(t/2),l=s((e+r)/2),u=a((e+r)/2),f=s((e-r)/2),d=a((e-r)/2),h=s((r-e)/2),p=a((r-e)/2);switch(i){case"XYX":n.set(o*u,c*f,c*d,o*l);break;case"YZY":n.set(c*d,o*u,c*f,o*l);break;case"ZXZ":n.set(c*f,c*d,o*u,o*l);break;case"XZX":n.set(o*u,c*p,c*h,o*l);break;case"YXY":n.set(c*h,o*u,c*p,o*l);break;case"ZYZ":n.set(c*p,c*h,o*u,o*l);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Ui(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return n/4294967295;case Uint16Array:return n/65535;case Uint8Array:return n/255;case Int32Array:return Math.max(n/2147483647,-1);case Int16Array:return Math.max(n/32767,-1);case Int8Array:return Math.max(n/127,-1);default:throw new Error("Invalid component type.")}}function Xt(n,e){switch(e.constructor){case Float32Array:return n;case Uint32Array:return Math.round(n*4294967295);case Uint16Array:return Math.round(n*65535);case Uint8Array:return Math.round(n*255);case Int32Array:return Math.round(n*2147483647);case Int16Array:return Math.round(n*32767);case Int8Array:return Math.round(n*127);default:throw new Error("Invalid component type.")}}const Ih={DEG2RAD:mu,RAD2DEG:jc,generateUUID:Gi,clamp:tr,euclideanModulo:r0,mapLinear:iN,inverseLerp:sN,lerp:vu,damp:aN,pingpong:oN,smoothstep:cN,smootherstep:lN,randInt:uN,randFloat:fN,randFloatSpread:dN,seededRandom:hN,degToRad:pN,radToDeg:mN,isPowerOfTwo:vN,ceilPowerOfTwo:gN,floorPowerOfTwo:xN,setQuaternionFromProperEuler:bN,normalize:Xt,denormalize:Ui};class Ye{constructor(e=0,t=0){Ye.prototype.isVector2=!0,this.x=e,this.y=t}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,t){return this.x=e,this.y=t,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const t=this.x,r=this.y,i=e.elements;return this.x=i[0]*t+i[3]*r+i[6],this.y=i[1]*t+i[4]*r+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(tr(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y;return t*t+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this}rotateAround(e,t){const r=Math.cos(t),i=Math.sin(t),s=this.x-e.x,a=this.y-e.y;return this.x=s*r-a*i+e.x,this.y=s*i+a*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class yt{constructor(e,t,r,i,s,a,o,c,l){yt.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,t,r,i,s,a,o,c,l)}set(e,t,r,i,s,a,o,c,l){const u=this.elements;return u[0]=e,u[1]=i,u[2]=o,u[3]=t,u[4]=s,u[5]=c,u[6]=r,u[7]=a,u[8]=l,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],this}extractBasis(e,t,r){return e.setFromMatrix3Column(this,0),t.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const t=e.elements;return this.set(t[0],t[4],t[8],t[1],t[5],t[9],t[2],t[6],t[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,i=t.elements,s=this.elements,a=r[0],o=r[3],c=r[6],l=r[1],u=r[4],f=r[7],d=r[2],h=r[5],p=r[8],g=i[0],m=i[3],v=i[6],x=i[1],b=i[4],_=i[7],w=i[2],E=i[5],S=i[8];return s[0]=a*g+o*x+c*w,s[3]=a*m+o*b+c*E,s[6]=a*v+o*_+c*S,s[1]=l*g+u*x+f*w,s[4]=l*m+u*b+f*E,s[7]=l*v+u*_+f*S,s[2]=d*g+h*x+p*w,s[5]=d*m+h*b+p*E,s[8]=d*v+h*_+p*S,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[3]*=e,t[6]*=e,t[1]*=e,t[4]*=e,t[7]*=e,t[2]*=e,t[5]*=e,t[8]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],a=e[4],o=e[5],c=e[6],l=e[7],u=e[8];return t*a*u-t*o*l-r*s*u+r*o*c+i*s*l-i*a*c}invert(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],a=e[4],o=e[5],c=e[6],l=e[7],u=e[8],f=u*a-o*l,d=o*c-u*s,h=l*s-a*c,p=t*f+r*d+i*h;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const g=1/p;return e[0]=f*g,e[1]=(i*l-u*r)*g,e[2]=(o*r-i*a)*g,e[3]=d*g,e[4]=(u*t-i*c)*g,e[5]=(i*s-o*t)*g,e[6]=h*g,e[7]=(r*c-l*t)*g,e[8]=(a*t-r*s)*g,this}transpose(){let e;const t=this.elements;return e=t[1],t[1]=t[3],t[3]=e,e=t[2],t[2]=t[6],t[6]=e,e=t[5],t[5]=t[7],t[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const t=this.elements;return e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8],this}setUvTransform(e,t,r,i,s,a,o){const c=Math.cos(s),l=Math.sin(s);return this.set(r*c,r*l,-r*(c*a+l*o)+a+e,-i*l,i*c,-i*(-l*a+c*o)+o+t,0,0,1),this}scale(e,t){return this.premultiply(Qm.makeScale(e,t)),this}rotate(e){return this.premultiply(Qm.makeRotation(-e)),this}translate(e,t){return this.premultiply(Qm.makeTranslation(e,t)),this}makeTranslation(e,t){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,t,0,0,1),this}makeRotation(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,r,t,0,0,0,1),this}makeScale(e,t){return this.set(e,0,0,0,t,0,0,0,1),this}equals(e){const t=this.elements,r=e.elements;for(let i=0;i<9;i++)if(t[i]!==r[i])return!1;return!0}fromArray(e,t=0){for(let r=0;r<9;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const Qm=new yt;function fE(n){for(let e=n.length-1;e>=0;--e)if(n[e]>=65535)return!0;return!1}function wu(n){return document.createElementNS("http://www.w3.org/1999/xhtml",n)}function _N(){const n=wu("canvas");return n.style.display="block",n}const Wy={};function vh(n){n in Wy||(Wy[n]=!0,console.warn(n))}function yN(n,e,t){return new Promise(function(r,i){function s(){switch(n.clientWaitSync(e,n.SYNC_FLUSH_COMMANDS_BIT,0)){case n.WAIT_FAILED:i();break;case n.TIMEOUT_EXPIRED:setTimeout(s,t);break;default:r()}}setTimeout(s,t)})}function wN(n){const e=n.elements;e[2]=.5*e[2]+.5*e[3],e[6]=.5*e[6]+.5*e[7],e[10]=.5*e[10]+.5*e[11],e[14]=.5*e[14]+.5*e[15]}function EN(n){const e=n.elements;e[11]===-1?(e[10]=-e[10]-1,e[14]=-e[14]):(e[10]=-e[10],e[14]=-e[14]+1)}const qy=new yt().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),Xy=new yt().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),Xl={[rr]:{transfer:Sh,primaries:Th,luminanceCoefficients:[.2126,.7152,.0722],toReference:n=>n,fromReference:n=>n},[Xn]:{transfer:on,primaries:Th,luminanceCoefficients:[.2126,.7152,.0722],toReference:n=>n.convertSRGBToLinear(),fromReference:n=>n.convertLinearToSRGB()},[vp]:{transfer:Sh,primaries:Ah,luminanceCoefficients:[.2289,.6917,.0793],toReference:n=>n.applyMatrix3(Xy),fromReference:n=>n.applyMatrix3(qy)},[n0]:{transfer:on,primaries:Ah,luminanceCoefficients:[.2289,.6917,.0793],toReference:n=>n.convertSRGBToLinear().applyMatrix3(Xy),fromReference:n=>n.applyMatrix3(qy).convertLinearToSRGB()}},SN=new Set([rr,vp]),Lt={enabled:!0,_workingColorSpace:rr,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(n){if(!SN.has(n))throw new Error(`Unsupported working color space, "${n}".`);this._workingColorSpace=n},convert:function(n,e,t){if(this.enabled===!1||e===t||!e||!t)return n;const r=Xl[e].toReference,i=Xl[t].fromReference;return i(r(n))},fromWorkingColorSpace:function(n,e){return this.convert(n,this._workingColorSpace,e)},toWorkingColorSpace:function(n,e){return this.convert(n,e,this._workingColorSpace)},getPrimaries:function(n){return Xl[n].primaries},getTransfer:function(n){return n===ga?Sh:Xl[n].transfer},getLuminanceCoefficients:function(n,e=this._workingColorSpace){return n.fromArray(Xl[e].luminanceCoefficients)}};function zc(n){return n<.04045?n*.0773993808:Math.pow(n*.9478672986+.0521327014,2.4)}function Jm(n){return n<.0031308?n*12.92:1.055*Math.pow(n,.41666)-.055}let ic;class TN{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let t;if(e instanceof HTMLCanvasElement)t=e;else{ic===void 0&&(ic=wu("canvas")),ic.width=e.width,ic.height=e.height;const r=ic.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),t=ic}return t.width>2048||t.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),t.toDataURL("image/jpeg",.6)):t.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const t=wu("canvas");t.width=e.width,t.height=e.height;const r=t.getContext("2d");r.drawImage(e,0,0,e.width,e.height);const i=r.getImageData(0,0,e.width,e.height),s=i.data;for(let a=0;a<s.length;a++)s[a]=zc(s[a]/255)*255;return r.putImageData(i,0,0),t}else if(e.data){const t=e.data.slice(0);for(let r=0;r<t.length;r++)t instanceof Uint8Array||t instanceof Uint8ClampedArray?t[r]=Math.floor(zc(t[r]/255)*255):t[r]=zc(t[r]);return{data:t,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let AN=0;class dE{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:AN++}),this.uuid=Gi(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const r={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let a=0,o=i.length;a<o;a++)i[a].isDataTexture?s.push(ev(i[a].image)):s.push(ev(i[a]))}else s=ev(i);r.url=s}return t||(e.images[this.uuid]=r),r}}function ev(n){return typeof HTMLImageElement<"u"&&n instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&n instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&n instanceof ImageBitmap?TN.getDataURL(n):n.data?{data:Array.from(n.data),width:n.width,height:n.height,type:n.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let CN=0;class Vn extends Bo{constructor(e=Vn.DEFAULT_IMAGE,t=Vn.DEFAULT_MAPPING,r=Fs,i=Fs,s=Rn,a=$s,o=Jr,c=yi,l=Vn.DEFAULT_ANISOTROPY,u=ga){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:CN++}),this.uuid=Gi(),this.name="",this.source=new dE(e),this.mipmaps=[],this.mapping=t,this.channel=0,this.wrapS=r,this.wrapT=i,this.magFilter=s,this.minFilter=a,this.anisotropy=l,this.format=o,this.internalFormat=null,this.type=c,this.offset=new Ye(0,0),this.repeat=new Ye(1,1),this.center=new Ye(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new yt,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const t=e===void 0||typeof e=="string";if(!t&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const r={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(r.userData=this.userData),t||(e.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==Qw)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case qc:e.x=e.x-Math.floor(e.x);break;case Fs:e.x=e.x<0?0:1;break;case Eh:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case qc:e.y=e.y-Math.floor(e.y);break;case Fs:e.y=e.y<0?0:1;break;case Eh:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}Vn.DEFAULT_IMAGE=null;Vn.DEFAULT_MAPPING=Qw;Vn.DEFAULT_ANISOTROPY=1;class Bt{constructor(e=0,t=0,r=0,i=1){Bt.prototype.isVector4=!0,this.x=e,this.y=t,this.z=r,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,t,r,i){return this.x=e,this.y=t,this.z=r,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;case 3:this.w=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this.w=e.w+t.w,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this.w+=e.w*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this.w=e.w-t.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const t=this.x,r=this.y,i=this.z,s=this.w,a=e.elements;return this.x=a[0]*t+a[4]*r+a[8]*i+a[12]*s,this.y=a[1]*t+a[5]*r+a[9]*i+a[13]*s,this.z=a[2]*t+a[6]*r+a[10]*i+a[14]*s,this.w=a[3]*t+a[7]*r+a[11]*i+a[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const t=Math.sqrt(1-e.w*e.w);return t<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/t,this.y=e.y/t,this.z=e.z/t),this}setAxisAngleFromRotationMatrix(e){let t,r,i,s;const c=e.elements,l=c[0],u=c[4],f=c[8],d=c[1],h=c[5],p=c[9],g=c[2],m=c[6],v=c[10];if(Math.abs(u-d)<.01&&Math.abs(f-g)<.01&&Math.abs(p-m)<.01){if(Math.abs(u+d)<.1&&Math.abs(f+g)<.1&&Math.abs(p+m)<.1&&Math.abs(l+h+v-3)<.1)return this.set(1,0,0,0),this;t=Math.PI;const b=(l+1)/2,_=(h+1)/2,w=(v+1)/2,E=(u+d)/4,S=(f+g)/4,T=(p+m)/4;return b>_&&b>w?b<.01?(r=0,i=.707106781,s=.707106781):(r=Math.sqrt(b),i=E/r,s=S/r):_>w?_<.01?(r=.707106781,i=0,s=.707106781):(i=Math.sqrt(_),r=E/i,s=T/i):w<.01?(r=.707106781,i=.707106781,s=0):(s=Math.sqrt(w),r=S/s,i=T/s),this.set(r,i,s,t),this}let x=Math.sqrt((m-p)*(m-p)+(f-g)*(f-g)+(d-u)*(d-u));return Math.abs(x)<.001&&(x=1),this.x=(m-p)/x,this.y=(f-g)/x,this.z=(d-u)/x,this.w=Math.acos((l+h+v-1)/2),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this.w=t[15],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this.w=Math.max(e.w,Math.min(t.w,this.w)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this.w=Math.max(e,Math.min(t,this.w)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this.w+=(e.w-this.w)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this.w=e.w+(t.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this.w=e[t+3],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e[t+3]=this.w,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this.w=e.getW(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class IN extends Bo{constructor(e=1,t=1,r={}){super(),this.isRenderTarget=!0,this.width=e,this.height=t,this.depth=1,this.scissor=new Bt(0,0,e,t),this.scissorTest=!1,this.viewport=new Bt(0,0,e,t);const i={width:e,height:t,depth:1};r=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:Rn,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1},r);const s=new Vn(i,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.colorSpace);s.flipY=!1,s.generateMipmaps=r.generateMipmaps,s.internalFormat=r.internalFormat,this.textures=[];const a=r.count;for(let o=0;o<a;o++)this.textures[o]=s.clone(),this.textures[o].isRenderTargetTexture=!0;this.depthBuffer=r.depthBuffer,this.stencilBuffer=r.stencilBuffer,this.resolveDepthBuffer=r.resolveDepthBuffer,this.resolveStencilBuffer=r.resolveStencilBuffer,this.depthTexture=r.depthTexture,this.samples=r.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}setSize(e,t,r=1){if(this.width!==e||this.height!==t||this.depth!==r){this.width=e,this.height=t,this.depth=r;for(let i=0,s=this.textures.length;i<s;i++)this.textures[i].image.width=e,this.textures[i].image.height=t,this.textures[i].image.depth=r;this.dispose()}this.viewport.set(0,0,e,t),this.scissor.set(0,0,e,t)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let r=0,i=e.textures.length;r<i;r++)this.textures[r]=e.textures[r].clone(),this.textures[r].isRenderTargetTexture=!0;const t=Object.assign({},e.texture.image);return this.texture.source=new dE(t),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,this.resolveDepthBuffer=e.resolveDepthBuffer,this.resolveStencilBuffer=e.resolveStencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class So extends IN{constructor(e=1,t=1,r={}){super(e,t,r),this.isWebGLRenderTarget=!0}}class hE extends Vn{constructor(e=null,t=1,r=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:t,height:r,depth:i},this.magFilter=cn,this.minFilter=cn,this.wrapR=Fs,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(e){this.layerUpdates.add(e)}clearLayerUpdates(){this.layerUpdates.clear()}}class pE extends Vn{constructor(e=null,t=1,r=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:t,height:r,depth:i},this.magFilter=cn,this.minFilter=cn,this.wrapR=Fs,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Xi{constructor(e=0,t=0,r=0,i=1){this.isQuaternion=!0,this._x=e,this._y=t,this._z=r,this._w=i}static slerpFlat(e,t,r,i,s,a,o){let c=r[i+0],l=r[i+1],u=r[i+2],f=r[i+3];const d=s[a+0],h=s[a+1],p=s[a+2],g=s[a+3];if(o===0){e[t+0]=c,e[t+1]=l,e[t+2]=u,e[t+3]=f;return}if(o===1){e[t+0]=d,e[t+1]=h,e[t+2]=p,e[t+3]=g;return}if(f!==g||c!==d||l!==h||u!==p){let m=1-o;const v=c*d+l*h+u*p+f*g,x=v>=0?1:-1,b=1-v*v;if(b>Number.EPSILON){const w=Math.sqrt(b),E=Math.atan2(w,v*x);m=Math.sin(m*E)/w,o=Math.sin(o*E)/w}const _=o*x;if(c=c*m+d*_,l=l*m+h*_,u=u*m+p*_,f=f*m+g*_,m===1-o){const w=1/Math.sqrt(c*c+l*l+u*u+f*f);c*=w,l*=w,u*=w,f*=w}}e[t]=c,e[t+1]=l,e[t+2]=u,e[t+3]=f}static multiplyQuaternionsFlat(e,t,r,i,s,a){const o=r[i],c=r[i+1],l=r[i+2],u=r[i+3],f=s[a],d=s[a+1],h=s[a+2],p=s[a+3];return e[t]=o*p+u*f+c*h-l*d,e[t+1]=c*p+u*d+l*f-o*h,e[t+2]=l*p+u*h+o*d-c*f,e[t+3]=u*p-o*f-c*d-l*h,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,t,r,i){return this._x=e,this._y=t,this._z=r,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,t=!0){const r=e._x,i=e._y,s=e._z,a=e._order,o=Math.cos,c=Math.sin,l=o(r/2),u=o(i/2),f=o(s/2),d=c(r/2),h=c(i/2),p=c(s/2);switch(a){case"XYZ":this._x=d*u*f+l*h*p,this._y=l*h*f-d*u*p,this._z=l*u*p+d*h*f,this._w=l*u*f-d*h*p;break;case"YXZ":this._x=d*u*f+l*h*p,this._y=l*h*f-d*u*p,this._z=l*u*p-d*h*f,this._w=l*u*f+d*h*p;break;case"ZXY":this._x=d*u*f-l*h*p,this._y=l*h*f+d*u*p,this._z=l*u*p+d*h*f,this._w=l*u*f-d*h*p;break;case"ZYX":this._x=d*u*f-l*h*p,this._y=l*h*f+d*u*p,this._z=l*u*p-d*h*f,this._w=l*u*f+d*h*p;break;case"YZX":this._x=d*u*f+l*h*p,this._y=l*h*f+d*u*p,this._z=l*u*p-d*h*f,this._w=l*u*f-d*h*p;break;case"XZY":this._x=d*u*f-l*h*p,this._y=l*h*f-d*u*p,this._z=l*u*p+d*h*f,this._w=l*u*f+d*h*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+a)}return t===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,t){const r=t/2,i=Math.sin(r);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const t=e.elements,r=t[0],i=t[4],s=t[8],a=t[1],o=t[5],c=t[9],l=t[2],u=t[6],f=t[10],d=r+o+f;if(d>0){const h=.5/Math.sqrt(d+1);this._w=.25/h,this._x=(u-c)*h,this._y=(s-l)*h,this._z=(a-i)*h}else if(r>o&&r>f){const h=2*Math.sqrt(1+r-o-f);this._w=(u-c)/h,this._x=.25*h,this._y=(i+a)/h,this._z=(s+l)/h}else if(o>f){const h=2*Math.sqrt(1+o-r-f);this._w=(s-l)/h,this._x=(i+a)/h,this._y=.25*h,this._z=(c+u)/h}else{const h=2*Math.sqrt(1+f-r-o);this._w=(a-i)/h,this._x=(s+l)/h,this._y=(c+u)/h,this._z=.25*h}return this._onChangeCallback(),this}setFromUnitVectors(e,t){let r=e.dot(t)+1;return r<Number.EPSILON?(r=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=r):(this._x=0,this._y=-e.z,this._z=e.y,this._w=r)):(this._x=e.y*t.z-e.z*t.y,this._y=e.z*t.x-e.x*t.z,this._z=e.x*t.y-e.y*t.x,this._w=r),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(tr(this.dot(e),-1,1)))}rotateTowards(e,t){const r=this.angleTo(e);if(r===0)return this;const i=Math.min(1,t/r);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,t){const r=e._x,i=e._y,s=e._z,a=e._w,o=t._x,c=t._y,l=t._z,u=t._w;return this._x=r*u+a*o+i*l-s*c,this._y=i*u+a*c+s*o-r*l,this._z=s*u+a*l+r*c-i*o,this._w=a*u-r*o-i*c-s*l,this._onChangeCallback(),this}slerp(e,t){if(t===0)return this;if(t===1)return this.copy(e);const r=this._x,i=this._y,s=this._z,a=this._w;let o=a*e._w+r*e._x+i*e._y+s*e._z;if(o<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,o=-o):this.copy(e),o>=1)return this._w=a,this._x=r,this._y=i,this._z=s,this;const c=1-o*o;if(c<=Number.EPSILON){const h=1-t;return this._w=h*a+t*this._w,this._x=h*r+t*this._x,this._y=h*i+t*this._y,this._z=h*s+t*this._z,this.normalize(),this}const l=Math.sqrt(c),u=Math.atan2(l,o),f=Math.sin((1-t)*u)/l,d=Math.sin(t*u)/l;return this._w=a*f+this._w*d,this._x=r*f+this._x*d,this._y=i*f+this._y*d,this._z=s*f+this._z*d,this._onChangeCallback(),this}slerpQuaternions(e,t,r){return this.copy(e).slerp(t,r)}random(){const e=2*Math.PI*Math.random(),t=2*Math.PI*Math.random(),r=Math.random(),i=Math.sqrt(1-r),s=Math.sqrt(r);return this.set(i*Math.sin(e),i*Math.cos(e),s*Math.sin(t),s*Math.cos(t))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,t=0){return this._x=e[t],this._y=e[t+1],this._z=e[t+2],this._w=e[t+3],this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._w,e}fromBufferAttribute(e,t){return this._x=e.getX(t),this._y=e.getY(t),this._z=e.getZ(t),this._w=e.getW(t),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class ${constructor(e=0,t=0,r=0){$.prototype.isVector3=!0,this.x=e,this.y=t,this.z=r}set(e,t,r){return r===void 0&&(r=this.z),this.x=e,this.y=t,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,t){switch(e){case 0:this.x=t;break;case 1:this.y=t;break;case 2:this.z=t;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,t){return this.x=e.x+t.x,this.y=e.y+t.y,this.z=e.z+t.z,this}addScaledVector(e,t){return this.x+=e.x*t,this.y+=e.y*t,this.z+=e.z*t,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,t){return this.x=e.x-t.x,this.y=e.y-t.y,this.z=e.z-t.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,t){return this.x=e.x*t.x,this.y=e.y*t.y,this.z=e.z*t.z,this}applyEuler(e){return this.applyQuaternion(Ky.setFromEuler(e))}applyAxisAngle(e,t){return this.applyQuaternion(Ky.setFromAxisAngle(e,t))}applyMatrix3(e){const t=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[3]*r+s[6]*i,this.y=s[1]*t+s[4]*r+s[7]*i,this.z=s[2]*t+s[5]*r+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const t=this.x,r=this.y,i=this.z,s=e.elements,a=1/(s[3]*t+s[7]*r+s[11]*i+s[15]);return this.x=(s[0]*t+s[4]*r+s[8]*i+s[12])*a,this.y=(s[1]*t+s[5]*r+s[9]*i+s[13])*a,this.z=(s[2]*t+s[6]*r+s[10]*i+s[14])*a,this}applyQuaternion(e){const t=this.x,r=this.y,i=this.z,s=e.x,a=e.y,o=e.z,c=e.w,l=2*(a*i-o*r),u=2*(o*t-s*i),f=2*(s*r-a*t);return this.x=t+c*l+a*f-o*u,this.y=r+c*u+o*l-s*f,this.z=i+c*f+s*u-a*l,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const t=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*t+s[4]*r+s[8]*i,this.y=s[1]*t+s[5]*r+s[9]*i,this.z=s[2]*t+s[6]*r+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,t){return this.x=Math.max(e.x,Math.min(t.x,this.x)),this.y=Math.max(e.y,Math.min(t.y,this.y)),this.z=Math.max(e.z,Math.min(t.z,this.z)),this}clampScalar(e,t){return this.x=Math.max(e,Math.min(t,this.x)),this.y=Math.max(e,Math.min(t,this.y)),this.z=Math.max(e,Math.min(t,this.z)),this}clampLength(e,t){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(t,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,t){return this.x+=(e.x-this.x)*t,this.y+=(e.y-this.y)*t,this.z+=(e.z-this.z)*t,this}lerpVectors(e,t,r){return this.x=e.x+(t.x-e.x)*r,this.y=e.y+(t.y-e.y)*r,this.z=e.z+(t.z-e.z)*r,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,t){const r=e.x,i=e.y,s=e.z,a=t.x,o=t.y,c=t.z;return this.x=i*c-s*o,this.y=s*a-r*c,this.z=r*o-i*a,this}projectOnVector(e){const t=e.lengthSq();if(t===0)return this.set(0,0,0);const r=e.dot(this)/t;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return tv.copy(this).projectOnVector(e),this.sub(tv)}reflect(e){return this.sub(tv.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const t=Math.sqrt(this.lengthSq()*e.lengthSq());if(t===0)return Math.PI/2;const r=this.dot(e)/t;return Math.acos(tr(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const t=this.x-e.x,r=this.y-e.y,i=this.z-e.z;return t*t+r*r+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,t,r){const i=Math.sin(t)*e;return this.x=i*Math.sin(r),this.y=Math.cos(t)*e,this.z=i*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,t,r){return this.x=e*Math.sin(t),this.y=r,this.z=e*Math.cos(t),this}setFromMatrixPosition(e){const t=e.elements;return this.x=t[12],this.y=t[13],this.z=t[14],this}setFromMatrixScale(e){const t=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=t,this.y=r,this.z=i,this}setFromMatrixColumn(e,t){return this.fromArray(e.elements,t*4)}setFromMatrix3Column(e,t){return this.fromArray(e.elements,t*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,t=0){return this.x=e[t],this.y=e[t+1],this.z=e[t+2],this}toArray(e=[],t=0){return e[t]=this.x,e[t+1]=this.y,e[t+2]=this.z,e}fromBufferAttribute(e,t){return this.x=e.getX(t),this.y=e.getY(t),this.z=e.getZ(t),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,t=Math.random()*2-1,r=Math.sqrt(1-t*t);return this.x=r*Math.cos(e),this.y=t,this.z=r*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const tv=new $,Ky=new Xi;class Qs{constructor(e=new $(1/0,1/0,1/0),t=new $(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=t}set(e,t){return this.min.copy(e),this.max.copy(t),this}setFromArray(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t+=3)this.expandByPoint(ki.fromArray(e,t));return this}setFromBufferAttribute(e){this.makeEmpty();for(let t=0,r=e.count;t<r;t++)this.expandByPoint(ki.fromBufferAttribute(e,t));return this}setFromPoints(e){this.makeEmpty();for(let t=0,r=e.length;t<r;t++)this.expandByPoint(e[t]);return this}setFromCenterAndSize(e,t){const r=ki.copy(t).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e,t=!1){return this.makeEmpty(),this.expandByObject(e,t)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,t=!1){e.updateWorldMatrix(!1,!1);const r=e.geometry;if(r!==void 0){const s=r.getAttribute("position");if(t===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let a=0,o=s.count;a<o;a++)e.isMesh===!0?e.getVertexPosition(a,ki):ki.fromBufferAttribute(s,a),ki.applyMatrix4(e.matrixWorld),this.expandByPoint(ki);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),xd.copy(e.boundingBox)):(r.boundingBox===null&&r.computeBoundingBox(),xd.copy(r.boundingBox)),xd.applyMatrix4(e.matrixWorld),this.union(xd)}const i=e.children;for(let s=0,a=i.length;s<a;s++)this.expandByObject(i[s],t);return this}containsPoint(e){return e.x>=this.min.x&&e.x<=this.max.x&&e.y>=this.min.y&&e.y<=this.max.y&&e.z>=this.min.z&&e.z<=this.max.z}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,t){return t.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return e.max.x>=this.min.x&&e.min.x<=this.max.x&&e.max.y>=this.min.y&&e.min.y<=this.max.y&&e.max.z>=this.min.z&&e.min.z<=this.max.z}intersectsSphere(e){return this.clampPoint(e.center,ki),ki.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let t,r;return e.normal.x>0?(t=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(t=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(t+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(t+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(t+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(t+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),t<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(Kl),bd.subVectors(this.max,Kl),sc.subVectors(e.a,Kl),ac.subVectors(e.b,Kl),oc.subVectors(e.c,Kl),sa.subVectors(ac,sc),aa.subVectors(oc,ac),Za.subVectors(sc,oc);let t=[0,-sa.z,sa.y,0,-aa.z,aa.y,0,-Za.z,Za.y,sa.z,0,-sa.x,aa.z,0,-aa.x,Za.z,0,-Za.x,-sa.y,sa.x,0,-aa.y,aa.x,0,-Za.y,Za.x,0];return!nv(t,sc,ac,oc,bd)||(t=[1,0,0,0,1,0,0,0,1],!nv(t,sc,ac,oc,bd))?!1:(_d.crossVectors(sa,aa),t=[_d.x,_d.y,_d.z],nv(t,sc,ac,oc,bd))}clampPoint(e,t){return t.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,ki).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(ki).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Cs[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Cs[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Cs[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Cs[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Cs[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Cs[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Cs[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Cs[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Cs),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Cs=[new $,new $,new $,new $,new $,new $,new $,new $],ki=new $,xd=new Qs,sc=new $,ac=new $,oc=new $,sa=new $,aa=new $,Za=new $,Kl=new $,bd=new $,_d=new $,Qa=new $;function nv(n,e,t,r,i){for(let s=0,a=n.length-3;s<=a;s+=3){Qa.fromArray(n,s);const o=i.x*Math.abs(Qa.x)+i.y*Math.abs(Qa.y)+i.z*Math.abs(Qa.z),c=e.dot(Qa),l=t.dot(Qa),u=r.dot(Qa);if(Math.max(-Math.max(c,l,u),Math.min(c,l,u))>o)return!1}return!0}const MN=new Qs,jl=new $,rv=new $;class ys{constructor(e=new $,t=-1){this.isSphere=!0,this.center=e,this.radius=t}set(e,t){return this.center.copy(e),this.radius=t,this}setFromPoints(e,t){const r=this.center;t!==void 0?r.copy(t):MN.setFromPoints(e).getCenter(r);let i=0;for(let s=0,a=e.length;s<a;s++)i=Math.max(i,r.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const t=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=t*t}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,t){const r=this.center.distanceToSquared(e);return t.copy(e),r>this.radius*this.radius&&(t.sub(this.center).normalize(),t.multiplyScalar(this.radius).add(this.center)),t}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;jl.subVectors(e,this.center);const t=jl.lengthSq();if(t>this.radius*this.radius){const r=Math.sqrt(t),i=(r-this.radius)*.5;this.center.addScaledVector(jl,i/r),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(rv.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(jl.copy(e.center).add(rv)),this.expandByPoint(jl.copy(e.center).sub(rv))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Is=new $,iv=new $,yd=new $,oa=new $,sv=new $,wd=new $,av=new $;class vl{constructor(e=new $,t=new $(0,0,-1)){this.origin=e,this.direction=t}set(e,t){return this.origin.copy(e),this.direction.copy(t),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,t){return t.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Is)),this}closestPointToPoint(e,t){t.subVectors(e,this.origin);const r=t.dot(this.direction);return r<0?t.copy(this.origin):t.copy(this.origin).addScaledVector(this.direction,r)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const t=Is.subVectors(e,this.origin).dot(this.direction);return t<0?this.origin.distanceToSquared(e):(Is.copy(this.origin).addScaledVector(this.direction,t),Is.distanceToSquared(e))}distanceSqToSegment(e,t,r,i){iv.copy(e).add(t).multiplyScalar(.5),yd.copy(t).sub(e).normalize(),oa.copy(this.origin).sub(iv);const s=e.distanceTo(t)*.5,a=-this.direction.dot(yd),o=oa.dot(this.direction),c=-oa.dot(yd),l=oa.lengthSq(),u=Math.abs(1-a*a);let f,d,h,p;if(u>0)if(f=a*c-o,d=a*o-c,p=s*u,f>=0)if(d>=-p)if(d<=p){const g=1/u;f*=g,d*=g,h=f*(f+a*d+2*o)+d*(a*f+d+2*c)+l}else d=s,f=Math.max(0,-(a*d+o)),h=-f*f+d*(d+2*c)+l;else d=-s,f=Math.max(0,-(a*d+o)),h=-f*f+d*(d+2*c)+l;else d<=-p?(f=Math.max(0,-(-a*s+o)),d=f>0?-s:Math.min(Math.max(-s,-c),s),h=-f*f+d*(d+2*c)+l):d<=p?(f=0,d=Math.min(Math.max(-s,-c),s),h=d*(d+2*c)+l):(f=Math.max(0,-(a*s+o)),d=f>0?s:Math.min(Math.max(-s,-c),s),h=-f*f+d*(d+2*c)+l);else d=a>0?-s:s,f=Math.max(0,-(a*d+o)),h=-f*f+d*(d+2*c)+l;return r&&r.copy(this.origin).addScaledVector(this.direction,f),i&&i.copy(iv).addScaledVector(yd,d),h}intersectSphere(e,t){Is.subVectors(e.center,this.origin);const r=Is.dot(this.direction),i=Is.dot(Is)-r*r,s=e.radius*e.radius;if(i>s)return null;const a=Math.sqrt(s-i),o=r-a,c=r+a;return c<0?null:o<0?this.at(c,t):this.at(o,t)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const t=e.normal.dot(this.direction);if(t===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/t;return r>=0?r:null}intersectPlane(e,t){const r=this.distanceToPlane(e);return r===null?null:this.at(r,t)}intersectsPlane(e){const t=e.distanceToPoint(this.origin);return t===0||e.normal.dot(this.direction)*t<0}intersectBox(e,t){let r,i,s,a,o,c;const l=1/this.direction.x,u=1/this.direction.y,f=1/this.direction.z,d=this.origin;return l>=0?(r=(e.min.x-d.x)*l,i=(e.max.x-d.x)*l):(r=(e.max.x-d.x)*l,i=(e.min.x-d.x)*l),u>=0?(s=(e.min.y-d.y)*u,a=(e.max.y-d.y)*u):(s=(e.max.y-d.y)*u,a=(e.min.y-d.y)*u),r>a||s>i||((s>r||isNaN(r))&&(r=s),(a<i||isNaN(i))&&(i=a),f>=0?(o=(e.min.z-d.z)*f,c=(e.max.z-d.z)*f):(o=(e.max.z-d.z)*f,c=(e.min.z-d.z)*f),r>c||o>i)||((o>r||r!==r)&&(r=o),(c<i||i!==i)&&(i=c),i<0)?null:this.at(r>=0?r:i,t)}intersectsBox(e){return this.intersectBox(e,Is)!==null}intersectTriangle(e,t,r,i,s){sv.subVectors(t,e),wd.subVectors(r,e),av.crossVectors(sv,wd);let a=this.direction.dot(av),o;if(a>0){if(i)return null;o=1}else if(a<0)o=-1,a=-a;else return null;oa.subVectors(this.origin,e);const c=o*this.direction.dot(wd.crossVectors(oa,wd));if(c<0)return null;const l=o*this.direction.dot(sv.cross(oa));if(l<0||c+l>a)return null;const u=-o*oa.dot(av);return u<0?null:this.at(u/a,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class lt{constructor(e,t,r,i,s,a,o,c,l,u,f,d,h,p,g,m){lt.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,t,r,i,s,a,o,c,l,u,f,d,h,p,g,m)}set(e,t,r,i,s,a,o,c,l,u,f,d,h,p,g,m){const v=this.elements;return v[0]=e,v[4]=t,v[8]=r,v[12]=i,v[1]=s,v[5]=a,v[9]=o,v[13]=c,v[2]=l,v[6]=u,v[10]=f,v[14]=d,v[3]=h,v[7]=p,v[11]=g,v[15]=m,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new lt().fromArray(this.elements)}copy(e){const t=this.elements,r=e.elements;return t[0]=r[0],t[1]=r[1],t[2]=r[2],t[3]=r[3],t[4]=r[4],t[5]=r[5],t[6]=r[6],t[7]=r[7],t[8]=r[8],t[9]=r[9],t[10]=r[10],t[11]=r[11],t[12]=r[12],t[13]=r[13],t[14]=r[14],t[15]=r[15],this}copyPosition(e){const t=this.elements,r=e.elements;return t[12]=r[12],t[13]=r[13],t[14]=r[14],this}setFromMatrix3(e){const t=e.elements;return this.set(t[0],t[3],t[6],0,t[1],t[4],t[7],0,t[2],t[5],t[8],0,0,0,0,1),this}extractBasis(e,t,r){return e.setFromMatrixColumn(this,0),t.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,t,r){return this.set(e.x,t.x,r.x,0,e.y,t.y,r.y,0,e.z,t.z,r.z,0,0,0,0,1),this}extractRotation(e){const t=this.elements,r=e.elements,i=1/cc.setFromMatrixColumn(e,0).length(),s=1/cc.setFromMatrixColumn(e,1).length(),a=1/cc.setFromMatrixColumn(e,2).length();return t[0]=r[0]*i,t[1]=r[1]*i,t[2]=r[2]*i,t[3]=0,t[4]=r[4]*s,t[5]=r[5]*s,t[6]=r[6]*s,t[7]=0,t[8]=r[8]*a,t[9]=r[9]*a,t[10]=r[10]*a,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromEuler(e){const t=this.elements,r=e.x,i=e.y,s=e.z,a=Math.cos(r),o=Math.sin(r),c=Math.cos(i),l=Math.sin(i),u=Math.cos(s),f=Math.sin(s);if(e.order==="XYZ"){const d=a*u,h=a*f,p=o*u,g=o*f;t[0]=c*u,t[4]=-c*f,t[8]=l,t[1]=h+p*l,t[5]=d-g*l,t[9]=-o*c,t[2]=g-d*l,t[6]=p+h*l,t[10]=a*c}else if(e.order==="YXZ"){const d=c*u,h=c*f,p=l*u,g=l*f;t[0]=d+g*o,t[4]=p*o-h,t[8]=a*l,t[1]=a*f,t[5]=a*u,t[9]=-o,t[2]=h*o-p,t[6]=g+d*o,t[10]=a*c}else if(e.order==="ZXY"){const d=c*u,h=c*f,p=l*u,g=l*f;t[0]=d-g*o,t[4]=-a*f,t[8]=p+h*o,t[1]=h+p*o,t[5]=a*u,t[9]=g-d*o,t[2]=-a*l,t[6]=o,t[10]=a*c}else if(e.order==="ZYX"){const d=a*u,h=a*f,p=o*u,g=o*f;t[0]=c*u,t[4]=p*l-h,t[8]=d*l+g,t[1]=c*f,t[5]=g*l+d,t[9]=h*l-p,t[2]=-l,t[6]=o*c,t[10]=a*c}else if(e.order==="YZX"){const d=a*c,h=a*l,p=o*c,g=o*l;t[0]=c*u,t[4]=g-d*f,t[8]=p*f+h,t[1]=f,t[5]=a*u,t[9]=-o*u,t[2]=-l*u,t[6]=h*f+p,t[10]=d-g*f}else if(e.order==="XZY"){const d=a*c,h=a*l,p=o*c,g=o*l;t[0]=c*u,t[4]=-f,t[8]=l*u,t[1]=d*f+g,t[5]=a*u,t[9]=h*f-p,t[2]=p*f-h,t[6]=o*u,t[10]=g*f+d}return t[3]=0,t[7]=0,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}makeRotationFromQuaternion(e){return this.compose(RN,e,NN)}lookAt(e,t,r){const i=this.elements;return Yr.subVectors(e,t),Yr.lengthSq()===0&&(Yr.z=1),Yr.normalize(),ca.crossVectors(r,Yr),ca.lengthSq()===0&&(Math.abs(r.z)===1?Yr.x+=1e-4:Yr.z+=1e-4,Yr.normalize(),ca.crossVectors(r,Yr)),ca.normalize(),Ed.crossVectors(Yr,ca),i[0]=ca.x,i[4]=Ed.x,i[8]=Yr.x,i[1]=ca.y,i[5]=Ed.y,i[9]=Yr.y,i[2]=ca.z,i[6]=Ed.z,i[10]=Yr.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,t){const r=e.elements,i=t.elements,s=this.elements,a=r[0],o=r[4],c=r[8],l=r[12],u=r[1],f=r[5],d=r[9],h=r[13],p=r[2],g=r[6],m=r[10],v=r[14],x=r[3],b=r[7],_=r[11],w=r[15],E=i[0],S=i[4],T=i[8],C=i[12],y=i[1],A=i[5],k=i[9],M=i[13],L=i[2],z=i[6],D=i[10],F=i[14],O=i[3],V=i[7],J=i[11],Q=i[15];return s[0]=a*E+o*y+c*L+l*O,s[4]=a*S+o*A+c*z+l*V,s[8]=a*T+o*k+c*D+l*J,s[12]=a*C+o*M+c*F+l*Q,s[1]=u*E+f*y+d*L+h*O,s[5]=u*S+f*A+d*z+h*V,s[9]=u*T+f*k+d*D+h*J,s[13]=u*C+f*M+d*F+h*Q,s[2]=p*E+g*y+m*L+v*O,s[6]=p*S+g*A+m*z+v*V,s[10]=p*T+g*k+m*D+v*J,s[14]=p*C+g*M+m*F+v*Q,s[3]=x*E+b*y+_*L+w*O,s[7]=x*S+b*A+_*z+w*V,s[11]=x*T+b*k+_*D+w*J,s[15]=x*C+b*M+_*F+w*Q,this}multiplyScalar(e){const t=this.elements;return t[0]*=e,t[4]*=e,t[8]*=e,t[12]*=e,t[1]*=e,t[5]*=e,t[9]*=e,t[13]*=e,t[2]*=e,t[6]*=e,t[10]*=e,t[14]*=e,t[3]*=e,t[7]*=e,t[11]*=e,t[15]*=e,this}determinant(){const e=this.elements,t=e[0],r=e[4],i=e[8],s=e[12],a=e[1],o=e[5],c=e[9],l=e[13],u=e[2],f=e[6],d=e[10],h=e[14],p=e[3],g=e[7],m=e[11],v=e[15];return p*(+s*c*f-i*l*f-s*o*d+r*l*d+i*o*h-r*c*h)+g*(+t*c*h-t*l*d+s*a*d-i*a*h+i*l*u-s*c*u)+m*(+t*l*f-t*o*h-s*a*f+r*a*h+s*o*u-r*l*u)+v*(-i*o*u-t*c*f+t*o*d+i*a*f-r*a*d+r*c*u)}transpose(){const e=this.elements;let t;return t=e[1],e[1]=e[4],e[4]=t,t=e[2],e[2]=e[8],e[8]=t,t=e[6],e[6]=e[9],e[9]=t,t=e[3],e[3]=e[12],e[12]=t,t=e[7],e[7]=e[13],e[13]=t,t=e[11],e[11]=e[14],e[14]=t,this}setPosition(e,t,r){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=t,i[14]=r),this}invert(){const e=this.elements,t=e[0],r=e[1],i=e[2],s=e[3],a=e[4],o=e[5],c=e[6],l=e[7],u=e[8],f=e[9],d=e[10],h=e[11],p=e[12],g=e[13],m=e[14],v=e[15],x=f*m*l-g*d*l+g*c*h-o*m*h-f*c*v+o*d*v,b=p*d*l-u*m*l-p*c*h+a*m*h+u*c*v-a*d*v,_=u*g*l-p*f*l+p*o*h-a*g*h-u*o*v+a*f*v,w=p*f*c-u*g*c-p*o*d+a*g*d+u*o*m-a*f*m,E=t*x+r*b+i*_+s*w;if(E===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const S=1/E;return e[0]=x*S,e[1]=(g*d*s-f*m*s-g*i*h+r*m*h+f*i*v-r*d*v)*S,e[2]=(o*m*s-g*c*s+g*i*l-r*m*l-o*i*v+r*c*v)*S,e[3]=(f*c*s-o*d*s-f*i*l+r*d*l+o*i*h-r*c*h)*S,e[4]=b*S,e[5]=(u*m*s-p*d*s+p*i*h-t*m*h-u*i*v+t*d*v)*S,e[6]=(p*c*s-a*m*s-p*i*l+t*m*l+a*i*v-t*c*v)*S,e[7]=(a*d*s-u*c*s+u*i*l-t*d*l-a*i*h+t*c*h)*S,e[8]=_*S,e[9]=(p*f*s-u*g*s-p*r*h+t*g*h+u*r*v-t*f*v)*S,e[10]=(a*g*s-p*o*s+p*r*l-t*g*l-a*r*v+t*o*v)*S,e[11]=(u*o*s-a*f*s-u*r*l+t*f*l+a*r*h-t*o*h)*S,e[12]=w*S,e[13]=(u*g*i-p*f*i+p*r*d-t*g*d-u*r*m+t*f*m)*S,e[14]=(p*o*i-a*g*i-p*r*c+t*g*c+a*r*m-t*o*m)*S,e[15]=(a*f*i-u*o*i+u*r*c-t*f*c-a*r*d+t*o*d)*S,this}scale(e){const t=this.elements,r=e.x,i=e.y,s=e.z;return t[0]*=r,t[4]*=i,t[8]*=s,t[1]*=r,t[5]*=i,t[9]*=s,t[2]*=r,t[6]*=i,t[10]*=s,t[3]*=r,t[7]*=i,t[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,t=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(t,r,i))}makeTranslation(e,t,r){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,t,0,0,1,r,0,0,0,1),this}makeRotationX(e){const t=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,t,-r,0,0,r,t,0,0,0,0,1),this}makeRotationY(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,0,r,0,0,1,0,0,-r,0,t,0,0,0,0,1),this}makeRotationZ(e){const t=Math.cos(e),r=Math.sin(e);return this.set(t,-r,0,0,r,t,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,t){const r=Math.cos(t),i=Math.sin(t),s=1-r,a=e.x,o=e.y,c=e.z,l=s*a,u=s*o;return this.set(l*a+r,l*o-i*c,l*c+i*o,0,l*o+i*c,u*o+r,u*c-i*a,0,l*c-i*o,u*c+i*a,s*c*c+r,0,0,0,0,1),this}makeScale(e,t,r){return this.set(e,0,0,0,0,t,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,t,r,i,s,a){return this.set(1,r,s,0,e,1,a,0,t,i,1,0,0,0,0,1),this}compose(e,t,r){const i=this.elements,s=t._x,a=t._y,o=t._z,c=t._w,l=s+s,u=a+a,f=o+o,d=s*l,h=s*u,p=s*f,g=a*u,m=a*f,v=o*f,x=c*l,b=c*u,_=c*f,w=r.x,E=r.y,S=r.z;return i[0]=(1-(g+v))*w,i[1]=(h+_)*w,i[2]=(p-b)*w,i[3]=0,i[4]=(h-_)*E,i[5]=(1-(d+v))*E,i[6]=(m+x)*E,i[7]=0,i[8]=(p+b)*S,i[9]=(m-x)*S,i[10]=(1-(d+g))*S,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,t,r){const i=this.elements;let s=cc.set(i[0],i[1],i[2]).length();const a=cc.set(i[4],i[5],i[6]).length(),o=cc.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],Di.copy(this);const l=1/s,u=1/a,f=1/o;return Di.elements[0]*=l,Di.elements[1]*=l,Di.elements[2]*=l,Di.elements[4]*=u,Di.elements[5]*=u,Di.elements[6]*=u,Di.elements[8]*=f,Di.elements[9]*=f,Di.elements[10]*=f,t.setFromRotationMatrix(Di),r.x=s,r.y=a,r.z=o,this}makePerspective(e,t,r,i,s,a,o=Bs){const c=this.elements,l=2*s/(t-e),u=2*s/(r-i),f=(t+e)/(t-e),d=(r+i)/(r-i);let h,p;if(o===Bs)h=-(a+s)/(a-s),p=-2*a*s/(a-s);else if(o===Ch)h=-a/(a-s),p=-a*s/(a-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+o);return c[0]=l,c[4]=0,c[8]=f,c[12]=0,c[1]=0,c[5]=u,c[9]=d,c[13]=0,c[2]=0,c[6]=0,c[10]=h,c[14]=p,c[3]=0,c[7]=0,c[11]=-1,c[15]=0,this}makeOrthographic(e,t,r,i,s,a,o=Bs){const c=this.elements,l=1/(t-e),u=1/(r-i),f=1/(a-s),d=(t+e)*l,h=(r+i)*u;let p,g;if(o===Bs)p=(a+s)*f,g=-2*f;else if(o===Ch)p=s*f,g=-1*f;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+o);return c[0]=2*l,c[4]=0,c[8]=0,c[12]=-d,c[1]=0,c[5]=2*u,c[9]=0,c[13]=-h,c[2]=0,c[6]=0,c[10]=g,c[14]=-p,c[3]=0,c[7]=0,c[11]=0,c[15]=1,this}equals(e){const t=this.elements,r=e.elements;for(let i=0;i<16;i++)if(t[i]!==r[i])return!1;return!0}fromArray(e,t=0){for(let r=0;r<16;r++)this.elements[r]=e[r+t];return this}toArray(e=[],t=0){const r=this.elements;return e[t]=r[0],e[t+1]=r[1],e[t+2]=r[2],e[t+3]=r[3],e[t+4]=r[4],e[t+5]=r[5],e[t+6]=r[6],e[t+7]=r[7],e[t+8]=r[8],e[t+9]=r[9],e[t+10]=r[10],e[t+11]=r[11],e[t+12]=r[12],e[t+13]=r[13],e[t+14]=r[14],e[t+15]=r[15],e}}const cc=new $,Di=new lt,RN=new $(0,0,0),NN=new $(1,1,1),ca=new $,Ed=new $,Yr=new $,jy=new lt,Yy=new Xi;class ms{constructor(e=0,t=0,r=0,i=ms.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=t,this._z=r,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,t,r,i=this._order){return this._x=e,this._y=t,this._z=r,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,t=this._order,r=!0){const i=e.elements,s=i[0],a=i[4],o=i[8],c=i[1],l=i[5],u=i[9],f=i[2],d=i[6],h=i[10];switch(t){case"XYZ":this._y=Math.asin(tr(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(-u,h),this._z=Math.atan2(-a,s)):(this._x=Math.atan2(d,l),this._z=0);break;case"YXZ":this._x=Math.asin(-tr(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(o,h),this._z=Math.atan2(c,l)):(this._y=Math.atan2(-f,s),this._z=0);break;case"ZXY":this._x=Math.asin(tr(d,-1,1)),Math.abs(d)<.9999999?(this._y=Math.atan2(-f,h),this._z=Math.atan2(-a,l)):(this._y=0,this._z=Math.atan2(c,s));break;case"ZYX":this._y=Math.asin(-tr(f,-1,1)),Math.abs(f)<.9999999?(this._x=Math.atan2(d,h),this._z=Math.atan2(c,s)):(this._x=0,this._z=Math.atan2(-a,l));break;case"YZX":this._z=Math.asin(tr(c,-1,1)),Math.abs(c)<.9999999?(this._x=Math.atan2(-u,l),this._y=Math.atan2(-f,s)):(this._x=0,this._y=Math.atan2(o,h));break;case"XZY":this._z=Math.asin(-tr(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(d,l),this._y=Math.atan2(o,s)):(this._x=Math.atan2(-u,h),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+t)}return this._order=t,r===!0&&this._onChangeCallback(),this}setFromQuaternion(e,t,r){return jy.makeRotationFromQuaternion(e),this.setFromRotationMatrix(jy,t,r)}setFromVector3(e,t=this._order){return this.set(e.x,e.y,e.z,t)}reorder(e){return Yy.setFromEuler(this),this.setFromQuaternion(Yy,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],t=0){return e[t]=this._x,e[t+1]=this._y,e[t+2]=this._z,e[t+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}ms.DEFAULT_ORDER="XYZ";class i0{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let kN=0;const Zy=new $,lc=new Xi,Ms=new lt,Sd=new $,Yl=new $,DN=new $,LN=new Xi,Qy=new $(1,0,0),Jy=new $(0,1,0),e1=new $(0,0,1),t1={type:"added"},ON={type:"removed"},uc={type:"childadded",child:null},ov={type:"childremoved",child:null};class mn extends Bo{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:kN++}),this.uuid=Gi(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=mn.DEFAULT_UP.clone();const e=new $,t=new ms,r=new Xi,i=new $(1,1,1);function s(){r.setFromEuler(t,!1)}function a(){t.setFromQuaternion(r,void 0,!1)}t._onChange(s),r._onChange(a),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:t},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new lt},normalMatrix:{value:new yt}}),this.matrix=new lt,this.matrixWorld=new lt,this.matrixAutoUpdate=mn.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=mn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new i0,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,t){this.quaternion.setFromAxisAngle(e,t)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,t){return lc.setFromAxisAngle(e,t),this.quaternion.multiply(lc),this}rotateOnWorldAxis(e,t){return lc.setFromAxisAngle(e,t),this.quaternion.premultiply(lc),this}rotateX(e){return this.rotateOnAxis(Qy,e)}rotateY(e){return this.rotateOnAxis(Jy,e)}rotateZ(e){return this.rotateOnAxis(e1,e)}translateOnAxis(e,t){return Zy.copy(e).applyQuaternion(this.quaternion),this.position.add(Zy.multiplyScalar(t)),this}translateX(e){return this.translateOnAxis(Qy,e)}translateY(e){return this.translateOnAxis(Jy,e)}translateZ(e){return this.translateOnAxis(e1,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Ms.copy(this.matrixWorld).invert())}lookAt(e,t,r){e.isVector3?Sd.copy(e):Sd.set(e,t,r);const i=this.parent;this.updateWorldMatrix(!0,!1),Yl.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Ms.lookAt(Yl,Sd,this.up):Ms.lookAt(Sd,Yl,this.up),this.quaternion.setFromRotationMatrix(Ms),i&&(Ms.extractRotation(i.matrixWorld),lc.setFromRotationMatrix(Ms),this.quaternion.premultiply(lc.invert()))}add(e){if(arguments.length>1){for(let t=0;t<arguments.length;t++)this.add(arguments[t]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(t1),uc.child=e,this.dispatchEvent(uc),uc.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.remove(arguments[r]);return this}const t=this.children.indexOf(e);return t!==-1&&(e.parent=null,this.children.splice(t,1),e.dispatchEvent(ON),ov.child=e,this.dispatchEvent(ov),ov.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Ms.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Ms.multiply(e.parent.matrixWorld)),e.applyMatrix4(Ms),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(t1),uc.child=e,this.dispatchEvent(uc),uc.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,t){if(this[e]===t)return this;for(let r=0,i=this.children.length;r<i;r++){const a=this.children[r].getObjectByProperty(e,t);if(a!==void 0)return a}}getObjectsByProperty(e,t,r=[]){this[e]===t&&r.push(this);const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].getObjectsByProperty(e,t,r);return r}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yl,e,DN),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(Yl,LN,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const t=this.matrixWorld.elements;return e.set(t[8],t[9],t[10]).normalize()}raycast(){}traverse(e){e(this);const t=this.children;for(let r=0,i=t.length;r<i;r++)t[r].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const t=this.children;for(let r=0,i=t.length;r<i;r++)t[r].traverseVisible(e)}traverseAncestors(e){const t=this.parent;t!==null&&(e(t),t.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,e=!0);const t=this.children;for(let r=0,i=t.length;r<i;r++)t[r].updateMatrixWorld(e)}updateWorldMatrix(e,t){const r=this.parent;if(e===!0&&r!==null&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.matrixWorldAutoUpdate===!0&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),t===!0){const i=this.children;for(let s=0,a=i.length;s<a;s++)i[s].updateWorldMatrix(!1,!0)}}toJSON(e){const t=e===void 0||typeof e=="string",r={};t&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},r.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(o=>({boxInitialized:o.boxInitialized,boxMin:o.box.min.toArray(),boxMax:o.box.max.toArray(),sphereInitialized:o.sphereInitialized,sphereRadius:o.sphere.radius,sphereCenter:o.sphere.center.toArray()})),i.maxInstanceCount=this._maxInstanceCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(e),this._colorsTexture!==null&&(i.colorsTexture=this._colorsTexture.toJSON(e)),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function s(o,c){return o[c.uuid]===void 0&&(o[c.uuid]=c.toJSON(e)),c.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const o=this.geometry.parameters;if(o!==void 0&&o.shapes!==void 0){const c=o.shapes;if(Array.isArray(c))for(let l=0,u=c.length;l<u;l++){const f=c[l];s(e.shapes,f)}else s(e.shapes,c)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const o=[];for(let c=0,l=this.material.length;c<l;c++)o.push(s(e.materials,this.material[c]));i.material=o}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let o=0;o<this.children.length;o++)i.children.push(this.children[o].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let o=0;o<this.animations.length;o++){const c=this.animations[o];i.animations.push(s(e.animations,c))}}if(t){const o=a(e.geometries),c=a(e.materials),l=a(e.textures),u=a(e.images),f=a(e.shapes),d=a(e.skeletons),h=a(e.animations),p=a(e.nodes);o.length>0&&(r.geometries=o),c.length>0&&(r.materials=c),l.length>0&&(r.textures=l),u.length>0&&(r.images=u),f.length>0&&(r.shapes=f),d.length>0&&(r.skeletons=d),h.length>0&&(r.animations=h),p.length>0&&(r.nodes=p)}return r.object=i,r;function a(o){const c=[];for(const l in o){const u=o[l];delete u.metadata,c.push(u)}return c}}clone(e){return new this.constructor().copy(this,e)}copy(e,t=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),t===!0)for(let r=0;r<e.children.length;r++){const i=e.children[r];this.add(i.clone())}return this}}mn.DEFAULT_UP=new $(0,1,0);mn.DEFAULT_MATRIX_AUTO_UPDATE=!0;mn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Li=new $,Rs=new $,cv=new $,Ns=new $,fc=new $,dc=new $,n1=new $,lv=new $,uv=new $,fv=new $,dv=new Bt,hv=new Bt,pv=new Bt;class Bi{constructor(e=new $,t=new $,r=new $){this.a=e,this.b=t,this.c=r}static getNormal(e,t,r,i){i.subVectors(r,t),Li.subVectors(e,t),i.cross(Li);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,t,r,i,s){Li.subVectors(i,t),Rs.subVectors(r,t),cv.subVectors(e,t);const a=Li.dot(Li),o=Li.dot(Rs),c=Li.dot(cv),l=Rs.dot(Rs),u=Rs.dot(cv),f=a*l-o*o;if(f===0)return s.set(0,0,0),null;const d=1/f,h=(l*c-o*u)*d,p=(a*u-o*c)*d;return s.set(1-h-p,p,h)}static containsPoint(e,t,r,i){return this.getBarycoord(e,t,r,i,Ns)===null?!1:Ns.x>=0&&Ns.y>=0&&Ns.x+Ns.y<=1}static getInterpolation(e,t,r,i,s,a,o,c){return this.getBarycoord(e,t,r,i,Ns)===null?(c.x=0,c.y=0,"z"in c&&(c.z=0),"w"in c&&(c.w=0),null):(c.setScalar(0),c.addScaledVector(s,Ns.x),c.addScaledVector(a,Ns.y),c.addScaledVector(o,Ns.z),c)}static getInterpolatedAttribute(e,t,r,i,s,a){return dv.setScalar(0),hv.setScalar(0),pv.setScalar(0),dv.fromBufferAttribute(e,t),hv.fromBufferAttribute(e,r),pv.fromBufferAttribute(e,i),a.setScalar(0),a.addScaledVector(dv,s.x),a.addScaledVector(hv,s.y),a.addScaledVector(pv,s.z),a}static isFrontFacing(e,t,r,i){return Li.subVectors(r,t),Rs.subVectors(e,t),Li.cross(Rs).dot(i)<0}set(e,t,r){return this.a.copy(e),this.b.copy(t),this.c.copy(r),this}setFromPointsAndIndices(e,t,r,i){return this.a.copy(e[t]),this.b.copy(e[r]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,t,r,i){return this.a.fromBufferAttribute(e,t),this.b.fromBufferAttribute(e,r),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Li.subVectors(this.c,this.b),Rs.subVectors(this.a,this.b),Li.cross(Rs).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Bi.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,t){return Bi.getBarycoord(e,this.a,this.b,this.c,t)}getInterpolation(e,t,r,i,s){return Bi.getInterpolation(e,this.a,this.b,this.c,t,r,i,s)}containsPoint(e){return Bi.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Bi.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,t){const r=this.a,i=this.b,s=this.c;let a,o;fc.subVectors(i,r),dc.subVectors(s,r),lv.subVectors(e,r);const c=fc.dot(lv),l=dc.dot(lv);if(c<=0&&l<=0)return t.copy(r);uv.subVectors(e,i);const u=fc.dot(uv),f=dc.dot(uv);if(u>=0&&f<=u)return t.copy(i);const d=c*f-u*l;if(d<=0&&c>=0&&u<=0)return a=c/(c-u),t.copy(r).addScaledVector(fc,a);fv.subVectors(e,s);const h=fc.dot(fv),p=dc.dot(fv);if(p>=0&&h<=p)return t.copy(s);const g=h*l-c*p;if(g<=0&&l>=0&&p<=0)return o=l/(l-p),t.copy(r).addScaledVector(dc,o);const m=u*p-h*f;if(m<=0&&f-u>=0&&h-p>=0)return n1.subVectors(s,i),o=(f-u)/(f-u+(h-p)),t.copy(i).addScaledVector(n1,o);const v=1/(m+g+d);return a=g*v,o=d*v,t.copy(r).addScaledVector(fc,a).addScaledVector(dc,o)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const mE={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},la={h:0,s:0,l:0},Td={h:0,s:0,l:0};function mv(n,e,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?n+(e-n)*6*t:t<1/2?e:t<2/3?n+(e-n)*6*(2/3-t):n}class ht{constructor(e,t,r){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,t,r)}set(e,t,r){if(t===void 0&&r===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,t,r);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,t=Xn){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,Lt.toWorkingColorSpace(this,t),this}setRGB(e,t,r,i=Lt.workingColorSpace){return this.r=e,this.g=t,this.b=r,Lt.toWorkingColorSpace(this,i),this}setHSL(e,t,r,i=Lt.workingColorSpace){if(e=r0(e,1),t=tr(t,0,1),r=tr(r,0,1),t===0)this.r=this.g=this.b=r;else{const s=r<=.5?r*(1+t):r+t-r*t,a=2*r-s;this.r=mv(a,s,e+1/3),this.g=mv(a,s,e),this.b=mv(a,s,e-1/3)}return Lt.toWorkingColorSpace(this,i),this}setStyle(e,t=Xn){function r(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const a=i[1],o=i[2];switch(a){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,t);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,t);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(o))return r(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,t);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=i[1],a=s.length;if(a===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,t);if(a===6)return this.setHex(parseInt(s,16),t);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,t);return this}setColorName(e,t=Xn){const r=mE[e.toLowerCase()];return r!==void 0?this.setHex(r,t):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=zc(e.r),this.g=zc(e.g),this.b=zc(e.b),this}copyLinearToSRGB(e){return this.r=Jm(e.r),this.g=Jm(e.g),this.b=Jm(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=Xn){return Lt.fromWorkingColorSpace(fr.copy(this),e),Math.round(tr(fr.r*255,0,255))*65536+Math.round(tr(fr.g*255,0,255))*256+Math.round(tr(fr.b*255,0,255))}getHexString(e=Xn){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,t=Lt.workingColorSpace){Lt.fromWorkingColorSpace(fr.copy(this),t);const r=fr.r,i=fr.g,s=fr.b,a=Math.max(r,i,s),o=Math.min(r,i,s);let c,l;const u=(o+a)/2;if(o===a)c=0,l=0;else{const f=a-o;switch(l=u<=.5?f/(a+o):f/(2-a-o),a){case r:c=(i-s)/f+(i<s?6:0);break;case i:c=(s-r)/f+2;break;case s:c=(r-i)/f+4;break}c/=6}return e.h=c,e.s=l,e.l=u,e}getRGB(e,t=Lt.workingColorSpace){return Lt.fromWorkingColorSpace(fr.copy(this),t),e.r=fr.r,e.g=fr.g,e.b=fr.b,e}getStyle(e=Xn){Lt.fromWorkingColorSpace(fr.copy(this),e);const t=fr.r,r=fr.g,i=fr.b;return e!==Xn?`color(${e} ${t.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(t*255)},${Math.round(r*255)},${Math.round(i*255)})`}offsetHSL(e,t,r){return this.getHSL(la),this.setHSL(la.h+e,la.s+t,la.l+r)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,t){return this.r=e.r+t.r,this.g=e.g+t.g,this.b=e.b+t.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,t){return this.r+=(e.r-this.r)*t,this.g+=(e.g-this.g)*t,this.b+=(e.b-this.b)*t,this}lerpColors(e,t,r){return this.r=e.r+(t.r-e.r)*r,this.g=e.g+(t.g-e.g)*r,this.b=e.b+(t.b-e.b)*r,this}lerpHSL(e,t){this.getHSL(la),e.getHSL(Td);const r=vu(la.h,Td.h,t),i=vu(la.s,Td.s,t),s=vu(la.l,Td.l,t);return this.setHSL(r,i,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const t=this.r,r=this.g,i=this.b,s=e.elements;return this.r=s[0]*t+s[3]*r+s[6]*i,this.g=s[1]*t+s[4]*r+s[7]*i,this.b=s[2]*t+s[5]*r+s[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,t=0){return this.r=e[t],this.g=e[t+1],this.b=e[t+2],this}toArray(e=[],t=0){return e[t]=this.r,e[t+1]=this.g,e[t+2]=this.b,e}fromBufferAttribute(e,t){return this.r=e.getX(t),this.g=e.getY(t),this.b=e.getZ(t),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const fr=new ht;ht.NAMES=mE;let zN=0;class cs extends Bo{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:zN++}),this.uuid=Gi(),this.name="",this.type="Material",this.blending=Lc,this.side=Ws,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=ag,this.blendDst=og,this.blendEquation=co,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new ht(0,0,0),this.blendAlpha=0,this.depthFunc=Gc,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=Gy,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=rc,this.stencilZFail=rc,this.stencilZPass=rc,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const t in e){const r=e[t];if(r===void 0){console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);continue}const i=this[t];if(i===void 0){console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(r):i&&i.isVector3&&r&&r.isVector3?i.copy(r):this[t]=r}}toJSON(e){const t=e===void 0||typeof e=="string";t&&(e={textures:{},images:{}});const r={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.color&&this.color.isColor&&(r.color=this.color.getHex()),this.roughness!==void 0&&(r.roughness=this.roughness),this.metalness!==void 0&&(r.metalness=this.metalness),this.sheen!==void 0&&(r.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(r.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(r.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(r.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(r.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(r.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(r.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(r.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(r.shininess=this.shininess),this.clearcoat!==void 0&&(r.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(r.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(r.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(r.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,r.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.dispersion!==void 0&&(r.dispersion=this.dispersion),this.iridescence!==void 0&&(r.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(r.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(r.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(r.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(r.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(r.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(r.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(r.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(r.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(r.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(r.lightMap=this.lightMap.toJSON(e).uuid,r.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(r.aoMap=this.aoMap.toJSON(e).uuid,r.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(r.bumpMap=this.bumpMap.toJSON(e).uuid,r.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(r.normalMap=this.normalMap.toJSON(e).uuid,r.normalMapType=this.normalMapType,r.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(r.displacementMap=this.displacementMap.toJSON(e).uuid,r.displacementScale=this.displacementScale,r.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(r.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(r.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(r.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(r.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(r.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(r.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(r.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(r.combine=this.combine)),this.envMapRotation!==void 0&&(r.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(r.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(r.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(r.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(r.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(r.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(r.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(r.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(r.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(r.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(r.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(r.size=this.size),this.shadowSide!==null&&(r.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(r.sizeAttenuation=this.sizeAttenuation),this.blending!==Lc&&(r.blending=this.blending),this.side!==Ws&&(r.side=this.side),this.vertexColors===!0&&(r.vertexColors=!0),this.opacity<1&&(r.opacity=this.opacity),this.transparent===!0&&(r.transparent=!0),this.blendSrc!==ag&&(r.blendSrc=this.blendSrc),this.blendDst!==og&&(r.blendDst=this.blendDst),this.blendEquation!==co&&(r.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(r.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(r.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(r.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(r.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(r.blendAlpha=this.blendAlpha),this.depthFunc!==Gc&&(r.depthFunc=this.depthFunc),this.depthTest===!1&&(r.depthTest=this.depthTest),this.depthWrite===!1&&(r.depthWrite=this.depthWrite),this.colorWrite===!1&&(r.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(r.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==Gy&&(r.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(r.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(r.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==rc&&(r.stencilFail=this.stencilFail),this.stencilZFail!==rc&&(r.stencilZFail=this.stencilZFail),this.stencilZPass!==rc&&(r.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(r.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(r.rotation=this.rotation),this.polygonOffset===!0&&(r.polygonOffset=!0),this.polygonOffsetFactor!==0&&(r.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(r.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(r.linewidth=this.linewidth),this.dashSize!==void 0&&(r.dashSize=this.dashSize),this.gapSize!==void 0&&(r.gapSize=this.gapSize),this.scale!==void 0&&(r.scale=this.scale),this.dithering===!0&&(r.dithering=!0),this.alphaTest>0&&(r.alphaTest=this.alphaTest),this.alphaHash===!0&&(r.alphaHash=!0),this.alphaToCoverage===!0&&(r.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(r.premultipliedAlpha=!0),this.forceSinglePass===!0&&(r.forceSinglePass=!0),this.wireframe===!0&&(r.wireframe=!0),this.wireframeLinewidth>1&&(r.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(r.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(r.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(r.flatShading=!0),this.visible===!1&&(r.visible=!1),this.toneMapped===!1&&(r.toneMapped=!1),this.fog===!1&&(r.fog=!1),Object.keys(this.userData).length>0&&(r.userData=this.userData);function i(s){const a=[];for(const o in s){const c=s[o];delete c.metadata,a.push(c)}return a}if(t){const s=i(e.textures),a=i(e.images);s.length>0&&(r.textures=s),a.length>0&&(r.images=a)}return r}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const t=e.clippingPlanes;let r=null;if(t!==null){const i=t.length;r=new Array(i);for(let s=0;s!==i;++s)r[s]=t[s].clone()}return this.clippingPlanes=r,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}onBuild(){console.warn("Material: onBuild() has been removed.")}}class xa extends cs{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new ht(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ms,this.combine=Zw,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const Mn=new $,Ad=new Ye;class Mr{constructor(e,t,r=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=t,this.count=e!==void 0?e.length/t:0,this.normalized=r,this.usage=Hg,this.updateRanges=[],this.gpuType=pi,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,t,r){e*=this.itemSize,r*=t.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=t.array[r+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let t=0,r=this.count;t<r;t++)Ad.fromBufferAttribute(this,t),Ad.applyMatrix3(e),this.setXY(t,Ad.x,Ad.y);else if(this.itemSize===3)for(let t=0,r=this.count;t<r;t++)Mn.fromBufferAttribute(this,t),Mn.applyMatrix3(e),this.setXYZ(t,Mn.x,Mn.y,Mn.z);return this}applyMatrix4(e){for(let t=0,r=this.count;t<r;t++)Mn.fromBufferAttribute(this,t),Mn.applyMatrix4(e),this.setXYZ(t,Mn.x,Mn.y,Mn.z);return this}applyNormalMatrix(e){for(let t=0,r=this.count;t<r;t++)Mn.fromBufferAttribute(this,t),Mn.applyNormalMatrix(e),this.setXYZ(t,Mn.x,Mn.y,Mn.z);return this}transformDirection(e){for(let t=0,r=this.count;t<r;t++)Mn.fromBufferAttribute(this,t),Mn.transformDirection(e),this.setXYZ(t,Mn.x,Mn.y,Mn.z);return this}set(e,t=0){return this.array.set(e,t),this}getComponent(e,t){let r=this.array[e*this.itemSize+t];return this.normalized&&(r=Ui(r,this.array)),r}setComponent(e,t,r){return this.normalized&&(r=Xt(r,this.array)),this.array[e*this.itemSize+t]=r,this}getX(e){let t=this.array[e*this.itemSize];return this.normalized&&(t=Ui(t,this.array)),t}setX(e,t){return this.normalized&&(t=Xt(t,this.array)),this.array[e*this.itemSize]=t,this}getY(e){let t=this.array[e*this.itemSize+1];return this.normalized&&(t=Ui(t,this.array)),t}setY(e,t){return this.normalized&&(t=Xt(t,this.array)),this.array[e*this.itemSize+1]=t,this}getZ(e){let t=this.array[e*this.itemSize+2];return this.normalized&&(t=Ui(t,this.array)),t}setZ(e,t){return this.normalized&&(t=Xt(t,this.array)),this.array[e*this.itemSize+2]=t,this}getW(e){let t=this.array[e*this.itemSize+3];return this.normalized&&(t=Ui(t,this.array)),t}setW(e,t){return this.normalized&&(t=Xt(t,this.array)),this.array[e*this.itemSize+3]=t,this}setXY(e,t,r){return e*=this.itemSize,this.normalized&&(t=Xt(t,this.array),r=Xt(r,this.array)),this.array[e+0]=t,this.array[e+1]=r,this}setXYZ(e,t,r,i){return e*=this.itemSize,this.normalized&&(t=Xt(t,this.array),r=Xt(r,this.array),i=Xt(i,this.array)),this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=i,this}setXYZW(e,t,r,i,s){return e*=this.itemSize,this.normalized&&(t=Xt(t,this.array),r=Xt(r,this.array),i=Xt(i,this.array),s=Xt(s,this.array)),this.array[e+0]=t,this.array[e+1]=r,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Hg&&(e.usage=this.usage),e}}class vE extends Mr{constructor(e,t,r){super(new Uint16Array(e),t,r)}}class gE extends Mr{constructor(e,t,r){super(new Uint32Array(e),t,r)}}class Gs extends Mr{constructor(e,t,r){super(new Float32Array(e),t,r)}}let PN=0;const ai=new lt,vv=new mn,hc=new $,Zr=new Qs,Zl=new Qs,qn=new $;class ws extends Bo{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:PN++}),this.uuid=Gi(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(fE(e)?gE:vE)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,t){return this.attributes[e]=t,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,t,r=0){this.groups.push({start:e,count:t,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(e,t){this.drawRange.start=e,this.drawRange.count=t}applyMatrix4(e){const t=this.attributes.position;t!==void 0&&(t.applyMatrix4(e),t.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const s=new yt().getNormalMatrix(e);r.applyNormalMatrix(s),r.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return ai.makeRotationFromQuaternion(e),this.applyMatrix4(ai),this}rotateX(e){return ai.makeRotationX(e),this.applyMatrix4(ai),this}rotateY(e){return ai.makeRotationY(e),this.applyMatrix4(ai),this}rotateZ(e){return ai.makeRotationZ(e),this.applyMatrix4(ai),this}translate(e,t,r){return ai.makeTranslation(e,t,r),this.applyMatrix4(ai),this}scale(e,t,r){return ai.makeScale(e,t,r),this.applyMatrix4(ai),this}lookAt(e){return vv.lookAt(e),vv.updateMatrix(),this.applyMatrix4(vv.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(hc).negate(),this.translate(hc.x,hc.y,hc.z),this}setFromPoints(e){const t=[];for(let r=0,i=e.length;r<i;r++){const s=e[r];t.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new Gs(t,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new Qs);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new $(-1/0,-1/0,-1/0),new $(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),t)for(let r=0,i=t.length;r<i;r++){const s=t[r];Zr.setFromBufferAttribute(s),this.morphTargetsRelative?(qn.addVectors(this.boundingBox.min,Zr.min),this.boundingBox.expandByPoint(qn),qn.addVectors(this.boundingBox.max,Zr.max),this.boundingBox.expandByPoint(qn)):(this.boundingBox.expandByPoint(Zr.min),this.boundingBox.expandByPoint(Zr.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new ys);const e=this.attributes.position,t=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new $,1/0);return}if(e){const r=this.boundingSphere.center;if(Zr.setFromBufferAttribute(e),t)for(let s=0,a=t.length;s<a;s++){const o=t[s];Zl.setFromBufferAttribute(o),this.morphTargetsRelative?(qn.addVectors(Zr.min,Zl.min),Zr.expandByPoint(qn),qn.addVectors(Zr.max,Zl.max),Zr.expandByPoint(qn)):(Zr.expandByPoint(Zl.min),Zr.expandByPoint(Zl.max))}Zr.getCenter(r);let i=0;for(let s=0,a=e.count;s<a;s++)qn.fromBufferAttribute(e,s),i=Math.max(i,r.distanceToSquared(qn));if(t)for(let s=0,a=t.length;s<a;s++){const o=t[s],c=this.morphTargetsRelative;for(let l=0,u=o.count;l<u;l++)qn.fromBufferAttribute(o,l),c&&(hc.fromBufferAttribute(e,l),qn.add(hc)),i=Math.max(i,r.distanceToSquared(qn))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,t=this.attributes;if(e===null||t.position===void 0||t.normal===void 0||t.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const r=t.position,i=t.normal,s=t.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new Mr(new Float32Array(4*r.count),4));const a=this.getAttribute("tangent"),o=[],c=[];for(let T=0;T<r.count;T++)o[T]=new $,c[T]=new $;const l=new $,u=new $,f=new $,d=new Ye,h=new Ye,p=new Ye,g=new $,m=new $;function v(T,C,y){l.fromBufferAttribute(r,T),u.fromBufferAttribute(r,C),f.fromBufferAttribute(r,y),d.fromBufferAttribute(s,T),h.fromBufferAttribute(s,C),p.fromBufferAttribute(s,y),u.sub(l),f.sub(l),h.sub(d),p.sub(d);const A=1/(h.x*p.y-p.x*h.y);isFinite(A)&&(g.copy(u).multiplyScalar(p.y).addScaledVector(f,-h.y).multiplyScalar(A),m.copy(f).multiplyScalar(h.x).addScaledVector(u,-p.x).multiplyScalar(A),o[T].add(g),o[C].add(g),o[y].add(g),c[T].add(m),c[C].add(m),c[y].add(m))}let x=this.groups;x.length===0&&(x=[{start:0,count:e.count}]);for(let T=0,C=x.length;T<C;++T){const y=x[T],A=y.start,k=y.count;for(let M=A,L=A+k;M<L;M+=3)v(e.getX(M+0),e.getX(M+1),e.getX(M+2))}const b=new $,_=new $,w=new $,E=new $;function S(T){w.fromBufferAttribute(i,T),E.copy(w);const C=o[T];b.copy(C),b.sub(w.multiplyScalar(w.dot(C))).normalize(),_.crossVectors(E,C);const A=_.dot(c[T])<0?-1:1;a.setXYZW(T,b.x,b.y,b.z,A)}for(let T=0,C=x.length;T<C;++T){const y=x[T],A=y.start,k=y.count;for(let M=A,L=A+k;M<L;M+=3)S(e.getX(M+0)),S(e.getX(M+1)),S(e.getX(M+2))}}computeVertexNormals(){const e=this.index,t=this.getAttribute("position");if(t!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new Mr(new Float32Array(t.count*3),3),this.setAttribute("normal",r);else for(let d=0,h=r.count;d<h;d++)r.setXYZ(d,0,0,0);const i=new $,s=new $,a=new $,o=new $,c=new $,l=new $,u=new $,f=new $;if(e)for(let d=0,h=e.count;d<h;d+=3){const p=e.getX(d+0),g=e.getX(d+1),m=e.getX(d+2);i.fromBufferAttribute(t,p),s.fromBufferAttribute(t,g),a.fromBufferAttribute(t,m),u.subVectors(a,s),f.subVectors(i,s),u.cross(f),o.fromBufferAttribute(r,p),c.fromBufferAttribute(r,g),l.fromBufferAttribute(r,m),o.add(u),c.add(u),l.add(u),r.setXYZ(p,o.x,o.y,o.z),r.setXYZ(g,c.x,c.y,c.z),r.setXYZ(m,l.x,l.y,l.z)}else for(let d=0,h=t.count;d<h;d+=3)i.fromBufferAttribute(t,d+0),s.fromBufferAttribute(t,d+1),a.fromBufferAttribute(t,d+2),u.subVectors(a,s),f.subVectors(i,s),u.cross(f),r.setXYZ(d+0,u.x,u.y,u.z),r.setXYZ(d+1,u.x,u.y,u.z),r.setXYZ(d+2,u.x,u.y,u.z);this.normalizeNormals(),r.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let t=0,r=e.count;t<r;t++)qn.fromBufferAttribute(e,t),qn.normalize(),e.setXYZ(t,qn.x,qn.y,qn.z)}toNonIndexed(){function e(o,c){const l=o.array,u=o.itemSize,f=o.normalized,d=new l.constructor(c.length*u);let h=0,p=0;for(let g=0,m=c.length;g<m;g++){o.isInterleavedBufferAttribute?h=c[g]*o.data.stride+o.offset:h=c[g]*u;for(let v=0;v<u;v++)d[p++]=l[h++]}return new Mr(d,u,f)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const t=new ws,r=this.index.array,i=this.attributes;for(const o in i){const c=i[o],l=e(c,r);t.setAttribute(o,l)}const s=this.morphAttributes;for(const o in s){const c=[],l=s[o];for(let u=0,f=l.length;u<f;u++){const d=l[u],h=e(d,r);c.push(h)}t.morphAttributes[o]=c}t.morphTargetsRelative=this.morphTargetsRelative;const a=this.groups;for(let o=0,c=a.length;o<c;o++){const l=a[o];t.addGroup(l.start,l.count,l.materialIndex)}return t}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const c=this.parameters;for(const l in c)c[l]!==void 0&&(e[l]=c[l]);return e}e.data={attributes:{}};const t=this.index;t!==null&&(e.data.index={type:t.array.constructor.name,array:Array.prototype.slice.call(t.array)});const r=this.attributes;for(const c in r){const l=r[c];e.data.attributes[c]=l.toJSON(e.data)}const i={};let s=!1;for(const c in this.morphAttributes){const l=this.morphAttributes[c],u=[];for(let f=0,d=l.length;f<d;f++){const h=l[f];u.push(h.toJSON(e.data))}u.length>0&&(i[c]=u,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const a=this.groups;a.length>0&&(e.data.groups=JSON.parse(JSON.stringify(a)));const o=this.boundingSphere;return o!==null&&(e.data.boundingSphere={center:o.center.toArray(),radius:o.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const t={};this.name=e.name;const r=e.index;r!==null&&this.setIndex(r.clone(t));const i=e.attributes;for(const l in i){const u=i[l];this.setAttribute(l,u.clone(t))}const s=e.morphAttributes;for(const l in s){const u=[],f=s[l];for(let d=0,h=f.length;d<h;d++)u.push(f[d].clone(t));this.morphAttributes[l]=u}this.morphTargetsRelative=e.morphTargetsRelative;const a=e.groups;for(let l=0,u=a.length;l<u;l++){const f=a[l];this.addGroup(f.start,f.count,f.materialIndex)}const o=e.boundingBox;o!==null&&(this.boundingBox=o.clone());const c=e.boundingSphere;return c!==null&&(this.boundingSphere=c.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const r1=new lt,Ja=new vl,Cd=new ys,i1=new $,Id=new $,Md=new $,Rd=new $,gv=new $,Nd=new $,s1=new $,kd=new $;class gr extends mn{constructor(e=new ws,t=new xa){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const t=this.geometry.morphAttributes,r=Object.keys(t);if(r.length>0){const i=t[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}getVertexPosition(e,t){const r=this.geometry,i=r.attributes.position,s=r.morphAttributes.position,a=r.morphTargetsRelative;t.fromBufferAttribute(i,e);const o=this.morphTargetInfluences;if(s&&o){Nd.set(0,0,0);for(let c=0,l=s.length;c<l;c++){const u=o[c],f=s[c];u!==0&&(gv.fromBufferAttribute(f,e),a?Nd.addScaledVector(gv,u):Nd.addScaledVector(gv.sub(t),u))}t.add(Nd)}return t}raycast(e,t){const r=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(r.boundingSphere===null&&r.computeBoundingSphere(),Cd.copy(r.boundingSphere),Cd.applyMatrix4(s),Ja.copy(e.ray).recast(e.near),!(Cd.containsPoint(Ja.origin)===!1&&(Ja.intersectSphere(Cd,i1)===null||Ja.origin.distanceToSquared(i1)>(e.far-e.near)**2))&&(r1.copy(s).invert(),Ja.copy(e.ray).applyMatrix4(r1),!(r.boundingBox!==null&&Ja.intersectsBox(r.boundingBox)===!1)&&this._computeIntersections(e,t,Ja)))}_computeIntersections(e,t,r){let i;const s=this.geometry,a=this.material,o=s.index,c=s.attributes.position,l=s.attributes.uv,u=s.attributes.uv1,f=s.attributes.normal,d=s.groups,h=s.drawRange;if(o!==null)if(Array.isArray(a))for(let p=0,g=d.length;p<g;p++){const m=d[p],v=a[m.materialIndex],x=Math.max(m.start,h.start),b=Math.min(o.count,Math.min(m.start+m.count,h.start+h.count));for(let _=x,w=b;_<w;_+=3){const E=o.getX(_),S=o.getX(_+1),T=o.getX(_+2);i=Dd(this,v,e,r,l,u,f,E,S,T),i&&(i.faceIndex=Math.floor(_/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{const p=Math.max(0,h.start),g=Math.min(o.count,h.start+h.count);for(let m=p,v=g;m<v;m+=3){const x=o.getX(m),b=o.getX(m+1),_=o.getX(m+2);i=Dd(this,a,e,r,l,u,f,x,b,_),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}else if(c!==void 0)if(Array.isArray(a))for(let p=0,g=d.length;p<g;p++){const m=d[p],v=a[m.materialIndex],x=Math.max(m.start,h.start),b=Math.min(c.count,Math.min(m.start+m.count,h.start+h.count));for(let _=x,w=b;_<w;_+=3){const E=_,S=_+1,T=_+2;i=Dd(this,v,e,r,l,u,f,E,S,T),i&&(i.faceIndex=Math.floor(_/3),i.face.materialIndex=m.materialIndex,t.push(i))}}else{const p=Math.max(0,h.start),g=Math.min(c.count,h.start+h.count);for(let m=p,v=g;m<v;m+=3){const x=m,b=m+1,_=m+2;i=Dd(this,a,e,r,l,u,f,x,b,_),i&&(i.faceIndex=Math.floor(m/3),t.push(i))}}}}function FN(n,e,t,r,i,s,a,o){let c;if(e.side===Ir?c=r.intersectTriangle(a,s,i,!0,o):c=r.intersectTriangle(i,s,a,e.side===Ws,o),c===null)return null;kd.copy(o),kd.applyMatrix4(n.matrixWorld);const l=t.ray.origin.distanceTo(kd);return l<t.near||l>t.far?null:{distance:l,point:kd.clone(),object:n}}function Dd(n,e,t,r,i,s,a,o,c,l){n.getVertexPosition(o,Id),n.getVertexPosition(c,Md),n.getVertexPosition(l,Rd);const u=FN(n,e,t,r,Id,Md,Rd,s1);if(u){const f=new $;Bi.getBarycoord(s1,Id,Md,Rd,f),i&&(u.uv=Bi.getInterpolatedAttribute(i,o,c,l,f,new Ye)),s&&(u.uv1=Bi.getInterpolatedAttribute(s,o,c,l,f,new Ye)),a&&(u.normal=Bi.getInterpolatedAttribute(a,o,c,l,f,new $),u.normal.dot(r.direction)>0&&u.normal.multiplyScalar(-1));const d={a:o,b:c,c:l,normal:new $,materialIndex:0};Bi.getNormal(Id,Md,Rd,d.normal),u.face=d,u.barycoord=f}return u}class gl extends ws{constructor(e=1,t=1,r=1,i=1,s=1,a=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:t,depth:r,widthSegments:i,heightSegments:s,depthSegments:a};const o=this;i=Math.floor(i),s=Math.floor(s),a=Math.floor(a);const c=[],l=[],u=[],f=[];let d=0,h=0;p("z","y","x",-1,-1,r,t,e,a,s,0),p("z","y","x",1,-1,r,t,-e,a,s,1),p("x","z","y",1,1,e,r,t,i,a,2),p("x","z","y",1,-1,e,r,-t,i,a,3),p("x","y","z",1,-1,e,t,r,i,s,4),p("x","y","z",-1,-1,e,t,-r,i,s,5),this.setIndex(c),this.setAttribute("position",new Gs(l,3)),this.setAttribute("normal",new Gs(u,3)),this.setAttribute("uv",new Gs(f,2));function p(g,m,v,x,b,_,w,E,S,T,C){const y=_/S,A=w/T,k=_/2,M=w/2,L=E/2,z=S+1,D=T+1;let F=0,O=0;const V=new $;for(let J=0;J<D;J++){const Q=J*A-M;for(let de=0;de<z;de++){const le=de*y-k;V[g]=le*x,V[m]=Q*b,V[v]=L,l.push(V.x,V.y,V.z),V[g]=0,V[m]=0,V[v]=E>0?1:-1,u.push(V.x,V.y,V.z),f.push(de/S),f.push(1-J/T),F+=1}}for(let J=0;J<T;J++)for(let Q=0;Q<S;Q++){const de=d+Q+z*J,le=d+Q+z*(J+1),H=d+(Q+1)+z*(J+1),q=d+(Q+1)+z*J;c.push(de,le,q),c.push(le,H,q),O+=6}o.addGroup(h,O,C),h+=O,d+=F}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new gl(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Yc(n){const e={};for(const t in n){e[t]={};for(const r in n[t]){const i=n[t][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[t][r]=null):e[t][r]=i.clone():Array.isArray(i)?e[t][r]=i.slice():e[t][r]=i}}return e}function yr(n){const e={};for(let t=0;t<n.length;t++){const r=Yc(n[t]);for(const i in r)e[i]=r[i]}return e}function $N(n){const e=[];for(let t=0;t<n.length;t++)e.push(n[t].clone());return e}function xE(n){const e=n.getRenderTarget();return e===null?n.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:Lt.workingColorSpace}const UN={clone:Yc,merge:yr};var BN=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,VN=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class qs extends cs{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=BN,this.fragmentShader=VN,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Yc(e.uniforms),this.uniformsGroups=$N(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const t=super.toJSON(e);t.glslVersion=this.glslVersion,t.uniforms={};for(const i in this.uniforms){const a=this.uniforms[i].value;a&&a.isTexture?t.uniforms[i]={type:"t",value:a.toJSON(e).uuid}:a&&a.isColor?t.uniforms[i]={type:"c",value:a.getHex()}:a&&a.isVector2?t.uniforms[i]={type:"v2",value:a.toArray()}:a&&a.isVector3?t.uniforms[i]={type:"v3",value:a.toArray()}:a&&a.isVector4?t.uniforms[i]={type:"v4",value:a.toArray()}:a&&a.isMatrix3?t.uniforms[i]={type:"m3",value:a.toArray()}:a&&a.isMatrix4?t.uniforms[i]={type:"m4",value:a.toArray()}:t.uniforms[i]={value:a}}Object.keys(this.defines).length>0&&(t.defines=this.defines),t.vertexShader=this.vertexShader,t.fragmentShader=this.fragmentShader,t.lights=this.lights,t.clipping=this.clipping;const r={};for(const i in this.extensions)this.extensions[i]===!0&&(r[i]=!0);return Object.keys(r).length>0&&(t.extensions=r),t}}let bE=class extends mn{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new lt,this.projectionMatrix=new lt,this.projectionMatrixInverse=new lt,this.coordinateSystem=Bs}copy(e,t){return super.copy(e,t),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,t){super.updateWorldMatrix(e,t),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}};const ua=new $,a1=new Ye,o1=new Ye;class Er extends bE{constructor(e=50,t=1,r=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=r,this.far=i,this.focus=10,this.aspect=t,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const t=.5*this.getFilmHeight()/e;this.fov=jc*2*Math.atan(t),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(mu*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return jc*2*Math.atan(Math.tan(mu*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,t,r){ua.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),t.set(ua.x,ua.y).multiplyScalar(-e/ua.z),ua.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),r.set(ua.x,ua.y).multiplyScalar(-e/ua.z)}getViewSize(e,t){return this.getViewBounds(e,a1,o1),t.subVectors(o1,a1)}setViewOffset(e,t,r,i,s,a){this.aspect=e/t,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let t=e*Math.tan(mu*.5*this.fov)/this.zoom,r=2*t,i=this.aspect*r,s=-.5*i;const a=this.view;if(this.view!==null&&this.view.enabled){const c=a.fullWidth,l=a.fullHeight;s+=a.offsetX*i/c,t-=a.offsetY*r/l,i*=a.width/c,r*=a.height/l}const o=this.filmOffset;o!==0&&(s+=e*o/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,t,t-r,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.fov=this.fov,t.object.zoom=this.zoom,t.object.near=this.near,t.object.far=this.far,t.object.focus=this.focus,t.object.aspect=this.aspect,this.view!==null&&(t.object.view=Object.assign({},this.view)),t.object.filmGauge=this.filmGauge,t.object.filmOffset=this.filmOffset,t}}const pc=-90,mc=1;class GN extends mn{constructor(e,t,r){super(),this.type="CubeCamera",this.renderTarget=r,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Er(pc,mc,e,t);i.layers=this.layers,this.add(i);const s=new Er(pc,mc,e,t);s.layers=this.layers,this.add(s);const a=new Er(pc,mc,e,t);a.layers=this.layers,this.add(a);const o=new Er(pc,mc,e,t);o.layers=this.layers,this.add(o);const c=new Er(pc,mc,e,t);c.layers=this.layers,this.add(c);const l=new Er(pc,mc,e,t);l.layers=this.layers,this.add(l)}updateCoordinateSystem(){const e=this.coordinateSystem,t=this.children.concat(),[r,i,s,a,o,c]=t;for(const l of t)this.remove(l);if(e===Bs)r.up.set(0,1,0),r.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),a.up.set(0,0,1),a.lookAt(0,-1,0),o.up.set(0,1,0),o.lookAt(0,0,1),c.up.set(0,1,0),c.lookAt(0,0,-1);else if(e===Ch)r.up.set(0,-1,0),r.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),a.up.set(0,0,-1),a.lookAt(0,-1,0),o.up.set(0,-1,0),o.lookAt(0,0,1),c.up.set(0,-1,0),c.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const l of t)this.add(l),l.updateMatrixWorld()}update(e,t){this.parent===null&&this.updateMatrixWorld();const{renderTarget:r,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,a,o,c,l,u]=this.children,f=e.getRenderTarget(),d=e.getActiveCubeFace(),h=e.getActiveMipmapLevel(),p=e.xr.enabled;e.xr.enabled=!1;const g=r.texture.generateMipmaps;r.texture.generateMipmaps=!1,e.setRenderTarget(r,0,i),e.render(t,s),e.setRenderTarget(r,1,i),e.render(t,a),e.setRenderTarget(r,2,i),e.render(t,o),e.setRenderTarget(r,3,i),e.render(t,c),e.setRenderTarget(r,4,i),e.render(t,l),r.texture.generateMipmaps=g,e.setRenderTarget(r,5,i),e.render(t,u),e.setRenderTarget(f,d,h),e.xr.enabled=p,r.texture.needsPMREMUpdate=!0}}class s0 extends Vn{constructor(e,t,r,i,s,a,o,c,l,u){e=e!==void 0?e:[],t=t!==void 0?t:Hc,super(e,t,r,i,s,a,o,c,l,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class HN extends So{constructor(e=1,t={}){super(e,e,t),this.isWebGLCubeRenderTarget=!0;const r={width:e,height:e,depth:1},i=[r,r,r,r,r,r];this.texture=new s0(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=t.generateMipmaps!==void 0?t.generateMipmaps:!1,this.texture.minFilter=t.minFilter!==void 0?t.minFilter:Rn}fromEquirectangularTexture(e,t){this.texture.type=t.type,this.texture.colorSpace=t.colorSpace,this.texture.generateMipmaps=t.generateMipmaps,this.texture.minFilter=t.minFilter,this.texture.magFilter=t.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new gl(5,5,5),s=new qs({name:"CubemapFromEquirect",uniforms:Yc(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:Ir,blending:Sa});s.uniforms.tEquirect.value=t;const a=new gr(i,s),o=t.minFilter;return t.minFilter===$s&&(t.minFilter=Rn),new GN(1,10,this).update(e,a),t.minFilter=o,a.geometry.dispose(),a.material.dispose(),this}clear(e,t,r,i){const s=e.getRenderTarget();for(let a=0;a<6;a++)e.setRenderTarget(this,a),e.clear(t,r,i);e.setRenderTarget(s)}}const xv=new $,WN=new $,qN=new yt;class ma{constructor(e=new $(1,0,0),t=0){this.isPlane=!0,this.normal=e,this.constant=t}set(e,t){return this.normal.copy(e),this.constant=t,this}setComponents(e,t,r,i){return this.normal.set(e,t,r),this.constant=i,this}setFromNormalAndCoplanarPoint(e,t){return this.normal.copy(e),this.constant=-t.dot(this.normal),this}setFromCoplanarPoints(e,t,r){const i=xv.subVectors(r,t).cross(WN.subVectors(e,t)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,t){return t.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,t){const r=e.delta(xv),i=this.normal.dot(r);if(i===0)return this.distanceToPoint(e.start)===0?t.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:t.copy(e.start).addScaledVector(r,s)}intersectsLine(e){const t=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return t<0&&r>0||r<0&&t>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,t){const r=t||qN.getNormalMatrix(e),i=this.coplanarPoint(xv).applyMatrix4(e),s=this.normal.applyMatrix3(r).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const eo=new ys,Ld=new $;class a0{constructor(e=new ma,t=new ma,r=new ma,i=new ma,s=new ma,a=new ma){this.planes=[e,t,r,i,s,a]}set(e,t,r,i,s,a){const o=this.planes;return o[0].copy(e),o[1].copy(t),o[2].copy(r),o[3].copy(i),o[4].copy(s),o[5].copy(a),this}copy(e){const t=this.planes;for(let r=0;r<6;r++)t[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e,t=Bs){const r=this.planes,i=e.elements,s=i[0],a=i[1],o=i[2],c=i[3],l=i[4],u=i[5],f=i[6],d=i[7],h=i[8],p=i[9],g=i[10],m=i[11],v=i[12],x=i[13],b=i[14],_=i[15];if(r[0].setComponents(c-s,d-l,m-h,_-v).normalize(),r[1].setComponents(c+s,d+l,m+h,_+v).normalize(),r[2].setComponents(c+a,d+u,m+p,_+x).normalize(),r[3].setComponents(c-a,d-u,m-p,_-x).normalize(),r[4].setComponents(c-o,d-f,m-g,_-b).normalize(),t===Bs)r[5].setComponents(c+o,d+f,m+g,_+b).normalize();else if(t===Ch)r[5].setComponents(o,f,g,b).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+t);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),eo.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const t=e.geometry;t.boundingSphere===null&&t.computeBoundingSphere(),eo.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(eo)}intersectsSprite(e){return eo.center.set(0,0,0),eo.radius=.7071067811865476,eo.applyMatrix4(e.matrixWorld),this.intersectsSphere(eo)}intersectsSphere(e){const t=this.planes,r=e.center,i=-e.radius;for(let s=0;s<6;s++)if(t[s].distanceToPoint(r)<i)return!1;return!0}intersectsBox(e){const t=this.planes;for(let r=0;r<6;r++){const i=t[r];if(Ld.x=i.normal.x>0?e.max.x:e.min.x,Ld.y=i.normal.y>0?e.max.y:e.min.y,Ld.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Ld)<0)return!1}return!0}containsPoint(e){const t=this.planes;for(let r=0;r<6;r++)if(t[r].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function _E(){let n=null,e=!1,t=null,r=null;function i(s,a){t(s,a),r=n.requestAnimationFrame(i)}return{start:function(){e!==!0&&t!==null&&(r=n.requestAnimationFrame(i),e=!0)},stop:function(){n.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(s){t=s},setContext:function(s){n=s}}}function XN(n){const e=new WeakMap;function t(o,c){const l=o.array,u=o.usage,f=l.byteLength,d=n.createBuffer();n.bindBuffer(c,d),n.bufferData(c,l,u),o.onUploadCallback();let h;if(l instanceof Float32Array)h=n.FLOAT;else if(l instanceof Uint16Array)o.isFloat16BufferAttribute?h=n.HALF_FLOAT:h=n.UNSIGNED_SHORT;else if(l instanceof Int16Array)h=n.SHORT;else if(l instanceof Uint32Array)h=n.UNSIGNED_INT;else if(l instanceof Int32Array)h=n.INT;else if(l instanceof Int8Array)h=n.BYTE;else if(l instanceof Uint8Array)h=n.UNSIGNED_BYTE;else if(l instanceof Uint8ClampedArray)h=n.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+l);return{buffer:d,type:h,bytesPerElement:l.BYTES_PER_ELEMENT,version:o.version,size:f}}function r(o,c,l){const u=c.array,f=c.updateRanges;if(n.bindBuffer(l,o),f.length===0)n.bufferSubData(l,0,u);else{f.sort((h,p)=>h.start-p.start);let d=0;for(let h=1;h<f.length;h++){const p=f[d],g=f[h];g.start<=p.start+p.count+1?p.count=Math.max(p.count,g.start+g.count-p.start):(++d,f[d]=g)}f.length=d+1;for(let h=0,p=f.length;h<p;h++){const g=f[h];n.bufferSubData(l,g.start*u.BYTES_PER_ELEMENT,u,g.start,g.count)}c.clearUpdateRanges()}c.onUploadCallback()}function i(o){return o.isInterleavedBufferAttribute&&(o=o.data),e.get(o)}function s(o){o.isInterleavedBufferAttribute&&(o=o.data);const c=e.get(o);c&&(n.deleteBuffer(c.buffer),e.delete(o))}function a(o,c){if(o.isInterleavedBufferAttribute&&(o=o.data),o.isGLBufferAttribute){const u=e.get(o);(!u||u.version<o.version)&&e.set(o,{buffer:o.buffer,type:o.type,bytesPerElement:o.elementSize,version:o.version});return}const l=e.get(o);if(l===void 0)e.set(o,t(o,c));else if(l.version<o.version){if(l.size!==o.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");r(l.buffer,o,c),l.version=o.version}}return{get:i,remove:s,update:a}}class Bu extends ws{constructor(e=1,t=1,r=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:t,widthSegments:r,heightSegments:i};const s=e/2,a=t/2,o=Math.floor(r),c=Math.floor(i),l=o+1,u=c+1,f=e/o,d=t/c,h=[],p=[],g=[],m=[];for(let v=0;v<u;v++){const x=v*d-a;for(let b=0;b<l;b++){const _=b*f-s;p.push(_,-x,0),g.push(0,0,1),m.push(b/o),m.push(1-v/c)}}for(let v=0;v<c;v++)for(let x=0;x<o;x++){const b=x+l*v,_=x+l*(v+1),w=x+1+l*(v+1),E=x+1+l*v;h.push(b,_,E),h.push(_,w,E)}this.setIndex(h),this.setAttribute("position",new Gs(p,3)),this.setAttribute("normal",new Gs(g,3)),this.setAttribute("uv",new Gs(m,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Bu(e.width,e.height,e.widthSegments,e.heightSegments)}}var KN=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,jN=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,YN=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,ZN=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,QN=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,JN=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,ek=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,tk=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,nk=`#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,rk=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,ik=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,sk=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,ak=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,ok=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,ck=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,lk=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,uk=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,fk=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,dk=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,hk=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,pk=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,mk=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,vk=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,gk=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,xk=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,bk=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,_k=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,yk=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,wk=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Ek=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,Sk="gl_FragColor = linearToOutputTexel( gl_FragColor );",Tk=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,Ak=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Ck=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Ik=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Mk=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,Rk=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Nk=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,kk=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Dk=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Lk=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Ok=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,zk=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Pk=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Fk=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,$k=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Uk=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,Bk=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Vk=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Gk=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,Hk=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,Wk=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,qk=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,Xk=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,Kk=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,jk=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,Yk=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,Zk=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Qk=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,Jk=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,e4=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,t4=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,n4=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,r4=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,i4=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,s4=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,a4=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,o4=`#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,c4=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,l4=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,u4=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,f4=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,d4=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,h4=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,p4=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,m4=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,v4=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,g4=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,x4=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,b4=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,_4=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,y4=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,w4=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,E4=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,S4=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,T4=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,A4=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,C4=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,I4=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,M4=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,R4=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,N4=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,k4=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,D4=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,L4=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,O4=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,z4=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,P4=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,F4=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,$4=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,U4=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,B4=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,V4=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,G4=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,H4=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,W4=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,q4=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const X4=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,K4=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,j4=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Y4=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,Z4=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,Q4=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,J4=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,eD=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,tD=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,nD=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,rD=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,iD=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,sD=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,aD=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,oD=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,cD=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,lD=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,uD=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,fD=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,dD=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,hD=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,pD=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,mD=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,vD=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,gD=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,xD=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,bD=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,_D=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,yD=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,wD=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,ED=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,SD=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,TD=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,AD=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,wt={alphahash_fragment:KN,alphahash_pars_fragment:jN,alphamap_fragment:YN,alphamap_pars_fragment:ZN,alphatest_fragment:QN,alphatest_pars_fragment:JN,aomap_fragment:ek,aomap_pars_fragment:tk,batching_pars_vertex:nk,batching_vertex:rk,begin_vertex:ik,beginnormal_vertex:sk,bsdfs:ak,iridescence_fragment:ok,bumpmap_pars_fragment:ck,clipping_planes_fragment:lk,clipping_planes_pars_fragment:uk,clipping_planes_pars_vertex:fk,clipping_planes_vertex:dk,color_fragment:hk,color_pars_fragment:pk,color_pars_vertex:mk,color_vertex:vk,common:gk,cube_uv_reflection_fragment:xk,defaultnormal_vertex:bk,displacementmap_pars_vertex:_k,displacementmap_vertex:yk,emissivemap_fragment:wk,emissivemap_pars_fragment:Ek,colorspace_fragment:Sk,colorspace_pars_fragment:Tk,envmap_fragment:Ak,envmap_common_pars_fragment:Ck,envmap_pars_fragment:Ik,envmap_pars_vertex:Mk,envmap_physical_pars_fragment:Uk,envmap_vertex:Rk,fog_vertex:Nk,fog_pars_vertex:kk,fog_fragment:Dk,fog_pars_fragment:Lk,gradientmap_pars_fragment:Ok,lightmap_pars_fragment:zk,lights_lambert_fragment:Pk,lights_lambert_pars_fragment:Fk,lights_pars_begin:$k,lights_toon_fragment:Bk,lights_toon_pars_fragment:Vk,lights_phong_fragment:Gk,lights_phong_pars_fragment:Hk,lights_physical_fragment:Wk,lights_physical_pars_fragment:qk,lights_fragment_begin:Xk,lights_fragment_maps:Kk,lights_fragment_end:jk,logdepthbuf_fragment:Yk,logdepthbuf_pars_fragment:Zk,logdepthbuf_pars_vertex:Qk,logdepthbuf_vertex:Jk,map_fragment:e4,map_pars_fragment:t4,map_particle_fragment:n4,map_particle_pars_fragment:r4,metalnessmap_fragment:i4,metalnessmap_pars_fragment:s4,morphinstance_vertex:a4,morphcolor_vertex:o4,morphnormal_vertex:c4,morphtarget_pars_vertex:l4,morphtarget_vertex:u4,normal_fragment_begin:f4,normal_fragment_maps:d4,normal_pars_fragment:h4,normal_pars_vertex:p4,normal_vertex:m4,normalmap_pars_fragment:v4,clearcoat_normal_fragment_begin:g4,clearcoat_normal_fragment_maps:x4,clearcoat_pars_fragment:b4,iridescence_pars_fragment:_4,opaque_fragment:y4,packing:w4,premultiplied_alpha_fragment:E4,project_vertex:S4,dithering_fragment:T4,dithering_pars_fragment:A4,roughnessmap_fragment:C4,roughnessmap_pars_fragment:I4,shadowmap_pars_fragment:M4,shadowmap_pars_vertex:R4,shadowmap_vertex:N4,shadowmask_pars_fragment:k4,skinbase_vertex:D4,skinning_pars_vertex:L4,skinning_vertex:O4,skinnormal_vertex:z4,specularmap_fragment:P4,specularmap_pars_fragment:F4,tonemapping_fragment:$4,tonemapping_pars_fragment:U4,transmission_fragment:B4,transmission_pars_fragment:V4,uv_pars_fragment:G4,uv_pars_vertex:H4,uv_vertex:W4,worldpos_vertex:q4,background_vert:X4,background_frag:K4,backgroundCube_vert:j4,backgroundCube_frag:Y4,cube_vert:Z4,cube_frag:Q4,depth_vert:J4,depth_frag:eD,distanceRGBA_vert:tD,distanceRGBA_frag:nD,equirect_vert:rD,equirect_frag:iD,linedashed_vert:sD,linedashed_frag:aD,meshbasic_vert:oD,meshbasic_frag:cD,meshlambert_vert:lD,meshlambert_frag:uD,meshmatcap_vert:fD,meshmatcap_frag:dD,meshnormal_vert:hD,meshnormal_frag:pD,meshphong_vert:mD,meshphong_frag:vD,meshphysical_vert:gD,meshphysical_frag:xD,meshtoon_vert:bD,meshtoon_frag:_D,points_vert:yD,points_frag:wD,shadow_vert:ED,shadow_frag:SD,sprite_vert:TD,sprite_frag:AD},Re={common:{diffuse:{value:new ht(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new yt},alphaMap:{value:null},alphaMapTransform:{value:new yt},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new yt}},envmap:{envMap:{value:null},envMapRotation:{value:new yt},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new yt}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new yt}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new yt},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new yt},normalScale:{value:new Ye(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new yt},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new yt}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new yt}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new yt}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new ht(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowIntensity:1,shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new ht(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new yt},alphaTest:{value:0},uvTransform:{value:new yt}},sprite:{diffuse:{value:new ht(16777215)},opacity:{value:1},center:{value:new Ye(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new yt},alphaMap:{value:null},alphaMapTransform:{value:new yt},alphaTest:{value:0}}},rs={basic:{uniforms:yr([Re.common,Re.specularmap,Re.envmap,Re.aomap,Re.lightmap,Re.fog]),vertexShader:wt.meshbasic_vert,fragmentShader:wt.meshbasic_frag},lambert:{uniforms:yr([Re.common,Re.specularmap,Re.envmap,Re.aomap,Re.lightmap,Re.emissivemap,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.fog,Re.lights,{emissive:{value:new ht(0)}}]),vertexShader:wt.meshlambert_vert,fragmentShader:wt.meshlambert_frag},phong:{uniforms:yr([Re.common,Re.specularmap,Re.envmap,Re.aomap,Re.lightmap,Re.emissivemap,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.fog,Re.lights,{emissive:{value:new ht(0)},specular:{value:new ht(1118481)},shininess:{value:30}}]),vertexShader:wt.meshphong_vert,fragmentShader:wt.meshphong_frag},standard:{uniforms:yr([Re.common,Re.envmap,Re.aomap,Re.lightmap,Re.emissivemap,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.roughnessmap,Re.metalnessmap,Re.fog,Re.lights,{emissive:{value:new ht(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:wt.meshphysical_vert,fragmentShader:wt.meshphysical_frag},toon:{uniforms:yr([Re.common,Re.aomap,Re.lightmap,Re.emissivemap,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.gradientmap,Re.fog,Re.lights,{emissive:{value:new ht(0)}}]),vertexShader:wt.meshtoon_vert,fragmentShader:wt.meshtoon_frag},matcap:{uniforms:yr([Re.common,Re.bumpmap,Re.normalmap,Re.displacementmap,Re.fog,{matcap:{value:null}}]),vertexShader:wt.meshmatcap_vert,fragmentShader:wt.meshmatcap_frag},points:{uniforms:yr([Re.points,Re.fog]),vertexShader:wt.points_vert,fragmentShader:wt.points_frag},dashed:{uniforms:yr([Re.common,Re.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:wt.linedashed_vert,fragmentShader:wt.linedashed_frag},depth:{uniforms:yr([Re.common,Re.displacementmap]),vertexShader:wt.depth_vert,fragmentShader:wt.depth_frag},normal:{uniforms:yr([Re.common,Re.bumpmap,Re.normalmap,Re.displacementmap,{opacity:{value:1}}]),vertexShader:wt.meshnormal_vert,fragmentShader:wt.meshnormal_frag},sprite:{uniforms:yr([Re.sprite,Re.fog]),vertexShader:wt.sprite_vert,fragmentShader:wt.sprite_frag},background:{uniforms:{uvTransform:{value:new yt},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:wt.background_vert,fragmentShader:wt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new yt}},vertexShader:wt.backgroundCube_vert,fragmentShader:wt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:wt.cube_vert,fragmentShader:wt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:wt.equirect_vert,fragmentShader:wt.equirect_frag},distanceRGBA:{uniforms:yr([Re.common,Re.displacementmap,{referencePosition:{value:new $},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:wt.distanceRGBA_vert,fragmentShader:wt.distanceRGBA_frag},shadow:{uniforms:yr([Re.lights,Re.fog,{color:{value:new ht(0)},opacity:{value:1}}]),vertexShader:wt.shadow_vert,fragmentShader:wt.shadow_frag}};rs.physical={uniforms:yr([rs.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new yt},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new yt},clearcoatNormalScale:{value:new Ye(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new yt},dispersion:{value:0},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new yt},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new yt},sheen:{value:0},sheenColor:{value:new ht(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new yt},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new yt},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new yt},transmissionSamplerSize:{value:new Ye},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new yt},attenuationDistance:{value:0},attenuationColor:{value:new ht(0)},specularColor:{value:new ht(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new yt},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new yt},anisotropyVector:{value:new Ye},anisotropyMap:{value:null},anisotropyMapTransform:{value:new yt}}]),vertexShader:wt.meshphysical_vert,fragmentShader:wt.meshphysical_frag};const Od={r:0,b:0,g:0},to=new ms,CD=new lt;function ID(n,e,t,r,i,s,a){const o=new ht(0);let c=s===!0?0:1,l,u,f=null,d=0,h=null;function p(x){let b=x.isScene===!0?x.background:null;return b&&b.isTexture&&(b=(x.backgroundBlurriness>0?t:e).get(b)),b}function g(x){let b=!1;const _=p(x);_===null?v(o,c):_&&_.isColor&&(v(_,1),b=!0);const w=n.xr.getEnvironmentBlendMode();w==="additive"?r.buffers.color.setClear(0,0,0,1,a):w==="alpha-blend"&&r.buffers.color.setClear(0,0,0,0,a),(n.autoClear||b)&&(r.buffers.depth.setTest(!0),r.buffers.depth.setMask(!0),r.buffers.color.setMask(!0),n.clear(n.autoClearColor,n.autoClearDepth,n.autoClearStencil))}function m(x,b){const _=p(b);_&&(_.isCubeTexture||_.mapping===pp)?(u===void 0&&(u=new gr(new gl(1,1,1),new qs({name:"BackgroundCubeMaterial",uniforms:Yc(rs.backgroundCube.uniforms),vertexShader:rs.backgroundCube.vertexShader,fragmentShader:rs.backgroundCube.fragmentShader,side:Ir,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(w,E,S){this.matrixWorld.copyPosition(S.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),to.copy(b.backgroundRotation),to.x*=-1,to.y*=-1,to.z*=-1,_.isCubeTexture&&_.isRenderTargetTexture===!1&&(to.y*=-1,to.z*=-1),u.material.uniforms.envMap.value=_,u.material.uniforms.flipEnvMap.value=_.isCubeTexture&&_.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=b.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=b.backgroundIntensity,u.material.uniforms.backgroundRotation.value.setFromMatrix4(CD.makeRotationFromEuler(to)),u.material.toneMapped=Lt.getTransfer(_.colorSpace)!==on,(f!==_||d!==_.version||h!==n.toneMapping)&&(u.material.needsUpdate=!0,f=_,d=_.version,h=n.toneMapping),u.layers.enableAll(),x.unshift(u,u.geometry,u.material,0,0,null)):_&&_.isTexture&&(l===void 0&&(l=new gr(new Bu(2,2),new qs({name:"BackgroundMaterial",uniforms:Yc(rs.background.uniforms),vertexShader:rs.background.vertexShader,fragmentShader:rs.background.fragmentShader,side:Ws,depthTest:!1,depthWrite:!1,fog:!1})),l.geometry.deleteAttribute("normal"),Object.defineProperty(l.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(l)),l.material.uniforms.t2D.value=_,l.material.uniforms.backgroundIntensity.value=b.backgroundIntensity,l.material.toneMapped=Lt.getTransfer(_.colorSpace)!==on,_.matrixAutoUpdate===!0&&_.updateMatrix(),l.material.uniforms.uvTransform.value.copy(_.matrix),(f!==_||d!==_.version||h!==n.toneMapping)&&(l.material.needsUpdate=!0,f=_,d=_.version,h=n.toneMapping),l.layers.enableAll(),x.unshift(l,l.geometry,l.material,0,0,null))}function v(x,b){x.getRGB(Od,xE(n)),r.buffers.color.setClear(Od.r,Od.g,Od.b,b,a)}return{getClearColor:function(){return o},setClearColor:function(x,b=1){o.set(x),c=b,v(o,c)},getClearAlpha:function(){return c},setClearAlpha:function(x){c=x,v(o,c)},render:g,addToRenderList:m}}function MD(n,e){const t=n.getParameter(n.MAX_VERTEX_ATTRIBS),r={},i=d(null);let s=i,a=!1;function o(y,A,k,M,L){let z=!1;const D=f(M,k,A);s!==D&&(s=D,l(s.object)),z=h(y,M,k,L),z&&p(y,M,k,L),L!==null&&e.update(L,n.ELEMENT_ARRAY_BUFFER),(z||a)&&(a=!1,_(y,A,k,M),L!==null&&n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,e.get(L).buffer))}function c(){return n.createVertexArray()}function l(y){return n.bindVertexArray(y)}function u(y){return n.deleteVertexArray(y)}function f(y,A,k){const M=k.wireframe===!0;let L=r[y.id];L===void 0&&(L={},r[y.id]=L);let z=L[A.id];z===void 0&&(z={},L[A.id]=z);let D=z[M];return D===void 0&&(D=d(c()),z[M]=D),D}function d(y){const A=[],k=[],M=[];for(let L=0;L<t;L++)A[L]=0,k[L]=0,M[L]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:A,enabledAttributes:k,attributeDivisors:M,object:y,attributes:{},index:null}}function h(y,A,k,M){const L=s.attributes,z=A.attributes;let D=0;const F=k.getAttributes();for(const O in F)if(F[O].location>=0){const J=L[O];let Q=z[O];if(Q===void 0&&(O==="instanceMatrix"&&y.instanceMatrix&&(Q=y.instanceMatrix),O==="instanceColor"&&y.instanceColor&&(Q=y.instanceColor)),J===void 0||J.attribute!==Q||Q&&J.data!==Q.data)return!0;D++}return s.attributesNum!==D||s.index!==M}function p(y,A,k,M){const L={},z=A.attributes;let D=0;const F=k.getAttributes();for(const O in F)if(F[O].location>=0){let J=z[O];J===void 0&&(O==="instanceMatrix"&&y.instanceMatrix&&(J=y.instanceMatrix),O==="instanceColor"&&y.instanceColor&&(J=y.instanceColor));const Q={};Q.attribute=J,J&&J.data&&(Q.data=J.data),L[O]=Q,D++}s.attributes=L,s.attributesNum=D,s.index=M}function g(){const y=s.newAttributes;for(let A=0,k=y.length;A<k;A++)y[A]=0}function m(y){v(y,0)}function v(y,A){const k=s.newAttributes,M=s.enabledAttributes,L=s.attributeDivisors;k[y]=1,M[y]===0&&(n.enableVertexAttribArray(y),M[y]=1),L[y]!==A&&(n.vertexAttribDivisor(y,A),L[y]=A)}function x(){const y=s.newAttributes,A=s.enabledAttributes;for(let k=0,M=A.length;k<M;k++)A[k]!==y[k]&&(n.disableVertexAttribArray(k),A[k]=0)}function b(y,A,k,M,L,z,D){D===!0?n.vertexAttribIPointer(y,A,k,L,z):n.vertexAttribPointer(y,A,k,M,L,z)}function _(y,A,k,M){g();const L=M.attributes,z=k.getAttributes(),D=A.defaultAttributeValues;for(const F in z){const O=z[F];if(O.location>=0){let V=L[F];if(V===void 0&&(F==="instanceMatrix"&&y.instanceMatrix&&(V=y.instanceMatrix),F==="instanceColor"&&y.instanceColor&&(V=y.instanceColor)),V!==void 0){const J=V.normalized,Q=V.itemSize,de=e.get(V);if(de===void 0)continue;const le=de.buffer,H=de.type,q=de.bytesPerElement,oe=H===n.INT||H===n.UNSIGNED_INT||V.gpuType===Yx;if(V.isInterleavedBufferAttribute){const fe=V.data,_e=fe.stride,xe=V.offset;if(fe.isInstancedInterleavedBuffer){for(let Se=0;Se<O.locationSize;Se++)v(O.location+Se,fe.meshPerAttribute);y.isInstancedMesh!==!0&&M._maxInstanceCount===void 0&&(M._maxInstanceCount=fe.meshPerAttribute*fe.count)}else for(let Se=0;Se<O.locationSize;Se++)m(O.location+Se);n.bindBuffer(n.ARRAY_BUFFER,le);for(let Se=0;Se<O.locationSize;Se++)b(O.location+Se,Q/O.locationSize,H,J,_e*q,(xe+Q/O.locationSize*Se)*q,oe)}else{if(V.isInstancedBufferAttribute){for(let fe=0;fe<O.locationSize;fe++)v(O.location+fe,V.meshPerAttribute);y.isInstancedMesh!==!0&&M._maxInstanceCount===void 0&&(M._maxInstanceCount=V.meshPerAttribute*V.count)}else for(let fe=0;fe<O.locationSize;fe++)m(O.location+fe);n.bindBuffer(n.ARRAY_BUFFER,le);for(let fe=0;fe<O.locationSize;fe++)b(O.location+fe,Q/O.locationSize,H,J,Q*q,Q/O.locationSize*fe*q,oe)}}else if(D!==void 0){const J=D[F];if(J!==void 0)switch(J.length){case 2:n.vertexAttrib2fv(O.location,J);break;case 3:n.vertexAttrib3fv(O.location,J);break;case 4:n.vertexAttrib4fv(O.location,J);break;default:n.vertexAttrib1fv(O.location,J)}}}}x()}function w(){T();for(const y in r){const A=r[y];for(const k in A){const M=A[k];for(const L in M)u(M[L].object),delete M[L];delete A[k]}delete r[y]}}function E(y){if(r[y.id]===void 0)return;const A=r[y.id];for(const k in A){const M=A[k];for(const L in M)u(M[L].object),delete M[L];delete A[k]}delete r[y.id]}function S(y){for(const A in r){const k=r[A];if(k[y.id]===void 0)continue;const M=k[y.id];for(const L in M)u(M[L].object),delete M[L];delete k[y.id]}}function T(){C(),a=!0,s!==i&&(s=i,l(s.object))}function C(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:o,reset:T,resetDefaultState:C,dispose:w,releaseStatesOfGeometry:E,releaseStatesOfProgram:S,initAttributes:g,enableAttribute:m,disableUnusedAttributes:x}}function RD(n,e,t){let r;function i(l){r=l}function s(l,u){n.drawArrays(r,l,u),t.update(u,r,1)}function a(l,u,f){f!==0&&(n.drawArraysInstanced(r,l,u,f),t.update(u,r,f))}function o(l,u,f){if(f===0)return;e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(r,l,0,u,0,f);let h=0;for(let p=0;p<f;p++)h+=u[p];t.update(h,r,1)}function c(l,u,f,d){if(f===0)return;const h=e.get("WEBGL_multi_draw");if(h===null)for(let p=0;p<l.length;p++)a(l[p],u[p],d[p]);else{h.multiDrawArraysInstancedWEBGL(r,l,0,u,0,d,0,f);let p=0;for(let g=0;g<f;g++)p+=u[g];for(let g=0;g<d.length;g++)t.update(p,r,d[g])}}this.setMode=i,this.render=s,this.renderInstances=a,this.renderMultiDraw=o,this.renderMultiDrawInstances=c}function ND(n,e,t,r){let i;function s(){if(i!==void 0)return i;if(e.has("EXT_texture_filter_anisotropic")===!0){const S=e.get("EXT_texture_filter_anisotropic");i=n.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else i=0;return i}function a(S){return!(S!==Jr&&r.convert(S)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_FORMAT))}function o(S){const T=S===Us&&(e.has("EXT_color_buffer_half_float")||e.has("EXT_color_buffer_float"));return!(S!==yi&&r.convert(S)!==n.getParameter(n.IMPLEMENTATION_COLOR_READ_TYPE)&&S!==pi&&!T)}function c(S){if(S==="highp"){if(n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision>0)return"highp";S="mediump"}return S==="mediump"&&n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision>0&&n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let l=t.precision!==void 0?t.precision:"highp";const u=c(l);u!==l&&(console.warn("THREE.WebGLRenderer:",l,"not supported, using",u,"instead."),l=u);const f=t.logarithmicDepthBuffer===!0,d=t.reverseDepthBuffer===!0&&e.has("EXT_clip_control");if(d===!0){const S=e.get("EXT_clip_control");S.clipControlEXT(S.LOWER_LEFT_EXT,S.ZERO_TO_ONE_EXT)}const h=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS),p=n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS),g=n.getParameter(n.MAX_TEXTURE_SIZE),m=n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE),v=n.getParameter(n.MAX_VERTEX_ATTRIBS),x=n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS),b=n.getParameter(n.MAX_VARYING_VECTORS),_=n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS),w=p>0,E=n.getParameter(n.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:s,getMaxPrecision:c,textureFormatReadable:a,textureTypeReadable:o,precision:l,logarithmicDepthBuffer:f,reverseDepthBuffer:d,maxTextures:h,maxVertexTextures:p,maxTextureSize:g,maxCubemapSize:m,maxAttributes:v,maxVertexUniforms:x,maxVaryings:b,maxFragmentUniforms:_,vertexTextures:w,maxSamples:E}}function kD(n){const e=this;let t=null,r=0,i=!1,s=!1;const a=new ma,o=new yt,c={value:null,needsUpdate:!1};this.uniform=c,this.numPlanes=0,this.numIntersection=0,this.init=function(f,d){const h=f.length!==0||d||r!==0||i;return i=d,r=f.length,h},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(f,d){t=u(f,d,0)},this.setState=function(f,d,h){const p=f.clippingPlanes,g=f.clipIntersection,m=f.clipShadows,v=n.get(f);if(!i||p===null||p.length===0||s&&!m)s?u(null):l();else{const x=s?0:r,b=x*4;let _=v.clippingState||null;c.value=_,_=u(p,d,b,h);for(let w=0;w!==b;++w)_[w]=t[w];v.clippingState=_,this.numIntersection=g?this.numPlanes:0,this.numPlanes+=x}};function l(){c.value!==t&&(c.value=t,c.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(f,d,h,p){const g=f!==null?f.length:0;let m=null;if(g!==0){if(m=c.value,p!==!0||m===null){const v=h+g*4,x=d.matrixWorldInverse;o.getNormalMatrix(x),(m===null||m.length<v)&&(m=new Float32Array(v));for(let b=0,_=h;b!==g;++b,_+=4)a.copy(f[b]).applyMatrix4(x,o),a.normal.toArray(m,_),m[_+3]=a.constant}c.value=m,c.needsUpdate=!0}return e.numPlanes=g,e.numIntersection=0,m}}function DD(n){let e=new WeakMap;function t(a,o){return o===mg?a.mapping=Hc:o===vg&&(a.mapping=Wc),a}function r(a){if(a&&a.isTexture){const o=a.mapping;if(o===mg||o===vg)if(e.has(a)){const c=e.get(a).texture;return t(c,a.mapping)}else{const c=a.image;if(c&&c.height>0){const l=new HN(c.height);return l.fromEquirectangularTexture(n,a),e.set(a,l),a.addEventListener("dispose",i),t(l.texture,a.mapping)}else return null}}return a}function i(a){const o=a.target;o.removeEventListener("dispose",i);const c=e.get(o);c!==void 0&&(e.delete(o),c.dispose())}function s(){e=new WeakMap}return{get:r,dispose:s}}class o0 extends bE{constructor(e=-1,t=1,r=1,i=-1,s=.1,a=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=t,this.top=r,this.bottom=i,this.near=s,this.far=a,this.updateProjectionMatrix()}copy(e,t){return super.copy(e,t),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,t,r,i,s,a){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=t,this.view.offsetX=r,this.view.offsetY=i,this.view.width=s,this.view.height=a,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),t=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=r-e,a=r+e,o=i+t,c=i-t;if(this.view!==null&&this.view.enabled){const l=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=l*this.view.offsetX,a=s+l*this.view.width,o-=u*this.view.offsetY,c=o-u*this.view.height}this.projectionMatrix.makeOrthographic(s,a,o,c,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const t=super.toJSON(e);return t.object.zoom=this.zoom,t.object.left=this.left,t.object.right=this.right,t.object.top=this.top,t.object.bottom=this.bottom,t.object.near=this.near,t.object.far=this.far,this.view!==null&&(t.object.view=Object.assign({},this.view)),t}}const Ic=4,c1=[.125,.215,.35,.446,.526,.582],lo=20,bv=new o0,l1=new ht;let _v=null,yv=0,wv=0,Ev=!1;const ao=(1+Math.sqrt(5))/2,vc=1/ao,u1=[new $(-ao,vc,0),new $(ao,vc,0),new $(-vc,0,ao),new $(vc,0,ao),new $(0,ao,-vc),new $(0,ao,vc),new $(-1,1,-1),new $(1,1,-1),new $(-1,1,1),new $(1,1,1)];class f1{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,t=0,r=.1,i=100){_v=this._renderer.getRenderTarget(),yv=this._renderer.getActiveCubeFace(),wv=this._renderer.getActiveMipmapLevel(),Ev=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,r,i,s),t>0&&this._blur(s,0,0,t),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,t=null){return this._fromTexture(e,t)}fromCubemap(e,t=null){return this._fromTexture(e,t)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=p1(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=h1(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(_v,yv,wv),this._renderer.xr.enabled=Ev,e.scissorTest=!1,zd(e,0,0,e.width,e.height)}_fromTexture(e,t){e.mapping===Hc||e.mapping===Wc?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),_v=this._renderer.getRenderTarget(),yv=this._renderer.getActiveCubeFace(),wv=this._renderer.getActiveMipmapLevel(),Ev=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const r=t||this._allocateTargets();return this._textureToCubeUV(e,r),this._applyPMREM(r),this._cleanup(r),r}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),t=4*this._cubeSize,r={magFilter:Rn,minFilter:Rn,generateMipmaps:!1,type:Us,format:Jr,colorSpace:rr,depthBuffer:!1},i=d1(e,t,r);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==t){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=d1(e,t,r);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=LD(s)),this._blurMaterial=OD(s,e,t)}return i}_compileMaterial(e){const t=new gr(this._lodPlanes[0],e);this._renderer.compile(t,bv)}_sceneToCubeUV(e,t,r,i){const o=new Er(90,1,t,r),c=[1,-1,1,1,1,1],l=[1,1,1,-1,-1,-1],u=this._renderer,f=u.autoClear,d=u.toneMapping;u.getClearColor(l1),u.toneMapping=Ta,u.autoClear=!1;const h=new xa({name:"PMREM.Background",side:Ir,depthWrite:!1,depthTest:!1}),p=new gr(new gl,h);let g=!1;const m=e.background;m?m.isColor&&(h.color.copy(m),e.background=null,g=!0):(h.color.copy(l1),g=!0);for(let v=0;v<6;v++){const x=v%3;x===0?(o.up.set(0,c[v],0),o.lookAt(l[v],0,0)):x===1?(o.up.set(0,0,c[v]),o.lookAt(0,l[v],0)):(o.up.set(0,c[v],0),o.lookAt(0,0,l[v]));const b=this._cubeSize;zd(i,x*b,v>2?b:0,b,b),u.setRenderTarget(i),g&&u.render(p,o),u.render(e,o)}p.geometry.dispose(),p.material.dispose(),u.toneMapping=d,u.autoClear=f,e.background=m}_textureToCubeUV(e,t){const r=this._renderer,i=e.mapping===Hc||e.mapping===Wc;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=p1()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=h1());const s=i?this._cubemapMaterial:this._equirectMaterial,a=new gr(this._lodPlanes[0],s),o=s.uniforms;o.envMap.value=e;const c=this._cubeSize;zd(t,0,0,3*c,2*c),r.setRenderTarget(t),r.render(a,bv)}_applyPMREM(e){const t=this._renderer,r=t.autoClear;t.autoClear=!1;const i=this._lodPlanes.length;for(let s=1;s<i;s++){const a=Math.sqrt(this._sigmas[s]*this._sigmas[s]-this._sigmas[s-1]*this._sigmas[s-1]),o=u1[(i-s-1)%u1.length];this._blur(e,s-1,s,a,o)}t.autoClear=r}_blur(e,t,r,i,s){const a=this._pingPongRenderTarget;this._halfBlur(e,a,t,r,i,"latitudinal",s),this._halfBlur(a,e,r,r,i,"longitudinal",s)}_halfBlur(e,t,r,i,s,a,o){const c=this._renderer,l=this._blurMaterial;a!=="latitudinal"&&a!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,f=new gr(this._lodPlanes[i],l),d=l.uniforms,h=this._sizeLods[r]-1,p=isFinite(s)?Math.PI/(2*h):2*Math.PI/(2*lo-1),g=s/p,m=isFinite(s)?1+Math.floor(u*g):lo;m>lo&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${lo}`);const v=[];let x=0;for(let S=0;S<lo;++S){const T=S/g,C=Math.exp(-T*T/2);v.push(C),S===0?x+=C:S<m&&(x+=2*C)}for(let S=0;S<v.length;S++)v[S]=v[S]/x;d.envMap.value=e.texture,d.samples.value=m,d.weights.value=v,d.latitudinal.value=a==="latitudinal",o&&(d.poleAxis.value=o);const{_lodMax:b}=this;d.dTheta.value=p,d.mipInt.value=b-r;const _=this._sizeLods[i],w=3*_*(i>b-Ic?i-b+Ic:0),E=4*(this._cubeSize-_);zd(t,w,E,3*_,2*_),c.setRenderTarget(t),c.render(f,bv)}}function LD(n){const e=[],t=[],r=[];let i=n;const s=n-Ic+1+c1.length;for(let a=0;a<s;a++){const o=Math.pow(2,i);t.push(o);let c=1/o;a>n-Ic?c=c1[a-n+Ic-1]:a===0&&(c=0),r.push(c);const l=1/(o-2),u=-l,f=1+l,d=[u,u,f,u,f,f,u,u,f,f,u,f],h=6,p=6,g=3,m=2,v=1,x=new Float32Array(g*p*h),b=new Float32Array(m*p*h),_=new Float32Array(v*p*h);for(let E=0;E<h;E++){const S=E%3*2/3-1,T=E>2?0:-1,C=[S,T,0,S+2/3,T,0,S+2/3,T+1,0,S,T,0,S+2/3,T+1,0,S,T+1,0];x.set(C,g*p*E),b.set(d,m*p*E);const y=[E,E,E,E,E,E];_.set(y,v*p*E)}const w=new ws;w.setAttribute("position",new Mr(x,g)),w.setAttribute("uv",new Mr(b,m)),w.setAttribute("faceIndex",new Mr(_,v)),e.push(w),i>Ic&&i--}return{lodPlanes:e,sizeLods:t,sigmas:r}}function d1(n,e,t){const r=new So(n,e,t);return r.texture.mapping=pp,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function zd(n,e,t,r,i){n.viewport.set(e,t,r,i),n.scissor.set(e,t,r,i)}function OD(n,e,t){const r=new Float32Array(lo),i=new $(0,1,0);return new qs({name:"SphericalGaussianBlur",defines:{n:lo,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/t,CUBEUV_MAX_MIP:`${n}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:c0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:Sa,depthTest:!1,depthWrite:!1})}function h1(){return new qs({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:c0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:Sa,depthTest:!1,depthWrite:!1})}function p1(){return new qs({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:c0(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:Sa,depthTest:!1,depthWrite:!1})}function c0(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function zD(n){let e=new WeakMap,t=null;function r(o){if(o&&o.isTexture){const c=o.mapping,l=c===mg||c===vg,u=c===Hc||c===Wc;if(l||u){let f=e.get(o);const d=f!==void 0?f.texture.pmremVersion:0;if(o.isRenderTargetTexture&&o.pmremVersion!==d)return t===null&&(t=new f1(n)),f=l?t.fromEquirectangular(o,f):t.fromCubemap(o,f),f.texture.pmremVersion=o.pmremVersion,e.set(o,f),f.texture;if(f!==void 0)return f.texture;{const h=o.image;return l&&h&&h.height>0||u&&h&&i(h)?(t===null&&(t=new f1(n)),f=l?t.fromEquirectangular(o):t.fromCubemap(o),f.texture.pmremVersion=o.pmremVersion,e.set(o,f),o.addEventListener("dispose",s),f.texture):null}}}return o}function i(o){let c=0;const l=6;for(let u=0;u<l;u++)o[u]!==void 0&&c++;return c===l}function s(o){const c=o.target;c.removeEventListener("dispose",s);const l=e.get(c);l!==void 0&&(e.delete(c),l.dispose())}function a(){e=new WeakMap,t!==null&&(t.dispose(),t=null)}return{get:r,dispose:a}}function PD(n){const e={};function t(r){if(e[r]!==void 0)return e[r];let i;switch(r){case"WEBGL_depth_texture":i=n.getExtension("WEBGL_depth_texture")||n.getExtension("MOZ_WEBGL_depth_texture")||n.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("MOZ_EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=n.getExtension("WEBGL_compressed_texture_s3tc")||n.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=n.getExtension("WEBGL_compressed_texture_pvrtc")||n.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=n.getExtension(r)}return e[r]=i,i}return{has:function(r){return t(r)!==null},init:function(){t("EXT_color_buffer_float"),t("WEBGL_clip_cull_distance"),t("OES_texture_float_linear"),t("EXT_color_buffer_half_float"),t("WEBGL_multisampled_render_to_texture"),t("WEBGL_render_shared_exponent")},get:function(r){const i=t(r);return i===null&&vh("THREE.WebGLRenderer: "+r+" extension not supported."),i}}}function FD(n,e,t,r){const i={},s=new WeakMap;function a(f){const d=f.target;d.index!==null&&e.remove(d.index);for(const p in d.attributes)e.remove(d.attributes[p]);for(const p in d.morphAttributes){const g=d.morphAttributes[p];for(let m=0,v=g.length;m<v;m++)e.remove(g[m])}d.removeEventListener("dispose",a),delete i[d.id];const h=s.get(d);h&&(e.remove(h),s.delete(d)),r.releaseStatesOfGeometry(d),d.isInstancedBufferGeometry===!0&&delete d._maxInstanceCount,t.memory.geometries--}function o(f,d){return i[d.id]===!0||(d.addEventListener("dispose",a),i[d.id]=!0,t.memory.geometries++),d}function c(f){const d=f.attributes;for(const p in d)e.update(d[p],n.ARRAY_BUFFER);const h=f.morphAttributes;for(const p in h){const g=h[p];for(let m=0,v=g.length;m<v;m++)e.update(g[m],n.ARRAY_BUFFER)}}function l(f){const d=[],h=f.index,p=f.attributes.position;let g=0;if(h!==null){const x=h.array;g=h.version;for(let b=0,_=x.length;b<_;b+=3){const w=x[b+0],E=x[b+1],S=x[b+2];d.push(w,E,E,S,S,w)}}else if(p!==void 0){const x=p.array;g=p.version;for(let b=0,_=x.length/3-1;b<_;b+=3){const w=b+0,E=b+1,S=b+2;d.push(w,E,E,S,S,w)}}else return;const m=new(fE(d)?gE:vE)(d,1);m.version=g;const v=s.get(f);v&&e.remove(v),s.set(f,m)}function u(f){const d=s.get(f);if(d){const h=f.index;h!==null&&d.version<h.version&&l(f)}else l(f);return s.get(f)}return{get:o,update:c,getWireframeAttribute:u}}function $D(n,e,t){let r;function i(d){r=d}let s,a;function o(d){s=d.type,a=d.bytesPerElement}function c(d,h){n.drawElements(r,h,s,d*a),t.update(h,r,1)}function l(d,h,p){p!==0&&(n.drawElementsInstanced(r,h,s,d*a,p),t.update(h,r,p))}function u(d,h,p){if(p===0)return;e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(r,h,0,s,d,0,p);let m=0;for(let v=0;v<p;v++)m+=h[v];t.update(m,r,1)}function f(d,h,p,g){if(p===0)return;const m=e.get("WEBGL_multi_draw");if(m===null)for(let v=0;v<d.length;v++)l(d[v]/a,h[v],g[v]);else{m.multiDrawElementsInstancedWEBGL(r,h,0,s,d,0,g,0,p);let v=0;for(let x=0;x<p;x++)v+=h[x];for(let x=0;x<g.length;x++)t.update(v,r,g[x])}}this.setMode=i,this.setIndex=o,this.render=c,this.renderInstances=l,this.renderMultiDraw=u,this.renderMultiDrawInstances=f}function UD(n){const e={geometries:0,textures:0},t={frame:0,calls:0,triangles:0,points:0,lines:0};function r(s,a,o){switch(t.calls++,a){case n.TRIANGLES:t.triangles+=o*(s/3);break;case n.LINES:t.lines+=o*(s/2);break;case n.LINE_STRIP:t.lines+=o*(s-1);break;case n.LINE_LOOP:t.lines+=o*s;break;case n.POINTS:t.points+=o*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",a);break}}function i(){t.calls=0,t.triangles=0,t.points=0,t.lines=0}return{memory:e,render:t,programs:null,autoReset:!0,reset:i,update:r}}function BD(n,e,t){const r=new WeakMap,i=new Bt;function s(a,o,c){const l=a.morphTargetInfluences,u=o.morphAttributes.position||o.morphAttributes.normal||o.morphAttributes.color,f=u!==void 0?u.length:0;let d=r.get(o);if(d===void 0||d.count!==f){let y=function(){T.dispose(),r.delete(o),o.removeEventListener("dispose",y)};var h=y;d!==void 0&&d.texture.dispose();const p=o.morphAttributes.position!==void 0,g=o.morphAttributes.normal!==void 0,m=o.morphAttributes.color!==void 0,v=o.morphAttributes.position||[],x=o.morphAttributes.normal||[],b=o.morphAttributes.color||[];let _=0;p===!0&&(_=1),g===!0&&(_=2),m===!0&&(_=3);let w=o.attributes.position.count*_,E=1;w>e.maxTextureSize&&(E=Math.ceil(w/e.maxTextureSize),w=e.maxTextureSize);const S=new Float32Array(w*E*4*f),T=new hE(S,w,E,f);T.type=pi,T.needsUpdate=!0;const C=_*4;for(let A=0;A<f;A++){const k=v[A],M=x[A],L=b[A],z=w*E*4*A;for(let D=0;D<k.count;D++){const F=D*C;p===!0&&(i.fromBufferAttribute(k,D),S[z+F+0]=i.x,S[z+F+1]=i.y,S[z+F+2]=i.z,S[z+F+3]=0),g===!0&&(i.fromBufferAttribute(M,D),S[z+F+4]=i.x,S[z+F+5]=i.y,S[z+F+6]=i.z,S[z+F+7]=0),m===!0&&(i.fromBufferAttribute(L,D),S[z+F+8]=i.x,S[z+F+9]=i.y,S[z+F+10]=i.z,S[z+F+11]=L.itemSize===4?i.w:1)}}d={count:f,texture:T,size:new Ye(w,E)},r.set(o,d),o.addEventListener("dispose",y)}if(a.isInstancedMesh===!0&&a.morphTexture!==null)c.getUniforms().setValue(n,"morphTexture",a.morphTexture,t);else{let p=0;for(let m=0;m<l.length;m++)p+=l[m];const g=o.morphTargetsRelative?1:1-p;c.getUniforms().setValue(n,"morphTargetBaseInfluence",g),c.getUniforms().setValue(n,"morphTargetInfluences",l)}c.getUniforms().setValue(n,"morphTargetsTexture",d.texture,t),c.getUniforms().setValue(n,"morphTargetsTextureSize",d.size)}return{update:s}}function VD(n,e,t,r){let i=new WeakMap;function s(c){const l=r.render.frame,u=c.geometry,f=e.get(c,u);if(i.get(f)!==l&&(e.update(f),i.set(f,l)),c.isInstancedMesh&&(c.hasEventListener("dispose",o)===!1&&c.addEventListener("dispose",o),i.get(c)!==l&&(t.update(c.instanceMatrix,n.ARRAY_BUFFER),c.instanceColor!==null&&t.update(c.instanceColor,n.ARRAY_BUFFER),i.set(c,l))),c.isSkinnedMesh){const d=c.skeleton;i.get(d)!==l&&(d.update(),i.set(d,l))}return f}function a(){i=new WeakMap}function o(c){const l=c.target;l.removeEventListener("dispose",o),t.remove(l.instanceMatrix),l.instanceColor!==null&&t.remove(l.instanceColor)}return{update:s,dispose:a}}class yE extends Vn{constructor(e,t,r,i,s,a,o,c,l,u=Oc){if(u!==Oc&&u!==Kc)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");r===void 0&&u===Oc&&(r=Eo),r===void 0&&u===Kc&&(r=Xc),super(null,i,s,a,o,c,u,r,l),this.isDepthTexture=!0,this.image={width:e,height:t},this.magFilter=o!==void 0?o:cn,this.minFilter=c!==void 0?c:cn,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const t=super.toJSON(e);return this.compareFunction!==null&&(t.compareFunction=this.compareFunction),t}}const wE=new Vn,m1=new yE(1,1),EE=new hE,SE=new pE,TE=new s0,v1=[],g1=[],x1=new Float32Array(16),b1=new Float32Array(9),_1=new Float32Array(4);function xl(n,e,t){const r=n[0];if(r<=0||r>0)return n;const i=e*t;let s=v1[i];if(s===void 0&&(s=new Float32Array(i),v1[i]=s),e!==0){r.toArray(s,0);for(let a=1,o=0;a!==e;++a)o+=t,n[a].toArray(s,o)}return s}function Gn(n,e){if(n.length!==e.length)return!1;for(let t=0,r=n.length;t<r;t++)if(n[t]!==e[t])return!1;return!0}function Hn(n,e){for(let t=0,r=e.length;t<r;t++)n[t]=e[t]}function gp(n,e){let t=g1[e];t===void 0&&(t=new Int32Array(e),g1[e]=t);for(let r=0;r!==e;++r)t[r]=n.allocateTextureUnit();return t}function GD(n,e){const t=this.cache;t[0]!==e&&(n.uniform1f(this.addr,e),t[0]=e)}function HD(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2f(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Gn(t,e))return;n.uniform2fv(this.addr,e),Hn(t,e)}}function WD(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3f(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else if(e.r!==void 0)(t[0]!==e.r||t[1]!==e.g||t[2]!==e.b)&&(n.uniform3f(this.addr,e.r,e.g,e.b),t[0]=e.r,t[1]=e.g,t[2]=e.b);else{if(Gn(t,e))return;n.uniform3fv(this.addr,e),Hn(t,e)}}function qD(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4f(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Gn(t,e))return;n.uniform4fv(this.addr,e),Hn(t,e)}}function XD(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Gn(t,e))return;n.uniformMatrix2fv(this.addr,!1,e),Hn(t,e)}else{if(Gn(t,r))return;_1.set(r),n.uniformMatrix2fv(this.addr,!1,_1),Hn(t,r)}}function KD(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Gn(t,e))return;n.uniformMatrix3fv(this.addr,!1,e),Hn(t,e)}else{if(Gn(t,r))return;b1.set(r),n.uniformMatrix3fv(this.addr,!1,b1),Hn(t,r)}}function jD(n,e){const t=this.cache,r=e.elements;if(r===void 0){if(Gn(t,e))return;n.uniformMatrix4fv(this.addr,!1,e),Hn(t,e)}else{if(Gn(t,r))return;x1.set(r),n.uniformMatrix4fv(this.addr,!1,x1),Hn(t,r)}}function YD(n,e){const t=this.cache;t[0]!==e&&(n.uniform1i(this.addr,e),t[0]=e)}function ZD(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2i(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Gn(t,e))return;n.uniform2iv(this.addr,e),Hn(t,e)}}function QD(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3i(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Gn(t,e))return;n.uniform3iv(this.addr,e),Hn(t,e)}}function JD(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4i(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Gn(t,e))return;n.uniform4iv(this.addr,e),Hn(t,e)}}function eL(n,e){const t=this.cache;t[0]!==e&&(n.uniform1ui(this.addr,e),t[0]=e)}function tL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y)&&(n.uniform2ui(this.addr,e.x,e.y),t[0]=e.x,t[1]=e.y);else{if(Gn(t,e))return;n.uniform2uiv(this.addr,e),Hn(t,e)}}function nL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z)&&(n.uniform3ui(this.addr,e.x,e.y,e.z),t[0]=e.x,t[1]=e.y,t[2]=e.z);else{if(Gn(t,e))return;n.uniform3uiv(this.addr,e),Hn(t,e)}}function rL(n,e){const t=this.cache;if(e.x!==void 0)(t[0]!==e.x||t[1]!==e.y||t[2]!==e.z||t[3]!==e.w)&&(n.uniform4ui(this.addr,e.x,e.y,e.z,e.w),t[0]=e.x,t[1]=e.y,t[2]=e.z,t[3]=e.w);else{if(Gn(t,e))return;n.uniform4uiv(this.addr,e),Hn(t,e)}}function iL(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i);let s;this.type===n.SAMPLER_2D_SHADOW?(m1.compareFunction=uE,s=m1):s=wE,t.setTexture2D(e||s,i)}function sL(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.setTexture3D(e||SE,i)}function aL(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.setTextureCube(e||TE,i)}function oL(n,e,t){const r=this.cache,i=t.allocateTextureUnit();r[0]!==i&&(n.uniform1i(this.addr,i),r[0]=i),t.setTexture2DArray(e||EE,i)}function cL(n){switch(n){case 5126:return GD;case 35664:return HD;case 35665:return WD;case 35666:return qD;case 35674:return XD;case 35675:return KD;case 35676:return jD;case 5124:case 35670:return YD;case 35667:case 35671:return ZD;case 35668:case 35672:return QD;case 35669:case 35673:return JD;case 5125:return eL;case 36294:return tL;case 36295:return nL;case 36296:return rL;case 35678:case 36198:case 36298:case 36306:case 35682:return iL;case 35679:case 36299:case 36307:return sL;case 35680:case 36300:case 36308:case 36293:return aL;case 36289:case 36303:case 36311:case 36292:return oL}}function lL(n,e){n.uniform1fv(this.addr,e)}function uL(n,e){const t=xl(e,this.size,2);n.uniform2fv(this.addr,t)}function fL(n,e){const t=xl(e,this.size,3);n.uniform3fv(this.addr,t)}function dL(n,e){const t=xl(e,this.size,4);n.uniform4fv(this.addr,t)}function hL(n,e){const t=xl(e,this.size,4);n.uniformMatrix2fv(this.addr,!1,t)}function pL(n,e){const t=xl(e,this.size,9);n.uniformMatrix3fv(this.addr,!1,t)}function mL(n,e){const t=xl(e,this.size,16);n.uniformMatrix4fv(this.addr,!1,t)}function vL(n,e){n.uniform1iv(this.addr,e)}function gL(n,e){n.uniform2iv(this.addr,e)}function xL(n,e){n.uniform3iv(this.addr,e)}function bL(n,e){n.uniform4iv(this.addr,e)}function _L(n,e){n.uniform1uiv(this.addr,e)}function yL(n,e){n.uniform2uiv(this.addr,e)}function wL(n,e){n.uniform3uiv(this.addr,e)}function EL(n,e){n.uniform4uiv(this.addr,e)}function SL(n,e,t){const r=this.cache,i=e.length,s=gp(t,i);Gn(r,s)||(n.uniform1iv(this.addr,s),Hn(r,s));for(let a=0;a!==i;++a)t.setTexture2D(e[a]||wE,s[a])}function TL(n,e,t){const r=this.cache,i=e.length,s=gp(t,i);Gn(r,s)||(n.uniform1iv(this.addr,s),Hn(r,s));for(let a=0;a!==i;++a)t.setTexture3D(e[a]||SE,s[a])}function AL(n,e,t){const r=this.cache,i=e.length,s=gp(t,i);Gn(r,s)||(n.uniform1iv(this.addr,s),Hn(r,s));for(let a=0;a!==i;++a)t.setTextureCube(e[a]||TE,s[a])}function CL(n,e,t){const r=this.cache,i=e.length,s=gp(t,i);Gn(r,s)||(n.uniform1iv(this.addr,s),Hn(r,s));for(let a=0;a!==i;++a)t.setTexture2DArray(e[a]||EE,s[a])}function IL(n){switch(n){case 5126:return lL;case 35664:return uL;case 35665:return fL;case 35666:return dL;case 35674:return hL;case 35675:return pL;case 35676:return mL;case 5124:case 35670:return vL;case 35667:case 35671:return gL;case 35668:case 35672:return xL;case 35669:case 35673:return bL;case 5125:return _L;case 36294:return yL;case 36295:return wL;case 36296:return EL;case 35678:case 36198:case 36298:case 36306:case 35682:return SL;case 35679:case 36299:case 36307:return TL;case 35680:case 36300:case 36308:case 36293:return AL;case 36289:case 36303:case 36311:case 36292:return CL}}class ML{constructor(e,t,r){this.id=e,this.addr=r,this.cache=[],this.type=t.type,this.setValue=cL(t.type)}}class RL{constructor(e,t,r){this.id=e,this.addr=r,this.cache=[],this.type=t.type,this.size=t.size,this.setValue=IL(t.type)}}class NL{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,t,r){const i=this.seq;for(let s=0,a=i.length;s!==a;++s){const o=i[s];o.setValue(e,t[o.id],r)}}}const Sv=/(\w+)(\])?(\[|\.)?/g;function y1(n,e){n.seq.push(e),n.map[e.id]=e}function kL(n,e,t){const r=n.name,i=r.length;for(Sv.lastIndex=0;;){const s=Sv.exec(r),a=Sv.lastIndex;let o=s[1];const c=s[2]==="]",l=s[3];if(c&&(o=o|0),l===void 0||l==="["&&a+2===i){y1(t,l===void 0?new ML(o,n,e):new RL(o,n,e));break}else{let f=t.map[o];f===void 0&&(f=new NL(o),y1(t,f)),t=f}}}class gh{constructor(e,t){this.seq=[],this.map={};const r=e.getProgramParameter(t,e.ACTIVE_UNIFORMS);for(let i=0;i<r;++i){const s=e.getActiveUniform(t,i),a=e.getUniformLocation(t,s.name);kL(s,a,this)}}setValue(e,t,r,i){const s=this.map[t];s!==void 0&&s.setValue(e,r,i)}setOptional(e,t,r){const i=t[r];i!==void 0&&this.setValue(e,r,i)}static upload(e,t,r,i){for(let s=0,a=t.length;s!==a;++s){const o=t[s],c=r[o.id];c.needsUpdate!==!1&&o.setValue(e,c.value,i)}}static seqWithValue(e,t){const r=[];for(let i=0,s=e.length;i!==s;++i){const a=e[i];a.id in t&&r.push(a)}return r}}function w1(n,e,t){const r=n.createShader(e);return n.shaderSource(r,t),n.compileShader(r),r}const DL=37297;let LL=0;function OL(n,e){const t=n.split(`
`),r=[],i=Math.max(e-6,0),s=Math.min(e+6,t.length);for(let a=i;a<s;a++){const o=a+1;r.push(`${o===e?">":" "} ${o}: ${t[a]}`)}return r.join(`
`)}function zL(n){const e=Lt.getPrimaries(Lt.workingColorSpace),t=Lt.getPrimaries(n);let r;switch(e===t?r="":e===Ah&&t===Th?r="LinearDisplayP3ToLinearSRGB":e===Th&&t===Ah&&(r="LinearSRGBToLinearDisplayP3"),n){case rr:case vp:return[r,"LinearTransferOETF"];case Xn:case n0:return[r,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",n),[r,"LinearTransferOETF"]}}function E1(n,e,t){const r=n.getShaderParameter(e,n.COMPILE_STATUS),i=n.getShaderInfoLog(e).trim();if(r&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const a=parseInt(s[1]);return t.toUpperCase()+`

`+i+`

`+OL(n.getShaderSource(e),a)}else return i}function PL(n,e){const t=zL(e);return`vec4 ${n}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`}function FL(n,e){let t;switch(e){case FR:t="Linear";break;case $R:t="Reinhard";break;case UR:t="Cineon";break;case BR:t="ACESFilmic";break;case GR:t="AgX";break;case HR:t="Neutral";break;case VR:t="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),t="Linear"}return"vec3 "+n+"( vec3 color ) { return "+t+"ToneMapping( color ); }"}const Pd=new $;function $L(){Lt.getLuminanceCoefficients(Pd);const n=Pd.x.toFixed(4),e=Pd.y.toFixed(4),t=Pd.z.toFixed(4);return["float luminance( const in vec3 rgb ) {",`	const vec3 weights = vec3( ${n}, ${e}, ${t} );`,"	return dot( weights, rgb );","}"].join(`
`)}function UL(n){return[n.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",n.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(cu).join(`
`)}function BL(n){const e=[];for(const t in n){const r=n[t];r!==!1&&e.push("#define "+t+" "+r)}return e.join(`
`)}function VL(n,e){const t={},r=n.getProgramParameter(e,n.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const s=n.getActiveAttrib(e,i),a=s.name;let o=1;s.type===n.FLOAT_MAT2&&(o=2),s.type===n.FLOAT_MAT3&&(o=3),s.type===n.FLOAT_MAT4&&(o=4),t[a]={type:s.type,location:n.getAttribLocation(e,a),locationSize:o}}return t}function cu(n){return n!==""}function S1(n,e){const t=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return n.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,t).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function T1(n,e){return n.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const GL=/^[ \t]*#include +<([\w\d./]+)>/gm;function qg(n){return n.replace(GL,WL)}const HL=new Map;function WL(n,e){let t=wt[e];if(t===void 0){const r=HL.get(e);if(r!==void 0)t=wt[r],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,r);else throw new Error("Can not resolve #include <"+e+">")}return qg(t)}const qL=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function A1(n){return n.replace(qL,XL)}function XL(n,e,t,r){let i="";for(let s=parseInt(e);s<parseInt(t);s++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function C1(n){let e=`precision ${n.precision} float;
	precision ${n.precision} int;
	precision ${n.precision} sampler2D;
	precision ${n.precision} samplerCube;
	precision ${n.precision} sampler3D;
	precision ${n.precision} sampler2DArray;
	precision ${n.precision} sampler2DShadow;
	precision ${n.precision} samplerCubeShadow;
	precision ${n.precision} sampler2DArrayShadow;
	precision ${n.precision} isampler2D;
	precision ${n.precision} isampler3D;
	precision ${n.precision} isamplerCube;
	precision ${n.precision} isampler2DArray;
	precision ${n.precision} usampler2D;
	precision ${n.precision} usampler3D;
	precision ${n.precision} usamplerCube;
	precision ${n.precision} usampler2DArray;
	`;return n.precision==="highp"?e+=`
#define HIGH_PRECISION`:n.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:n.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function KL(n){let e="SHADOWMAP_TYPE_BASIC";return n.shadowMapType===Yw?e="SHADOWMAP_TYPE_PCF":n.shadowMapType===gR?e="SHADOWMAP_TYPE_PCF_SOFT":n.shadowMapType===Ds&&(e="SHADOWMAP_TYPE_VSM"),e}function jL(n){let e="ENVMAP_TYPE_CUBE";if(n.envMap)switch(n.envMapMode){case Hc:case Wc:e="ENVMAP_TYPE_CUBE";break;case pp:e="ENVMAP_TYPE_CUBE_UV";break}return e}function YL(n){let e="ENVMAP_MODE_REFLECTION";if(n.envMap)switch(n.envMapMode){case Wc:e="ENVMAP_MODE_REFRACTION";break}return e}function ZL(n){let e="ENVMAP_BLENDING_NONE";if(n.envMap)switch(n.combine){case Zw:e="ENVMAP_BLENDING_MULTIPLY";break;case zR:e="ENVMAP_BLENDING_MIX";break;case PR:e="ENVMAP_BLENDING_ADD";break}return e}function QL(n){const e=n.envMapCubeUVHeight;if(e===null)return null;const t=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,t),7*16)),texelHeight:r,maxMip:t}}function JL(n,e,t,r){const i=n.getContext(),s=t.defines;let a=t.vertexShader,o=t.fragmentShader;const c=KL(t),l=jL(t),u=YL(t),f=ZL(t),d=QL(t),h=UL(t),p=BL(s),g=i.createProgram();let m,v,x=t.glslVersion?"#version "+t.glslVersion+`
`:"";t.isRawShaderMaterial?(m=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,p].filter(cu).join(`
`),m.length>0&&(m+=`
`),v=["#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,p].filter(cu).join(`
`),v.length>0&&(v+=`
`)):(m=[C1(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,p,t.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",t.batching?"#define USE_BATCHING":"",t.batchingColor?"#define USE_BATCHING_COLOR":"",t.instancing?"#define USE_INSTANCING":"",t.instancingColor?"#define USE_INSTANCING_COLOR":"",t.instancingMorph?"#define USE_INSTANCING_MORPH":"",t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.map?"#define USE_MAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+u:"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.displacementMap?"#define USE_DISPLACEMENTMAP":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.mapUv?"#define MAP_UV "+t.mapUv:"",t.alphaMapUv?"#define ALPHAMAP_UV "+t.alphaMapUv:"",t.lightMapUv?"#define LIGHTMAP_UV "+t.lightMapUv:"",t.aoMapUv?"#define AOMAP_UV "+t.aoMapUv:"",t.emissiveMapUv?"#define EMISSIVEMAP_UV "+t.emissiveMapUv:"",t.bumpMapUv?"#define BUMPMAP_UV "+t.bumpMapUv:"",t.normalMapUv?"#define NORMALMAP_UV "+t.normalMapUv:"",t.displacementMapUv?"#define DISPLACEMENTMAP_UV "+t.displacementMapUv:"",t.metalnessMapUv?"#define METALNESSMAP_UV "+t.metalnessMapUv:"",t.roughnessMapUv?"#define ROUGHNESSMAP_UV "+t.roughnessMapUv:"",t.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+t.anisotropyMapUv:"",t.clearcoatMapUv?"#define CLEARCOATMAP_UV "+t.clearcoatMapUv:"",t.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+t.clearcoatNormalMapUv:"",t.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+t.clearcoatRoughnessMapUv:"",t.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+t.iridescenceMapUv:"",t.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+t.iridescenceThicknessMapUv:"",t.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+t.sheenColorMapUv:"",t.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+t.sheenRoughnessMapUv:"",t.specularMapUv?"#define SPECULARMAP_UV "+t.specularMapUv:"",t.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+t.specularColorMapUv:"",t.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+t.specularIntensityMapUv:"",t.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+t.transmissionMapUv:"",t.thicknessMapUv?"#define THICKNESSMAP_UV "+t.thicknessMapUv:"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.flatShading?"#define FLAT_SHADED":"",t.skinning?"#define USE_SKINNING":"",t.morphTargets?"#define USE_MORPHTARGETS":"",t.morphNormals&&t.flatShading===!1?"#define USE_MORPHNORMALS":"",t.morphColors?"#define USE_MORPHCOLORS":"",t.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+t.morphTextureStride:"",t.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+t.morphTargetsCount:"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.sizeAttenuation?"#define USE_SIZEATTENUATION":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(cu).join(`
`),v=[C1(t),"#define SHADER_TYPE "+t.shaderType,"#define SHADER_NAME "+t.shaderName,p,t.useFog&&t.fog?"#define USE_FOG":"",t.useFog&&t.fogExp2?"#define FOG_EXP2":"",t.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",t.map?"#define USE_MAP":"",t.matcap?"#define USE_MATCAP":"",t.envMap?"#define USE_ENVMAP":"",t.envMap?"#define "+l:"",t.envMap?"#define "+u:"",t.envMap?"#define "+f:"",d?"#define CUBEUV_TEXEL_WIDTH "+d.texelWidth:"",d?"#define CUBEUV_TEXEL_HEIGHT "+d.texelHeight:"",d?"#define CUBEUV_MAX_MIP "+d.maxMip+".0":"",t.lightMap?"#define USE_LIGHTMAP":"",t.aoMap?"#define USE_AOMAP":"",t.bumpMap?"#define USE_BUMPMAP":"",t.normalMap?"#define USE_NORMALMAP":"",t.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",t.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",t.emissiveMap?"#define USE_EMISSIVEMAP":"",t.anisotropy?"#define USE_ANISOTROPY":"",t.anisotropyMap?"#define USE_ANISOTROPYMAP":"",t.clearcoat?"#define USE_CLEARCOAT":"",t.clearcoatMap?"#define USE_CLEARCOATMAP":"",t.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",t.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",t.dispersion?"#define USE_DISPERSION":"",t.iridescence?"#define USE_IRIDESCENCE":"",t.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",t.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",t.specularMap?"#define USE_SPECULARMAP":"",t.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",t.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",t.roughnessMap?"#define USE_ROUGHNESSMAP":"",t.metalnessMap?"#define USE_METALNESSMAP":"",t.alphaMap?"#define USE_ALPHAMAP":"",t.alphaTest?"#define USE_ALPHATEST":"",t.alphaHash?"#define USE_ALPHAHASH":"",t.sheen?"#define USE_SHEEN":"",t.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",t.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",t.transmission?"#define USE_TRANSMISSION":"",t.transmissionMap?"#define USE_TRANSMISSIONMAP":"",t.thicknessMap?"#define USE_THICKNESSMAP":"",t.vertexTangents&&t.flatShading===!1?"#define USE_TANGENT":"",t.vertexColors||t.instancingColor||t.batchingColor?"#define USE_COLOR":"",t.vertexAlphas?"#define USE_COLOR_ALPHA":"",t.vertexUv1s?"#define USE_UV1":"",t.vertexUv2s?"#define USE_UV2":"",t.vertexUv3s?"#define USE_UV3":"",t.pointsUvs?"#define USE_POINTS_UV":"",t.gradientMap?"#define USE_GRADIENTMAP":"",t.flatShading?"#define FLAT_SHADED":"",t.doubleSided?"#define DOUBLE_SIDED":"",t.flipSided?"#define FLIP_SIDED":"",t.shadowMapEnabled?"#define USE_SHADOWMAP":"",t.shadowMapEnabled?"#define "+c:"",t.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",t.numLightProbes>0?"#define USE_LIGHT_PROBES":"",t.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",t.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"",t.reverseDepthBuffer?"#define USE_REVERSEDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",t.toneMapping!==Ta?"#define TONE_MAPPING":"",t.toneMapping!==Ta?wt.tonemapping_pars_fragment:"",t.toneMapping!==Ta?FL("toneMapping",t.toneMapping):"",t.dithering?"#define DITHERING":"",t.opaque?"#define OPAQUE":"",wt.colorspace_pars_fragment,PL("linearToOutputTexel",t.outputColorSpace),$L(),t.useDepthPacking?"#define DEPTH_PACKING "+t.depthPacking:"",`
`].filter(cu).join(`
`)),a=qg(a),a=S1(a,t),a=T1(a,t),o=qg(o),o=S1(o,t),o=T1(o,t),a=A1(a),o=A1(o),t.isRawShaderMaterial!==!0&&(x=`#version 300 es
`,m=[h,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+m,v=["#define varying in",t.glslVersion===Wg?"":"layout(location = 0) out highp vec4 pc_fragColor;",t.glslVersion===Wg?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+v);const b=x+m+a,_=x+v+o,w=w1(i,i.VERTEX_SHADER,b),E=w1(i,i.FRAGMENT_SHADER,_);i.attachShader(g,w),i.attachShader(g,E),t.index0AttributeName!==void 0?i.bindAttribLocation(g,0,t.index0AttributeName):t.morphTargets===!0&&i.bindAttribLocation(g,0,"position"),i.linkProgram(g);function S(A){if(n.debug.checkShaderErrors){const k=i.getProgramInfoLog(g).trim(),M=i.getShaderInfoLog(w).trim(),L=i.getShaderInfoLog(E).trim();let z=!0,D=!0;if(i.getProgramParameter(g,i.LINK_STATUS)===!1)if(z=!1,typeof n.debug.onShaderError=="function")n.debug.onShaderError(i,g,w,E);else{const F=E1(i,w,"vertex"),O=E1(i,E,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(g,i.VALIDATE_STATUS)+`

Material Name: `+A.name+`
Material Type: `+A.type+`

Program Info Log: `+k+`
`+F+`
`+O)}else k!==""?console.warn("THREE.WebGLProgram: Program Info Log:",k):(M===""||L==="")&&(D=!1);D&&(A.diagnostics={runnable:z,programLog:k,vertexShader:{log:M,prefix:m},fragmentShader:{log:L,prefix:v}})}i.deleteShader(w),i.deleteShader(E),T=new gh(i,g),C=VL(i,g)}let T;this.getUniforms=function(){return T===void 0&&S(this),T};let C;this.getAttributes=function(){return C===void 0&&S(this),C};let y=t.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return y===!1&&(y=i.getProgramParameter(g,DL)),y},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(g),this.program=void 0},this.type=t.shaderType,this.name=t.shaderName,this.id=LL++,this.cacheKey=e,this.usedTimes=1,this.program=g,this.vertexShader=w,this.fragmentShader=E,this}let eO=0;class tO{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const t=e.vertexShader,r=e.fragmentShader,i=this._getShaderStage(t),s=this._getShaderStage(r),a=this._getShaderCacheForMaterial(e);return a.has(i)===!1&&(a.add(i),i.usedTimes++),a.has(s)===!1&&(a.add(s),s.usedTimes++),this}remove(e){const t=this.materialCache.get(e);for(const r of t)r.usedTimes--,r.usedTimes===0&&this.shaderCache.delete(r.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const t=this.materialCache;let r=t.get(e);return r===void 0&&(r=new Set,t.set(e,r)),r}_getShaderStage(e){const t=this.shaderCache;let r=t.get(e);return r===void 0&&(r=new nO(e),t.set(e,r)),r}}class nO{constructor(e){this.id=eO++,this.code=e,this.usedTimes=0}}function rO(n,e,t,r,i,s,a){const o=new i0,c=new tO,l=new Set,u=[],f=i.logarithmicDepthBuffer,d=i.reverseDepthBuffer,h=i.vertexTextures;let p=i.precision;const g={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function m(y){return l.add(y),y===0?"uv":`uv${y}`}function v(y,A,k,M,L){const z=M.fog,D=L.geometry,F=y.isMeshStandardMaterial?M.environment:null,O=(y.isMeshStandardMaterial?t:e).get(y.envMap||F),V=O&&O.mapping===pp?O.image.height:null,J=g[y.type];y.precision!==null&&(p=i.getMaxPrecision(y.precision),p!==y.precision&&console.warn("THREE.WebGLProgram.getParameters:",y.precision,"not supported, using",p,"instead."));const Q=D.morphAttributes.position||D.morphAttributes.normal||D.morphAttributes.color,de=Q!==void 0?Q.length:0;let le=0;D.morphAttributes.position!==void 0&&(le=1),D.morphAttributes.normal!==void 0&&(le=2),D.morphAttributes.color!==void 0&&(le=3);let H,q,oe,fe;if(J){const Lr=rs[J];H=Lr.vertexShader,q=Lr.fragmentShader}else H=y.vertexShader,q=y.fragmentShader,c.update(y),oe=c.getVertexShaderID(y),fe=c.getFragmentShaderID(y);const _e=n.getRenderTarget(),xe=L.isInstancedMesh===!0,Se=L.isBatchedMesh===!0,Me=!!y.map,Le=!!y.matcap,B=!!O,bt=!!y.aoMap,qe=!!y.lightMap,Xe=!!y.bumpMap,Oe=!!y.normalMap,it=!!y.displacementMap,rt=!!y.emissiveMap,P=!!y.metalnessMap,I=!!y.roughnessMap,ne=y.anisotropy>0,me=y.clearcoat>0,ve=y.dispersion>0,pe=y.iridescence>0,Be=y.sheen>0,Te=y.transmission>0,ke=ne&&!!y.anisotropyMap,At=me&&!!y.clearcoatMap,we=me&&!!y.clearcoatNormalMap,Fe=me&&!!y.clearcoatRoughnessMap,ut=pe&&!!y.iridescenceMap,at=pe&&!!y.iridescenceThicknessMap,Ve=Be&&!!y.sheenColorMap,It=Be&&!!y.sheenRoughnessMap,gt=!!y.specularMap,tn=!!y.specularColorMap,K=!!y.specularIntensityMap,$e=Te&&!!y.transmissionMap,he=Te&&!!y.thicknessMap,be=!!y.gradientMap,ze=!!y.alphaMap,Ue=y.alphaTest>0,Dt=!!y.alphaHash,In=!!y.extensions;let Dr=Ta;y.toneMapped&&(_e===null||_e.isXRRenderTarget===!0)&&(Dr=n.toneMapping);const Ft={shaderID:J,shaderType:y.type,shaderName:y.name,vertexShader:H,fragmentShader:q,defines:y.defines,customVertexShaderID:oe,customFragmentShaderID:fe,isRawShaderMaterial:y.isRawShaderMaterial===!0,glslVersion:y.glslVersion,precision:p,batching:Se,batchingColor:Se&&L._colorsTexture!==null,instancing:xe,instancingColor:xe&&L.instanceColor!==null,instancingMorph:xe&&L.morphTexture!==null,supportsVertexTextures:h,outputColorSpace:_e===null?n.outputColorSpace:_e.isXRRenderTarget===!0?_e.texture.colorSpace:rr,alphaToCoverage:!!y.alphaToCoverage,map:Me,matcap:Le,envMap:B,envMapMode:B&&O.mapping,envMapCubeUVHeight:V,aoMap:bt,lightMap:qe,bumpMap:Xe,normalMap:Oe,displacementMap:h&&it,emissiveMap:rt,normalMapObjectSpace:Oe&&y.normalMapType===YR,normalMapTangentSpace:Oe&&y.normalMapType===lE,metalnessMap:P,roughnessMap:I,anisotropy:ne,anisotropyMap:ke,clearcoat:me,clearcoatMap:At,clearcoatNormalMap:we,clearcoatRoughnessMap:Fe,dispersion:ve,iridescence:pe,iridescenceMap:ut,iridescenceThicknessMap:at,sheen:Be,sheenColorMap:Ve,sheenRoughnessMap:It,specularMap:gt,specularColorMap:tn,specularIntensityMap:K,transmission:Te,transmissionMap:$e,thicknessMap:he,gradientMap:be,opaque:y.transparent===!1&&y.blending===Lc&&y.alphaToCoverage===!1,alphaMap:ze,alphaTest:Ue,alphaHash:Dt,combine:y.combine,mapUv:Me&&m(y.map.channel),aoMapUv:bt&&m(y.aoMap.channel),lightMapUv:qe&&m(y.lightMap.channel),bumpMapUv:Xe&&m(y.bumpMap.channel),normalMapUv:Oe&&m(y.normalMap.channel),displacementMapUv:it&&m(y.displacementMap.channel),emissiveMapUv:rt&&m(y.emissiveMap.channel),metalnessMapUv:P&&m(y.metalnessMap.channel),roughnessMapUv:I&&m(y.roughnessMap.channel),anisotropyMapUv:ke&&m(y.anisotropyMap.channel),clearcoatMapUv:At&&m(y.clearcoatMap.channel),clearcoatNormalMapUv:we&&m(y.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:Fe&&m(y.clearcoatRoughnessMap.channel),iridescenceMapUv:ut&&m(y.iridescenceMap.channel),iridescenceThicknessMapUv:at&&m(y.iridescenceThicknessMap.channel),sheenColorMapUv:Ve&&m(y.sheenColorMap.channel),sheenRoughnessMapUv:It&&m(y.sheenRoughnessMap.channel),specularMapUv:gt&&m(y.specularMap.channel),specularColorMapUv:tn&&m(y.specularColorMap.channel),specularIntensityMapUv:K&&m(y.specularIntensityMap.channel),transmissionMapUv:$e&&m(y.transmissionMap.channel),thicknessMapUv:he&&m(y.thicknessMap.channel),alphaMapUv:ze&&m(y.alphaMap.channel),vertexTangents:!!D.attributes.tangent&&(Oe||ne),vertexColors:y.vertexColors,vertexAlphas:y.vertexColors===!0&&!!D.attributes.color&&D.attributes.color.itemSize===4,pointsUvs:L.isPoints===!0&&!!D.attributes.uv&&(Me||ze),fog:!!z,useFog:y.fog===!0,fogExp2:!!z&&z.isFogExp2,flatShading:y.flatShading===!0,sizeAttenuation:y.sizeAttenuation===!0,logarithmicDepthBuffer:f,reverseDepthBuffer:d,skinning:L.isSkinnedMesh===!0,morphTargets:D.morphAttributes.position!==void 0,morphNormals:D.morphAttributes.normal!==void 0,morphColors:D.morphAttributes.color!==void 0,morphTargetsCount:de,morphTextureStride:le,numDirLights:A.directional.length,numPointLights:A.point.length,numSpotLights:A.spot.length,numSpotLightMaps:A.spotLightMap.length,numRectAreaLights:A.rectArea.length,numHemiLights:A.hemi.length,numDirLightShadows:A.directionalShadowMap.length,numPointLightShadows:A.pointShadowMap.length,numSpotLightShadows:A.spotShadowMap.length,numSpotLightShadowsWithMaps:A.numSpotLightShadowsWithMaps,numLightProbes:A.numLightProbes,numClippingPlanes:a.numPlanes,numClipIntersection:a.numIntersection,dithering:y.dithering,shadowMapEnabled:n.shadowMap.enabled&&k.length>0,shadowMapType:n.shadowMap.type,toneMapping:Dr,decodeVideoTexture:Me&&y.map.isVideoTexture===!0&&Lt.getTransfer(y.map.colorSpace)===on,premultipliedAlpha:y.premultipliedAlpha,doubleSided:y.side===$i,flipSided:y.side===Ir,useDepthPacking:y.depthPacking>=0,depthPacking:y.depthPacking||0,index0AttributeName:y.index0AttributeName,extensionClipCullDistance:In&&y.extensions.clipCullDistance===!0&&r.has("WEBGL_clip_cull_distance"),extensionMultiDraw:(In&&y.extensions.multiDraw===!0||Se)&&r.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:y.customProgramCacheKey()};return Ft.vertexUv1s=l.has(1),Ft.vertexUv2s=l.has(2),Ft.vertexUv3s=l.has(3),l.clear(),Ft}function x(y){const A=[];if(y.shaderID?A.push(y.shaderID):(A.push(y.customVertexShaderID),A.push(y.customFragmentShaderID)),y.defines!==void 0)for(const k in y.defines)A.push(k),A.push(y.defines[k]);return y.isRawShaderMaterial===!1&&(b(A,y),_(A,y),A.push(n.outputColorSpace)),A.push(y.customProgramCacheKey),A.join()}function b(y,A){y.push(A.precision),y.push(A.outputColorSpace),y.push(A.envMapMode),y.push(A.envMapCubeUVHeight),y.push(A.mapUv),y.push(A.alphaMapUv),y.push(A.lightMapUv),y.push(A.aoMapUv),y.push(A.bumpMapUv),y.push(A.normalMapUv),y.push(A.displacementMapUv),y.push(A.emissiveMapUv),y.push(A.metalnessMapUv),y.push(A.roughnessMapUv),y.push(A.anisotropyMapUv),y.push(A.clearcoatMapUv),y.push(A.clearcoatNormalMapUv),y.push(A.clearcoatRoughnessMapUv),y.push(A.iridescenceMapUv),y.push(A.iridescenceThicknessMapUv),y.push(A.sheenColorMapUv),y.push(A.sheenRoughnessMapUv),y.push(A.specularMapUv),y.push(A.specularColorMapUv),y.push(A.specularIntensityMapUv),y.push(A.transmissionMapUv),y.push(A.thicknessMapUv),y.push(A.combine),y.push(A.fogExp2),y.push(A.sizeAttenuation),y.push(A.morphTargetsCount),y.push(A.morphAttributeCount),y.push(A.numDirLights),y.push(A.numPointLights),y.push(A.numSpotLights),y.push(A.numSpotLightMaps),y.push(A.numHemiLights),y.push(A.numRectAreaLights),y.push(A.numDirLightShadows),y.push(A.numPointLightShadows),y.push(A.numSpotLightShadows),y.push(A.numSpotLightShadowsWithMaps),y.push(A.numLightProbes),y.push(A.shadowMapType),y.push(A.toneMapping),y.push(A.numClippingPlanes),y.push(A.numClipIntersection),y.push(A.depthPacking)}function _(y,A){o.disableAll(),A.supportsVertexTextures&&o.enable(0),A.instancing&&o.enable(1),A.instancingColor&&o.enable(2),A.instancingMorph&&o.enable(3),A.matcap&&o.enable(4),A.envMap&&o.enable(5),A.normalMapObjectSpace&&o.enable(6),A.normalMapTangentSpace&&o.enable(7),A.clearcoat&&o.enable(8),A.iridescence&&o.enable(9),A.alphaTest&&o.enable(10),A.vertexColors&&o.enable(11),A.vertexAlphas&&o.enable(12),A.vertexUv1s&&o.enable(13),A.vertexUv2s&&o.enable(14),A.vertexUv3s&&o.enable(15),A.vertexTangents&&o.enable(16),A.anisotropy&&o.enable(17),A.alphaHash&&o.enable(18),A.batching&&o.enable(19),A.dispersion&&o.enable(20),A.batchingColor&&o.enable(21),y.push(o.mask),o.disableAll(),A.fog&&o.enable(0),A.useFog&&o.enable(1),A.flatShading&&o.enable(2),A.logarithmicDepthBuffer&&o.enable(3),A.reverseDepthBuffer&&o.enable(4),A.skinning&&o.enable(5),A.morphTargets&&o.enable(6),A.morphNormals&&o.enable(7),A.morphColors&&o.enable(8),A.premultipliedAlpha&&o.enable(9),A.shadowMapEnabled&&o.enable(10),A.doubleSided&&o.enable(11),A.flipSided&&o.enable(12),A.useDepthPacking&&o.enable(13),A.dithering&&o.enable(14),A.transmission&&o.enable(15),A.sheen&&o.enable(16),A.opaque&&o.enable(17),A.pointsUvs&&o.enable(18),A.decodeVideoTexture&&o.enable(19),A.alphaToCoverage&&o.enable(20),y.push(o.mask)}function w(y){const A=g[y.type];let k;if(A){const M=rs[A];k=UN.clone(M.uniforms)}else k=y.uniforms;return k}function E(y,A){let k;for(let M=0,L=u.length;M<L;M++){const z=u[M];if(z.cacheKey===A){k=z,++k.usedTimes;break}}return k===void 0&&(k=new JL(n,A,y,s),u.push(k)),k}function S(y){if(--y.usedTimes===0){const A=u.indexOf(y);u[A]=u[u.length-1],u.pop(),y.destroy()}}function T(y){c.remove(y)}function C(){c.dispose()}return{getParameters:v,getProgramCacheKey:x,getUniforms:w,acquireProgram:E,releaseProgram:S,releaseShaderCache:T,programs:u,dispose:C}}function iO(){let n=new WeakMap;function e(a){return n.has(a)}function t(a){let o=n.get(a);return o===void 0&&(o={},n.set(a,o)),o}function r(a){n.delete(a)}function i(a,o,c){n.get(a)[o]=c}function s(){n=new WeakMap}return{has:e,get:t,remove:r,update:i,dispose:s}}function sO(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.material.id!==e.material.id?n.material.id-e.material.id:n.z!==e.z?n.z-e.z:n.id-e.id}function I1(n,e){return n.groupOrder!==e.groupOrder?n.groupOrder-e.groupOrder:n.renderOrder!==e.renderOrder?n.renderOrder-e.renderOrder:n.z!==e.z?e.z-n.z:n.id-e.id}function M1(){const n=[];let e=0;const t=[],r=[],i=[];function s(){e=0,t.length=0,r.length=0,i.length=0}function a(f,d,h,p,g,m){let v=n[e];return v===void 0?(v={id:f.id,object:f,geometry:d,material:h,groupOrder:p,renderOrder:f.renderOrder,z:g,group:m},n[e]=v):(v.id=f.id,v.object=f,v.geometry=d,v.material=h,v.groupOrder=p,v.renderOrder=f.renderOrder,v.z=g,v.group=m),e++,v}function o(f,d,h,p,g,m){const v=a(f,d,h,p,g,m);h.transmission>0?r.push(v):h.transparent===!0?i.push(v):t.push(v)}function c(f,d,h,p,g,m){const v=a(f,d,h,p,g,m);h.transmission>0?r.unshift(v):h.transparent===!0?i.unshift(v):t.unshift(v)}function l(f,d){t.length>1&&t.sort(f||sO),r.length>1&&r.sort(d||I1),i.length>1&&i.sort(d||I1)}function u(){for(let f=e,d=n.length;f<d;f++){const h=n[f];if(h.id===null)break;h.id=null,h.object=null,h.geometry=null,h.material=null,h.group=null}}return{opaque:t,transmissive:r,transparent:i,init:s,push:o,unshift:c,finish:u,sort:l}}function aO(){let n=new WeakMap;function e(r,i){const s=n.get(r);let a;return s===void 0?(a=new M1,n.set(r,[a])):i>=s.length?(a=new M1,s.push(a)):a=s[i],a}function t(){n=new WeakMap}return{get:e,dispose:t}}function oO(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={direction:new $,color:new ht};break;case"SpotLight":t={position:new $,direction:new $,color:new ht,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":t={position:new $,color:new ht,distance:0,decay:0};break;case"HemisphereLight":t={direction:new $,skyColor:new ht,groundColor:new ht};break;case"RectAreaLight":t={color:new ht,position:new $,halfWidth:new $,halfHeight:new $};break}return n[e.id]=t,t}}}function cO(){const n={};return{get:function(e){if(n[e.id]!==void 0)return n[e.id];let t;switch(e.type){case"DirectionalLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ye};break;case"SpotLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ye};break;case"PointLight":t={shadowIntensity:1,shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Ye,shadowCameraNear:1,shadowCameraFar:1e3};break}return n[e.id]=t,t}}}let lO=0;function uO(n,e){return(e.castShadow?2:0)-(n.castShadow?2:0)+(e.map?1:0)-(n.map?1:0)}function fO(n){const e=new oO,t=cO(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let l=0;l<9;l++)r.probe.push(new $);const i=new $,s=new lt,a=new lt;function o(l){let u=0,f=0,d=0;for(let C=0;C<9;C++)r.probe[C].set(0,0,0);let h=0,p=0,g=0,m=0,v=0,x=0,b=0,_=0,w=0,E=0,S=0;l.sort(uO);for(let C=0,y=l.length;C<y;C++){const A=l[C],k=A.color,M=A.intensity,L=A.distance,z=A.shadow&&A.shadow.map?A.shadow.map.texture:null;if(A.isAmbientLight)u+=k.r*M,f+=k.g*M,d+=k.b*M;else if(A.isLightProbe){for(let D=0;D<9;D++)r.probe[D].addScaledVector(A.sh.coefficients[D],M);S++}else if(A.isDirectionalLight){const D=e.get(A);if(D.color.copy(A.color).multiplyScalar(A.intensity),A.castShadow){const F=A.shadow,O=t.get(A);O.shadowIntensity=F.intensity,O.shadowBias=F.bias,O.shadowNormalBias=F.normalBias,O.shadowRadius=F.radius,O.shadowMapSize=F.mapSize,r.directionalShadow[h]=O,r.directionalShadowMap[h]=z,r.directionalShadowMatrix[h]=A.shadow.matrix,x++}r.directional[h]=D,h++}else if(A.isSpotLight){const D=e.get(A);D.position.setFromMatrixPosition(A.matrixWorld),D.color.copy(k).multiplyScalar(M),D.distance=L,D.coneCos=Math.cos(A.angle),D.penumbraCos=Math.cos(A.angle*(1-A.penumbra)),D.decay=A.decay,r.spot[g]=D;const F=A.shadow;if(A.map&&(r.spotLightMap[w]=A.map,w++,F.updateMatrices(A),A.castShadow&&E++),r.spotLightMatrix[g]=F.matrix,A.castShadow){const O=t.get(A);O.shadowIntensity=F.intensity,O.shadowBias=F.bias,O.shadowNormalBias=F.normalBias,O.shadowRadius=F.radius,O.shadowMapSize=F.mapSize,r.spotShadow[g]=O,r.spotShadowMap[g]=z,_++}g++}else if(A.isRectAreaLight){const D=e.get(A);D.color.copy(k).multiplyScalar(M),D.halfWidth.set(A.width*.5,0,0),D.halfHeight.set(0,A.height*.5,0),r.rectArea[m]=D,m++}else if(A.isPointLight){const D=e.get(A);if(D.color.copy(A.color).multiplyScalar(A.intensity),D.distance=A.distance,D.decay=A.decay,A.castShadow){const F=A.shadow,O=t.get(A);O.shadowIntensity=F.intensity,O.shadowBias=F.bias,O.shadowNormalBias=F.normalBias,O.shadowRadius=F.radius,O.shadowMapSize=F.mapSize,O.shadowCameraNear=F.camera.near,O.shadowCameraFar=F.camera.far,r.pointShadow[p]=O,r.pointShadowMap[p]=z,r.pointShadowMatrix[p]=A.shadow.matrix,b++}r.point[p]=D,p++}else if(A.isHemisphereLight){const D=e.get(A);D.skyColor.copy(A.color).multiplyScalar(M),D.groundColor.copy(A.groundColor).multiplyScalar(M),r.hemi[v]=D,v++}}m>0&&(n.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=Re.LTC_FLOAT_1,r.rectAreaLTC2=Re.LTC_FLOAT_2):(r.rectAreaLTC1=Re.LTC_HALF_1,r.rectAreaLTC2=Re.LTC_HALF_2)),r.ambient[0]=u,r.ambient[1]=f,r.ambient[2]=d;const T=r.hash;(T.directionalLength!==h||T.pointLength!==p||T.spotLength!==g||T.rectAreaLength!==m||T.hemiLength!==v||T.numDirectionalShadows!==x||T.numPointShadows!==b||T.numSpotShadows!==_||T.numSpotMaps!==w||T.numLightProbes!==S)&&(r.directional.length=h,r.spot.length=g,r.rectArea.length=m,r.point.length=p,r.hemi.length=v,r.directionalShadow.length=x,r.directionalShadowMap.length=x,r.pointShadow.length=b,r.pointShadowMap.length=b,r.spotShadow.length=_,r.spotShadowMap.length=_,r.directionalShadowMatrix.length=x,r.pointShadowMatrix.length=b,r.spotLightMatrix.length=_+w-E,r.spotLightMap.length=w,r.numSpotLightShadowsWithMaps=E,r.numLightProbes=S,T.directionalLength=h,T.pointLength=p,T.spotLength=g,T.rectAreaLength=m,T.hemiLength=v,T.numDirectionalShadows=x,T.numPointShadows=b,T.numSpotShadows=_,T.numSpotMaps=w,T.numLightProbes=S,r.version=lO++)}function c(l,u){let f=0,d=0,h=0,p=0,g=0;const m=u.matrixWorldInverse;for(let v=0,x=l.length;v<x;v++){const b=l[v];if(b.isDirectionalLight){const _=r.directional[f];_.direction.setFromMatrixPosition(b.matrixWorld),i.setFromMatrixPosition(b.target.matrixWorld),_.direction.sub(i),_.direction.transformDirection(m),f++}else if(b.isSpotLight){const _=r.spot[h];_.position.setFromMatrixPosition(b.matrixWorld),_.position.applyMatrix4(m),_.direction.setFromMatrixPosition(b.matrixWorld),i.setFromMatrixPosition(b.target.matrixWorld),_.direction.sub(i),_.direction.transformDirection(m),h++}else if(b.isRectAreaLight){const _=r.rectArea[p];_.position.setFromMatrixPosition(b.matrixWorld),_.position.applyMatrix4(m),a.identity(),s.copy(b.matrixWorld),s.premultiply(m),a.extractRotation(s),_.halfWidth.set(b.width*.5,0,0),_.halfHeight.set(0,b.height*.5,0),_.halfWidth.applyMatrix4(a),_.halfHeight.applyMatrix4(a),p++}else if(b.isPointLight){const _=r.point[d];_.position.setFromMatrixPosition(b.matrixWorld),_.position.applyMatrix4(m),d++}else if(b.isHemisphereLight){const _=r.hemi[g];_.direction.setFromMatrixPosition(b.matrixWorld),_.direction.transformDirection(m),g++}}}return{setup:o,setupView:c,state:r}}function R1(n){const e=new fO(n),t=[],r=[];function i(u){l.camera=u,t.length=0,r.length=0}function s(u){t.push(u)}function a(u){r.push(u)}function o(){e.setup(t)}function c(u){e.setupView(t,u)}const l={lightsArray:t,shadowsArray:r,camera:null,lights:e,transmissionRenderTarget:{}};return{init:i,state:l,setupLights:o,setupLightsView:c,pushLight:s,pushShadow:a}}function dO(n){let e=new WeakMap;function t(i,s=0){const a=e.get(i);let o;return a===void 0?(o=new R1(n),e.set(i,[o])):s>=a.length?(o=new R1(n),a.push(o)):o=a[s],o}function r(){e=new WeakMap}return{get:t,dispose:r}}class hO extends cs{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=KR,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class pO extends cs{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const mO=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,vO=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function gO(n,e,t){let r=new a0;const i=new Ye,s=new Ye,a=new Bt,o=new hO({depthPacking:jR}),c=new pO,l={},u=t.maxTextureSize,f={[Ws]:Ir,[Ir]:Ws,[$i]:$i},d=new qs({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Ye},radius:{value:4}},vertexShader:mO,fragmentShader:vO}),h=d.clone();h.defines.HORIZONTAL_PASS=1;const p=new ws;p.setAttribute("position",new Mr(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const g=new gr(p,d),m=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=Yw;let v=this.type;this.render=function(E,S,T){if(m.enabled===!1||m.autoUpdate===!1&&m.needsUpdate===!1||E.length===0)return;const C=n.getRenderTarget(),y=n.getActiveCubeFace(),A=n.getActiveMipmapLevel(),k=n.state;k.setBlending(Sa),k.buffers.color.setClear(1,1,1,1),k.buffers.depth.setTest(!0),k.setScissorTest(!1);const M=v!==Ds&&this.type===Ds,L=v===Ds&&this.type!==Ds;for(let z=0,D=E.length;z<D;z++){const F=E[z],O=F.shadow;if(O===void 0){console.warn("THREE.WebGLShadowMap:",F,"has no shadow.");continue}if(O.autoUpdate===!1&&O.needsUpdate===!1)continue;i.copy(O.mapSize);const V=O.getFrameExtents();if(i.multiply(V),s.copy(O.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(s.x=Math.floor(u/V.x),i.x=s.x*V.x,O.mapSize.x=s.x),i.y>u&&(s.y=Math.floor(u/V.y),i.y=s.y*V.y,O.mapSize.y=s.y)),O.map===null||M===!0||L===!0){const Q=this.type!==Ds?{minFilter:cn,magFilter:cn}:{};O.map!==null&&O.map.dispose(),O.map=new So(i.x,i.y,Q),O.map.texture.name=F.name+".shadowMap",O.camera.updateProjectionMatrix()}n.setRenderTarget(O.map),n.clear();const J=O.getViewportCount();for(let Q=0;Q<J;Q++){const de=O.getViewport(Q);a.set(s.x*de.x,s.y*de.y,s.x*de.z,s.y*de.w),k.viewport(a),O.updateMatrices(F,Q),r=O.getFrustum(),_(S,T,O.camera,F,this.type)}O.isPointLightShadow!==!0&&this.type===Ds&&x(O,T),O.needsUpdate=!1}v=this.type,m.needsUpdate=!1,n.setRenderTarget(C,y,A)};function x(E,S){const T=e.update(g);d.defines.VSM_SAMPLES!==E.blurSamples&&(d.defines.VSM_SAMPLES=E.blurSamples,h.defines.VSM_SAMPLES=E.blurSamples,d.needsUpdate=!0,h.needsUpdate=!0),E.mapPass===null&&(E.mapPass=new So(i.x,i.y)),d.uniforms.shadow_pass.value=E.map.texture,d.uniforms.resolution.value=E.mapSize,d.uniforms.radius.value=E.radius,n.setRenderTarget(E.mapPass),n.clear(),n.renderBufferDirect(S,null,T,d,g,null),h.uniforms.shadow_pass.value=E.mapPass.texture,h.uniforms.resolution.value=E.mapSize,h.uniforms.radius.value=E.radius,n.setRenderTarget(E.map),n.clear(),n.renderBufferDirect(S,null,T,h,g,null)}function b(E,S,T,C){let y=null;const A=T.isPointLight===!0?E.customDistanceMaterial:E.customDepthMaterial;if(A!==void 0)y=A;else if(y=T.isPointLight===!0?c:o,n.localClippingEnabled&&S.clipShadows===!0&&Array.isArray(S.clippingPlanes)&&S.clippingPlanes.length!==0||S.displacementMap&&S.displacementScale!==0||S.alphaMap&&S.alphaTest>0||S.map&&S.alphaTest>0){const k=y.uuid,M=S.uuid;let L=l[k];L===void 0&&(L={},l[k]=L);let z=L[M];z===void 0&&(z=y.clone(),L[M]=z,S.addEventListener("dispose",w)),y=z}if(y.visible=S.visible,y.wireframe=S.wireframe,C===Ds?y.side=S.shadowSide!==null?S.shadowSide:S.side:y.side=S.shadowSide!==null?S.shadowSide:f[S.side],y.alphaMap=S.alphaMap,y.alphaTest=S.alphaTest,y.map=S.map,y.clipShadows=S.clipShadows,y.clippingPlanes=S.clippingPlanes,y.clipIntersection=S.clipIntersection,y.displacementMap=S.displacementMap,y.displacementScale=S.displacementScale,y.displacementBias=S.displacementBias,y.wireframeLinewidth=S.wireframeLinewidth,y.linewidth=S.linewidth,T.isPointLight===!0&&y.isMeshDistanceMaterial===!0){const k=n.properties.get(y);k.light=T}return y}function _(E,S,T,C,y){if(E.visible===!1)return;if(E.layers.test(S.layers)&&(E.isMesh||E.isLine||E.isPoints)&&(E.castShadow||E.receiveShadow&&y===Ds)&&(!E.frustumCulled||r.intersectsObject(E))){E.modelViewMatrix.multiplyMatrices(T.matrixWorldInverse,E.matrixWorld);const M=e.update(E),L=E.material;if(Array.isArray(L)){const z=M.groups;for(let D=0,F=z.length;D<F;D++){const O=z[D],V=L[O.materialIndex];if(V&&V.visible){const J=b(E,V,C,y);E.onBeforeShadow(n,E,S,T,M,J,O),n.renderBufferDirect(T,null,M,J,E,O),E.onAfterShadow(n,E,S,T,M,J,O)}}}else if(L.visible){const z=b(E,L,C,y);E.onBeforeShadow(n,E,S,T,M,z,null),n.renderBufferDirect(T,null,M,z,E,null),E.onAfterShadow(n,E,S,T,M,z,null)}}const k=E.children;for(let M=0,L=k.length;M<L;M++)_(k[M],S,T,C,y)}function w(E){E.target.removeEventListener("dispose",w);for(const T in l){const C=l[T],y=E.target.uuid;y in C&&(C[y].dispose(),delete C[y])}}}const xO={[cg]:lg,[ug]:hg,[fg]:pg,[Gc]:dg,[lg]:cg,[hg]:ug,[pg]:fg,[dg]:Gc};function bO(n){function e(){let K=!1;const $e=new Bt;let he=null;const be=new Bt(0,0,0,0);return{setMask:function(ze){he!==ze&&!K&&(n.colorMask(ze,ze,ze,ze),he=ze)},setLocked:function(ze){K=ze},setClear:function(ze,Ue,Dt,In,Dr){Dr===!0&&(ze*=In,Ue*=In,Dt*=In),$e.set(ze,Ue,Dt,In),be.equals($e)===!1&&(n.clearColor(ze,Ue,Dt,In),be.copy($e))},reset:function(){K=!1,he=null,be.set(-1,0,0,0)}}}function t(){let K=!1,$e=!1,he=null,be=null,ze=null;return{setReversed:function(Ue){$e=Ue},setTest:function(Ue){Ue?oe(n.DEPTH_TEST):fe(n.DEPTH_TEST)},setMask:function(Ue){he!==Ue&&!K&&(n.depthMask(Ue),he=Ue)},setFunc:function(Ue){if($e&&(Ue=xO[Ue]),be!==Ue){switch(Ue){case cg:n.depthFunc(n.NEVER);break;case lg:n.depthFunc(n.ALWAYS);break;case ug:n.depthFunc(n.LESS);break;case Gc:n.depthFunc(n.LEQUAL);break;case fg:n.depthFunc(n.EQUAL);break;case dg:n.depthFunc(n.GEQUAL);break;case hg:n.depthFunc(n.GREATER);break;case pg:n.depthFunc(n.NOTEQUAL);break;default:n.depthFunc(n.LEQUAL)}be=Ue}},setLocked:function(Ue){K=Ue},setClear:function(Ue){ze!==Ue&&(n.clearDepth(Ue),ze=Ue)},reset:function(){K=!1,he=null,be=null,ze=null}}}function r(){let K=!1,$e=null,he=null,be=null,ze=null,Ue=null,Dt=null,In=null,Dr=null;return{setTest:function(Ft){K||(Ft?oe(n.STENCIL_TEST):fe(n.STENCIL_TEST))},setMask:function(Ft){$e!==Ft&&!K&&(n.stencilMask(Ft),$e=Ft)},setFunc:function(Ft,Lr,As){(he!==Ft||be!==Lr||ze!==As)&&(n.stencilFunc(Ft,Lr,As),he=Ft,be=Lr,ze=As)},setOp:function(Ft,Lr,As){(Ue!==Ft||Dt!==Lr||In!==As)&&(n.stencilOp(Ft,Lr,As),Ue=Ft,Dt=Lr,In=As)},setLocked:function(Ft){K=Ft},setClear:function(Ft){Dr!==Ft&&(n.clearStencil(Ft),Dr=Ft)},reset:function(){K=!1,$e=null,he=null,be=null,ze=null,Ue=null,Dt=null,In=null,Dr=null}}}const i=new e,s=new t,a=new r,o=new WeakMap,c=new WeakMap;let l={},u={},f=new WeakMap,d=[],h=null,p=!1,g=null,m=null,v=null,x=null,b=null,_=null,w=null,E=new ht(0,0,0),S=0,T=!1,C=null,y=null,A=null,k=null,M=null;const L=n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let z=!1,D=0;const F=n.getParameter(n.VERSION);F.indexOf("WebGL")!==-1?(D=parseFloat(/^WebGL (\d)/.exec(F)[1]),z=D>=1):F.indexOf("OpenGL ES")!==-1&&(D=parseFloat(/^OpenGL ES (\d)/.exec(F)[1]),z=D>=2);let O=null,V={};const J=n.getParameter(n.SCISSOR_BOX),Q=n.getParameter(n.VIEWPORT),de=new Bt().fromArray(J),le=new Bt().fromArray(Q);function H(K,$e,he,be){const ze=new Uint8Array(4),Ue=n.createTexture();n.bindTexture(K,Ue),n.texParameteri(K,n.TEXTURE_MIN_FILTER,n.NEAREST),n.texParameteri(K,n.TEXTURE_MAG_FILTER,n.NEAREST);for(let Dt=0;Dt<he;Dt++)K===n.TEXTURE_3D||K===n.TEXTURE_2D_ARRAY?n.texImage3D($e,0,n.RGBA,1,1,be,0,n.RGBA,n.UNSIGNED_BYTE,ze):n.texImage2D($e+Dt,0,n.RGBA,1,1,0,n.RGBA,n.UNSIGNED_BYTE,ze);return Ue}const q={};q[n.TEXTURE_2D]=H(n.TEXTURE_2D,n.TEXTURE_2D,1),q[n.TEXTURE_CUBE_MAP]=H(n.TEXTURE_CUBE_MAP,n.TEXTURE_CUBE_MAP_POSITIVE_X,6),q[n.TEXTURE_2D_ARRAY]=H(n.TEXTURE_2D_ARRAY,n.TEXTURE_2D_ARRAY,1,1),q[n.TEXTURE_3D]=H(n.TEXTURE_3D,n.TEXTURE_3D,1,1),i.setClear(0,0,0,1),s.setClear(1),a.setClear(0),oe(n.DEPTH_TEST),s.setFunc(Gc),qe(!1),Xe(Oy),oe(n.CULL_FACE),B(Sa);function oe(K){l[K]!==!0&&(n.enable(K),l[K]=!0)}function fe(K){l[K]!==!1&&(n.disable(K),l[K]=!1)}function _e(K,$e){return u[K]!==$e?(n.bindFramebuffer(K,$e),u[K]=$e,K===n.DRAW_FRAMEBUFFER&&(u[n.FRAMEBUFFER]=$e),K===n.FRAMEBUFFER&&(u[n.DRAW_FRAMEBUFFER]=$e),!0):!1}function xe(K,$e){let he=d,be=!1;if(K){he=f.get($e),he===void 0&&(he=[],f.set($e,he));const ze=K.textures;if(he.length!==ze.length||he[0]!==n.COLOR_ATTACHMENT0){for(let Ue=0,Dt=ze.length;Ue<Dt;Ue++)he[Ue]=n.COLOR_ATTACHMENT0+Ue;he.length=ze.length,be=!0}}else he[0]!==n.BACK&&(he[0]=n.BACK,be=!0);be&&n.drawBuffers(he)}function Se(K){return h!==K?(n.useProgram(K),h=K,!0):!1}const Me={[co]:n.FUNC_ADD,[bR]:n.FUNC_SUBTRACT,[_R]:n.FUNC_REVERSE_SUBTRACT};Me[yR]=n.MIN,Me[wR]=n.MAX;const Le={[ER]:n.ZERO,[SR]:n.ONE,[TR]:n.SRC_COLOR,[ag]:n.SRC_ALPHA,[NR]:n.SRC_ALPHA_SATURATE,[MR]:n.DST_COLOR,[CR]:n.DST_ALPHA,[AR]:n.ONE_MINUS_SRC_COLOR,[og]:n.ONE_MINUS_SRC_ALPHA,[RR]:n.ONE_MINUS_DST_COLOR,[IR]:n.ONE_MINUS_DST_ALPHA,[kR]:n.CONSTANT_COLOR,[DR]:n.ONE_MINUS_CONSTANT_COLOR,[LR]:n.CONSTANT_ALPHA,[OR]:n.ONE_MINUS_CONSTANT_ALPHA};function B(K,$e,he,be,ze,Ue,Dt,In,Dr,Ft){if(K===Sa){p===!0&&(fe(n.BLEND),p=!1);return}if(p===!1&&(oe(n.BLEND),p=!0),K!==xR){if(K!==g||Ft!==T){if((m!==co||b!==co)&&(n.blendEquation(n.FUNC_ADD),m=co,b=co),Ft)switch(K){case Lc:n.blendFuncSeparate(n.ONE,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case zy:n.blendFunc(n.ONE,n.ONE);break;case Py:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case Fy:n.blendFuncSeparate(n.ZERO,n.SRC_COLOR,n.ZERO,n.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",K);break}else switch(K){case Lc:n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA);break;case zy:n.blendFunc(n.SRC_ALPHA,n.ONE);break;case Py:n.blendFuncSeparate(n.ZERO,n.ONE_MINUS_SRC_COLOR,n.ZERO,n.ONE);break;case Fy:n.blendFunc(n.ZERO,n.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",K);break}v=null,x=null,_=null,w=null,E.set(0,0,0),S=0,g=K,T=Ft}return}ze=ze||$e,Ue=Ue||he,Dt=Dt||be,($e!==m||ze!==b)&&(n.blendEquationSeparate(Me[$e],Me[ze]),m=$e,b=ze),(he!==v||be!==x||Ue!==_||Dt!==w)&&(n.blendFuncSeparate(Le[he],Le[be],Le[Ue],Le[Dt]),v=he,x=be,_=Ue,w=Dt),(In.equals(E)===!1||Dr!==S)&&(n.blendColor(In.r,In.g,In.b,Dr),E.copy(In),S=Dr),g=K,T=!1}function bt(K,$e){K.side===$i?fe(n.CULL_FACE):oe(n.CULL_FACE);let he=K.side===Ir;$e&&(he=!he),qe(he),K.blending===Lc&&K.transparent===!1?B(Sa):B(K.blending,K.blendEquation,K.blendSrc,K.blendDst,K.blendEquationAlpha,K.blendSrcAlpha,K.blendDstAlpha,K.blendColor,K.blendAlpha,K.premultipliedAlpha),s.setFunc(K.depthFunc),s.setTest(K.depthTest),s.setMask(K.depthWrite),i.setMask(K.colorWrite);const be=K.stencilWrite;a.setTest(be),be&&(a.setMask(K.stencilWriteMask),a.setFunc(K.stencilFunc,K.stencilRef,K.stencilFuncMask),a.setOp(K.stencilFail,K.stencilZFail,K.stencilZPass)),it(K.polygonOffset,K.polygonOffsetFactor,K.polygonOffsetUnits),K.alphaToCoverage===!0?oe(n.SAMPLE_ALPHA_TO_COVERAGE):fe(n.SAMPLE_ALPHA_TO_COVERAGE)}function qe(K){C!==K&&(K?n.frontFace(n.CW):n.frontFace(n.CCW),C=K)}function Xe(K){K!==mR?(oe(n.CULL_FACE),K!==y&&(K===Oy?n.cullFace(n.BACK):K===vR?n.cullFace(n.FRONT):n.cullFace(n.FRONT_AND_BACK))):fe(n.CULL_FACE),y=K}function Oe(K){K!==A&&(z&&n.lineWidth(K),A=K)}function it(K,$e,he){K?(oe(n.POLYGON_OFFSET_FILL),(k!==$e||M!==he)&&(n.polygonOffset($e,he),k=$e,M=he)):fe(n.POLYGON_OFFSET_FILL)}function rt(K){K?oe(n.SCISSOR_TEST):fe(n.SCISSOR_TEST)}function P(K){K===void 0&&(K=n.TEXTURE0+L-1),O!==K&&(n.activeTexture(K),O=K)}function I(K,$e,he){he===void 0&&(O===null?he=n.TEXTURE0+L-1:he=O);let be=V[he];be===void 0&&(be={type:void 0,texture:void 0},V[he]=be),(be.type!==K||be.texture!==$e)&&(O!==he&&(n.activeTexture(he),O=he),n.bindTexture(K,$e||q[K]),be.type=K,be.texture=$e)}function ne(){const K=V[O];K!==void 0&&K.type!==void 0&&(n.bindTexture(K.type,null),K.type=void 0,K.texture=void 0)}function me(){try{n.compressedTexImage2D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function ve(){try{n.compressedTexImage3D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function pe(){try{n.texSubImage2D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function Be(){try{n.texSubImage3D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function Te(){try{n.compressedTexSubImage2D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function ke(){try{n.compressedTexSubImage3D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function At(){try{n.texStorage2D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function we(){try{n.texStorage3D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function Fe(){try{n.texImage2D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function ut(){try{n.texImage3D.apply(n,arguments)}catch(K){console.error("THREE.WebGLState:",K)}}function at(K){de.equals(K)===!1&&(n.scissor(K.x,K.y,K.z,K.w),de.copy(K))}function Ve(K){le.equals(K)===!1&&(n.viewport(K.x,K.y,K.z,K.w),le.copy(K))}function It(K,$e){let he=c.get($e);he===void 0&&(he=new WeakMap,c.set($e,he));let be=he.get(K);be===void 0&&(be=n.getUniformBlockIndex($e,K.name),he.set(K,be))}function gt(K,$e){const be=c.get($e).get(K);o.get($e)!==be&&(n.uniformBlockBinding($e,be,K.__bindingPointIndex),o.set($e,be))}function tn(){n.disable(n.BLEND),n.disable(n.CULL_FACE),n.disable(n.DEPTH_TEST),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SCISSOR_TEST),n.disable(n.STENCIL_TEST),n.disable(n.SAMPLE_ALPHA_TO_COVERAGE),n.blendEquation(n.FUNC_ADD),n.blendFunc(n.ONE,n.ZERO),n.blendFuncSeparate(n.ONE,n.ZERO,n.ONE,n.ZERO),n.blendColor(0,0,0,0),n.colorMask(!0,!0,!0,!0),n.clearColor(0,0,0,0),n.depthMask(!0),n.depthFunc(n.LESS),n.clearDepth(1),n.stencilMask(4294967295),n.stencilFunc(n.ALWAYS,0,4294967295),n.stencilOp(n.KEEP,n.KEEP,n.KEEP),n.clearStencil(0),n.cullFace(n.BACK),n.frontFace(n.CCW),n.polygonOffset(0,0),n.activeTexture(n.TEXTURE0),n.bindFramebuffer(n.FRAMEBUFFER,null),n.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),n.bindFramebuffer(n.READ_FRAMEBUFFER,null),n.useProgram(null),n.lineWidth(1),n.scissor(0,0,n.canvas.width,n.canvas.height),n.viewport(0,0,n.canvas.width,n.canvas.height),l={},O=null,V={},u={},f=new WeakMap,d=[],h=null,p=!1,g=null,m=null,v=null,x=null,b=null,_=null,w=null,E=new ht(0,0,0),S=0,T=!1,C=null,y=null,A=null,k=null,M=null,de.set(0,0,n.canvas.width,n.canvas.height),le.set(0,0,n.canvas.width,n.canvas.height),i.reset(),s.reset(),a.reset()}return{buffers:{color:i,depth:s,stencil:a},enable:oe,disable:fe,bindFramebuffer:_e,drawBuffers:xe,useProgram:Se,setBlending:B,setMaterial:bt,setFlipSided:qe,setCullFace:Xe,setLineWidth:Oe,setPolygonOffset:it,setScissorTest:rt,activeTexture:P,bindTexture:I,unbindTexture:ne,compressedTexImage2D:me,compressedTexImage3D:ve,texImage2D:Fe,texImage3D:ut,updateUBOMapping:It,uniformBlockBinding:gt,texStorage2D:At,texStorage3D:we,texSubImage2D:pe,texSubImage3D:Be,compressedTexSubImage2D:Te,compressedTexSubImage3D:ke,scissor:at,viewport:Ve,reset:tn}}function N1(n,e,t,r){const i=_O(r);switch(t){case rE:return n*e;case sE:return n*e;case aE:return n*e*2;case mp:return n*e/i.components*i.byteLength;case po:return n*e/i.components*i.byteLength;case Jx:return n*e*2/i.components*i.byteLength;case e0:return n*e*2/i.components*i.byteLength;case iE:return n*e*3/i.components*i.byteLength;case Jr:return n*e*4/i.components*i.byteLength;case t0:return n*e*4/i.components*i.byteLength;case fh:case dh:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case hh:case ph:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case xg:case _g:return Math.max(n,16)*Math.max(e,8)/4;case gg:case bg:return Math.max(n,8)*Math.max(e,8)/2;case yg:case wg:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*8;case Eg:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case Sg:return Math.floor((n+3)/4)*Math.floor((e+3)/4)*16;case Tg:return Math.floor((n+4)/5)*Math.floor((e+3)/4)*16;case Ag:return Math.floor((n+4)/5)*Math.floor((e+4)/5)*16;case Cg:return Math.floor((n+5)/6)*Math.floor((e+4)/5)*16;case Ig:return Math.floor((n+5)/6)*Math.floor((e+5)/6)*16;case Mg:return Math.floor((n+7)/8)*Math.floor((e+4)/5)*16;case Rg:return Math.floor((n+7)/8)*Math.floor((e+5)/6)*16;case Ng:return Math.floor((n+7)/8)*Math.floor((e+7)/8)*16;case kg:return Math.floor((n+9)/10)*Math.floor((e+4)/5)*16;case Dg:return Math.floor((n+9)/10)*Math.floor((e+5)/6)*16;case Lg:return Math.floor((n+9)/10)*Math.floor((e+7)/8)*16;case Og:return Math.floor((n+9)/10)*Math.floor((e+9)/10)*16;case zg:return Math.floor((n+11)/12)*Math.floor((e+9)/10)*16;case Pg:return Math.floor((n+11)/12)*Math.floor((e+11)/12)*16;case mh:case Fg:case $g:return Math.ceil(n/4)*Math.ceil(e/4)*16;case oE:case Ug:return Math.ceil(n/4)*Math.ceil(e/4)*8;case Bg:case Vg:return Math.ceil(n/4)*Math.ceil(e/4)*16}throw new Error(`Unable to determine texture byte length for ${t} format.`)}function _O(n){switch(n){case yi:case eE:return{byteLength:1,components:1};case wo:case tE:case Us:return{byteLength:2,components:1};case Zx:case Qx:return{byteLength:2,components:4};case Eo:case Yx:case pi:return{byteLength:4,components:1};case nE:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${n}.`)}function yO(n,e,t,r,i,s,a){const o=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,c=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),l=new Ye,u=new WeakMap;let f;const d=new WeakMap;let h=!1;try{h=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(P,I){return h?new OffscreenCanvas(P,I):wu("canvas")}function g(P,I,ne){let me=1;const ve=rt(P);if((ve.width>ne||ve.height>ne)&&(me=ne/Math.max(ve.width,ve.height)),me<1)if(typeof HTMLImageElement<"u"&&P instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&P instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&P instanceof ImageBitmap||typeof VideoFrame<"u"&&P instanceof VideoFrame){const pe=Math.floor(me*ve.width),Be=Math.floor(me*ve.height);f===void 0&&(f=p(pe,Be));const Te=I?p(pe,Be):f;return Te.width=pe,Te.height=Be,Te.getContext("2d").drawImage(P,0,0,pe,Be),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ve.width+"x"+ve.height+") to ("+pe+"x"+Be+")."),Te}else return"data"in P&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ve.width+"x"+ve.height+")."),P;return P}function m(P){return P.generateMipmaps&&P.minFilter!==cn&&P.minFilter!==Rn}function v(P){n.generateMipmap(P)}function x(P,I,ne,me,ve=!1){if(P!==null){if(n[P]!==void 0)return n[P];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+P+"'")}let pe=I;if(I===n.RED&&(ne===n.FLOAT&&(pe=n.R32F),ne===n.HALF_FLOAT&&(pe=n.R16F),ne===n.UNSIGNED_BYTE&&(pe=n.R8)),I===n.RED_INTEGER&&(ne===n.UNSIGNED_BYTE&&(pe=n.R8UI),ne===n.UNSIGNED_SHORT&&(pe=n.R16UI),ne===n.UNSIGNED_INT&&(pe=n.R32UI),ne===n.BYTE&&(pe=n.R8I),ne===n.SHORT&&(pe=n.R16I),ne===n.INT&&(pe=n.R32I)),I===n.RG&&(ne===n.FLOAT&&(pe=n.RG32F),ne===n.HALF_FLOAT&&(pe=n.RG16F),ne===n.UNSIGNED_BYTE&&(pe=n.RG8)),I===n.RG_INTEGER&&(ne===n.UNSIGNED_BYTE&&(pe=n.RG8UI),ne===n.UNSIGNED_SHORT&&(pe=n.RG16UI),ne===n.UNSIGNED_INT&&(pe=n.RG32UI),ne===n.BYTE&&(pe=n.RG8I),ne===n.SHORT&&(pe=n.RG16I),ne===n.INT&&(pe=n.RG32I)),I===n.RGB_INTEGER&&(ne===n.UNSIGNED_BYTE&&(pe=n.RGB8UI),ne===n.UNSIGNED_SHORT&&(pe=n.RGB16UI),ne===n.UNSIGNED_INT&&(pe=n.RGB32UI),ne===n.BYTE&&(pe=n.RGB8I),ne===n.SHORT&&(pe=n.RGB16I),ne===n.INT&&(pe=n.RGB32I)),I===n.RGBA_INTEGER&&(ne===n.UNSIGNED_BYTE&&(pe=n.RGBA8UI),ne===n.UNSIGNED_SHORT&&(pe=n.RGBA16UI),ne===n.UNSIGNED_INT&&(pe=n.RGBA32UI),ne===n.BYTE&&(pe=n.RGBA8I),ne===n.SHORT&&(pe=n.RGBA16I),ne===n.INT&&(pe=n.RGBA32I)),I===n.RGB&&ne===n.UNSIGNED_INT_5_9_9_9_REV&&(pe=n.RGB9_E5),I===n.RGBA){const Be=ve?Sh:Lt.getTransfer(me);ne===n.FLOAT&&(pe=n.RGBA32F),ne===n.HALF_FLOAT&&(pe=n.RGBA16F),ne===n.UNSIGNED_BYTE&&(pe=Be===on?n.SRGB8_ALPHA8:n.RGBA8),ne===n.UNSIGNED_SHORT_4_4_4_4&&(pe=n.RGBA4),ne===n.UNSIGNED_SHORT_5_5_5_1&&(pe=n.RGB5_A1)}return(pe===n.R16F||pe===n.R32F||pe===n.RG16F||pe===n.RG32F||pe===n.RGBA16F||pe===n.RGBA32F)&&e.get("EXT_color_buffer_float"),pe}function b(P,I){let ne;return P?I===null||I===Eo||I===Xc?ne=n.DEPTH24_STENCIL8:I===pi?ne=n.DEPTH32F_STENCIL8:I===wo&&(ne=n.DEPTH24_STENCIL8,console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")):I===null||I===Eo||I===Xc?ne=n.DEPTH_COMPONENT24:I===pi?ne=n.DEPTH_COMPONENT32F:I===wo&&(ne=n.DEPTH_COMPONENT16),ne}function _(P,I){return m(P)===!0||P.isFramebufferTexture&&P.minFilter!==cn&&P.minFilter!==Rn?Math.log2(Math.max(I.width,I.height))+1:P.mipmaps!==void 0&&P.mipmaps.length>0?P.mipmaps.length:P.isCompressedTexture&&Array.isArray(P.image)?I.mipmaps.length:1}function w(P){const I=P.target;I.removeEventListener("dispose",w),S(I),I.isVideoTexture&&u.delete(I)}function E(P){const I=P.target;I.removeEventListener("dispose",E),C(I)}function S(P){const I=r.get(P);if(I.__webglInit===void 0)return;const ne=P.source,me=d.get(ne);if(me){const ve=me[I.__cacheKey];ve.usedTimes--,ve.usedTimes===0&&T(P),Object.keys(me).length===0&&d.delete(ne)}r.remove(P)}function T(P){const I=r.get(P);n.deleteTexture(I.__webglTexture);const ne=P.source,me=d.get(ne);delete me[I.__cacheKey],a.memory.textures--}function C(P){const I=r.get(P);if(P.depthTexture&&P.depthTexture.dispose(),P.isWebGLCubeRenderTarget)for(let me=0;me<6;me++){if(Array.isArray(I.__webglFramebuffer[me]))for(let ve=0;ve<I.__webglFramebuffer[me].length;ve++)n.deleteFramebuffer(I.__webglFramebuffer[me][ve]);else n.deleteFramebuffer(I.__webglFramebuffer[me]);I.__webglDepthbuffer&&n.deleteRenderbuffer(I.__webglDepthbuffer[me])}else{if(Array.isArray(I.__webglFramebuffer))for(let me=0;me<I.__webglFramebuffer.length;me++)n.deleteFramebuffer(I.__webglFramebuffer[me]);else n.deleteFramebuffer(I.__webglFramebuffer);if(I.__webglDepthbuffer&&n.deleteRenderbuffer(I.__webglDepthbuffer),I.__webglMultisampledFramebuffer&&n.deleteFramebuffer(I.__webglMultisampledFramebuffer),I.__webglColorRenderbuffer)for(let me=0;me<I.__webglColorRenderbuffer.length;me++)I.__webglColorRenderbuffer[me]&&n.deleteRenderbuffer(I.__webglColorRenderbuffer[me]);I.__webglDepthRenderbuffer&&n.deleteRenderbuffer(I.__webglDepthRenderbuffer)}const ne=P.textures;for(let me=0,ve=ne.length;me<ve;me++){const pe=r.get(ne[me]);pe.__webglTexture&&(n.deleteTexture(pe.__webglTexture),a.memory.textures--),r.remove(ne[me])}r.remove(P)}let y=0;function A(){y=0}function k(){const P=y;return P>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+P+" texture units while this GPU supports only "+i.maxTextures),y+=1,P}function M(P){const I=[];return I.push(P.wrapS),I.push(P.wrapT),I.push(P.wrapR||0),I.push(P.magFilter),I.push(P.minFilter),I.push(P.anisotropy),I.push(P.internalFormat),I.push(P.format),I.push(P.type),I.push(P.generateMipmaps),I.push(P.premultiplyAlpha),I.push(P.flipY),I.push(P.unpackAlignment),I.push(P.colorSpace),I.join()}function L(P,I){const ne=r.get(P);if(P.isVideoTexture&&Oe(P),P.isRenderTargetTexture===!1&&P.version>0&&ne.__version!==P.version){const me=P.image;if(me===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(me.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{le(ne,P,I);return}}t.bindTexture(n.TEXTURE_2D,ne.__webglTexture,n.TEXTURE0+I)}function z(P,I){const ne=r.get(P);if(P.version>0&&ne.__version!==P.version){le(ne,P,I);return}t.bindTexture(n.TEXTURE_2D_ARRAY,ne.__webglTexture,n.TEXTURE0+I)}function D(P,I){const ne=r.get(P);if(P.version>0&&ne.__version!==P.version){le(ne,P,I);return}t.bindTexture(n.TEXTURE_3D,ne.__webglTexture,n.TEXTURE0+I)}function F(P,I){const ne=r.get(P);if(P.version>0&&ne.__version!==P.version){H(ne,P,I);return}t.bindTexture(n.TEXTURE_CUBE_MAP,ne.__webglTexture,n.TEXTURE0+I)}const O={[qc]:n.REPEAT,[Fs]:n.CLAMP_TO_EDGE,[Eh]:n.MIRRORED_REPEAT},V={[cn]:n.NEAREST,[Jw]:n.NEAREST_MIPMAP_NEAREST,[ou]:n.NEAREST_MIPMAP_LINEAR,[Rn]:n.LINEAR,[uh]:n.LINEAR_MIPMAP_NEAREST,[$s]:n.LINEAR_MIPMAP_LINEAR},J={[ZR]:n.NEVER,[rN]:n.ALWAYS,[QR]:n.LESS,[uE]:n.LEQUAL,[JR]:n.EQUAL,[nN]:n.GEQUAL,[eN]:n.GREATER,[tN]:n.NOTEQUAL};function Q(P,I){if(I.type===pi&&e.has("OES_texture_float_linear")===!1&&(I.magFilter===Rn||I.magFilter===uh||I.magFilter===ou||I.magFilter===$s||I.minFilter===Rn||I.minFilter===uh||I.minFilter===ou||I.minFilter===$s)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),n.texParameteri(P,n.TEXTURE_WRAP_S,O[I.wrapS]),n.texParameteri(P,n.TEXTURE_WRAP_T,O[I.wrapT]),(P===n.TEXTURE_3D||P===n.TEXTURE_2D_ARRAY)&&n.texParameteri(P,n.TEXTURE_WRAP_R,O[I.wrapR]),n.texParameteri(P,n.TEXTURE_MAG_FILTER,V[I.magFilter]),n.texParameteri(P,n.TEXTURE_MIN_FILTER,V[I.minFilter]),I.compareFunction&&(n.texParameteri(P,n.TEXTURE_COMPARE_MODE,n.COMPARE_REF_TO_TEXTURE),n.texParameteri(P,n.TEXTURE_COMPARE_FUNC,J[I.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if(I.magFilter===cn||I.minFilter!==ou&&I.minFilter!==$s||I.type===pi&&e.has("OES_texture_float_linear")===!1)return;if(I.anisotropy>1||r.get(I).__currentAnisotropy){const ne=e.get("EXT_texture_filter_anisotropic");n.texParameterf(P,ne.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(I.anisotropy,i.getMaxAnisotropy())),r.get(I).__currentAnisotropy=I.anisotropy}}}function de(P,I){let ne=!1;P.__webglInit===void 0&&(P.__webglInit=!0,I.addEventListener("dispose",w));const me=I.source;let ve=d.get(me);ve===void 0&&(ve={},d.set(me,ve));const pe=M(I);if(pe!==P.__cacheKey){ve[pe]===void 0&&(ve[pe]={texture:n.createTexture(),usedTimes:0},a.memory.textures++,ne=!0),ve[pe].usedTimes++;const Be=ve[P.__cacheKey];Be!==void 0&&(ve[P.__cacheKey].usedTimes--,Be.usedTimes===0&&T(I)),P.__cacheKey=pe,P.__webglTexture=ve[pe].texture}return ne}function le(P,I,ne){let me=n.TEXTURE_2D;(I.isDataArrayTexture||I.isCompressedArrayTexture)&&(me=n.TEXTURE_2D_ARRAY),I.isData3DTexture&&(me=n.TEXTURE_3D);const ve=de(P,I),pe=I.source;t.bindTexture(me,P.__webglTexture,n.TEXTURE0+ne);const Be=r.get(pe);if(pe.version!==Be.__version||ve===!0){t.activeTexture(n.TEXTURE0+ne);const Te=Lt.getPrimaries(Lt.workingColorSpace),ke=I.colorSpace===ga?null:Lt.getPrimaries(I.colorSpace),At=I.colorSpace===ga||Te===ke?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,I.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,I.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,I.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,At);let we=g(I.image,!1,i.maxTextureSize);we=it(I,we);const Fe=s.convert(I.format,I.colorSpace),ut=s.convert(I.type);let at=x(I.internalFormat,Fe,ut,I.colorSpace,I.isVideoTexture);Q(me,I);let Ve;const It=I.mipmaps,gt=I.isVideoTexture!==!0,tn=Be.__version===void 0||ve===!0,K=pe.dataReady,$e=_(I,we);if(I.isDepthTexture)at=b(I.format===Kc,I.type),tn&&(gt?t.texStorage2D(n.TEXTURE_2D,1,at,we.width,we.height):t.texImage2D(n.TEXTURE_2D,0,at,we.width,we.height,0,Fe,ut,null));else if(I.isDataTexture)if(It.length>0){gt&&tn&&t.texStorage2D(n.TEXTURE_2D,$e,at,It[0].width,It[0].height);for(let he=0,be=It.length;he<be;he++)Ve=It[he],gt?K&&t.texSubImage2D(n.TEXTURE_2D,he,0,0,Ve.width,Ve.height,Fe,ut,Ve.data):t.texImage2D(n.TEXTURE_2D,he,at,Ve.width,Ve.height,0,Fe,ut,Ve.data);I.generateMipmaps=!1}else gt?(tn&&t.texStorage2D(n.TEXTURE_2D,$e,at,we.width,we.height),K&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,we.width,we.height,Fe,ut,we.data)):t.texImage2D(n.TEXTURE_2D,0,at,we.width,we.height,0,Fe,ut,we.data);else if(I.isCompressedTexture)if(I.isCompressedArrayTexture){gt&&tn&&t.texStorage3D(n.TEXTURE_2D_ARRAY,$e,at,It[0].width,It[0].height,we.depth);for(let he=0,be=It.length;he<be;he++)if(Ve=It[he],I.format!==Jr)if(Fe!==null)if(gt){if(K)if(I.layerUpdates.size>0){const ze=N1(Ve.width,Ve.height,I.format,I.type);for(const Ue of I.layerUpdates){const Dt=Ve.data.subarray(Ue*ze/Ve.data.BYTES_PER_ELEMENT,(Ue+1)*ze/Ve.data.BYTES_PER_ELEMENT);t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,he,0,0,Ue,Ve.width,Ve.height,1,Fe,Dt,0,0)}I.clearLayerUpdates()}else t.compressedTexSubImage3D(n.TEXTURE_2D_ARRAY,he,0,0,0,Ve.width,Ve.height,we.depth,Fe,Ve.data,0,0)}else t.compressedTexImage3D(n.TEXTURE_2D_ARRAY,he,at,Ve.width,Ve.height,we.depth,0,Ve.data,0,0);else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");else gt?K&&t.texSubImage3D(n.TEXTURE_2D_ARRAY,he,0,0,0,Ve.width,Ve.height,we.depth,Fe,ut,Ve.data):t.texImage3D(n.TEXTURE_2D_ARRAY,he,at,Ve.width,Ve.height,we.depth,0,Fe,ut,Ve.data)}else{gt&&tn&&t.texStorage2D(n.TEXTURE_2D,$e,at,It[0].width,It[0].height);for(let he=0,be=It.length;he<be;he++)Ve=It[he],I.format!==Jr?Fe!==null?gt?K&&t.compressedTexSubImage2D(n.TEXTURE_2D,he,0,0,Ve.width,Ve.height,Fe,Ve.data):t.compressedTexImage2D(n.TEXTURE_2D,he,at,Ve.width,Ve.height,0,Ve.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):gt?K&&t.texSubImage2D(n.TEXTURE_2D,he,0,0,Ve.width,Ve.height,Fe,ut,Ve.data):t.texImage2D(n.TEXTURE_2D,he,at,Ve.width,Ve.height,0,Fe,ut,Ve.data)}else if(I.isDataArrayTexture)if(gt){if(tn&&t.texStorage3D(n.TEXTURE_2D_ARRAY,$e,at,we.width,we.height,we.depth),K)if(I.layerUpdates.size>0){const he=N1(we.width,we.height,I.format,I.type);for(const be of I.layerUpdates){const ze=we.data.subarray(be*he/we.data.BYTES_PER_ELEMENT,(be+1)*he/we.data.BYTES_PER_ELEMENT);t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,be,we.width,we.height,1,Fe,ut,ze)}I.clearLayerUpdates()}else t.texSubImage3D(n.TEXTURE_2D_ARRAY,0,0,0,0,we.width,we.height,we.depth,Fe,ut,we.data)}else t.texImage3D(n.TEXTURE_2D_ARRAY,0,at,we.width,we.height,we.depth,0,Fe,ut,we.data);else if(I.isData3DTexture)gt?(tn&&t.texStorage3D(n.TEXTURE_3D,$e,at,we.width,we.height,we.depth),K&&t.texSubImage3D(n.TEXTURE_3D,0,0,0,0,we.width,we.height,we.depth,Fe,ut,we.data)):t.texImage3D(n.TEXTURE_3D,0,at,we.width,we.height,we.depth,0,Fe,ut,we.data);else if(I.isFramebufferTexture){if(tn)if(gt)t.texStorage2D(n.TEXTURE_2D,$e,at,we.width,we.height);else{let he=we.width,be=we.height;for(let ze=0;ze<$e;ze++)t.texImage2D(n.TEXTURE_2D,ze,at,he,be,0,Fe,ut,null),he>>=1,be>>=1}}else if(It.length>0){if(gt&&tn){const he=rt(It[0]);t.texStorage2D(n.TEXTURE_2D,$e,at,he.width,he.height)}for(let he=0,be=It.length;he<be;he++)Ve=It[he],gt?K&&t.texSubImage2D(n.TEXTURE_2D,he,0,0,Fe,ut,Ve):t.texImage2D(n.TEXTURE_2D,he,at,Fe,ut,Ve);I.generateMipmaps=!1}else if(gt){if(tn){const he=rt(we);t.texStorage2D(n.TEXTURE_2D,$e,at,he.width,he.height)}K&&t.texSubImage2D(n.TEXTURE_2D,0,0,0,Fe,ut,we)}else t.texImage2D(n.TEXTURE_2D,0,at,Fe,ut,we);m(I)&&v(me),Be.__version=pe.version,I.onUpdate&&I.onUpdate(I)}P.__version=I.version}function H(P,I,ne){if(I.image.length!==6)return;const me=de(P,I),ve=I.source;t.bindTexture(n.TEXTURE_CUBE_MAP,P.__webglTexture,n.TEXTURE0+ne);const pe=r.get(ve);if(ve.version!==pe.__version||me===!0){t.activeTexture(n.TEXTURE0+ne);const Be=Lt.getPrimaries(Lt.workingColorSpace),Te=I.colorSpace===ga?null:Lt.getPrimaries(I.colorSpace),ke=I.colorSpace===ga||Be===Te?n.NONE:n.BROWSER_DEFAULT_WEBGL;n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL,I.flipY),n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL,I.premultiplyAlpha),n.pixelStorei(n.UNPACK_ALIGNMENT,I.unpackAlignment),n.pixelStorei(n.UNPACK_COLORSPACE_CONVERSION_WEBGL,ke);const At=I.isCompressedTexture||I.image[0].isCompressedTexture,we=I.image[0]&&I.image[0].isDataTexture,Fe=[];for(let be=0;be<6;be++)!At&&!we?Fe[be]=g(I.image[be],!0,i.maxCubemapSize):Fe[be]=we?I.image[be].image:I.image[be],Fe[be]=it(I,Fe[be]);const ut=Fe[0],at=s.convert(I.format,I.colorSpace),Ve=s.convert(I.type),It=x(I.internalFormat,at,Ve,I.colorSpace),gt=I.isVideoTexture!==!0,tn=pe.__version===void 0||me===!0,K=ve.dataReady;let $e=_(I,ut);Q(n.TEXTURE_CUBE_MAP,I);let he;if(At){gt&&tn&&t.texStorage2D(n.TEXTURE_CUBE_MAP,$e,It,ut.width,ut.height);for(let be=0;be<6;be++){he=Fe[be].mipmaps;for(let ze=0;ze<he.length;ze++){const Ue=he[ze];I.format!==Jr?at!==null?gt?K&&t.compressedTexSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,ze,0,0,Ue.width,Ue.height,at,Ue.data):t.compressedTexImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,ze,It,Ue.width,Ue.height,0,Ue.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):gt?K&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,ze,0,0,Ue.width,Ue.height,at,Ve,Ue.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,ze,It,Ue.width,Ue.height,0,at,Ve,Ue.data)}}}else{if(he=I.mipmaps,gt&&tn){he.length>0&&$e++;const be=rt(Fe[0]);t.texStorage2D(n.TEXTURE_CUBE_MAP,$e,It,be.width,be.height)}for(let be=0;be<6;be++)if(we){gt?K&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,0,0,0,Fe[be].width,Fe[be].height,at,Ve,Fe[be].data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,0,It,Fe[be].width,Fe[be].height,0,at,Ve,Fe[be].data);for(let ze=0;ze<he.length;ze++){const Dt=he[ze].image[be].image;gt?K&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,ze+1,0,0,Dt.width,Dt.height,at,Ve,Dt.data):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,ze+1,It,Dt.width,Dt.height,0,at,Ve,Dt.data)}}else{gt?K&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,0,0,0,at,Ve,Fe[be]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,0,It,at,Ve,Fe[be]);for(let ze=0;ze<he.length;ze++){const Ue=he[ze];gt?K&&t.texSubImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,ze+1,0,0,at,Ve,Ue.image[be]):t.texImage2D(n.TEXTURE_CUBE_MAP_POSITIVE_X+be,ze+1,It,at,Ve,Ue.image[be])}}}m(I)&&v(n.TEXTURE_CUBE_MAP),pe.__version=ve.version,I.onUpdate&&I.onUpdate(I)}P.__version=I.version}function q(P,I,ne,me,ve,pe){const Be=s.convert(ne.format,ne.colorSpace),Te=s.convert(ne.type),ke=x(ne.internalFormat,Be,Te,ne.colorSpace);if(!r.get(I).__hasExternalTextures){const we=Math.max(1,I.width>>pe),Fe=Math.max(1,I.height>>pe);ve===n.TEXTURE_3D||ve===n.TEXTURE_2D_ARRAY?t.texImage3D(ve,pe,ke,we,Fe,I.depth,0,Be,Te,null):t.texImage2D(ve,pe,ke,we,Fe,0,Be,Te,null)}t.bindFramebuffer(n.FRAMEBUFFER,P),Xe(I)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,me,ve,r.get(ne).__webglTexture,0,qe(I)):(ve===n.TEXTURE_2D||ve>=n.TEXTURE_CUBE_MAP_POSITIVE_X&&ve<=n.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&n.framebufferTexture2D(n.FRAMEBUFFER,me,ve,r.get(ne).__webglTexture,pe),t.bindFramebuffer(n.FRAMEBUFFER,null)}function oe(P,I,ne){if(n.bindRenderbuffer(n.RENDERBUFFER,P),I.depthBuffer){const me=I.depthTexture,ve=me&&me.isDepthTexture?me.type:null,pe=b(I.stencilBuffer,ve),Be=I.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Te=qe(I);Xe(I)?o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,Te,pe,I.width,I.height):ne?n.renderbufferStorageMultisample(n.RENDERBUFFER,Te,pe,I.width,I.height):n.renderbufferStorage(n.RENDERBUFFER,pe,I.width,I.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,Be,n.RENDERBUFFER,P)}else{const me=I.textures;for(let ve=0;ve<me.length;ve++){const pe=me[ve],Be=s.convert(pe.format,pe.colorSpace),Te=s.convert(pe.type),ke=x(pe.internalFormat,Be,Te,pe.colorSpace),At=qe(I);ne&&Xe(I)===!1?n.renderbufferStorageMultisample(n.RENDERBUFFER,At,ke,I.width,I.height):Xe(I)?o.renderbufferStorageMultisampleEXT(n.RENDERBUFFER,At,ke,I.width,I.height):n.renderbufferStorage(n.RENDERBUFFER,ke,I.width,I.height)}}n.bindRenderbuffer(n.RENDERBUFFER,null)}function fe(P,I){if(I&&I.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(t.bindFramebuffer(n.FRAMEBUFFER,P),!(I.depthTexture&&I.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get(I.depthTexture).__webglTexture||I.depthTexture.image.width!==I.width||I.depthTexture.image.height!==I.height)&&(I.depthTexture.image.width=I.width,I.depthTexture.image.height=I.height,I.depthTexture.needsUpdate=!0),L(I.depthTexture,0);const me=r.get(I.depthTexture).__webglTexture,ve=qe(I);if(I.depthTexture.format===Oc)Xe(I)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,me,0,ve):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,me,0);else if(I.depthTexture.format===Kc)Xe(I)?o.framebufferTexture2DMultisampleEXT(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,me,0,ve):n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_STENCIL_ATTACHMENT,n.TEXTURE_2D,me,0);else throw new Error("Unknown depthTexture format")}function _e(P){const I=r.get(P),ne=P.isWebGLCubeRenderTarget===!0;if(I.__boundDepthTexture!==P.depthTexture){const me=P.depthTexture;if(I.__depthDisposeCallback&&I.__depthDisposeCallback(),me){const ve=()=>{delete I.__boundDepthTexture,delete I.__depthDisposeCallback,me.removeEventListener("dispose",ve)};me.addEventListener("dispose",ve),I.__depthDisposeCallback=ve}I.__boundDepthTexture=me}if(P.depthTexture&&!I.__autoAllocateDepthBuffer){if(ne)throw new Error("target.depthTexture not supported in Cube render targets");fe(I.__webglFramebuffer,P)}else if(ne){I.__webglDepthbuffer=[];for(let me=0;me<6;me++)if(t.bindFramebuffer(n.FRAMEBUFFER,I.__webglFramebuffer[me]),I.__webglDepthbuffer[me]===void 0)I.__webglDepthbuffer[me]=n.createRenderbuffer(),oe(I.__webglDepthbuffer[me],P,!1);else{const ve=P.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,pe=I.__webglDepthbuffer[me];n.bindRenderbuffer(n.RENDERBUFFER,pe),n.framebufferRenderbuffer(n.FRAMEBUFFER,ve,n.RENDERBUFFER,pe)}}else if(t.bindFramebuffer(n.FRAMEBUFFER,I.__webglFramebuffer),I.__webglDepthbuffer===void 0)I.__webglDepthbuffer=n.createRenderbuffer(),oe(I.__webglDepthbuffer,P,!1);else{const me=P.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,ve=I.__webglDepthbuffer;n.bindRenderbuffer(n.RENDERBUFFER,ve),n.framebufferRenderbuffer(n.FRAMEBUFFER,me,n.RENDERBUFFER,ve)}t.bindFramebuffer(n.FRAMEBUFFER,null)}function xe(P,I,ne){const me=r.get(P);I!==void 0&&q(me.__webglFramebuffer,P,P.texture,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,0),ne!==void 0&&_e(P)}function Se(P){const I=P.texture,ne=r.get(P),me=r.get(I);P.addEventListener("dispose",E);const ve=P.textures,pe=P.isWebGLCubeRenderTarget===!0,Be=ve.length>1;if(Be||(me.__webglTexture===void 0&&(me.__webglTexture=n.createTexture()),me.__version=I.version,a.memory.textures++),pe){ne.__webglFramebuffer=[];for(let Te=0;Te<6;Te++)if(I.mipmaps&&I.mipmaps.length>0){ne.__webglFramebuffer[Te]=[];for(let ke=0;ke<I.mipmaps.length;ke++)ne.__webglFramebuffer[Te][ke]=n.createFramebuffer()}else ne.__webglFramebuffer[Te]=n.createFramebuffer()}else{if(I.mipmaps&&I.mipmaps.length>0){ne.__webglFramebuffer=[];for(let Te=0;Te<I.mipmaps.length;Te++)ne.__webglFramebuffer[Te]=n.createFramebuffer()}else ne.__webglFramebuffer=n.createFramebuffer();if(Be)for(let Te=0,ke=ve.length;Te<ke;Te++){const At=r.get(ve[Te]);At.__webglTexture===void 0&&(At.__webglTexture=n.createTexture(),a.memory.textures++)}if(P.samples>0&&Xe(P)===!1){ne.__webglMultisampledFramebuffer=n.createFramebuffer(),ne.__webglColorRenderbuffer=[],t.bindFramebuffer(n.FRAMEBUFFER,ne.__webglMultisampledFramebuffer);for(let Te=0;Te<ve.length;Te++){const ke=ve[Te];ne.__webglColorRenderbuffer[Te]=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,ne.__webglColorRenderbuffer[Te]);const At=s.convert(ke.format,ke.colorSpace),we=s.convert(ke.type),Fe=x(ke.internalFormat,At,we,ke.colorSpace,P.isXRRenderTarget===!0),ut=qe(P);n.renderbufferStorageMultisample(n.RENDERBUFFER,ut,Fe,P.width,P.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+Te,n.RENDERBUFFER,ne.__webglColorRenderbuffer[Te])}n.bindRenderbuffer(n.RENDERBUFFER,null),P.depthBuffer&&(ne.__webglDepthRenderbuffer=n.createRenderbuffer(),oe(ne.__webglDepthRenderbuffer,P,!0)),t.bindFramebuffer(n.FRAMEBUFFER,null)}}if(pe){t.bindTexture(n.TEXTURE_CUBE_MAP,me.__webglTexture),Q(n.TEXTURE_CUBE_MAP,I);for(let Te=0;Te<6;Te++)if(I.mipmaps&&I.mipmaps.length>0)for(let ke=0;ke<I.mipmaps.length;ke++)q(ne.__webglFramebuffer[Te][ke],P,I,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+Te,ke);else q(ne.__webglFramebuffer[Te],P,I,n.COLOR_ATTACHMENT0,n.TEXTURE_CUBE_MAP_POSITIVE_X+Te,0);m(I)&&v(n.TEXTURE_CUBE_MAP),t.unbindTexture()}else if(Be){for(let Te=0,ke=ve.length;Te<ke;Te++){const At=ve[Te],we=r.get(At);t.bindTexture(n.TEXTURE_2D,we.__webglTexture),Q(n.TEXTURE_2D,At),q(ne.__webglFramebuffer,P,At,n.COLOR_ATTACHMENT0+Te,n.TEXTURE_2D,0),m(At)&&v(n.TEXTURE_2D)}t.unbindTexture()}else{let Te=n.TEXTURE_2D;if((P.isWebGL3DRenderTarget||P.isWebGLArrayRenderTarget)&&(Te=P.isWebGL3DRenderTarget?n.TEXTURE_3D:n.TEXTURE_2D_ARRAY),t.bindTexture(Te,me.__webglTexture),Q(Te,I),I.mipmaps&&I.mipmaps.length>0)for(let ke=0;ke<I.mipmaps.length;ke++)q(ne.__webglFramebuffer[ke],P,I,n.COLOR_ATTACHMENT0,Te,ke);else q(ne.__webglFramebuffer,P,I,n.COLOR_ATTACHMENT0,Te,0);m(I)&&v(Te),t.unbindTexture()}P.depthBuffer&&_e(P)}function Me(P){const I=P.textures;for(let ne=0,me=I.length;ne<me;ne++){const ve=I[ne];if(m(ve)){const pe=P.isWebGLCubeRenderTarget?n.TEXTURE_CUBE_MAP:n.TEXTURE_2D,Be=r.get(ve).__webglTexture;t.bindTexture(pe,Be),v(pe),t.unbindTexture()}}}const Le=[],B=[];function bt(P){if(P.samples>0){if(Xe(P)===!1){const I=P.textures,ne=P.width,me=P.height;let ve=n.COLOR_BUFFER_BIT;const pe=P.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT,Be=r.get(P),Te=I.length>1;if(Te)for(let ke=0;ke<I.length;ke++)t.bindFramebuffer(n.FRAMEBUFFER,Be.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+ke,n.RENDERBUFFER,null),t.bindFramebuffer(n.FRAMEBUFFER,Be.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+ke,n.TEXTURE_2D,null,0);t.bindFramebuffer(n.READ_FRAMEBUFFER,Be.__webglMultisampledFramebuffer),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Be.__webglFramebuffer);for(let ke=0;ke<I.length;ke++){if(P.resolveDepthBuffer&&(P.depthBuffer&&(ve|=n.DEPTH_BUFFER_BIT),P.stencilBuffer&&P.resolveStencilBuffer&&(ve|=n.STENCIL_BUFFER_BIT)),Te){n.framebufferRenderbuffer(n.READ_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.RENDERBUFFER,Be.__webglColorRenderbuffer[ke]);const At=r.get(I[ke]).__webglTexture;n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,At,0)}n.blitFramebuffer(0,0,ne,me,0,0,ne,me,ve,n.NEAREST),c===!0&&(Le.length=0,B.length=0,Le.push(n.COLOR_ATTACHMENT0+ke),P.depthBuffer&&P.resolveDepthBuffer===!1&&(Le.push(pe),B.push(pe),n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,B)),n.invalidateFramebuffer(n.READ_FRAMEBUFFER,Le))}if(t.bindFramebuffer(n.READ_FRAMEBUFFER,null),t.bindFramebuffer(n.DRAW_FRAMEBUFFER,null),Te)for(let ke=0;ke<I.length;ke++){t.bindFramebuffer(n.FRAMEBUFFER,Be.__webglMultisampledFramebuffer),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0+ke,n.RENDERBUFFER,Be.__webglColorRenderbuffer[ke]);const At=r.get(I[ke]).__webglTexture;t.bindFramebuffer(n.FRAMEBUFFER,Be.__webglFramebuffer),n.framebufferTexture2D(n.DRAW_FRAMEBUFFER,n.COLOR_ATTACHMENT0+ke,n.TEXTURE_2D,At,0)}t.bindFramebuffer(n.DRAW_FRAMEBUFFER,Be.__webglMultisampledFramebuffer)}else if(P.depthBuffer&&P.resolveDepthBuffer===!1&&c){const I=P.stencilBuffer?n.DEPTH_STENCIL_ATTACHMENT:n.DEPTH_ATTACHMENT;n.invalidateFramebuffer(n.DRAW_FRAMEBUFFER,[I])}}}function qe(P){return Math.min(i.maxSamples,P.samples)}function Xe(P){const I=r.get(P);return P.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&I.__useRenderToTexture!==!1}function Oe(P){const I=a.render.frame;u.get(P)!==I&&(u.set(P,I),P.update())}function it(P,I){const ne=P.colorSpace,me=P.format,ve=P.type;return P.isCompressedTexture===!0||P.isVideoTexture===!0||ne!==rr&&ne!==ga&&(Lt.getTransfer(ne)===on?(me!==Jr||ve!==yi)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",ne)),I}function rt(P){return typeof HTMLImageElement<"u"&&P instanceof HTMLImageElement?(l.width=P.naturalWidth||P.width,l.height=P.naturalHeight||P.height):typeof VideoFrame<"u"&&P instanceof VideoFrame?(l.width=P.displayWidth,l.height=P.displayHeight):(l.width=P.width,l.height=P.height),l}this.allocateTextureUnit=k,this.resetTextureUnits=A,this.setTexture2D=L,this.setTexture2DArray=z,this.setTexture3D=D,this.setTextureCube=F,this.rebindTextures=xe,this.setupRenderTarget=Se,this.updateRenderTargetMipmap=Me,this.updateMultisampleRenderTarget=bt,this.setupDepthRenderbuffer=_e,this.setupFrameBufferTexture=q,this.useMultisampledRTT=Xe}function wO(n,e){function t(r,i=ga){let s;const a=Lt.getTransfer(i);if(r===yi)return n.UNSIGNED_BYTE;if(r===Zx)return n.UNSIGNED_SHORT_4_4_4_4;if(r===Qx)return n.UNSIGNED_SHORT_5_5_5_1;if(r===nE)return n.UNSIGNED_INT_5_9_9_9_REV;if(r===eE)return n.BYTE;if(r===tE)return n.SHORT;if(r===wo)return n.UNSIGNED_SHORT;if(r===Yx)return n.INT;if(r===Eo)return n.UNSIGNED_INT;if(r===pi)return n.FLOAT;if(r===Us)return n.HALF_FLOAT;if(r===rE)return n.ALPHA;if(r===iE)return n.RGB;if(r===Jr)return n.RGBA;if(r===sE)return n.LUMINANCE;if(r===aE)return n.LUMINANCE_ALPHA;if(r===Oc)return n.DEPTH_COMPONENT;if(r===Kc)return n.DEPTH_STENCIL;if(r===mp)return n.RED;if(r===po)return n.RED_INTEGER;if(r===Jx)return n.RG;if(r===e0)return n.RG_INTEGER;if(r===t0)return n.RGBA_INTEGER;if(r===fh||r===dh||r===hh||r===ph)if(a===on)if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(r===fh)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===dh)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===hh)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===ph)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=e.get("WEBGL_compressed_texture_s3tc"),s!==null){if(r===fh)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===dh)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===hh)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===ph)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===gg||r===xg||r===bg||r===_g)if(s=e.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(r===gg)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===xg)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===bg)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===_g)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===yg||r===wg||r===Eg)if(s=e.get("WEBGL_compressed_texture_etc"),s!==null){if(r===yg||r===wg)return a===on?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(r===Eg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===Sg||r===Tg||r===Ag||r===Cg||r===Ig||r===Mg||r===Rg||r===Ng||r===kg||r===Dg||r===Lg||r===Og||r===zg||r===Pg)if(s=e.get("WEBGL_compressed_texture_astc"),s!==null){if(r===Sg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===Tg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===Ag)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===Cg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===Ig)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===Mg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===Rg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===Ng)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===kg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===Dg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===Lg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===Og)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===zg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===Pg)return a===on?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===mh||r===Fg||r===$g)if(s=e.get("EXT_texture_compression_bptc"),s!==null){if(r===mh)return a===on?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(r===Fg)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(r===$g)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(r===oE||r===Ug||r===Bg||r===Vg)if(s=e.get("EXT_texture_compression_rgtc"),s!==null){if(r===mh)return s.COMPRESSED_RED_RGTC1_EXT;if(r===Ug)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(r===Bg)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(r===Vg)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return r===Xc?n.UNSIGNED_INT_24_8:n[r]!==void 0?n[r]:null}return{convert:t}}class EO extends Er{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class mo extends mn{constructor(){super(),this.isGroup=!0,this.type="Group"}}const SO={type:"move"};class Tv{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new mo,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new mo,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new $,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new $),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new mo,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new $,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new $),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const t=this._hand;if(t)for(const r of e.hand.values())this._getHandJoint(t,r)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,t,r){let i=null,s=null,a=null;const o=this._targetRay,c=this._grip,l=this._hand;if(e&&t.session.visibilityState!=="visible-blurred"){if(l&&e.hand){a=!0;for(const g of e.hand.values()){const m=t.getJointPose(g,r),v=this._getHandJoint(l,g);m!==null&&(v.matrix.fromArray(m.transform.matrix),v.matrix.decompose(v.position,v.rotation,v.scale),v.matrixWorldNeedsUpdate=!0,v.jointRadius=m.radius),v.visible=m!==null}const u=l.joints["index-finger-tip"],f=l.joints["thumb-tip"],d=u.position.distanceTo(f.position),h=.02,p=.005;l.inputState.pinching&&d>h+p?(l.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!l.inputState.pinching&&d<=h-p&&(l.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else c!==null&&e.gripSpace&&(s=t.getPose(e.gripSpace,r),s!==null&&(c.matrix.fromArray(s.transform.matrix),c.matrix.decompose(c.position,c.rotation,c.scale),c.matrixWorldNeedsUpdate=!0,s.linearVelocity?(c.hasLinearVelocity=!0,c.linearVelocity.copy(s.linearVelocity)):c.hasLinearVelocity=!1,s.angularVelocity?(c.hasAngularVelocity=!0,c.angularVelocity.copy(s.angularVelocity)):c.hasAngularVelocity=!1));o!==null&&(i=t.getPose(e.targetRaySpace,r),i===null&&s!==null&&(i=s),i!==null&&(o.matrix.fromArray(i.transform.matrix),o.matrix.decompose(o.position,o.rotation,o.scale),o.matrixWorldNeedsUpdate=!0,i.linearVelocity?(o.hasLinearVelocity=!0,o.linearVelocity.copy(i.linearVelocity)):o.hasLinearVelocity=!1,i.angularVelocity?(o.hasAngularVelocity=!0,o.angularVelocity.copy(i.angularVelocity)):o.hasAngularVelocity=!1,this.dispatchEvent(SO)))}return o!==null&&(o.visible=i!==null),c!==null&&(c.visible=s!==null),l!==null&&(l.visible=a!==null),this}_getHandJoint(e,t){if(e.joints[t.jointName]===void 0){const r=new mo;r.matrixAutoUpdate=!1,r.visible=!1,e.joints[t.jointName]=r,e.add(r)}return e.joints[t.jointName]}}const TO=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,AO=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class CO{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,t,r){if(this.texture===null){const i=new Vn,s=e.properties.get(i);s.__webglTexture=t.texture,(t.depthNear!=r.depthNear||t.depthFar!=r.depthFar)&&(this.depthNear=t.depthNear,this.depthFar=t.depthFar),this.texture=i}}getMesh(e){if(this.texture!==null&&this.mesh===null){const t=e.cameras[0].viewport,r=new qs({vertexShader:TO,fragmentShader:AO,uniforms:{depthColor:{value:this.texture},depthWidth:{value:t.z},depthHeight:{value:t.w}}});this.mesh=new gr(new Bu(20,20),r)}return this.mesh}reset(){this.texture=null,this.mesh=null}getDepthTexture(){return this.texture}}class IO extends Bo{constructor(e,t){super();const r=this;let i=null,s=1,a=null,o="local-floor",c=1,l=null,u=null,f=null,d=null,h=null,p=null;const g=new CO,m=t.getContextAttributes();let v=null,x=null;const b=[],_=[],w=new Ye;let E=null;const S=new Er;S.layers.enable(1),S.viewport=new Bt;const T=new Er;T.layers.enable(2),T.viewport=new Bt;const C=[S,T],y=new EO;y.layers.enable(1),y.layers.enable(2);let A=null,k=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(H){let q=b[H];return q===void 0&&(q=new Tv,b[H]=q),q.getTargetRaySpace()},this.getControllerGrip=function(H){let q=b[H];return q===void 0&&(q=new Tv,b[H]=q),q.getGripSpace()},this.getHand=function(H){let q=b[H];return q===void 0&&(q=new Tv,b[H]=q),q.getHandSpace()};function M(H){const q=_.indexOf(H.inputSource);if(q===-1)return;const oe=b[q];oe!==void 0&&(oe.update(H.inputSource,H.frame,l||a),oe.dispatchEvent({type:H.type,data:H.inputSource}))}function L(){i.removeEventListener("select",M),i.removeEventListener("selectstart",M),i.removeEventListener("selectend",M),i.removeEventListener("squeeze",M),i.removeEventListener("squeezestart",M),i.removeEventListener("squeezeend",M),i.removeEventListener("end",L),i.removeEventListener("inputsourceschange",z);for(let H=0;H<b.length;H++){const q=_[H];q!==null&&(_[H]=null,b[H].disconnect(q))}A=null,k=null,g.reset(),e.setRenderTarget(v),h=null,d=null,f=null,i=null,x=null,le.stop(),r.isPresenting=!1,e.setPixelRatio(E),e.setSize(w.width,w.height,!1),r.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(H){s=H,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(H){o=H,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return l||a},this.setReferenceSpace=function(H){l=H},this.getBaseLayer=function(){return d!==null?d:h},this.getBinding=function(){return f},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(H){if(i=H,i!==null){if(v=e.getRenderTarget(),i.addEventListener("select",M),i.addEventListener("selectstart",M),i.addEventListener("selectend",M),i.addEventListener("squeeze",M),i.addEventListener("squeezestart",M),i.addEventListener("squeezeend",M),i.addEventListener("end",L),i.addEventListener("inputsourceschange",z),m.xrCompatible!==!0&&await t.makeXRCompatible(),E=e.getPixelRatio(),e.getSize(w),i.renderState.layers===void 0){const q={antialias:m.antialias,alpha:!0,depth:m.depth,stencil:m.stencil,framebufferScaleFactor:s};h=new XRWebGLLayer(i,t,q),i.updateRenderState({baseLayer:h}),e.setPixelRatio(1),e.setSize(h.framebufferWidth,h.framebufferHeight,!1),x=new So(h.framebufferWidth,h.framebufferHeight,{format:Jr,type:yi,colorSpace:e.outputColorSpace,stencilBuffer:m.stencil})}else{let q=null,oe=null,fe=null;m.depth&&(fe=m.stencil?t.DEPTH24_STENCIL8:t.DEPTH_COMPONENT24,q=m.stencil?Kc:Oc,oe=m.stencil?Xc:Eo);const _e={colorFormat:t.RGBA8,depthFormat:fe,scaleFactor:s};f=new XRWebGLBinding(i,t),d=f.createProjectionLayer(_e),i.updateRenderState({layers:[d]}),e.setPixelRatio(1),e.setSize(d.textureWidth,d.textureHeight,!1),x=new So(d.textureWidth,d.textureHeight,{format:Jr,type:yi,depthTexture:new yE(d.textureWidth,d.textureHeight,oe,void 0,void 0,void 0,void 0,void 0,void 0,q),stencilBuffer:m.stencil,colorSpace:e.outputColorSpace,samples:m.antialias?4:0,resolveDepthBuffer:d.ignoreDepthValues===!1})}x.isXRRenderTarget=!0,this.setFoveation(c),l=null,a=await i.requestReferenceSpace(o),le.setContext(i),le.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode},this.getDepthTexture=function(){return g.getDepthTexture()};function z(H){for(let q=0;q<H.removed.length;q++){const oe=H.removed[q],fe=_.indexOf(oe);fe>=0&&(_[fe]=null,b[fe].disconnect(oe))}for(let q=0;q<H.added.length;q++){const oe=H.added[q];let fe=_.indexOf(oe);if(fe===-1){for(let xe=0;xe<b.length;xe++)if(xe>=_.length){_.push(oe),fe=xe;break}else if(_[xe]===null){_[xe]=oe,fe=xe;break}if(fe===-1)break}const _e=b[fe];_e&&_e.connect(oe)}}const D=new $,F=new $;function O(H,q,oe){D.setFromMatrixPosition(q.matrixWorld),F.setFromMatrixPosition(oe.matrixWorld);const fe=D.distanceTo(F),_e=q.projectionMatrix.elements,xe=oe.projectionMatrix.elements,Se=_e[14]/(_e[10]-1),Me=_e[14]/(_e[10]+1),Le=(_e[9]+1)/_e[5],B=(_e[9]-1)/_e[5],bt=(_e[8]-1)/_e[0],qe=(xe[8]+1)/xe[0],Xe=Se*bt,Oe=Se*qe,it=fe/(-bt+qe),rt=it*-bt;if(q.matrixWorld.decompose(H.position,H.quaternion,H.scale),H.translateX(rt),H.translateZ(it),H.matrixWorld.compose(H.position,H.quaternion,H.scale),H.matrixWorldInverse.copy(H.matrixWorld).invert(),_e[10]===-1)H.projectionMatrix.copy(q.projectionMatrix),H.projectionMatrixInverse.copy(q.projectionMatrixInverse);else{const P=Se+it,I=Me+it,ne=Xe-rt,me=Oe+(fe-rt),ve=Le*Me/I*P,pe=B*Me/I*P;H.projectionMatrix.makePerspective(ne,me,ve,pe,P,I),H.projectionMatrixInverse.copy(H.projectionMatrix).invert()}}function V(H,q){q===null?H.matrixWorld.copy(H.matrix):H.matrixWorld.multiplyMatrices(q.matrixWorld,H.matrix),H.matrixWorldInverse.copy(H.matrixWorld).invert()}this.updateCamera=function(H){if(i===null)return;let q=H.near,oe=H.far;g.texture!==null&&(g.depthNear>0&&(q=g.depthNear),g.depthFar>0&&(oe=g.depthFar)),y.near=T.near=S.near=q,y.far=T.far=S.far=oe,(A!==y.near||k!==y.far)&&(i.updateRenderState({depthNear:y.near,depthFar:y.far}),A=y.near,k=y.far);const fe=H.parent,_e=y.cameras;V(y,fe);for(let xe=0;xe<_e.length;xe++)V(_e[xe],fe);_e.length===2?O(y,S,T):y.projectionMatrix.copy(S.projectionMatrix),J(H,y,fe)};function J(H,q,oe){oe===null?H.matrix.copy(q.matrixWorld):(H.matrix.copy(oe.matrixWorld),H.matrix.invert(),H.matrix.multiply(q.matrixWorld)),H.matrix.decompose(H.position,H.quaternion,H.scale),H.updateMatrixWorld(!0),H.projectionMatrix.copy(q.projectionMatrix),H.projectionMatrixInverse.copy(q.projectionMatrixInverse),H.isPerspectiveCamera&&(H.fov=jc*2*Math.atan(1/H.projectionMatrix.elements[5]),H.zoom=1)}this.getCamera=function(){return y},this.getFoveation=function(){if(!(d===null&&h===null))return c},this.setFoveation=function(H){c=H,d!==null&&(d.fixedFoveation=H),h!==null&&h.fixedFoveation!==void 0&&(h.fixedFoveation=H)},this.hasDepthSensing=function(){return g.texture!==null},this.getDepthSensingMesh=function(){return g.getMesh(y)};let Q=null;function de(H,q){if(u=q.getViewerPose(l||a),p=q,u!==null){const oe=u.views;h!==null&&(e.setRenderTargetFramebuffer(x,h.framebuffer),e.setRenderTarget(x));let fe=!1;oe.length!==y.cameras.length&&(y.cameras.length=0,fe=!0);for(let xe=0;xe<oe.length;xe++){const Se=oe[xe];let Me=null;if(h!==null)Me=h.getViewport(Se);else{const B=f.getViewSubImage(d,Se);Me=B.viewport,xe===0&&(e.setRenderTargetTextures(x,B.colorTexture,d.ignoreDepthValues?void 0:B.depthStencilTexture),e.setRenderTarget(x))}let Le=C[xe];Le===void 0&&(Le=new Er,Le.layers.enable(xe),Le.viewport=new Bt,C[xe]=Le),Le.matrix.fromArray(Se.transform.matrix),Le.matrix.decompose(Le.position,Le.quaternion,Le.scale),Le.projectionMatrix.fromArray(Se.projectionMatrix),Le.projectionMatrixInverse.copy(Le.projectionMatrix).invert(),Le.viewport.set(Me.x,Me.y,Me.width,Me.height),xe===0&&(y.matrix.copy(Le.matrix),y.matrix.decompose(y.position,y.quaternion,y.scale)),fe===!0&&y.cameras.push(Le)}const _e=i.enabledFeatures;if(_e&&_e.includes("depth-sensing")){const xe=f.getDepthInformation(oe[0]);xe&&xe.isValid&&xe.texture&&g.init(e,xe,i.renderState)}}for(let oe=0;oe<b.length;oe++){const fe=_[oe],_e=b[oe];fe!==null&&_e!==void 0&&_e.update(fe,q,l||a)}Q&&Q(H,q),q.detectedPlanes&&r.dispatchEvent({type:"planesdetected",data:q}),p=null}const le=new _E;le.setAnimationLoop(de),this.setAnimationLoop=function(H){Q=H},this.dispose=function(){}}}const no=new ms,MO=new lt;function RO(n,e){function t(m,v){m.matrixAutoUpdate===!0&&m.updateMatrix(),v.value.copy(m.matrix)}function r(m,v){v.color.getRGB(m.fogColor.value,xE(n)),v.isFog?(m.fogNear.value=v.near,m.fogFar.value=v.far):v.isFogExp2&&(m.fogDensity.value=v.density)}function i(m,v,x,b,_){v.isMeshBasicMaterial||v.isMeshLambertMaterial?s(m,v):v.isMeshToonMaterial?(s(m,v),f(m,v)):v.isMeshPhongMaterial?(s(m,v),u(m,v)):v.isMeshStandardMaterial?(s(m,v),d(m,v),v.isMeshPhysicalMaterial&&h(m,v,_)):v.isMeshMatcapMaterial?(s(m,v),p(m,v)):v.isMeshDepthMaterial?s(m,v):v.isMeshDistanceMaterial?(s(m,v),g(m,v)):v.isMeshNormalMaterial?s(m,v):v.isLineBasicMaterial?(a(m,v),v.isLineDashedMaterial&&o(m,v)):v.isPointsMaterial?c(m,v,x,b):v.isSpriteMaterial?l(m,v):v.isShadowMaterial?(m.color.value.copy(v.color),m.opacity.value=v.opacity):v.isShaderMaterial&&(v.uniformsNeedUpdate=!1)}function s(m,v){m.opacity.value=v.opacity,v.color&&m.diffuse.value.copy(v.color),v.emissive&&m.emissive.value.copy(v.emissive).multiplyScalar(v.emissiveIntensity),v.map&&(m.map.value=v.map,t(v.map,m.mapTransform)),v.alphaMap&&(m.alphaMap.value=v.alphaMap,t(v.alphaMap,m.alphaMapTransform)),v.bumpMap&&(m.bumpMap.value=v.bumpMap,t(v.bumpMap,m.bumpMapTransform),m.bumpScale.value=v.bumpScale,v.side===Ir&&(m.bumpScale.value*=-1)),v.normalMap&&(m.normalMap.value=v.normalMap,t(v.normalMap,m.normalMapTransform),m.normalScale.value.copy(v.normalScale),v.side===Ir&&m.normalScale.value.negate()),v.displacementMap&&(m.displacementMap.value=v.displacementMap,t(v.displacementMap,m.displacementMapTransform),m.displacementScale.value=v.displacementScale,m.displacementBias.value=v.displacementBias),v.emissiveMap&&(m.emissiveMap.value=v.emissiveMap,t(v.emissiveMap,m.emissiveMapTransform)),v.specularMap&&(m.specularMap.value=v.specularMap,t(v.specularMap,m.specularMapTransform)),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest);const x=e.get(v),b=x.envMap,_=x.envMapRotation;b&&(m.envMap.value=b,no.copy(_),no.x*=-1,no.y*=-1,no.z*=-1,b.isCubeTexture&&b.isRenderTargetTexture===!1&&(no.y*=-1,no.z*=-1),m.envMapRotation.value.setFromMatrix4(MO.makeRotationFromEuler(no)),m.flipEnvMap.value=b.isCubeTexture&&b.isRenderTargetTexture===!1?-1:1,m.reflectivity.value=v.reflectivity,m.ior.value=v.ior,m.refractionRatio.value=v.refractionRatio),v.lightMap&&(m.lightMap.value=v.lightMap,m.lightMapIntensity.value=v.lightMapIntensity,t(v.lightMap,m.lightMapTransform)),v.aoMap&&(m.aoMap.value=v.aoMap,m.aoMapIntensity.value=v.aoMapIntensity,t(v.aoMap,m.aoMapTransform))}function a(m,v){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity,v.map&&(m.map.value=v.map,t(v.map,m.mapTransform))}function o(m,v){m.dashSize.value=v.dashSize,m.totalSize.value=v.dashSize+v.gapSize,m.scale.value=v.scale}function c(m,v,x,b){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity,m.size.value=v.size*x,m.scale.value=b*.5,v.map&&(m.map.value=v.map,t(v.map,m.uvTransform)),v.alphaMap&&(m.alphaMap.value=v.alphaMap,t(v.alphaMap,m.alphaMapTransform)),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest)}function l(m,v){m.diffuse.value.copy(v.color),m.opacity.value=v.opacity,m.rotation.value=v.rotation,v.map&&(m.map.value=v.map,t(v.map,m.mapTransform)),v.alphaMap&&(m.alphaMap.value=v.alphaMap,t(v.alphaMap,m.alphaMapTransform)),v.alphaTest>0&&(m.alphaTest.value=v.alphaTest)}function u(m,v){m.specular.value.copy(v.specular),m.shininess.value=Math.max(v.shininess,1e-4)}function f(m,v){v.gradientMap&&(m.gradientMap.value=v.gradientMap)}function d(m,v){m.metalness.value=v.metalness,v.metalnessMap&&(m.metalnessMap.value=v.metalnessMap,t(v.metalnessMap,m.metalnessMapTransform)),m.roughness.value=v.roughness,v.roughnessMap&&(m.roughnessMap.value=v.roughnessMap,t(v.roughnessMap,m.roughnessMapTransform)),v.envMap&&(m.envMapIntensity.value=v.envMapIntensity)}function h(m,v,x){m.ior.value=v.ior,v.sheen>0&&(m.sheenColor.value.copy(v.sheenColor).multiplyScalar(v.sheen),m.sheenRoughness.value=v.sheenRoughness,v.sheenColorMap&&(m.sheenColorMap.value=v.sheenColorMap,t(v.sheenColorMap,m.sheenColorMapTransform)),v.sheenRoughnessMap&&(m.sheenRoughnessMap.value=v.sheenRoughnessMap,t(v.sheenRoughnessMap,m.sheenRoughnessMapTransform))),v.clearcoat>0&&(m.clearcoat.value=v.clearcoat,m.clearcoatRoughness.value=v.clearcoatRoughness,v.clearcoatMap&&(m.clearcoatMap.value=v.clearcoatMap,t(v.clearcoatMap,m.clearcoatMapTransform)),v.clearcoatRoughnessMap&&(m.clearcoatRoughnessMap.value=v.clearcoatRoughnessMap,t(v.clearcoatRoughnessMap,m.clearcoatRoughnessMapTransform)),v.clearcoatNormalMap&&(m.clearcoatNormalMap.value=v.clearcoatNormalMap,t(v.clearcoatNormalMap,m.clearcoatNormalMapTransform),m.clearcoatNormalScale.value.copy(v.clearcoatNormalScale),v.side===Ir&&m.clearcoatNormalScale.value.negate())),v.dispersion>0&&(m.dispersion.value=v.dispersion),v.iridescence>0&&(m.iridescence.value=v.iridescence,m.iridescenceIOR.value=v.iridescenceIOR,m.iridescenceThicknessMinimum.value=v.iridescenceThicknessRange[0],m.iridescenceThicknessMaximum.value=v.iridescenceThicknessRange[1],v.iridescenceMap&&(m.iridescenceMap.value=v.iridescenceMap,t(v.iridescenceMap,m.iridescenceMapTransform)),v.iridescenceThicknessMap&&(m.iridescenceThicknessMap.value=v.iridescenceThicknessMap,t(v.iridescenceThicknessMap,m.iridescenceThicknessMapTransform))),v.transmission>0&&(m.transmission.value=v.transmission,m.transmissionSamplerMap.value=x.texture,m.transmissionSamplerSize.value.set(x.width,x.height),v.transmissionMap&&(m.transmissionMap.value=v.transmissionMap,t(v.transmissionMap,m.transmissionMapTransform)),m.thickness.value=v.thickness,v.thicknessMap&&(m.thicknessMap.value=v.thicknessMap,t(v.thicknessMap,m.thicknessMapTransform)),m.attenuationDistance.value=v.attenuationDistance,m.attenuationColor.value.copy(v.attenuationColor)),v.anisotropy>0&&(m.anisotropyVector.value.set(v.anisotropy*Math.cos(v.anisotropyRotation),v.anisotropy*Math.sin(v.anisotropyRotation)),v.anisotropyMap&&(m.anisotropyMap.value=v.anisotropyMap,t(v.anisotropyMap,m.anisotropyMapTransform))),m.specularIntensity.value=v.specularIntensity,m.specularColor.value.copy(v.specularColor),v.specularColorMap&&(m.specularColorMap.value=v.specularColorMap,t(v.specularColorMap,m.specularColorMapTransform)),v.specularIntensityMap&&(m.specularIntensityMap.value=v.specularIntensityMap,t(v.specularIntensityMap,m.specularIntensityMapTransform))}function p(m,v){v.matcap&&(m.matcap.value=v.matcap)}function g(m,v){const x=e.get(v).light;m.referencePosition.value.setFromMatrixPosition(x.matrixWorld),m.nearDistance.value=x.shadow.camera.near,m.farDistance.value=x.shadow.camera.far}return{refreshFogUniforms:r,refreshMaterialUniforms:i}}function NO(n,e,t,r){let i={},s={},a=[];const o=n.getParameter(n.MAX_UNIFORM_BUFFER_BINDINGS);function c(x,b){const _=b.program;r.uniformBlockBinding(x,_)}function l(x,b){let _=i[x.id];_===void 0&&(p(x),_=u(x),i[x.id]=_,x.addEventListener("dispose",m));const w=b.program;r.updateUBOMapping(x,w);const E=e.render.frame;s[x.id]!==E&&(d(x),s[x.id]=E)}function u(x){const b=f();x.__bindingPointIndex=b;const _=n.createBuffer(),w=x.__size,E=x.usage;return n.bindBuffer(n.UNIFORM_BUFFER,_),n.bufferData(n.UNIFORM_BUFFER,w,E),n.bindBuffer(n.UNIFORM_BUFFER,null),n.bindBufferBase(n.UNIFORM_BUFFER,b,_),_}function f(){for(let x=0;x<o;x++)if(a.indexOf(x)===-1)return a.push(x),x;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function d(x){const b=i[x.id],_=x.uniforms,w=x.__cache;n.bindBuffer(n.UNIFORM_BUFFER,b);for(let E=0,S=_.length;E<S;E++){const T=Array.isArray(_[E])?_[E]:[_[E]];for(let C=0,y=T.length;C<y;C++){const A=T[C];if(h(A,E,C,w)===!0){const k=A.__offset,M=Array.isArray(A.value)?A.value:[A.value];let L=0;for(let z=0;z<M.length;z++){const D=M[z],F=g(D);typeof D=="number"||typeof D=="boolean"?(A.__data[0]=D,n.bufferSubData(n.UNIFORM_BUFFER,k+L,A.__data)):D.isMatrix3?(A.__data[0]=D.elements[0],A.__data[1]=D.elements[1],A.__data[2]=D.elements[2],A.__data[3]=0,A.__data[4]=D.elements[3],A.__data[5]=D.elements[4],A.__data[6]=D.elements[5],A.__data[7]=0,A.__data[8]=D.elements[6],A.__data[9]=D.elements[7],A.__data[10]=D.elements[8],A.__data[11]=0):(D.toArray(A.__data,L),L+=F.storage/Float32Array.BYTES_PER_ELEMENT)}n.bufferSubData(n.UNIFORM_BUFFER,k,A.__data)}}}n.bindBuffer(n.UNIFORM_BUFFER,null)}function h(x,b,_,w){const E=x.value,S=b+"_"+_;if(w[S]===void 0)return typeof E=="number"||typeof E=="boolean"?w[S]=E:w[S]=E.clone(),!0;{const T=w[S];if(typeof E=="number"||typeof E=="boolean"){if(T!==E)return w[S]=E,!0}else if(T.equals(E)===!1)return T.copy(E),!0}return!1}function p(x){const b=x.uniforms;let _=0;const w=16;for(let S=0,T=b.length;S<T;S++){const C=Array.isArray(b[S])?b[S]:[b[S]];for(let y=0,A=C.length;y<A;y++){const k=C[y],M=Array.isArray(k.value)?k.value:[k.value];for(let L=0,z=M.length;L<z;L++){const D=M[L],F=g(D),O=_%w,V=O%F.boundary,J=O+V;_+=V,J!==0&&w-J<F.storage&&(_+=w-J),k.__data=new Float32Array(F.storage/Float32Array.BYTES_PER_ELEMENT),k.__offset=_,_+=F.storage}}}const E=_%w;return E>0&&(_+=w-E),x.__size=_,x.__cache={},this}function g(x){const b={boundary:0,storage:0};return typeof x=="number"||typeof x=="boolean"?(b.boundary=4,b.storage=4):x.isVector2?(b.boundary=8,b.storage=8):x.isVector3||x.isColor?(b.boundary=16,b.storage=12):x.isVector4?(b.boundary=16,b.storage=16):x.isMatrix3?(b.boundary=48,b.storage=48):x.isMatrix4?(b.boundary=64,b.storage=64):x.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",x),b}function m(x){const b=x.target;b.removeEventListener("dispose",m);const _=a.indexOf(b.__bindingPointIndex);a.splice(_,1),n.deleteBuffer(i[b.id]),delete i[b.id],delete s[b.id]}function v(){for(const x in i)n.deleteBuffer(i[x]);a=[],i={},s={}}return{bind:c,update:l,dispose:v}}class kO{constructor(e={}){const{canvas:t=_N(),context:r=null,depth:i=!0,stencil:s=!1,alpha:a=!1,antialias:o=!1,premultipliedAlpha:c=!0,preserveDrawingBuffer:l=!1,powerPreference:u="default",failIfMajorPerformanceCaveat:f=!1}=e;this.isWebGLRenderer=!0;let d;if(r!==null){if(typeof WebGLRenderingContext<"u"&&r instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");d=r.getContextAttributes().alpha}else d=a;const h=new Uint32Array(4),p=new Int32Array(4);let g=null,m=null;const v=[],x=[];this.domElement=t,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=Xn,this.toneMapping=Ta,this.toneMappingExposure=1;const b=this;let _=!1,w=0,E=0,S=null,T=-1,C=null;const y=new Bt,A=new Bt;let k=null;const M=new ht(0);let L=0,z=t.width,D=t.height,F=1,O=null,V=null;const J=new Bt(0,0,z,D),Q=new Bt(0,0,z,D);let de=!1;const le=new a0;let H=!1,q=!1;const oe=new lt,fe=new lt,_e=new $,xe=new Bt,Se={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};let Me=!1;function Le(){return S===null?F:1}let B=r;function bt(N,Z){return t.getContext(N,Z)}try{const N={alpha:!0,depth:i,stencil:s,antialias:o,premultipliedAlpha:c,preserveDrawingBuffer:l,powerPreference:u,failIfMajorPerformanceCaveat:f};if("setAttribute"in t&&t.setAttribute("data-engine",`three.js r${jx}`),t.addEventListener("webglcontextlost",be,!1),t.addEventListener("webglcontextrestored",ze,!1),t.addEventListener("webglcontextcreationerror",Ue,!1),B===null){const Z="webgl2";if(B=bt(Z,N),B===null)throw bt(Z)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(N){throw console.error("THREE.WebGLRenderer: "+N.message),N}let qe,Xe,Oe,it,rt,P,I,ne,me,ve,pe,Be,Te,ke,At,we,Fe,ut,at,Ve,It,gt,tn,K;function $e(){qe=new PD(B),qe.init(),gt=new wO(B,qe),Xe=new ND(B,qe,e,gt),Oe=new bO(B),Xe.reverseDepthBuffer&&Oe.buffers.depth.setReversed(!0),it=new UD(B),rt=new iO,P=new yO(B,qe,Oe,rt,Xe,gt,it),I=new DD(b),ne=new zD(b),me=new XN(B),tn=new MD(B,me),ve=new FD(B,me,it,tn),pe=new VD(B,ve,me,it),at=new BD(B,Xe,P),we=new kD(rt),Be=new rO(b,I,ne,qe,Xe,tn,we),Te=new RO(b,rt),ke=new aO,At=new dO(qe),ut=new ID(b,I,ne,Oe,pe,d,c),Fe=new gO(b,pe,Xe),K=new NO(B,it,Xe,Oe),Ve=new RD(B,qe,it),It=new $D(B,qe,it),it.programs=Be.programs,b.capabilities=Xe,b.extensions=qe,b.properties=rt,b.renderLists=ke,b.shadowMap=Fe,b.state=Oe,b.info=it}$e();const he=new IO(b,B);this.xr=he,this.getContext=function(){return B},this.getContextAttributes=function(){return B.getContextAttributes()},this.forceContextLoss=function(){const N=qe.get("WEBGL_lose_context");N&&N.loseContext()},this.forceContextRestore=function(){const N=qe.get("WEBGL_lose_context");N&&N.restoreContext()},this.getPixelRatio=function(){return F},this.setPixelRatio=function(N){N!==void 0&&(F=N,this.setSize(z,D,!1))},this.getSize=function(N){return N.set(z,D)},this.setSize=function(N,Z,se=!0){if(he.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}z=N,D=Z,t.width=Math.floor(N*F),t.height=Math.floor(Z*F),se===!0&&(t.style.width=N+"px",t.style.height=Z+"px"),this.setViewport(0,0,N,Z)},this.getDrawingBufferSize=function(N){return N.set(z*F,D*F).floor()},this.setDrawingBufferSize=function(N,Z,se){z=N,D=Z,F=se,t.width=Math.floor(N*se),t.height=Math.floor(Z*se),this.setViewport(0,0,N,Z)},this.getCurrentViewport=function(N){return N.copy(y)},this.getViewport=function(N){return N.copy(J)},this.setViewport=function(N,Z,se,ae){N.isVector4?J.set(N.x,N.y,N.z,N.w):J.set(N,Z,se,ae),Oe.viewport(y.copy(J).multiplyScalar(F).round())},this.getScissor=function(N){return N.copy(Q)},this.setScissor=function(N,Z,se,ae){N.isVector4?Q.set(N.x,N.y,N.z,N.w):Q.set(N,Z,se,ae),Oe.scissor(A.copy(Q).multiplyScalar(F).round())},this.getScissorTest=function(){return de},this.setScissorTest=function(N){Oe.setScissorTest(de=N)},this.setOpaqueSort=function(N){O=N},this.setTransparentSort=function(N){V=N},this.getClearColor=function(N){return N.copy(ut.getClearColor())},this.setClearColor=function(){ut.setClearColor.apply(ut,arguments)},this.getClearAlpha=function(){return ut.getClearAlpha()},this.setClearAlpha=function(){ut.setClearAlpha.apply(ut,arguments)},this.clear=function(N=!0,Z=!0,se=!0){let ae=0;if(N){let ee=!1;if(S!==null){const Ee=S.texture.format;ee=Ee===t0||Ee===e0||Ee===po}if(ee){const Ee=S.texture.type,Pe=Ee===yi||Ee===Eo||Ee===wo||Ee===Xc||Ee===Zx||Ee===Qx,Ke=ut.getClearColor(),je=ut.getClearAlpha(),ft=Ke.r,dt=Ke.g,Je=Ke.b;Pe?(h[0]=ft,h[1]=dt,h[2]=Je,h[3]=je,B.clearBufferuiv(B.COLOR,0,h)):(p[0]=ft,p[1]=dt,p[2]=Je,p[3]=je,B.clearBufferiv(B.COLOR,0,p))}else ae|=B.COLOR_BUFFER_BIT}Z&&(ae|=B.DEPTH_BUFFER_BIT,B.clearDepth(this.capabilities.reverseDepthBuffer?0:1)),se&&(ae|=B.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),B.clear(ae)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){t.removeEventListener("webglcontextlost",be,!1),t.removeEventListener("webglcontextrestored",ze,!1),t.removeEventListener("webglcontextcreationerror",Ue,!1),ke.dispose(),At.dispose(),rt.dispose(),I.dispose(),ne.dispose(),pe.dispose(),tn.dispose(),K.dispose(),Be.dispose(),he.dispose(),he.removeEventListener("sessionstart",Cy),he.removeEventListener("sessionend",Iy),Ya.stop()};function be(N){N.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),_=!0}function ze(){console.log("THREE.WebGLRenderer: Context Restored."),_=!1;const N=it.autoReset,Z=Fe.enabled,se=Fe.autoUpdate,ae=Fe.needsUpdate,ee=Fe.type;$e(),it.autoReset=N,Fe.enabled=Z,Fe.autoUpdate=se,Fe.needsUpdate=ae,Fe.type=ee}function Ue(N){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",N.statusMessage)}function Dt(N){const Z=N.target;Z.removeEventListener("dispose",Dt),In(Z)}function In(N){Dr(N),rt.remove(N)}function Dr(N){const Z=rt.get(N).programs;Z!==void 0&&(Z.forEach(function(se){Be.releaseProgram(se)}),N.isShaderMaterial&&Be.releaseShaderCache(N))}this.renderBufferDirect=function(N,Z,se,ae,ee,Ee){Z===null&&(Z=Se);const Pe=ee.isMesh&&ee.matrixWorld.determinant()<0,Ke=cR(N,Z,se,ae,ee);Oe.setMaterial(ae,Pe);let je=se.index,ft=1;if(ae.wireframe===!0){if(je=ve.getWireframeAttribute(se),je===void 0)return;ft=2}const dt=se.drawRange,Je=se.attributes.position;let qt=dt.start*ft,an=(dt.start+dt.count)*ft;Ee!==null&&(qt=Math.max(qt,Ee.start*ft),an=Math.min(an,(Ee.start+Ee.count)*ft)),je!==null?(qt=Math.max(qt,0),an=Math.min(an,je.count)):Je!=null&&(qt=Math.max(qt,0),an=Math.min(an,Je.count));const vn=an-qt;if(vn<0||vn===1/0)return;tn.setup(ee,ae,Ke,se,je);let Kr,Vt=Ve;if(je!==null&&(Kr=me.get(je),Vt=It,Vt.setIndex(Kr)),ee.isMesh)ae.wireframe===!0?(Oe.setLineWidth(ae.wireframeLinewidth*Le()),Vt.setMode(B.LINES)):Vt.setMode(B.TRIANGLES);else if(ee.isLine){let tt=ae.linewidth;tt===void 0&&(tt=1),Oe.setLineWidth(tt*Le()),ee.isLineSegments?Vt.setMode(B.LINES):ee.isLineLoop?Vt.setMode(B.LINE_LOOP):Vt.setMode(B.LINE_STRIP)}else ee.isPoints?Vt.setMode(B.POINTS):ee.isSprite&&Vt.setMode(B.TRIANGLES);if(ee.isBatchedMesh)if(ee._multiDrawInstances!==null)Vt.renderMultiDrawInstances(ee._multiDrawStarts,ee._multiDrawCounts,ee._multiDrawCount,ee._multiDrawInstances);else if(qe.get("WEBGL_multi_draw"))Vt.renderMultiDraw(ee._multiDrawStarts,ee._multiDrawCounts,ee._multiDrawCount);else{const tt=ee._multiDrawStarts,Jn=ee._multiDrawCounts,Gt=ee._multiDrawCount,Ni=je?me.get(je).bytesPerElement:1,nc=rt.get(ae).currentProgram.getUniforms();for(let jr=0;jr<Gt;jr++)nc.setValue(B,"_gl_DrawID",jr),Vt.render(tt[jr]/Ni,Jn[jr])}else if(ee.isInstancedMesh)Vt.renderInstances(qt,vn,ee.count);else if(se.isInstancedBufferGeometry){const tt=se._maxInstanceCount!==void 0?se._maxInstanceCount:1/0,Jn=Math.min(se.instanceCount,tt);Vt.renderInstances(qt,vn,Jn)}else Vt.render(qt,vn)};function Ft(N,Z,se){N.transparent===!0&&N.side===$i&&N.forceSinglePass===!1?(N.side=Ir,N.needsUpdate=!0,gd(N,Z,se),N.side=Ws,N.needsUpdate=!0,gd(N,Z,se),N.side=$i):gd(N,Z,se)}this.compile=function(N,Z,se=null){se===null&&(se=N),m=At.get(se),m.init(Z),x.push(m),se.traverseVisible(function(ee){ee.isLight&&ee.layers.test(Z.layers)&&(m.pushLight(ee),ee.castShadow&&m.pushShadow(ee))}),N!==se&&N.traverseVisible(function(ee){ee.isLight&&ee.layers.test(Z.layers)&&(m.pushLight(ee),ee.castShadow&&m.pushShadow(ee))}),m.setupLights();const ae=new Set;return N.traverse(function(ee){if(!(ee.isMesh||ee.isPoints||ee.isLine||ee.isSprite))return;const Ee=ee.material;if(Ee)if(Array.isArray(Ee))for(let Pe=0;Pe<Ee.length;Pe++){const Ke=Ee[Pe];Ft(Ke,se,ee),ae.add(Ke)}else Ft(Ee,se,ee),ae.add(Ee)}),x.pop(),m=null,ae},this.compileAsync=function(N,Z,se=null){const ae=this.compile(N,Z,se);return new Promise(ee=>{function Ee(){if(ae.forEach(function(Pe){rt.get(Pe).currentProgram.isReady()&&ae.delete(Pe)}),ae.size===0){ee(N);return}setTimeout(Ee,10)}qe.get("KHR_parallel_shader_compile")!==null?Ee():setTimeout(Ee,10)})};let Lr=null;function As(N){Lr&&Lr(N)}function Cy(){Ya.stop()}function Iy(){Ya.start()}const Ya=new _E;Ya.setAnimationLoop(As),typeof self<"u"&&Ya.setContext(self),this.setAnimationLoop=function(N){Lr=N,he.setAnimationLoop(N),N===null?Ya.stop():Ya.start()},he.addEventListener("sessionstart",Cy),he.addEventListener("sessionend",Iy),this.render=function(N,Z){if(Z!==void 0&&Z.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(_===!0)return;if(N.matrixWorldAutoUpdate===!0&&N.updateMatrixWorld(),Z.parent===null&&Z.matrixWorldAutoUpdate===!0&&Z.updateMatrixWorld(),he.enabled===!0&&he.isPresenting===!0&&(he.cameraAutoUpdate===!0&&he.updateCamera(Z),Z=he.getCamera()),N.isScene===!0&&N.onBeforeRender(b,N,Z,S),m=At.get(N,x.length),m.init(Z),x.push(m),fe.multiplyMatrices(Z.projectionMatrix,Z.matrixWorldInverse),le.setFromProjectionMatrix(fe),q=this.localClippingEnabled,H=we.init(this.clippingPlanes,q),g=ke.get(N,v.length),g.init(),v.push(g),he.enabled===!0&&he.isPresenting===!0){const Ee=b.xr.getDepthSensingMesh();Ee!==null&&Xm(Ee,Z,-1/0,b.sortObjects)}Xm(N,Z,0,b.sortObjects),g.finish(),b.sortObjects===!0&&g.sort(O,V),Me=he.enabled===!1||he.isPresenting===!1||he.hasDepthSensing()===!1,Me&&ut.addToRenderList(g,N),this.info.render.frame++,H===!0&&we.beginShadows();const se=m.state.shadowsArray;Fe.render(se,N,Z),H===!0&&we.endShadows(),this.info.autoReset===!0&&this.info.reset();const ae=g.opaque,ee=g.transmissive;if(m.setupLights(),Z.isArrayCamera){const Ee=Z.cameras;if(ee.length>0)for(let Pe=0,Ke=Ee.length;Pe<Ke;Pe++){const je=Ee[Pe];Ry(ae,ee,N,je)}Me&&ut.render(N);for(let Pe=0,Ke=Ee.length;Pe<Ke;Pe++){const je=Ee[Pe];My(g,N,je,je.viewport)}}else ee.length>0&&Ry(ae,ee,N,Z),Me&&ut.render(N),My(g,N,Z);S!==null&&(P.updateMultisampleRenderTarget(S),P.updateRenderTargetMipmap(S)),N.isScene===!0&&N.onAfterRender(b,N,Z),tn.resetDefaultState(),T=-1,C=null,x.pop(),x.length>0?(m=x[x.length-1],H===!0&&we.setGlobalState(b.clippingPlanes,m.state.camera)):m=null,v.pop(),v.length>0?g=v[v.length-1]:g=null};function Xm(N,Z,se,ae){if(N.visible===!1)return;if(N.layers.test(Z.layers)){if(N.isGroup)se=N.renderOrder;else if(N.isLOD)N.autoUpdate===!0&&N.update(Z);else if(N.isLight)m.pushLight(N),N.castShadow&&m.pushShadow(N);else if(N.isSprite){if(!N.frustumCulled||le.intersectsSprite(N)){ae&&xe.setFromMatrixPosition(N.matrixWorld).applyMatrix4(fe);const Pe=pe.update(N),Ke=N.material;Ke.visible&&g.push(N,Pe,Ke,se,xe.z,null)}}else if((N.isMesh||N.isLine||N.isPoints)&&(!N.frustumCulled||le.intersectsObject(N))){const Pe=pe.update(N),Ke=N.material;if(ae&&(N.boundingSphere!==void 0?(N.boundingSphere===null&&N.computeBoundingSphere(),xe.copy(N.boundingSphere.center)):(Pe.boundingSphere===null&&Pe.computeBoundingSphere(),xe.copy(Pe.boundingSphere.center)),xe.applyMatrix4(N.matrixWorld).applyMatrix4(fe)),Array.isArray(Ke)){const je=Pe.groups;for(let ft=0,dt=je.length;ft<dt;ft++){const Je=je[ft],qt=Ke[Je.materialIndex];qt&&qt.visible&&g.push(N,Pe,qt,se,xe.z,Je)}}else Ke.visible&&g.push(N,Pe,Ke,se,xe.z,null)}}const Ee=N.children;for(let Pe=0,Ke=Ee.length;Pe<Ke;Pe++)Xm(Ee[Pe],Z,se,ae)}function My(N,Z,se,ae){const ee=N.opaque,Ee=N.transmissive,Pe=N.transparent;m.setupLightsView(se),H===!0&&we.setGlobalState(b.clippingPlanes,se),ae&&Oe.viewport(y.copy(ae)),ee.length>0&&vd(ee,Z,se),Ee.length>0&&vd(Ee,Z,se),Pe.length>0&&vd(Pe,Z,se),Oe.buffers.depth.setTest(!0),Oe.buffers.depth.setMask(!0),Oe.buffers.color.setMask(!0),Oe.setPolygonOffset(!1)}function Ry(N,Z,se,ae){if((se.isScene===!0?se.overrideMaterial:null)!==null)return;m.state.transmissionRenderTarget[ae.id]===void 0&&(m.state.transmissionRenderTarget[ae.id]=new So(1,1,{generateMipmaps:!0,type:qe.has("EXT_color_buffer_half_float")||qe.has("EXT_color_buffer_float")?Us:yi,minFilter:$s,samples:4,stencilBuffer:s,resolveDepthBuffer:!1,resolveStencilBuffer:!1,colorSpace:Lt.workingColorSpace}));const Ee=m.state.transmissionRenderTarget[ae.id],Pe=ae.viewport||y;Ee.setSize(Pe.z,Pe.w);const Ke=b.getRenderTarget();b.setRenderTarget(Ee),b.getClearColor(M),L=b.getClearAlpha(),L<1&&b.setClearColor(16777215,.5),b.clear(),Me&&ut.render(se);const je=b.toneMapping;b.toneMapping=Ta;const ft=ae.viewport;if(ae.viewport!==void 0&&(ae.viewport=void 0),m.setupLightsView(ae),H===!0&&we.setGlobalState(b.clippingPlanes,ae),vd(N,se,ae),P.updateMultisampleRenderTarget(Ee),P.updateRenderTargetMipmap(Ee),qe.has("WEBGL_multisampled_render_to_texture")===!1){let dt=!1;for(let Je=0,qt=Z.length;Je<qt;Je++){const an=Z[Je],vn=an.object,Kr=an.geometry,Vt=an.material,tt=an.group;if(Vt.side===$i&&vn.layers.test(ae.layers)){const Jn=Vt.side;Vt.side=Ir,Vt.needsUpdate=!0,Ny(vn,se,ae,Kr,Vt,tt),Vt.side=Jn,Vt.needsUpdate=!0,dt=!0}}dt===!0&&(P.updateMultisampleRenderTarget(Ee),P.updateRenderTargetMipmap(Ee))}b.setRenderTarget(Ke),b.setClearColor(M,L),ft!==void 0&&(ae.viewport=ft),b.toneMapping=je}function vd(N,Z,se){const ae=Z.isScene===!0?Z.overrideMaterial:null;for(let ee=0,Ee=N.length;ee<Ee;ee++){const Pe=N[ee],Ke=Pe.object,je=Pe.geometry,ft=ae===null?Pe.material:ae,dt=Pe.group;Ke.layers.test(se.layers)&&Ny(Ke,Z,se,je,ft,dt)}}function Ny(N,Z,se,ae,ee,Ee){N.onBeforeRender(b,Z,se,ae,ee,Ee),N.modelViewMatrix.multiplyMatrices(se.matrixWorldInverse,N.matrixWorld),N.normalMatrix.getNormalMatrix(N.modelViewMatrix),ee.onBeforeRender(b,Z,se,ae,N,Ee),ee.transparent===!0&&ee.side===$i&&ee.forceSinglePass===!1?(ee.side=Ir,ee.needsUpdate=!0,b.renderBufferDirect(se,Z,ae,ee,N,Ee),ee.side=Ws,ee.needsUpdate=!0,b.renderBufferDirect(se,Z,ae,ee,N,Ee),ee.side=$i):b.renderBufferDirect(se,Z,ae,ee,N,Ee),N.onAfterRender(b,Z,se,ae,ee,Ee)}function gd(N,Z,se){Z.isScene!==!0&&(Z=Se);const ae=rt.get(N),ee=m.state.lights,Ee=m.state.shadowsArray,Pe=ee.state.version,Ke=Be.getParameters(N,ee.state,Ee,Z,se),je=Be.getProgramCacheKey(Ke);let ft=ae.programs;ae.environment=N.isMeshStandardMaterial?Z.environment:null,ae.fog=Z.fog,ae.envMap=(N.isMeshStandardMaterial?ne:I).get(N.envMap||ae.environment),ae.envMapRotation=ae.environment!==null&&N.envMap===null?Z.environmentRotation:N.envMapRotation,ft===void 0&&(N.addEventListener("dispose",Dt),ft=new Map,ae.programs=ft);let dt=ft.get(je);if(dt!==void 0){if(ae.currentProgram===dt&&ae.lightsStateVersion===Pe)return Dy(N,Ke),dt}else Ke.uniforms=Be.getUniforms(N),N.onBeforeCompile(Ke,b),dt=Be.acquireProgram(Ke,je),ft.set(je,dt),ae.uniforms=Ke.uniforms;const Je=ae.uniforms;return(!N.isShaderMaterial&&!N.isRawShaderMaterial||N.clipping===!0)&&(Je.clippingPlanes=we.uniform),Dy(N,Ke),ae.needsLights=uR(N),ae.lightsStateVersion=Pe,ae.needsLights&&(Je.ambientLightColor.value=ee.state.ambient,Je.lightProbe.value=ee.state.probe,Je.directionalLights.value=ee.state.directional,Je.directionalLightShadows.value=ee.state.directionalShadow,Je.spotLights.value=ee.state.spot,Je.spotLightShadows.value=ee.state.spotShadow,Je.rectAreaLights.value=ee.state.rectArea,Je.ltc_1.value=ee.state.rectAreaLTC1,Je.ltc_2.value=ee.state.rectAreaLTC2,Je.pointLights.value=ee.state.point,Je.pointLightShadows.value=ee.state.pointShadow,Je.hemisphereLights.value=ee.state.hemi,Je.directionalShadowMap.value=ee.state.directionalShadowMap,Je.directionalShadowMatrix.value=ee.state.directionalShadowMatrix,Je.spotShadowMap.value=ee.state.spotShadowMap,Je.spotLightMatrix.value=ee.state.spotLightMatrix,Je.spotLightMap.value=ee.state.spotLightMap,Je.pointShadowMap.value=ee.state.pointShadowMap,Je.pointShadowMatrix.value=ee.state.pointShadowMatrix),ae.currentProgram=dt,ae.uniformsList=null,dt}function ky(N){if(N.uniformsList===null){const Z=N.currentProgram.getUniforms();N.uniformsList=gh.seqWithValue(Z.seq,N.uniforms)}return N.uniformsList}function Dy(N,Z){const se=rt.get(N);se.outputColorSpace=Z.outputColorSpace,se.batching=Z.batching,se.batchingColor=Z.batchingColor,se.instancing=Z.instancing,se.instancingColor=Z.instancingColor,se.instancingMorph=Z.instancingMorph,se.skinning=Z.skinning,se.morphTargets=Z.morphTargets,se.morphNormals=Z.morphNormals,se.morphColors=Z.morphColors,se.morphTargetsCount=Z.morphTargetsCount,se.numClippingPlanes=Z.numClippingPlanes,se.numIntersection=Z.numClipIntersection,se.vertexAlphas=Z.vertexAlphas,se.vertexTangents=Z.vertexTangents,se.toneMapping=Z.toneMapping}function cR(N,Z,se,ae,ee){Z.isScene!==!0&&(Z=Se),P.resetTextureUnits();const Ee=Z.fog,Pe=ae.isMeshStandardMaterial?Z.environment:null,Ke=S===null?b.outputColorSpace:S.isXRRenderTarget===!0?S.texture.colorSpace:rr,je=(ae.isMeshStandardMaterial?ne:I).get(ae.envMap||Pe),ft=ae.vertexColors===!0&&!!se.attributes.color&&se.attributes.color.itemSize===4,dt=!!se.attributes.tangent&&(!!ae.normalMap||ae.anisotropy>0),Je=!!se.morphAttributes.position,qt=!!se.morphAttributes.normal,an=!!se.morphAttributes.color;let vn=Ta;ae.toneMapped&&(S===null||S.isXRRenderTarget===!0)&&(vn=b.toneMapping);const Kr=se.morphAttributes.position||se.morphAttributes.normal||se.morphAttributes.color,Vt=Kr!==void 0?Kr.length:0,tt=rt.get(ae),Jn=m.state.lights;if(H===!0&&(q===!0||N!==C)){const si=N===C&&ae.id===T;we.setState(ae,N,si)}let Gt=!1;ae.version===tt.__version?(tt.needsLights&&tt.lightsStateVersion!==Jn.state.version||tt.outputColorSpace!==Ke||ee.isBatchedMesh&&tt.batching===!1||!ee.isBatchedMesh&&tt.batching===!0||ee.isBatchedMesh&&tt.batchingColor===!0&&ee.colorTexture===null||ee.isBatchedMesh&&tt.batchingColor===!1&&ee.colorTexture!==null||ee.isInstancedMesh&&tt.instancing===!1||!ee.isInstancedMesh&&tt.instancing===!0||ee.isSkinnedMesh&&tt.skinning===!1||!ee.isSkinnedMesh&&tt.skinning===!0||ee.isInstancedMesh&&tt.instancingColor===!0&&ee.instanceColor===null||ee.isInstancedMesh&&tt.instancingColor===!1&&ee.instanceColor!==null||ee.isInstancedMesh&&tt.instancingMorph===!0&&ee.morphTexture===null||ee.isInstancedMesh&&tt.instancingMorph===!1&&ee.morphTexture!==null||tt.envMap!==je||ae.fog===!0&&tt.fog!==Ee||tt.numClippingPlanes!==void 0&&(tt.numClippingPlanes!==we.numPlanes||tt.numIntersection!==we.numIntersection)||tt.vertexAlphas!==ft||tt.vertexTangents!==dt||tt.morphTargets!==Je||tt.morphNormals!==qt||tt.morphColors!==an||tt.toneMapping!==vn||tt.morphTargetsCount!==Vt)&&(Gt=!0):(Gt=!0,tt.__version=ae.version);let Ni=tt.currentProgram;Gt===!0&&(Ni=gd(ae,Z,ee));let nc=!1,jr=!1,Km=!1;const Sn=Ni.getUniforms(),ia=tt.uniforms;if(Oe.useProgram(Ni.program)&&(nc=!0,jr=!0,Km=!0),ae.id!==T&&(T=ae.id,jr=!0),nc||C!==N){Xe.reverseDepthBuffer?(oe.copy(N.projectionMatrix),wN(oe),EN(oe),Sn.setValue(B,"projectionMatrix",oe)):Sn.setValue(B,"projectionMatrix",N.projectionMatrix),Sn.setValue(B,"viewMatrix",N.matrixWorldInverse);const si=Sn.map.cameraPosition;si!==void 0&&si.setValue(B,_e.setFromMatrixPosition(N.matrixWorld)),Xe.logarithmicDepthBuffer&&Sn.setValue(B,"logDepthBufFC",2/(Math.log(N.far+1)/Math.LN2)),(ae.isMeshPhongMaterial||ae.isMeshToonMaterial||ae.isMeshLambertMaterial||ae.isMeshBasicMaterial||ae.isMeshStandardMaterial||ae.isShaderMaterial)&&Sn.setValue(B,"isOrthographic",N.isOrthographicCamera===!0),C!==N&&(C=N,jr=!0,Km=!0)}if(ee.isSkinnedMesh){Sn.setOptional(B,ee,"bindMatrix"),Sn.setOptional(B,ee,"bindMatrixInverse");const si=ee.skeleton;si&&(si.boneTexture===null&&si.computeBoneTexture(),Sn.setValue(B,"boneTexture",si.boneTexture,P))}ee.isBatchedMesh&&(Sn.setOptional(B,ee,"batchingTexture"),Sn.setValue(B,"batchingTexture",ee._matricesTexture,P),Sn.setOptional(B,ee,"batchingIdTexture"),Sn.setValue(B,"batchingIdTexture",ee._indirectTexture,P),Sn.setOptional(B,ee,"batchingColorTexture"),ee._colorsTexture!==null&&Sn.setValue(B,"batchingColorTexture",ee._colorsTexture,P));const jm=se.morphAttributes;if((jm.position!==void 0||jm.normal!==void 0||jm.color!==void 0)&&at.update(ee,se,Ni),(jr||tt.receiveShadow!==ee.receiveShadow)&&(tt.receiveShadow=ee.receiveShadow,Sn.setValue(B,"receiveShadow",ee.receiveShadow)),ae.isMeshGouraudMaterial&&ae.envMap!==null&&(ia.envMap.value=je,ia.flipEnvMap.value=je.isCubeTexture&&je.isRenderTargetTexture===!1?-1:1),ae.isMeshStandardMaterial&&ae.envMap===null&&Z.environment!==null&&(ia.envMapIntensity.value=Z.environmentIntensity),jr&&(Sn.setValue(B,"toneMappingExposure",b.toneMappingExposure),tt.needsLights&&lR(ia,Km),Ee&&ae.fog===!0&&Te.refreshFogUniforms(ia,Ee),Te.refreshMaterialUniforms(ia,ae,F,D,m.state.transmissionRenderTarget[N.id]),gh.upload(B,ky(tt),ia,P)),ae.isShaderMaterial&&ae.uniformsNeedUpdate===!0&&(gh.upload(B,ky(tt),ia,P),ae.uniformsNeedUpdate=!1),ae.isSpriteMaterial&&Sn.setValue(B,"center",ee.center),Sn.setValue(B,"modelViewMatrix",ee.modelViewMatrix),Sn.setValue(B,"normalMatrix",ee.normalMatrix),Sn.setValue(B,"modelMatrix",ee.matrixWorld),ae.isShaderMaterial||ae.isRawShaderMaterial){const si=ae.uniformsGroups;for(let Ym=0,fR=si.length;Ym<fR;Ym++){const Ly=si[Ym];K.update(Ly,Ni),K.bind(Ly,Ni)}}return Ni}function lR(N,Z){N.ambientLightColor.needsUpdate=Z,N.lightProbe.needsUpdate=Z,N.directionalLights.needsUpdate=Z,N.directionalLightShadows.needsUpdate=Z,N.pointLights.needsUpdate=Z,N.pointLightShadows.needsUpdate=Z,N.spotLights.needsUpdate=Z,N.spotLightShadows.needsUpdate=Z,N.rectAreaLights.needsUpdate=Z,N.hemisphereLights.needsUpdate=Z}function uR(N){return N.isMeshLambertMaterial||N.isMeshToonMaterial||N.isMeshPhongMaterial||N.isMeshStandardMaterial||N.isShadowMaterial||N.isShaderMaterial&&N.lights===!0}this.getActiveCubeFace=function(){return w},this.getActiveMipmapLevel=function(){return E},this.getRenderTarget=function(){return S},this.setRenderTargetTextures=function(N,Z,se){rt.get(N.texture).__webglTexture=Z,rt.get(N.depthTexture).__webglTexture=se;const ae=rt.get(N);ae.__hasExternalTextures=!0,ae.__autoAllocateDepthBuffer=se===void 0,ae.__autoAllocateDepthBuffer||qe.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),ae.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(N,Z){const se=rt.get(N);se.__webglFramebuffer=Z,se.__useDefaultFramebuffer=Z===void 0},this.setRenderTarget=function(N,Z=0,se=0){S=N,w=Z,E=se;let ae=!0,ee=null,Ee=!1,Pe=!1;if(N){const je=rt.get(N);if(je.__useDefaultFramebuffer!==void 0)Oe.bindFramebuffer(B.FRAMEBUFFER,null),ae=!1;else if(je.__webglFramebuffer===void 0)P.setupRenderTarget(N);else if(je.__hasExternalTextures)P.rebindTextures(N,rt.get(N.texture).__webglTexture,rt.get(N.depthTexture).__webglTexture);else if(N.depthBuffer){const Je=N.depthTexture;if(je.__boundDepthTexture!==Je){if(Je!==null&&rt.has(Je)&&(N.width!==Je.image.width||N.height!==Je.image.height))throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");P.setupDepthRenderbuffer(N)}}const ft=N.texture;(ft.isData3DTexture||ft.isDataArrayTexture||ft.isCompressedArrayTexture)&&(Pe=!0);const dt=rt.get(N).__webglFramebuffer;N.isWebGLCubeRenderTarget?(Array.isArray(dt[Z])?ee=dt[Z][se]:ee=dt[Z],Ee=!0):N.samples>0&&P.useMultisampledRTT(N)===!1?ee=rt.get(N).__webglMultisampledFramebuffer:Array.isArray(dt)?ee=dt[se]:ee=dt,y.copy(N.viewport),A.copy(N.scissor),k=N.scissorTest}else y.copy(J).multiplyScalar(F).floor(),A.copy(Q).multiplyScalar(F).floor(),k=de;if(Oe.bindFramebuffer(B.FRAMEBUFFER,ee)&&ae&&Oe.drawBuffers(N,ee),Oe.viewport(y),Oe.scissor(A),Oe.setScissorTest(k),Ee){const je=rt.get(N.texture);B.framebufferTexture2D(B.FRAMEBUFFER,B.COLOR_ATTACHMENT0,B.TEXTURE_CUBE_MAP_POSITIVE_X+Z,je.__webglTexture,se)}else if(Pe){const je=rt.get(N.texture),ft=Z||0;B.framebufferTextureLayer(B.FRAMEBUFFER,B.COLOR_ATTACHMENT0,je.__webglTexture,se||0,ft)}T=-1},this.readRenderTargetPixels=function(N,Z,se,ae,ee,Ee,Pe){if(!(N&&N.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Ke=rt.get(N).__webglFramebuffer;if(N.isWebGLCubeRenderTarget&&Pe!==void 0&&(Ke=Ke[Pe]),Ke){Oe.bindFramebuffer(B.FRAMEBUFFER,Ke);try{const je=N.texture,ft=je.format,dt=je.type;if(!Xe.textureFormatReadable(ft)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}if(!Xe.textureTypeReadable(dt)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}Z>=0&&Z<=N.width-ae&&se>=0&&se<=N.height-ee&&B.readPixels(Z,se,ae,ee,gt.convert(ft),gt.convert(dt),Ee)}finally{const je=S!==null?rt.get(S).__webglFramebuffer:null;Oe.bindFramebuffer(B.FRAMEBUFFER,je)}}},this.readRenderTargetPixelsAsync=async function(N,Z,se,ae,ee,Ee,Pe){if(!(N&&N.isWebGLRenderTarget))throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");let Ke=rt.get(N).__webglFramebuffer;if(N.isWebGLCubeRenderTarget&&Pe!==void 0&&(Ke=Ke[Pe]),Ke){const je=N.texture,ft=je.format,dt=je.type;if(!Xe.textureFormatReadable(ft))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");if(!Xe.textureTypeReadable(dt))throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");if(Z>=0&&Z<=N.width-ae&&se>=0&&se<=N.height-ee){Oe.bindFramebuffer(B.FRAMEBUFFER,Ke);const Je=B.createBuffer();B.bindBuffer(B.PIXEL_PACK_BUFFER,Je),B.bufferData(B.PIXEL_PACK_BUFFER,Ee.byteLength,B.STREAM_READ),B.readPixels(Z,se,ae,ee,gt.convert(ft),gt.convert(dt),0);const qt=S!==null?rt.get(S).__webglFramebuffer:null;Oe.bindFramebuffer(B.FRAMEBUFFER,qt);const an=B.fenceSync(B.SYNC_GPU_COMMANDS_COMPLETE,0);return B.flush(),await yN(B,an,4),B.bindBuffer(B.PIXEL_PACK_BUFFER,Je),B.getBufferSubData(B.PIXEL_PACK_BUFFER,0,Ee),B.deleteBuffer(Je),B.deleteSync(an),Ee}else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")}},this.copyFramebufferToTexture=function(N,Z=null,se=0){N.isTexture!==!0&&(vh("WebGLRenderer: copyFramebufferToTexture function signature has changed."),Z=arguments[0]||null,N=arguments[1]);const ae=Math.pow(2,-se),ee=Math.floor(N.image.width*ae),Ee=Math.floor(N.image.height*ae),Pe=Z!==null?Z.x:0,Ke=Z!==null?Z.y:0;P.setTexture2D(N,0),B.copyTexSubImage2D(B.TEXTURE_2D,se,0,0,Pe,Ke,ee,Ee),Oe.unbindTexture()},this.copyTextureToTexture=function(N,Z,se=null,ae=null,ee=0){N.isTexture!==!0&&(vh("WebGLRenderer: copyTextureToTexture function signature has changed."),ae=arguments[0]||null,N=arguments[1],Z=arguments[2],ee=arguments[3]||0,se=null);let Ee,Pe,Ke,je,ft,dt;se!==null?(Ee=se.max.x-se.min.x,Pe=se.max.y-se.min.y,Ke=se.min.x,je=se.min.y):(Ee=N.image.width,Pe=N.image.height,Ke=0,je=0),ae!==null?(ft=ae.x,dt=ae.y):(ft=0,dt=0);const Je=gt.convert(Z.format),qt=gt.convert(Z.type);P.setTexture2D(Z,0),B.pixelStorei(B.UNPACK_FLIP_Y_WEBGL,Z.flipY),B.pixelStorei(B.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Z.premultiplyAlpha),B.pixelStorei(B.UNPACK_ALIGNMENT,Z.unpackAlignment);const an=B.getParameter(B.UNPACK_ROW_LENGTH),vn=B.getParameter(B.UNPACK_IMAGE_HEIGHT),Kr=B.getParameter(B.UNPACK_SKIP_PIXELS),Vt=B.getParameter(B.UNPACK_SKIP_ROWS),tt=B.getParameter(B.UNPACK_SKIP_IMAGES),Jn=N.isCompressedTexture?N.mipmaps[ee]:N.image;B.pixelStorei(B.UNPACK_ROW_LENGTH,Jn.width),B.pixelStorei(B.UNPACK_IMAGE_HEIGHT,Jn.height),B.pixelStorei(B.UNPACK_SKIP_PIXELS,Ke),B.pixelStorei(B.UNPACK_SKIP_ROWS,je),N.isDataTexture?B.texSubImage2D(B.TEXTURE_2D,ee,ft,dt,Ee,Pe,Je,qt,Jn.data):N.isCompressedTexture?B.compressedTexSubImage2D(B.TEXTURE_2D,ee,ft,dt,Jn.width,Jn.height,Je,Jn.data):B.texSubImage2D(B.TEXTURE_2D,ee,ft,dt,Ee,Pe,Je,qt,Jn),B.pixelStorei(B.UNPACK_ROW_LENGTH,an),B.pixelStorei(B.UNPACK_IMAGE_HEIGHT,vn),B.pixelStorei(B.UNPACK_SKIP_PIXELS,Kr),B.pixelStorei(B.UNPACK_SKIP_ROWS,Vt),B.pixelStorei(B.UNPACK_SKIP_IMAGES,tt),ee===0&&Z.generateMipmaps&&B.generateMipmap(B.TEXTURE_2D),Oe.unbindTexture()},this.copyTextureToTexture3D=function(N,Z,se=null,ae=null,ee=0){N.isTexture!==!0&&(vh("WebGLRenderer: copyTextureToTexture3D function signature has changed."),se=arguments[0]||null,ae=arguments[1]||null,N=arguments[2],Z=arguments[3],ee=arguments[4]||0);let Ee,Pe,Ke,je,ft,dt,Je,qt,an;const vn=N.isCompressedTexture?N.mipmaps[ee]:N.image;se!==null?(Ee=se.max.x-se.min.x,Pe=se.max.y-se.min.y,Ke=se.max.z-se.min.z,je=se.min.x,ft=se.min.y,dt=se.min.z):(Ee=vn.width,Pe=vn.height,Ke=vn.depth,je=0,ft=0,dt=0),ae!==null?(Je=ae.x,qt=ae.y,an=ae.z):(Je=0,qt=0,an=0);const Kr=gt.convert(Z.format),Vt=gt.convert(Z.type);let tt;if(Z.isData3DTexture)P.setTexture3D(Z,0),tt=B.TEXTURE_3D;else if(Z.isDataArrayTexture||Z.isCompressedArrayTexture)P.setTexture2DArray(Z,0),tt=B.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}B.pixelStorei(B.UNPACK_FLIP_Y_WEBGL,Z.flipY),B.pixelStorei(B.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Z.premultiplyAlpha),B.pixelStorei(B.UNPACK_ALIGNMENT,Z.unpackAlignment);const Jn=B.getParameter(B.UNPACK_ROW_LENGTH),Gt=B.getParameter(B.UNPACK_IMAGE_HEIGHT),Ni=B.getParameter(B.UNPACK_SKIP_PIXELS),nc=B.getParameter(B.UNPACK_SKIP_ROWS),jr=B.getParameter(B.UNPACK_SKIP_IMAGES);B.pixelStorei(B.UNPACK_ROW_LENGTH,vn.width),B.pixelStorei(B.UNPACK_IMAGE_HEIGHT,vn.height),B.pixelStorei(B.UNPACK_SKIP_PIXELS,je),B.pixelStorei(B.UNPACK_SKIP_ROWS,ft),B.pixelStorei(B.UNPACK_SKIP_IMAGES,dt),N.isDataTexture||N.isData3DTexture?B.texSubImage3D(tt,ee,Je,qt,an,Ee,Pe,Ke,Kr,Vt,vn.data):Z.isCompressedArrayTexture?B.compressedTexSubImage3D(tt,ee,Je,qt,an,Ee,Pe,Ke,Kr,vn.data):B.texSubImage3D(tt,ee,Je,qt,an,Ee,Pe,Ke,Kr,Vt,vn),B.pixelStorei(B.UNPACK_ROW_LENGTH,Jn),B.pixelStorei(B.UNPACK_IMAGE_HEIGHT,Gt),B.pixelStorei(B.UNPACK_SKIP_PIXELS,Ni),B.pixelStorei(B.UNPACK_SKIP_ROWS,nc),B.pixelStorei(B.UNPACK_SKIP_IMAGES,jr),ee===0&&Z.generateMipmaps&&B.generateMipmap(tt),Oe.unbindTexture()},this.initRenderTarget=function(N){rt.get(N).__webglFramebuffer===void 0&&P.setupRenderTarget(N)},this.initTexture=function(N){N.isCubeTexture?P.setTextureCube(N,0):N.isData3DTexture?P.setTexture3D(N,0):N.isDataArrayTexture||N.isCompressedArrayTexture?P.setTexture2DArray(N,0):P.setTexture2D(N,0),Oe.unbindTexture()},this.resetState=function(){w=0,E=0,S=null,Oe.reset(),tn.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return Bs}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const t=this.getContext();t.drawingBufferColorSpace=e===n0?"display-p3":"srgb",t.unpackColorSpace=Lt.workingColorSpace===vp?"display-p3":"srgb"}}class DO extends mn{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new ms,this.environmentIntensity=1,this.environmentRotation=new ms,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,t){return super.copy(e,t),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const t=super.toJSON(e);return this.fog!==null&&(t.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(t.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(t.object.backgroundIntensity=this.backgroundIntensity),t.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(t.object.environmentIntensity=this.environmentIntensity),t.object.environmentRotation=this.environmentRotation.toArray(),t}}class LO{constructor(e,t){this.isInterleavedBuffer=!0,this.array=e,this.stride=t,this.count=e!==void 0?e.length/t:0,this.usage=Hg,this.updateRanges=[],this.version=0,this.uuid=Gi()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}setUsage(e){return this.usage=e,this}addUpdateRange(e,t){this.updateRanges.push({start:e,count:t})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,t,r){e*=this.stride,r*=t.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=t.array[r+i];return this}set(e,t=0){return this.array.set(e,t),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Gi()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const t=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),r=new this.constructor(t,this.stride);return r.setUsage(this.usage),r}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Gi()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _r=new $;class l0{constructor(e,t,r,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=t,this.offset=r,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let t=0,r=this.data.count;t<r;t++)_r.fromBufferAttribute(this,t),_r.applyMatrix4(e),this.setXYZ(t,_r.x,_r.y,_r.z);return this}applyNormalMatrix(e){for(let t=0,r=this.count;t<r;t++)_r.fromBufferAttribute(this,t),_r.applyNormalMatrix(e),this.setXYZ(t,_r.x,_r.y,_r.z);return this}transformDirection(e){for(let t=0,r=this.count;t<r;t++)_r.fromBufferAttribute(this,t),_r.transformDirection(e),this.setXYZ(t,_r.x,_r.y,_r.z);return this}getComponent(e,t){let r=this.array[e*this.data.stride+this.offset+t];return this.normalized&&(r=Ui(r,this.array)),r}setComponent(e,t,r){return this.normalized&&(r=Xt(r,this.array)),this.data.array[e*this.data.stride+this.offset+t]=r,this}setX(e,t){return this.normalized&&(t=Xt(t,this.array)),this.data.array[e*this.data.stride+this.offset]=t,this}setY(e,t){return this.normalized&&(t=Xt(t,this.array)),this.data.array[e*this.data.stride+this.offset+1]=t,this}setZ(e,t){return this.normalized&&(t=Xt(t,this.array)),this.data.array[e*this.data.stride+this.offset+2]=t,this}setW(e,t){return this.normalized&&(t=Xt(t,this.array)),this.data.array[e*this.data.stride+this.offset+3]=t,this}getX(e){let t=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(t=Ui(t,this.array)),t}getY(e){let t=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(t=Ui(t,this.array)),t}getZ(e){let t=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(t=Ui(t,this.array)),t}getW(e){let t=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(t=Ui(t,this.array)),t}setXY(e,t,r){return e=e*this.data.stride+this.offset,this.normalized&&(t=Xt(t,this.array),r=Xt(r,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this}setXYZ(e,t,r,i){return e=e*this.data.stride+this.offset,this.normalized&&(t=Xt(t,this.array),r=Xt(r,this.array),i=Xt(i,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=i,this}setXYZW(e,t,r,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(t=Xt(t,this.array),r=Xt(r,this.array),i=Xt(i,this.array),s=Xt(s,this.array)),this.data.array[e+0]=t,this.data.array[e+1]=r,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return new Mr(new this.array.constructor(t),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new l0(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const t=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)t.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:t,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}const k1=new $,D1=new Bt,L1=new Bt,OO=new $,O1=new lt,Fd=new $,Av=new ys,z1=new lt,Cv=new vl;class zO extends gr{constructor(e,t){super(e,t),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=$y,this.bindMatrix=new lt,this.bindMatrixInverse=new lt,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new Qs),this.boundingBox.makeEmpty();const t=e.getAttribute("position");for(let r=0;r<t.count;r++)this.getVertexPosition(r,Fd),this.boundingBox.expandByPoint(Fd)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new ys),this.boundingSphere.makeEmpty();const t=e.getAttribute("position");for(let r=0;r<t.count;r++)this.getVertexPosition(r,Fd),this.boundingSphere.expandByPoint(Fd)}copy(e,t){return super.copy(e,t),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,t){const r=this.material,i=this.matrixWorld;r!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Av.copy(this.boundingSphere),Av.applyMatrix4(i),e.ray.intersectsSphere(Av)!==!1&&(z1.copy(i).invert(),Cv.copy(e.ray).applyMatrix4(z1),!(this.boundingBox!==null&&Cv.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,t,Cv)))}getVertexPosition(e,t){return super.getVertexPosition(e,t),this.applyBoneTransform(e,t),t}bind(e,t){this.skeleton=e,t===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),t=this.matrixWorld),this.bindMatrix.copy(t),this.bindMatrixInverse.copy(t).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new Bt,t=this.geometry.attributes.skinWeight;for(let r=0,i=t.count;r<i;r++){e.fromBufferAttribute(t,r);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),t.setXYZW(r,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===$y?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===WR?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,t){const r=this.skeleton,i=this.geometry;D1.fromBufferAttribute(i.attributes.skinIndex,e),L1.fromBufferAttribute(i.attributes.skinWeight,e),k1.copy(t).applyMatrix4(this.bindMatrix),t.set(0,0,0);for(let s=0;s<4;s++){const a=L1.getComponent(s);if(a!==0){const o=D1.getComponent(s);O1.multiplyMatrices(r.bones[o].matrixWorld,r.boneInverses[o]),t.addScaledVector(OO.copy(k1).applyMatrix4(O1),a)}}return t.applyMatrix4(this.bindMatrixInverse)}}class AE extends mn{constructor(){super(),this.isBone=!0,this.type="Bone"}}class CE extends Vn{constructor(e=null,t=1,r=1,i,s,a,o,c,l=cn,u=cn,f,d){super(null,a,o,c,l,u,i,s,f,d),this.isDataTexture=!0,this.image={data:e,width:t,height:r},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const P1=new lt,PO=new lt;class u0{constructor(e=[],t=[]){this.uuid=Gi(),this.bones=e.slice(0),this.boneInverses=t,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,t=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),t.length===0)this.calculateInverses();else if(e.length!==t.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let r=0,i=this.bones.length;r<i;r++)this.boneInverses.push(new lt)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,t=this.bones.length;e<t;e++){const r=new lt;this.bones[e]&&r.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(r)}}pose(){for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];r&&r.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,t=this.bones.length;e<t;e++){const r=this.bones[e];r&&(r.parent&&r.parent.isBone?(r.matrix.copy(r.parent.matrixWorld).invert(),r.matrix.multiply(r.matrixWorld)):r.matrix.copy(r.matrixWorld),r.matrix.decompose(r.position,r.quaternion,r.scale))}}update(){const e=this.bones,t=this.boneInverses,r=this.boneMatrices,i=this.boneTexture;for(let s=0,a=e.length;s<a;s++){const o=e[s]?e[s].matrixWorld:PO;P1.multiplyMatrices(o,t[s]),P1.toArray(r,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new u0(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const t=new Float32Array(e*e*4);t.set(this.boneMatrices);const r=new CE(t,e,e,Jr,pi);return r.needsUpdate=!0,this.boneMatrices=t,this.boneTexture=r,this}getBoneByName(e){for(let t=0,r=this.bones.length;t<r;t++){const i=this.bones[t];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,t){this.uuid=e.uuid;for(let r=0,i=e.bones.length;r<i;r++){const s=e.bones[r];let a=t[s];a===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),a=new AE),this.bones.push(a),this.boneInverses.push(new lt().fromArray(e.boneInverses[r]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const t=this.bones,r=this.boneInverses;for(let i=0,s=t.length;i<s;i++){const a=t[i];e.bones.push(a.uuid);const o=r[i];e.boneInverses.push(o.toArray())}return e}}class Xg extends Mr{constructor(e,t,r,i=1){super(e,t,r),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const gc=new lt,F1=new lt,$d=[],$1=new Qs,FO=new lt,Ql=new gr,Jl=new ys;class $O extends gr{constructor(e,t,r){super(e,t),this.isInstancedMesh=!0,this.instanceMatrix=new Xg(new Float32Array(r*16),16),this.instanceColor=null,this.morphTexture=null,this.count=r,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<r;i++)this.setMatrixAt(i,FO)}computeBoundingBox(){const e=this.geometry,t=this.count;this.boundingBox===null&&(this.boundingBox=new Qs),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let r=0;r<t;r++)this.getMatrixAt(r,gc),$1.copy(e.boundingBox).applyMatrix4(gc),this.boundingBox.union($1)}computeBoundingSphere(){const e=this.geometry,t=this.count;this.boundingSphere===null&&(this.boundingSphere=new ys),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let r=0;r<t;r++)this.getMatrixAt(r,gc),Jl.copy(e.boundingSphere).applyMatrix4(gc),this.boundingSphere.union(Jl)}copy(e,t){return super.copy(e,t),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,t){t.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,t){t.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,t){const r=t.morphTargetInfluences,i=this.morphTexture.source.data.data,s=r.length+1,a=e*s+1;for(let o=0;o<r.length;o++)r[o]=i[a+o]}raycast(e,t){const r=this.matrixWorld,i=this.count;if(Ql.geometry=this.geometry,Ql.material=this.material,Ql.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Jl.copy(this.boundingSphere),Jl.applyMatrix4(r),e.ray.intersectsSphere(Jl)!==!1))for(let s=0;s<i;s++){this.getMatrixAt(s,gc),F1.multiplyMatrices(r,gc),Ql.matrixWorld=F1,Ql.raycast(e,$d);for(let a=0,o=$d.length;a<o;a++){const c=$d[a];c.instanceId=s,c.object=this,t.push(c)}$d.length=0}}setColorAt(e,t){this.instanceColor===null&&(this.instanceColor=new Xg(new Float32Array(this.instanceMatrix.count*3).fill(1),3)),t.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,t){t.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,t){const r=t.morphTargetInfluences,i=r.length+1;this.morphTexture===null&&(this.morphTexture=new CE(new Float32Array(i*this.count),i,this.count,mp,pi));const s=this.morphTexture.source.data.data;let a=0;for(let l=0;l<r.length;l++)a+=r[l];const o=this.geometry.morphTargetsRelative?1:1-a,c=i*e;s[c]=o,s.set(r,c+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}class IE extends cs{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new ht(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const Mh=new $,Rh=new $,U1=new lt,eu=new vl,Ud=new ys,Iv=new $,B1=new $;class f0 extends mn{constructor(e=new ws,t=new IE){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,r=[0];for(let i=1,s=t.count;i<s;i++)Mh.fromBufferAttribute(t,i-1),Rh.fromBufferAttribute(t,i),r[i]=r[i-1],r[i]+=Mh.distanceTo(Rh);e.setAttribute("lineDistance",new Gs(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,t){const r=this.geometry,i=this.matrixWorld,s=e.params.Line.threshold,a=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),Ud.copy(r.boundingSphere),Ud.applyMatrix4(i),Ud.radius+=s,e.ray.intersectsSphere(Ud)===!1)return;U1.copy(i).invert(),eu.copy(e.ray).applyMatrix4(U1);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),c=o*o,l=this.isLineSegments?2:1,u=r.index,d=r.attributes.position;if(u!==null){const h=Math.max(0,a.start),p=Math.min(u.count,a.start+a.count);for(let g=h,m=p-1;g<m;g+=l){const v=u.getX(g),x=u.getX(g+1),b=Bd(this,e,eu,c,v,x);b&&t.push(b)}if(this.isLineLoop){const g=u.getX(p-1),m=u.getX(h),v=Bd(this,e,eu,c,g,m);v&&t.push(v)}}else{const h=Math.max(0,a.start),p=Math.min(d.count,a.start+a.count);for(let g=h,m=p-1;g<m;g+=l){const v=Bd(this,e,eu,c,g,g+1);v&&t.push(v)}if(this.isLineLoop){const g=Bd(this,e,eu,c,p-1,h);g&&t.push(g)}}}updateMorphTargets(){const t=this.geometry.morphAttributes,r=Object.keys(t);if(r.length>0){const i=t[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}function Bd(n,e,t,r,i,s){const a=n.geometry.attributes.position;if(Mh.fromBufferAttribute(a,i),Rh.fromBufferAttribute(a,s),t.distanceSqToSegment(Mh,Rh,Iv,B1)>r)return;Iv.applyMatrix4(n.matrixWorld);const c=e.ray.origin.distanceTo(Iv);if(!(c<e.near||c>e.far))return{distance:c,point:B1.clone().applyMatrix4(n.matrixWorld),index:i,face:null,faceIndex:null,barycoord:null,object:n}}const V1=new $,G1=new $;class UO extends f0{constructor(e,t){super(e,t),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const t=e.attributes.position,r=[];for(let i=0,s=t.count;i<s;i+=2)V1.fromBufferAttribute(t,i),G1.fromBufferAttribute(t,i+1),r[i]=i===0?0:r[i-1],r[i+1]=r[i]+V1.distanceTo(G1);e.setAttribute("lineDistance",new Gs(r,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class BO extends f0{constructor(e,t){super(e,t),this.isLineLoop=!0,this.type="LineLoop"}}class ME extends cs{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new ht(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const H1=new lt,Kg=new vl,Vd=new ys,Gd=new $;class VO extends mn{constructor(e=new ws,t=new ME){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=t,this.updateMorphTargets()}copy(e,t){return super.copy(e,t),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,t){const r=this.geometry,i=this.matrixWorld,s=e.params.Points.threshold,a=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),Vd.copy(r.boundingSphere),Vd.applyMatrix4(i),Vd.radius+=s,e.ray.intersectsSphere(Vd)===!1)return;H1.copy(i).invert(),Kg.copy(e.ray).applyMatrix4(H1);const o=s/((this.scale.x+this.scale.y+this.scale.z)/3),c=o*o,l=r.index,f=r.attributes.position;if(l!==null){const d=Math.max(0,a.start),h=Math.min(l.count,a.start+a.count);for(let p=d,g=h;p<g;p++){const m=l.getX(p);Gd.fromBufferAttribute(f,m),W1(Gd,m,c,i,e,t,this)}}else{const d=Math.max(0,a.start),h=Math.min(f.count,a.start+a.count);for(let p=d,g=h;p<g;p++)Gd.fromBufferAttribute(f,p),W1(Gd,p,c,i,e,t,this)}}updateMorphTargets(){const t=this.geometry.morphAttributes,r=Object.keys(t);if(r.length>0){const i=t[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,a=i.length;s<a;s++){const o=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[o]=s}}}}}function W1(n,e,t,r,i,s,a){const o=Kg.distanceSqToPoint(n);if(o<t){const c=new $;Kg.closestPointToPoint(n,c),c.applyMatrix4(r);const l=i.ray.origin.distanceTo(c);if(l<i.near||l>i.far)return;s.push({distance:l,distanceToRay:Math.sqrt(o),point:c,index:e,face:null,faceIndex:null,barycoord:null,object:a})}}class d0 extends cs{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new ht(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new ht(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=lE,this.normalScale=new Ye(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new ms,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Es extends d0{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Ye(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return tr(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(t){this.ior=(1+.4*t)/(1-.4*t)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new ht(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new ht(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new ht(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get dispersion(){return this._dispersion}set dispersion(e){this._dispersion>0!=e>0&&this.version++,this._dispersion=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.dispersion=e.dispersion,this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}function Hd(n,e,t){return!n||!t&&n.constructor===e?n:typeof e.BYTES_PER_ELEMENT=="number"?new e(n):Array.prototype.slice.call(n)}function GO(n){return ArrayBuffer.isView(n)&&!(n instanceof DataView)}function HO(n){function e(i,s){return n[i]-n[s]}const t=n.length,r=new Array(t);for(let i=0;i!==t;++i)r[i]=i;return r.sort(e),r}function q1(n,e,t){const r=n.length,i=new n.constructor(r);for(let s=0,a=0;a!==r;++s){const o=t[s]*e;for(let c=0;c!==e;++c)i[a++]=n[o+c]}return i}function RE(n,e,t,r){let i=1,s=n[0];for(;s!==void 0&&s[r]===void 0;)s=n[i++];if(s===void 0)return;let a=s[r];if(a!==void 0)if(Array.isArray(a))do a=s[r],a!==void 0&&(e.push(s.time),t.push.apply(t,a)),s=n[i++];while(s!==void 0);else if(a.toArray!==void 0)do a=s[r],a!==void 0&&(e.push(s.time),a.toArray(t,t.length)),s=n[i++];while(s!==void 0);else do a=s[r],a!==void 0&&(e.push(s.time),t.push(a)),s=n[i++];while(s!==void 0)}class Vu{constructor(e,t,r,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new t.constructor(r),this.sampleValues=t,this.valueSize=r,this.settings=null,this.DefaultSettings_={}}evaluate(e){const t=this.parameterPositions;let r=this._cachedIndex,i=t[r],s=t[r-1];n:{e:{let a;t:{r:if(!(e<i)){for(let o=r+2;;){if(i===void 0){if(e<s)break r;return r=t.length,this._cachedIndex=r,this.copySampleValue_(r-1)}if(r===o)break;if(s=i,i=t[++r],e<i)break e}a=t.length;break t}if(!(e>=s)){const o=t[1];e<o&&(r=2,s=o);for(let c=r-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(r===c)break;if(i=s,s=t[--r-1],e>=s)break e}a=r,r=0;break t}break n}for(;r<a;){const o=r+a>>>1;e<t[o]?a=o:r=o+1}if(i=t[r],s=t[r-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return r=t.length,this._cachedIndex=r,this.copySampleValue_(r-1)}this._cachedIndex=r,this.intervalChanged_(r,s,i)}return this.interpolate_(r,s,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,i=this.valueSize,s=e*i;for(let a=0;a!==i;++a)t[a]=r[s+a];return t}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class WO extends Vu{constructor(e,t,r,i){super(e,t,r,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Uy,endingEnd:Uy}}intervalChanged_(e,t,r){const i=this.parameterPositions;let s=e-2,a=e+1,o=i[s],c=i[a];if(o===void 0)switch(this.getSettings_().endingStart){case By:s=e,o=2*t-r;break;case Vy:s=i.length-2,o=t+i[s]-i[s+1];break;default:s=e,o=r}if(c===void 0)switch(this.getSettings_().endingEnd){case By:a=e,c=2*r-t;break;case Vy:a=1,c=r+i[1]-i[0];break;default:a=e-1,c=t}const l=(r-t)*.5,u=this.valueSize;this._weightPrev=l/(t-o),this._weightNext=l/(c-r),this._offsetPrev=s*u,this._offsetNext=a*u}interpolate_(e,t,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,c=e*o,l=c-o,u=this._offsetPrev,f=this._offsetNext,d=this._weightPrev,h=this._weightNext,p=(r-t)/(i-t),g=p*p,m=g*p,v=-d*m+2*d*g-d*p,x=(1+d)*m+(-1.5-2*d)*g+(-.5+d)*p+1,b=(-1-h)*m+(1.5+h)*g+.5*p,_=h*m-h*g;for(let w=0;w!==o;++w)s[w]=v*a[u+w]+x*a[l+w]+b*a[c+w]+_*a[f+w];return s}}class qO extends Vu{constructor(e,t,r,i){super(e,t,r,i)}interpolate_(e,t,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,c=e*o,l=c-o,u=(r-t)/(i-t),f=1-u;for(let d=0;d!==o;++d)s[d]=a[l+d]*f+a[c+d]*u;return s}}class XO extends Vu{constructor(e,t,r,i){super(e,t,r,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class Ss{constructor(e,t,r,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(t===void 0||t.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Hd(t,this.TimeBufferType),this.values=Hd(r,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const t=e.constructor;let r;if(t.toJSON!==this.toJSON)r=t.toJSON(e);else{r={name:e.name,times:Hd(e.times,Array),values:Hd(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(r.interpolation=i)}return r.type=e.ValueTypeName,r}InterpolantFactoryMethodDiscrete(e){return new XO(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new qO(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new WO(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let t;switch(e){case _u:t=this.InterpolantFactoryMethodDiscrete;break;case yu:t=this.InterpolantFactoryMethodLinear;break;case Zm:t=this.InterpolantFactoryMethodSmooth;break}if(t===void 0){const r="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(r);return console.warn("THREE.KeyframeTrack:",r),this}return this.createInterpolant=t,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return _u;case this.InterpolantFactoryMethodLinear:return yu;case this.InterpolantFactoryMethodSmooth:return Zm}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const t=this.times;for(let r=0,i=t.length;r!==i;++r)t[r]+=e}return this}scale(e){if(e!==1){const t=this.times;for(let r=0,i=t.length;r!==i;++r)t[r]*=e}return this}trim(e,t){const r=this.times,i=r.length;let s=0,a=i-1;for(;s!==i&&r[s]<e;)++s;for(;a!==-1&&r[a]>t;)--a;if(++a,s!==0||a!==i){s>=a&&(a=Math.max(a,1),s=a-1);const o=this.getValueSize();this.times=r.slice(s,a),this.values=this.values.slice(s*o,a*o)}return this}validate(){let e=!0;const t=this.getValueSize();t-Math.floor(t)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const r=this.times,i=this.values,s=r.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let a=null;for(let o=0;o!==s;o++){const c=r[o];if(typeof c=="number"&&isNaN(c)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,o,c),e=!1;break}if(a!==null&&a>c){console.error("THREE.KeyframeTrack: Out of order keys.",this,o,c,a),e=!1;break}a=c}if(i!==void 0&&GO(i))for(let o=0,c=i.length;o!==c;++o){const l=i[o];if(isNaN(l)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,o,l),e=!1;break}}return e}optimize(){const e=this.times.slice(),t=this.values.slice(),r=this.getValueSize(),i=this.getInterpolation()===Zm,s=e.length-1;let a=1;for(let o=1;o<s;++o){let c=!1;const l=e[o],u=e[o+1];if(l!==u&&(o!==1||l!==e[0]))if(i)c=!0;else{const f=o*r,d=f-r,h=f+r;for(let p=0;p!==r;++p){const g=t[f+p];if(g!==t[d+p]||g!==t[h+p]){c=!0;break}}}if(c){if(o!==a){e[a]=e[o];const f=o*r,d=a*r;for(let h=0;h!==r;++h)t[d+h]=t[f+h]}++a}}if(s>0){e[a]=e[s];for(let o=s*r,c=a*r,l=0;l!==r;++l)t[c+l]=t[o+l];++a}return a!==e.length?(this.times=e.slice(0,a),this.values=t.slice(0,a*r)):(this.times=e,this.values=t),this}clone(){const e=this.times.slice(),t=this.values.slice(),r=this.constructor,i=new r(this.name,e,t);return i.createInterpolant=this.createInterpolant,i}}Ss.prototype.TimeBufferType=Float32Array;Ss.prototype.ValueBufferType=Float32Array;Ss.prototype.DefaultInterpolation=yu;class bl extends Ss{constructor(e,t,r){super(e,t,r)}}bl.prototype.ValueTypeName="bool";bl.prototype.ValueBufferType=Array;bl.prototype.DefaultInterpolation=_u;bl.prototype.InterpolantFactoryMethodLinear=void 0;bl.prototype.InterpolantFactoryMethodSmooth=void 0;class NE extends Ss{}NE.prototype.ValueTypeName="color";class Zc extends Ss{}Zc.prototype.ValueTypeName="number";class KO extends Vu{constructor(e,t,r,i){super(e,t,r,i)}interpolate_(e,t,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,c=(r-t)/(i-t);let l=e*o;for(let u=l+o;l!==u;l+=4)Xi.slerpFlat(s,0,a,l-o,a,l,c);return s}}class Qc extends Ss{InterpolantFactoryMethodLinear(e){return new KO(this.times,this.values,this.getValueSize(),e)}}Qc.prototype.ValueTypeName="quaternion";Qc.prototype.InterpolantFactoryMethodSmooth=void 0;class _l extends Ss{constructor(e,t,r){super(e,t,r)}}_l.prototype.ValueTypeName="string";_l.prototype.ValueBufferType=Array;_l.prototype.DefaultInterpolation=_u;_l.prototype.InterpolantFactoryMethodLinear=void 0;_l.prototype.InterpolantFactoryMethodSmooth=void 0;class Jc extends Ss{}Jc.prototype.ValueTypeName="vector";class jO{constructor(e="",t=-1,r=[],i=qR){this.name=e,this.tracks=r,this.duration=t,this.blendMode=i,this.uuid=Gi(),this.duration<0&&this.resetDuration()}static parse(e){const t=[],r=e.tracks,i=1/(e.fps||1);for(let a=0,o=r.length;a!==o;++a)t.push(ZO(r[a]).scale(i));const s=new this(e.name,e.duration,t,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const t=[],r=e.tracks,i={name:e.name,duration:e.duration,tracks:t,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,a=r.length;s!==a;++s)t.push(Ss.toJSON(r[s]));return i}static CreateFromMorphTargetSequence(e,t,r,i){const s=t.length,a=[];for(let o=0;o<s;o++){let c=[],l=[];c.push((o+s-1)%s,o,(o+1)%s),l.push(0,1,0);const u=HO(c);c=q1(c,1,u),l=q1(l,1,u),!i&&c[0]===0&&(c.push(s),l.push(l[0])),a.push(new Zc(".morphTargetInfluences["+t[o].name+"]",c,l).scale(1/r))}return new this(e,-1,a)}static findByName(e,t){let r=e;if(!Array.isArray(e)){const i=e;r=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<r.length;i++)if(r[i].name===t)return r[i];return null}static CreateClipsFromMorphTargetSequences(e,t,r){const i={},s=/^([\w-]*?)([\d]+)$/;for(let o=0,c=e.length;o<c;o++){const l=e[o],u=l.name.match(s);if(u&&u.length>1){const f=u[1];let d=i[f];d||(i[f]=d=[]),d.push(l)}}const a=[];for(const o in i)a.push(this.CreateFromMorphTargetSequence(o,i[o],t,r));return a}static parseAnimation(e,t){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const r=function(f,d,h,p,g){if(h.length!==0){const m=[],v=[];RE(h,m,v,p),m.length!==0&&g.push(new f(d,m,v))}},i=[],s=e.name||"default",a=e.fps||30,o=e.blendMode;let c=e.length||-1;const l=e.hierarchy||[];for(let f=0;f<l.length;f++){const d=l[f].keys;if(!(!d||d.length===0))if(d[0].morphTargets){const h={};let p;for(p=0;p<d.length;p++)if(d[p].morphTargets)for(let g=0;g<d[p].morphTargets.length;g++)h[d[p].morphTargets[g]]=-1;for(const g in h){const m=[],v=[];for(let x=0;x!==d[p].morphTargets.length;++x){const b=d[p];m.push(b.time),v.push(b.morphTarget===g?1:0)}i.push(new Zc(".morphTargetInfluence["+g+"]",m,v))}c=h.length*a}else{const h=".bones["+t[f].name+"]";r(Jc,h+".position",d,"pos",i),r(Qc,h+".quaternion",d,"rot",i),r(Jc,h+".scale",d,"scl",i)}}return i.length===0?null:new this(s,c,i,o)}resetDuration(){const e=this.tracks;let t=0;for(let r=0,i=e.length;r!==i;++r){const s=this.tracks[r];t=Math.max(t,s.times[s.times.length-1])}return this.duration=t,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let t=0;t<this.tracks.length;t++)e=e&&this.tracks[t].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let t=0;t<this.tracks.length;t++)e.push(this.tracks[t].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function YO(n){switch(n.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Zc;case"vector":case"vector2":case"vector3":case"vector4":return Jc;case"color":return NE;case"quaternion":return Qc;case"bool":case"boolean":return bl;case"string":return _l}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+n)}function ZO(n){if(n.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=YO(n.type);if(n.times===void 0){const t=[],r=[];RE(n.keys,t,r,"value"),n.times=t,n.values=r}return e.parse!==void 0?e.parse(n):new e(n.name,n.times,n.values,n.interpolation)}const ba={enabled:!1,files:{},add:function(n,e){this.enabled!==!1&&(this.files[n]=e)},get:function(n){if(this.enabled!==!1)return this.files[n]},remove:function(n){delete this.files[n]},clear:function(){this.files={}}};class QO{constructor(e,t,r){const i=this;let s=!1,a=0,o=0,c;const l=[];this.onStart=void 0,this.onLoad=e,this.onProgress=t,this.onError=r,this.itemStart=function(u){o++,s===!1&&i.onStart!==void 0&&i.onStart(u,a,o),s=!0},this.itemEnd=function(u){a++,i.onProgress!==void 0&&i.onProgress(u,a,o),a===o&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return c?c(u):u},this.setURLModifier=function(u){return c=u,this},this.addHandler=function(u,f){return l.push(u,f),this},this.removeHandler=function(u){const f=l.indexOf(u);return f!==-1&&l.splice(f,2),this},this.getHandler=function(u){for(let f=0,d=l.length;f<d;f+=2){const h=l[f],p=l[f+1];if(h.global&&(h.lastIndex=0),h.test(u))return p}return null}}}const JO=new QO;class Fa{constructor(e){this.manager=e!==void 0?e:JO,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,t){const r=this;return new Promise(function(i,s){r.load(e,i,t,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}Fa.DEFAULT_MATERIAL_NAME="__DEFAULT";const ks={};class ez extends Error{constructor(e,t){super(e),this.response=t}}class h0 extends Fa{constructor(e){super(e)}load(e,t,r,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=ba.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{t&&t(s),this.manager.itemEnd(e)},0),s;if(ks[e]!==void 0){ks[e].push({onLoad:t,onProgress:r,onError:i});return}ks[e]=[],ks[e].push({onLoad:t,onProgress:r,onError:i});const a=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),o=this.mimeType,c=this.responseType;fetch(a).then(l=>{if(l.status===200||l.status===0){if(l.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||l.body===void 0||l.body.getReader===void 0)return l;const u=ks[e],f=l.body.getReader(),d=l.headers.get("X-File-Size")||l.headers.get("Content-Length"),h=d?parseInt(d):0,p=h!==0;let g=0;const m=new ReadableStream({start(v){x();function x(){f.read().then(({done:b,value:_})=>{if(b)v.close();else{g+=_.byteLength;const w=new ProgressEvent("progress",{lengthComputable:p,loaded:g,total:h});for(let E=0,S=u.length;E<S;E++){const T=u[E];T.onProgress&&T.onProgress(w)}v.enqueue(_),x()}},b=>{v.error(b)})}}});return new Response(m)}else throw new ez(`fetch for "${l.url}" responded with ${l.status}: ${l.statusText}`,l)}).then(l=>{switch(c){case"arraybuffer":return l.arrayBuffer();case"blob":return l.blob();case"document":return l.text().then(u=>new DOMParser().parseFromString(u,o));case"json":return l.json();default:if(o===void 0)return l.text();{const f=/charset="?([^;"\s]*)"?/i.exec(o),d=f&&f[1]?f[1].toLowerCase():void 0,h=new TextDecoder(d);return l.arrayBuffer().then(p=>h.decode(p))}}}).then(l=>{ba.add(e,l);const u=ks[e];delete ks[e];for(let f=0,d=u.length;f<d;f++){const h=u[f];h.onLoad&&h.onLoad(l)}}).catch(l=>{const u=ks[e];if(u===void 0)throw this.manager.itemError(e),l;delete ks[e];for(let f=0,d=u.length;f<d;f++){const h=u[f];h.onError&&h.onError(l)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class kE extends Fa{constructor(e){super(e)}load(e,t,r,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=ba.get(e);if(a!==void 0)return s.manager.itemStart(e),setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a;const o=wu("img");function c(){u(),ba.add(e,this),t&&t(this),s.manager.itemEnd(e)}function l(f){u(),i&&i(f),s.manager.itemError(e),s.manager.itemEnd(e)}function u(){o.removeEventListener("load",c,!1),o.removeEventListener("error",l,!1)}return o.addEventListener("load",c,!1),o.addEventListener("error",l,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(o.crossOrigin=this.crossOrigin),s.manager.itemStart(e),o.src=e,o}}class tz extends Fa{constructor(e){super(e)}load(e,t,r,i){const s=new s0;s.colorSpace=Xn;const a=new kE(this.manager);a.setCrossOrigin(this.crossOrigin),a.setPath(this.path);let o=0;function c(l){a.load(e[l],function(u){s.images[l]=u,o++,o===6&&(s.needsUpdate=!0,t&&t(s))},void 0,i)}for(let l=0;l<e.length;++l)c(l);return s}}class DE extends Fa{constructor(e){super(e)}load(e,t,r,i){const s=new Vn,a=new kE(this.manager);return a.setCrossOrigin(this.crossOrigin),a.setPath(this.path),a.load(e,function(o){s.image=o,s.needsUpdate=!0,t!==void 0&&t(s)},r,i),s}}class p0 extends mn{constructor(e,t=1){super(),this.isLight=!0,this.type="Light",this.color=new ht(e),this.intensity=t}dispose(){}copy(e,t){return super.copy(e,t),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const t=super.toJSON(e);return t.object.color=this.color.getHex(),t.object.intensity=this.intensity,this.groundColor!==void 0&&(t.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(t.object.distance=this.distance),this.angle!==void 0&&(t.object.angle=this.angle),this.decay!==void 0&&(t.object.decay=this.decay),this.penumbra!==void 0&&(t.object.penumbra=this.penumbra),this.shadow!==void 0&&(t.object.shadow=this.shadow.toJSON()),this.target!==void 0&&(t.object.target=this.target.uuid),t}}const Mv=new lt,X1=new $,K1=new $;class m0{constructor(e){this.camera=e,this.intensity=1,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Ye(512,512),this.map=null,this.mapPass=null,this.matrix=new lt,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new a0,this._frameExtents=new Ye(1,1),this._viewportCount=1,this._viewports=[new Bt(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const t=this.camera,r=this.matrix;X1.setFromMatrixPosition(e.matrixWorld),t.position.copy(X1),K1.setFromMatrixPosition(e.target.matrixWorld),t.lookAt(K1),t.updateMatrixWorld(),Mv.multiplyMatrices(t.projectionMatrix,t.matrixWorldInverse),this._frustum.setFromProjectionMatrix(Mv),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(Mv)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.intensity=e.intensity,this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.intensity!==1&&(e.intensity=this.intensity),this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class nz extends m0{constructor(){super(new Er(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const t=this.camera,r=jc*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=e.distance||t.far;(r!==t.fov||i!==t.aspect||s!==t.far)&&(t.fov=r,t.aspect=i,t.far=s,t.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class rz extends p0{constructor(e,t,r=0,i=Math.PI/3,s=0,a=2){super(e,t),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(mn.DEFAULT_UP),this.updateMatrix(),this.target=new mn,this.distance=r,this.angle=i,this.penumbra=s,this.decay=a,this.map=null,this.shadow=new nz}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const j1=new lt,tu=new $,Rv=new $;class iz extends m0{constructor(){super(new Er(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Ye(4,2),this._viewportCount=6,this._viewports=[new Bt(2,1,1,1),new Bt(0,1,1,1),new Bt(3,1,1,1),new Bt(1,1,1,1),new Bt(3,0,1,1),new Bt(1,0,1,1)],this._cubeDirections=[new $(1,0,0),new $(-1,0,0),new $(0,0,1),new $(0,0,-1),new $(0,1,0),new $(0,-1,0)],this._cubeUps=[new $(0,1,0),new $(0,1,0),new $(0,1,0),new $(0,1,0),new $(0,0,1),new $(0,0,-1)]}updateMatrices(e,t=0){const r=this.camera,i=this.matrix,s=e.distance||r.far;s!==r.far&&(r.far=s,r.updateProjectionMatrix()),tu.setFromMatrixPosition(e.matrixWorld),r.position.copy(tu),Rv.copy(r.position),Rv.add(this._cubeDirections[t]),r.up.copy(this._cubeUps[t]),r.lookAt(Rv),r.updateMatrixWorld(),i.makeTranslation(-tu.x,-tu.y,-tu.z),j1.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix(j1)}}class sz extends p0{constructor(e,t,r=0,i=2){super(e,t),this.isPointLight=!0,this.type="PointLight",this.distance=r,this.decay=i,this.shadow=new iz}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,t){return super.copy(e,t),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class az extends m0{constructor(){super(new o0(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class oz extends p0{constructor(e,t){super(e,t),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(mn.DEFAULT_UP),this.updateMatrix(),this.target=new mn,this.shadow=new az}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class gu{static decodeText(e){if(console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),typeof TextDecoder<"u")return new TextDecoder().decode(e);let t="";for(let r=0,i=e.length;r<i;r++)t+=String.fromCharCode(e[r]);try{return decodeURIComponent(escape(t))}catch{return t}}static extractUrlBase(e){const t=e.lastIndexOf("/");return t===-1?"./":e.slice(0,t+1)}static resolveURL(e,t){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(t)&&/^\//.test(e)&&(t=t.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:t+e)}}class cz extends Fa{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,t,r,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,a=ba.get(e);if(a!==void 0){if(s.manager.itemStart(e),a.then){a.then(l=>{t&&t(l),s.manager.itemEnd(e)}).catch(l=>{i&&i(l)});return}return setTimeout(function(){t&&t(a),s.manager.itemEnd(e)},0),a}const o={};o.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",o.headers=this.requestHeader;const c=fetch(e,o).then(function(l){return l.blob()}).then(function(l){return createImageBitmap(l,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(l){return ba.add(e,l),t&&t(l),s.manager.itemEnd(e),l}).catch(function(l){i&&i(l),ba.remove(e),s.manager.itemError(e),s.manager.itemEnd(e)});ba.add(e,c),s.manager.itemStart(e)}}const v0="\\[\\]\\.:\\/",lz=new RegExp("["+v0+"]","g"),g0="[^"+v0+"]",uz="[^"+v0.replace("\\.","")+"]",fz=/((?:WC+[\/:])*)/.source.replace("WC",g0),dz=/(WCOD+)?/.source.replace("WCOD",uz),hz=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",g0),pz=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",g0),mz=new RegExp("^"+fz+dz+hz+pz+"$"),vz=["material","materials","bones","map"];class gz{constructor(e,t,r){const i=r||Kt.parseTrackName(t);this._targetGroup=e,this._bindings=e.subscribe_(t,i)}getValue(e,t){this.bind();const r=this._targetGroup.nCachedObjects_,i=this._bindings[r];i!==void 0&&i.getValue(e,t)}setValue(e,t){const r=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=r.length;i!==s;++i)r[i].setValue(e,t)}bind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,r=e.length;t!==r;++t)e[t].bind()}unbind(){const e=this._bindings;for(let t=this._targetGroup.nCachedObjects_,r=e.length;t!==r;++t)e[t].unbind()}}class Kt{constructor(e,t,r){this.path=t,this.parsedPath=r||Kt.parseTrackName(t),this.node=Kt.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,t,r){return e&&e.isAnimationObjectGroup?new Kt.Composite(e,t,r):new Kt(e,t,r)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(lz,"")}static parseTrackName(e){const t=mz.exec(e);if(t===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const r={nodeName:t[2],objectName:t[3],objectIndex:t[4],propertyName:t[5],propertyIndex:t[6]},i=r.nodeName&&r.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=r.nodeName.substring(i+1);vz.indexOf(s)!==-1&&(r.nodeName=r.nodeName.substring(0,i),r.objectName=s)}if(r.propertyName===null||r.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return r}static findNode(e,t){if(t===void 0||t===""||t==="."||t===-1||t===e.name||t===e.uuid)return e;if(e.skeleton){const r=e.skeleton.getBoneByName(t);if(r!==void 0)return r}if(e.children){const r=function(s){for(let a=0;a<s.length;a++){const o=s[a];if(o.name===t||o.uuid===t)return o;const c=r(o.children);if(c)return c}return null},i=r(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,t){e[t]=this.targetObject[this.propertyName]}_getValue_array(e,t){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)e[t++]=r[i]}_getValue_arrayElement(e,t){e[t]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,t){this.resolvedProperty.toArray(e,t)}_setValue_direct(e,t){this.targetObject[this.propertyName]=e[t]}_setValue_direct_setNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,t){this.targetObject[this.propertyName]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,t){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[t++]}_setValue_array_setNeedsUpdate(e,t){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[t++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,t){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[t++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,t){this.resolvedProperty[this.propertyIndex]=e[t]}_setValue_arrayElement_setNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty[this.propertyIndex]=e[t],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,t){this.resolvedProperty.fromArray(e,t)}_setValue_fromArray_setNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,t){this.resolvedProperty.fromArray(e,t),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,t){this.bind(),this.getValue(e,t)}_setValue_unbound(e,t){this.bind(),this.setValue(e,t)}bind(){let e=this.node;const t=this.parsedPath,r=t.objectName,i=t.propertyName;let s=t.propertyIndex;if(e||(e=Kt.findNode(this.rootNode,t.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(r){let l=t.objectIndex;switch(r){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===l){l=u;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[r]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[r]}if(l!==void 0){if(e[l]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[l]}}const a=e[i];if(a===void 0){const l=t.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+l+"."+i+" but it wasn't found.",e);return}let o=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?o=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(o=this.Versioning.MatrixWorldNeedsUpdate);let c=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}c=this.BindingType.ArrayElement,this.resolvedProperty=a,this.propertyIndex=s}else a.fromArray!==void 0&&a.toArray!==void 0?(c=this.BindingType.HasFromToArray,this.resolvedProperty=a):Array.isArray(a)?(c=this.BindingType.EntireArray,this.resolvedProperty=a):this.propertyName=i;this.getValue=this.GetterByBindingType[c],this.setValue=this.SetterByBindingTypeAndVersioning[c][o]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Kt.Composite=gz;Kt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Kt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Kt.prototype.GetterByBindingType=[Kt.prototype._getValue_direct,Kt.prototype._getValue_array,Kt.prototype._getValue_arrayElement,Kt.prototype._getValue_toArray];Kt.prototype.SetterByBindingTypeAndVersioning=[[Kt.prototype._setValue_direct,Kt.prototype._setValue_direct_setNeedsUpdate,Kt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Kt.prototype._setValue_array,Kt.prototype._setValue_array_setNeedsUpdate,Kt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Kt.prototype._setValue_arrayElement,Kt.prototype._setValue_arrayElement_setNeedsUpdate,Kt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Kt.prototype._setValue_fromArray,Kt.prototype._setValue_fromArray_setNeedsUpdate,Kt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class ui{constructor(e){this.value=e}clone(){return new ui(this.value.clone===void 0?this.value:this.value.clone())}}const Y1=new lt;class xz{constructor(e,t,r=0,i=1/0){this.ray=new vl(e,t),this.near=r,this.far=i,this.camera=null,this.layers=new i0,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,t){this.ray.set(e,t)}setFromCamera(e,t){t.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(t.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(t).sub(this.ray.origin).normalize(),this.camera=t):t.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(t.near+t.far)/(t.near-t.far)).unproject(t),this.ray.direction.set(0,0,-1).transformDirection(t.matrixWorld),this.camera=t):console.error("THREE.Raycaster: Unsupported camera type: "+t.type)}setFromXRController(e){return Y1.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(Y1),this}intersectObject(e,t=!0,r=[]){return jg(e,this,r,t),r.sort(Z1),r}intersectObjects(e,t=!0,r=[]){for(let i=0,s=e.length;i<s;i++)jg(e[i],this,r,t);return r.sort(Z1),r}}function Z1(n,e){return n.distance-e.distance}function jg(n,e,t,r){let i=!0;if(n.layers.test(e.layers)&&n.raycast(e,t)===!1&&(i=!1),i===!0&&r===!0){const s=n.children;for(let a=0,o=s.length;a<o;a++)jg(s[a],e,t,!0)}}class Q1{constructor(e=1,t=0,r=0){return this.radius=e,this.phi=t,this.theta=r,this}set(e,t,r){return this.radius=e,this.phi=t,this.theta=r,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,t,r){return this.radius=Math.sqrt(e*e+t*t+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(tr(t/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class LE extends Bo{constructor(e,t=null){super(),this.object=e,this.domElement=t,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(){}disconnect(){}dispose(){}update(){}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:jx}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=jx);class Js{constructor(){this.callbacks={},this.callbacks.base={}}on(e,t){return typeof e>"u"||e===""?(console.warn("wrong names"),!1):typeof t>"u"?(console.warn("wrong callback"),!1):(this.resolveNames(e).forEach(i=>{const s=this.resolveName(i);this.callbacks[s.namespace]instanceof Object||(this.callbacks[s.namespace]={}),this.callbacks[s.namespace][s.value]instanceof Array||(this.callbacks[s.namespace][s.value]=[]),this.callbacks[s.namespace][s.value].push(t)}),this)}off(e){return typeof e>"u"||e===""?(console.warn("wrong name"),!1):(this.resolveNames(e).forEach(r=>{const i=this.resolveName(r);if(i.namespace!=="base"&&i.value==="")delete this.callbacks[i.namespace];else if(i.namespace==="base")for(const s in this.callbacks)this.callbacks[s]instanceof Object&&this.callbacks[s][i.value]instanceof Array&&(delete this.callbacks[s][i.value],Object.keys(this.callbacks[s]).length===0&&delete this.callbacks[s]);else this.callbacks[i.namespace]instanceof Object&&this.callbacks[i.namespace][i.value]instanceof Array&&(delete this.callbacks[i.namespace][i.value],Object.keys(this.callbacks[i.namespace]).length===0&&delete this.callbacks[i.namespace])}),this)}trigger(e,t){if(typeof e>"u"||e==="")return console.warn("wrong name"),!1;let r=null;const i=t instanceof Array?t:[];let s=this.resolveNames(e);if(s=this.resolveName(s[0]),s.namespace==="base")for(const a in this.callbacks)this.callbacks[a]instanceof Object&&this.callbacks[a][s.value]instanceof Array&&this.callbacks[a][s.value].forEach(function(o){o.apply(this,i)});else if(this.callbacks[s.namespace]instanceof Object){if(s.value==="")return console.warn("wrong name"),this;this.callbacks[s.namespace][s.value].forEach(function(a){a.apply(this,i)})}return r}resolveNames(e){let t=e;return t=t.replace(/[^a-zA-Z0-9 ,/.]/g,""),t=t.replace(/[,/]+/g," "),t=t.split(" "),t}resolveName(e){const t={},r=e.split(".");return t.original=e,t.value=r[0],t.namespace="base",r.length>1&&r[1]!==""&&(t.namespace=r[1]),t}}const Nc=class Nc extends Js{constructor(){super(),this.settings={blockSize:4,downscaleFactor:.5,isosurfaceValue:.69,interpolationMethod:"trilinear",skippingMethod:"anisotropicDistanceMap",skippingEnabled:!0,debugEnabled:!0,statsEnabled:!0,discardingEnabled:!0}}set(e,t){if(e==="InterpolationMethod"&&!Nc.InterpolationMethods.includes(t)){console.warn(`Invalid InterpolationMethod: "${t}"`);return}if(e==="SkippingMethod"&&!Nc.SkippingMethods.includes(t)){console.warn(`Invalid SkippingMethod: "${t}"`);return}if(e in this.settings){const r=this.settings[e];this.settings[e]=t,this.trigger("change",{key:e,oldValue:r,newValue:t})}else console.warn(`Unknown config key: "${e}"`)}get(e){return e in this.settings?this.settings[e]:null}destroy(){this.settings=null,console.log("Config destroyed")}};re(Nc,"InterpolationMethods",["trilinear","tricubic"]),re(Nc,"SkippingMethods",["occupancyMap","isotropicDistanceMap","anisotropicDistanceMap","extendedDistanceMap"]);let Yg=Nc;/**
 * lil-gui
 * https://lil-gui.georgealways.com
 * @version 0.19.2
 * @author George Michael Brower
 * @license MIT
 */class ls{constructor(e,t,r,i,s="div"){this.parent=e,this.object=t,this.property=r,this._disabled=!1,this._hidden=!1,this.initialValue=this.getValue(),this.domElement=document.createElement(s),this.domElement.classList.add("controller"),this.domElement.classList.add(i),this.$name=document.createElement("div"),this.$name.classList.add("name"),ls.nextNameID=ls.nextNameID||0,this.$name.id=`lil-gui-name-${++ls.nextNameID}`,this.$widget=document.createElement("div"),this.$widget.classList.add("widget"),this.$disable=this.$widget,this.domElement.appendChild(this.$name),this.domElement.appendChild(this.$widget),this.domElement.addEventListener("keydown",a=>a.stopPropagation()),this.domElement.addEventListener("keyup",a=>a.stopPropagation()),this.parent.children.push(this),this.parent.controllers.push(this),this.parent.$children.appendChild(this.domElement),this._listenCallback=this._listenCallback.bind(this),this.name(r)}name(e){return this._name=e,this.$name.textContent=e,this}onChange(e){return this._onChange=e,this}_callOnChange(){this.parent._callOnChange(this),this._onChange!==void 0&&this._onChange.call(this,this.getValue()),this._changed=!0}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(){this._changed&&(this.parent._callOnFinishChange(this),this._onFinishChange!==void 0&&this._onFinishChange.call(this,this.getValue())),this._changed=!1}reset(){return this.setValue(this.initialValue),this._callOnFinishChange(),this}enable(e=!0){return this.disable(!e)}disable(e=!0){return e===this._disabled?this:(this._disabled=e,this.domElement.classList.toggle("disabled",e),this.$disable.toggleAttribute("disabled",e),this)}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}options(e){const t=this.parent.add(this.object,this.property,e);return t.name(this._name),this.destroy(),t}min(e){return this}max(e){return this}step(e){return this}decimals(e){return this}listen(e=!0){return this._listening=e,this._listenCallbackID!==void 0&&(cancelAnimationFrame(this._listenCallbackID),this._listenCallbackID=void 0),this._listening&&this._listenCallback(),this}_listenCallback(){this._listenCallbackID=requestAnimationFrame(this._listenCallback);const e=this.save();e!==this._listenPrevValue&&this.updateDisplay(),this._listenPrevValue=e}getValue(){return this.object[this.property]}setValue(e){return this.getValue()!==e&&(this.object[this.property]=e,this._callOnChange(),this.updateDisplay()),this}updateDisplay(){return this}load(e){return this.setValue(e),this._callOnFinishChange(),this}save(){return this.getValue()}destroy(){this.listen(!1),this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.controllers.splice(this.parent.controllers.indexOf(this),1),this.parent.$children.removeChild(this.domElement)}}class bz extends ls{constructor(e,t,r){super(e,t,r,"boolean","label"),this.$input=document.createElement("input"),this.$input.setAttribute("type","checkbox"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$widget.appendChild(this.$input),this.$input.addEventListener("change",()=>{this.setValue(this.$input.checked),this._callOnFinishChange()}),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.checked=this.getValue(),this}}function Zg(n){let e,t;return(e=n.match(/(#|0x)?([a-f0-9]{6})/i))?t=e[2]:(e=n.match(/rgb\(\s*(\d*)\s*,\s*(\d*)\s*,\s*(\d*)\s*\)/))?t=parseInt(e[1]).toString(16).padStart(2,0)+parseInt(e[2]).toString(16).padStart(2,0)+parseInt(e[3]).toString(16).padStart(2,0):(e=n.match(/^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i))&&(t=e[1]+e[1]+e[2]+e[2]+e[3]+e[3]),t?"#"+t:!1}const _z={isPrimitive:!0,match:n=>typeof n=="string",fromHexString:Zg,toHexString:Zg},Eu={isPrimitive:!0,match:n=>typeof n=="number",fromHexString:n=>parseInt(n.substring(1),16),toHexString:n=>"#"+n.toString(16).padStart(6,0)},yz={isPrimitive:!1,match:n=>Array.isArray(n),fromHexString(n,e,t=1){const r=Eu.fromHexString(n);e[0]=(r>>16&255)/255*t,e[1]=(r>>8&255)/255*t,e[2]=(r&255)/255*t},toHexString([n,e,t],r=1){r=255/r;const i=n*r<<16^e*r<<8^t*r<<0;return Eu.toHexString(i)}},wz={isPrimitive:!1,match:n=>Object(n)===n,fromHexString(n,e,t=1){const r=Eu.fromHexString(n);e.r=(r>>16&255)/255*t,e.g=(r>>8&255)/255*t,e.b=(r&255)/255*t},toHexString({r:n,g:e,b:t},r=1){r=255/r;const i=n*r<<16^e*r<<8^t*r<<0;return Eu.toHexString(i)}},Ez=[_z,Eu,yz,wz];function Sz(n){return Ez.find(e=>e.match(n))}class Tz extends ls{constructor(e,t,r,i){super(e,t,r,"color"),this.$input=document.createElement("input"),this.$input.setAttribute("type","color"),this.$input.setAttribute("tabindex",-1),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$text=document.createElement("input"),this.$text.setAttribute("type","text"),this.$text.setAttribute("spellcheck","false"),this.$text.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$display.appendChild(this.$input),this.$widget.appendChild(this.$display),this.$widget.appendChild(this.$text),this._format=Sz(this.initialValue),this._rgbScale=i,this._initialValueHexString=this.save(),this._textFocused=!1,this.$input.addEventListener("input",()=>{this._setValueFromHexString(this.$input.value)}),this.$input.addEventListener("blur",()=>{this._callOnFinishChange()}),this.$text.addEventListener("input",()=>{const s=Zg(this.$text.value);s&&this._setValueFromHexString(s)}),this.$text.addEventListener("focus",()=>{this._textFocused=!0,this.$text.select()}),this.$text.addEventListener("blur",()=>{this._textFocused=!1,this.updateDisplay(),this._callOnFinishChange()}),this.$disable=this.$text,this.updateDisplay()}reset(){return this._setValueFromHexString(this._initialValueHexString),this}_setValueFromHexString(e){if(this._format.isPrimitive){const t=this._format.fromHexString(e);this.setValue(t)}else this._format.fromHexString(e,this.getValue(),this._rgbScale),this._callOnChange(),this.updateDisplay()}save(){return this._format.toHexString(this.getValue(),this._rgbScale)}load(e){return this._setValueFromHexString(e),this._callOnFinishChange(),this}updateDisplay(){return this.$input.value=this._format.toHexString(this.getValue(),this._rgbScale),this._textFocused||(this.$text.value=this.$input.value.substring(1)),this.$display.style.backgroundColor=this.$input.value,this}}class Nv extends ls{constructor(e,t,r){super(e,t,r,"function"),this.$button=document.createElement("button"),this.$button.appendChild(this.$name),this.$widget.appendChild(this.$button),this.$button.addEventListener("click",i=>{i.preventDefault(),this.getValue().call(this.object),this._callOnChange()}),this.$button.addEventListener("touchstart",()=>{},{passive:!0}),this.$disable=this.$button}}class Az extends ls{constructor(e,t,r,i,s,a){super(e,t,r,"number"),this._initInput(),this.min(i),this.max(s);const o=a!==void 0;this.step(o?a:this._getImplicitStep(),o),this.updateDisplay()}decimals(e){return this._decimals=e,this.updateDisplay(),this}min(e){return this._min=e,this._onUpdateMinMax(),this}max(e){return this._max=e,this._onUpdateMinMax(),this}step(e,t=!0){return this._step=e,this._stepExplicit=t,this}updateDisplay(){const e=this.getValue();if(this._hasSlider){let t=(e-this._min)/(this._max-this._min);t=Math.max(0,Math.min(t,1)),this.$fill.style.width=t*100+"%"}return this._inputFocused||(this.$input.value=this._decimals===void 0?e:e.toFixed(this._decimals)),this}_initInput(){this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("aria-labelledby",this.$name.id),window.matchMedia("(pointer: coarse)").matches&&(this.$input.setAttribute("type","number"),this.$input.setAttribute("step","any")),this.$widget.appendChild(this.$input),this.$disable=this.$input;const t=()=>{let x=parseFloat(this.$input.value);isNaN(x)||(this._stepExplicit&&(x=this._snap(x)),this.setValue(this._clamp(x)))},r=x=>{const b=parseFloat(this.$input.value);isNaN(b)||(this._snapClampSetValue(b+x),this.$input.value=this.getValue())},i=x=>{x.key==="Enter"&&this.$input.blur(),x.code==="ArrowUp"&&(x.preventDefault(),r(this._step*this._arrowKeyMultiplier(x))),x.code==="ArrowDown"&&(x.preventDefault(),r(this._step*this._arrowKeyMultiplier(x)*-1))},s=x=>{this._inputFocused&&(x.preventDefault(),r(this._step*this._normalizeMouseWheel(x)))};let a=!1,o,c,l,u,f;const d=5,h=x=>{o=x.clientX,c=l=x.clientY,a=!0,u=this.getValue(),f=0,window.addEventListener("mousemove",p),window.addEventListener("mouseup",g)},p=x=>{if(a){const b=x.clientX-o,_=x.clientY-c;Math.abs(_)>d?(x.preventDefault(),this.$input.blur(),a=!1,this._setDraggingStyle(!0,"vertical")):Math.abs(b)>d&&g()}if(!a){const b=x.clientY-l;f-=b*this._step*this._arrowKeyMultiplier(x),u+f>this._max?f=this._max-u:u+f<this._min&&(f=this._min-u),this._snapClampSetValue(u+f)}l=x.clientY},g=()=>{this._setDraggingStyle(!1,"vertical"),this._callOnFinishChange(),window.removeEventListener("mousemove",p),window.removeEventListener("mouseup",g)},m=()=>{this._inputFocused=!0},v=()=>{this._inputFocused=!1,this.updateDisplay(),this._callOnFinishChange()};this.$input.addEventListener("input",t),this.$input.addEventListener("keydown",i),this.$input.addEventListener("wheel",s,{passive:!1}),this.$input.addEventListener("mousedown",h),this.$input.addEventListener("focus",m),this.$input.addEventListener("blur",v)}_initSlider(){this._hasSlider=!0,this.$slider=document.createElement("div"),this.$slider.classList.add("slider"),this.$fill=document.createElement("div"),this.$fill.classList.add("fill"),this.$slider.appendChild(this.$fill),this.$widget.insertBefore(this.$slider,this.$input),this.domElement.classList.add("hasSlider");const e=(v,x,b,_,w)=>(v-x)/(b-x)*(w-_)+_,t=v=>{const x=this.$slider.getBoundingClientRect();let b=e(v,x.left,x.right,this._min,this._max);this._snapClampSetValue(b)},r=v=>{this._setDraggingStyle(!0),t(v.clientX),window.addEventListener("mousemove",i),window.addEventListener("mouseup",s)},i=v=>{t(v.clientX)},s=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("mousemove",i),window.removeEventListener("mouseup",s)};let a=!1,o,c;const l=v=>{v.preventDefault(),this._setDraggingStyle(!0),t(v.touches[0].clientX),a=!1},u=v=>{v.touches.length>1||(this._hasScrollBar?(o=v.touches[0].clientX,c=v.touches[0].clientY,a=!0):l(v),window.addEventListener("touchmove",f,{passive:!1}),window.addEventListener("touchend",d))},f=v=>{if(a){const x=v.touches[0].clientX-o,b=v.touches[0].clientY-c;Math.abs(x)>Math.abs(b)?l(v):(window.removeEventListener("touchmove",f),window.removeEventListener("touchend",d))}else v.preventDefault(),t(v.touches[0].clientX)},d=()=>{this._callOnFinishChange(),this._setDraggingStyle(!1),window.removeEventListener("touchmove",f),window.removeEventListener("touchend",d)},h=this._callOnFinishChange.bind(this),p=400;let g;const m=v=>{if(Math.abs(v.deltaX)<Math.abs(v.deltaY)&&this._hasScrollBar)return;v.preventDefault();const b=this._normalizeMouseWheel(v)*this._step;this._snapClampSetValue(this.getValue()+b),this.$input.value=this.getValue(),clearTimeout(g),g=setTimeout(h,p)};this.$slider.addEventListener("mousedown",r),this.$slider.addEventListener("touchstart",u,{passive:!1}),this.$slider.addEventListener("wheel",m,{passive:!1})}_setDraggingStyle(e,t="horizontal"){this.$slider&&this.$slider.classList.toggle("active",e),document.body.classList.toggle("lil-gui-dragging",e),document.body.classList.toggle(`lil-gui-${t}`,e)}_getImplicitStep(){return this._hasMin&&this._hasMax?(this._max-this._min)/1e3:.1}_onUpdateMinMax(){!this._hasSlider&&this._hasMin&&this._hasMax&&(this._stepExplicit||this.step(this._getImplicitStep(),!1),this._initSlider(),this.updateDisplay())}_normalizeMouseWheel(e){let{deltaX:t,deltaY:r}=e;return Math.floor(e.deltaY)!==e.deltaY&&e.wheelDelta&&(t=0,r=-e.wheelDelta/120,r*=this._stepExplicit?1:10),t+-r}_arrowKeyMultiplier(e){let t=this._stepExplicit?1:10;return e.shiftKey?t*=10:e.altKey&&(t/=10),t}_snap(e){const t=Math.round(e/this._step)*this._step;return parseFloat(t.toPrecision(15))}_clamp(e){return e<this._min&&(e=this._min),e>this._max&&(e=this._max),e}_snapClampSetValue(e){this.setValue(this._clamp(this._snap(e)))}get _hasScrollBar(){const e=this.parent.root.$children;return e.scrollHeight>e.clientHeight}get _hasMin(){return this._min!==void 0}get _hasMax(){return this._max!==void 0}}class Cz extends ls{constructor(e,t,r,i){super(e,t,r,"option"),this.$select=document.createElement("select"),this.$select.setAttribute("aria-labelledby",this.$name.id),this.$display=document.createElement("div"),this.$display.classList.add("display"),this.$select.addEventListener("change",()=>{this.setValue(this._values[this.$select.selectedIndex]),this._callOnFinishChange()}),this.$select.addEventListener("focus",()=>{this.$display.classList.add("focus")}),this.$select.addEventListener("blur",()=>{this.$display.classList.remove("focus")}),this.$widget.appendChild(this.$select),this.$widget.appendChild(this.$display),this.$disable=this.$select,this.options(i)}options(e){return this._values=Array.isArray(e)?e:Object.values(e),this._names=Array.isArray(e)?e:Object.keys(e),this.$select.replaceChildren(),this._names.forEach(t=>{const r=document.createElement("option");r.textContent=t,this.$select.appendChild(r)}),this.updateDisplay(),this}updateDisplay(){const e=this.getValue(),t=this._values.indexOf(e);return this.$select.selectedIndex=t,this.$display.textContent=t===-1?e:this._names[t],this}}class Iz extends ls{constructor(e,t,r){super(e,t,r,"string"),this.$input=document.createElement("input"),this.$input.setAttribute("type","text"),this.$input.setAttribute("spellcheck","false"),this.$input.setAttribute("aria-labelledby",this.$name.id),this.$input.addEventListener("input",()=>{this.setValue(this.$input.value)}),this.$input.addEventListener("keydown",i=>{i.code==="Enter"&&this.$input.blur()}),this.$input.addEventListener("blur",()=>{this._callOnFinishChange()}),this.$widget.appendChild(this.$input),this.$disable=this.$input,this.updateDisplay()}updateDisplay(){return this.$input.value=this.getValue(),this}}const Mz=`.lil-gui {
  font-family: var(--font-family);
  font-size: var(--font-size);
  line-height: 1;
  font-weight: normal;
  font-style: normal;
  text-align: left;
  color: var(--text-color);
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  --background-color: #1f1f1f;
  --text-color: #ebebeb;
  --title-background-color: #111111;
  --title-text-color: #ebebeb;
  --widget-color: #424242;
  --hover-color: #4f4f4f;
  --focus-color: #595959;
  --number-color: #2cc9ff;
  --string-color: #a2db3c;
  --font-size: 11px;
  --input-font-size: 11px;
  --font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
  --font-family-mono: Menlo, Monaco, Consolas, "Droid Sans Mono", monospace;
  --padding: 4px;
  --spacing: 4px;
  --widget-height: 20px;
  --title-height: calc(var(--widget-height) + var(--spacing) * 1.25);
  --name-width: 45%;
  --slider-knob-width: 2px;
  --slider-input-width: 27%;
  --color-input-width: 27%;
  --slider-input-min-width: 45px;
  --color-input-min-width: 45px;
  --folder-indent: 7px;
  --widget-padding: 0 0 0 3px;
  --widget-border-radius: 2px;
  --checkbox-size: calc(0.75 * var(--widget-height));
  --scrollbar-width: 5px;
}
.lil-gui, .lil-gui * {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}
.lil-gui.root {
  width: var(--width, 245px);
  display: flex;
  flex-direction: column;
  background: var(--background-color);
}
.lil-gui.root > .title {
  background: var(--title-background-color);
  color: var(--title-text-color);
}
.lil-gui.root > .children {
  overflow-x: hidden;
  overflow-y: auto;
}
.lil-gui.root > .children::-webkit-scrollbar {
  width: var(--scrollbar-width);
  height: var(--scrollbar-width);
  background: var(--background-color);
}
.lil-gui.root > .children::-webkit-scrollbar-thumb {
  border-radius: var(--scrollbar-width);
  background: var(--focus-color);
}
@media (pointer: coarse) {
  .lil-gui.allow-touch-styles, .lil-gui.allow-touch-styles .lil-gui {
    --widget-height: 28px;
    --padding: 6px;
    --spacing: 6px;
    --font-size: 13px;
    --input-font-size: 16px;
    --folder-indent: 10px;
    --scrollbar-width: 7px;
    --slider-input-min-width: 50px;
    --color-input-min-width: 65px;
  }
}
.lil-gui.force-touch-styles, .lil-gui.force-touch-styles .lil-gui {
  --widget-height: 28px;
  --padding: 6px;
  --spacing: 6px;
  --font-size: 13px;
  --input-font-size: 16px;
  --folder-indent: 10px;
  --scrollbar-width: 7px;
  --slider-input-min-width: 50px;
  --color-input-min-width: 65px;
}
.lil-gui.autoPlace {
  max-height: 100%;
  position: fixed;
  top: 0;
  right: 15px;
  z-index: 1001;
}

.lil-gui .controller {
  display: flex;
  align-items: center;
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
}
.lil-gui .controller.disabled {
  opacity: 0.5;
}
.lil-gui .controller.disabled, .lil-gui .controller.disabled * {
  pointer-events: none !important;
}
.lil-gui .controller > .name {
  min-width: var(--name-width);
  flex-shrink: 0;
  white-space: pre;
  padding-right: var(--spacing);
  line-height: var(--widget-height);
}
.lil-gui .controller .widget {
  position: relative;
  display: flex;
  align-items: center;
  width: 100%;
  min-height: var(--widget-height);
}
.lil-gui .controller.string input {
  color: var(--string-color);
}
.lil-gui .controller.boolean {
  cursor: pointer;
}
.lil-gui .controller.color .display {
  width: 100%;
  height: var(--widget-height);
  border-radius: var(--widget-border-radius);
  position: relative;
}
@media (hover: hover) {
  .lil-gui .controller.color .display:hover:before {
    content: " ";
    display: block;
    position: absolute;
    border-radius: var(--widget-border-radius);
    border: 1px solid #fff9;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
.lil-gui .controller.color input[type=color] {
  opacity: 0;
  width: 100%;
  height: 100%;
  cursor: pointer;
}
.lil-gui .controller.color input[type=text] {
  margin-left: var(--spacing);
  font-family: var(--font-family-mono);
  min-width: var(--color-input-min-width);
  width: var(--color-input-width);
  flex-shrink: 0;
}
.lil-gui .controller.option select {
  opacity: 0;
  position: absolute;
  width: 100%;
  max-width: 100%;
}
.lil-gui .controller.option .display {
  position: relative;
  pointer-events: none;
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  line-height: var(--widget-height);
  max-width: 100%;
  overflow: hidden;
  word-break: break-all;
  padding-left: 0.55em;
  padding-right: 1.75em;
  background: var(--widget-color);
}
@media (hover: hover) {
  .lil-gui .controller.option .display.focus {
    background: var(--focus-color);
  }
}
.lil-gui .controller.option .display.active {
  background: var(--focus-color);
}
.lil-gui .controller.option .display:after {
  font-family: "lil-gui";
  content: "↕";
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  padding-right: 0.375em;
}
.lil-gui .controller.option .widget,
.lil-gui .controller.option select {
  cursor: pointer;
}
@media (hover: hover) {
  .lil-gui .controller.option .widget:hover .display {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number input {
  color: var(--number-color);
}
.lil-gui .controller.number.hasSlider input {
  margin-left: var(--spacing);
  width: var(--slider-input-width);
  min-width: var(--slider-input-min-width);
  flex-shrink: 0;
}
.lil-gui .controller.number .slider {
  width: 100%;
  height: var(--widget-height);
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  padding-right: var(--slider-knob-width);
  overflow: hidden;
  cursor: ew-resize;
  touch-action: pan-y;
}
@media (hover: hover) {
  .lil-gui .controller.number .slider:hover {
    background: var(--hover-color);
  }
}
.lil-gui .controller.number .slider.active {
  background: var(--focus-color);
}
.lil-gui .controller.number .slider.active .fill {
  opacity: 0.95;
}
.lil-gui .controller.number .fill {
  height: 100%;
  border-right: var(--slider-knob-width) solid var(--number-color);
  box-sizing: content-box;
}

.lil-gui-dragging .lil-gui {
  --hover-color: var(--widget-color);
}
.lil-gui-dragging * {
  cursor: ew-resize !important;
}

.lil-gui-dragging.lil-gui-vertical * {
  cursor: ns-resize !important;
}

.lil-gui .title {
  height: var(--title-height);
  line-height: calc(var(--title-height) - 4px);
  font-weight: 600;
  padding: 0 var(--padding);
  -webkit-tap-highlight-color: transparent;
  cursor: pointer;
  outline: none;
  text-decoration-skip: objects;
}
.lil-gui .title:before {
  font-family: "lil-gui";
  content: "▾";
  padding-right: 2px;
  display: inline-block;
}
.lil-gui .title:active {
  background: var(--title-background-color);
  opacity: 0.75;
}
@media (hover: hover) {
  body:not(.lil-gui-dragging) .lil-gui .title:hover {
    background: var(--title-background-color);
    opacity: 0.85;
  }
  .lil-gui .title:focus {
    text-decoration: underline var(--focus-color);
  }
}
.lil-gui.root > .title:focus {
  text-decoration: none !important;
}
.lil-gui.closed > .title:before {
  content: "▸";
}
.lil-gui.closed > .children {
  transform: translateY(-7px);
  opacity: 0;
}
.lil-gui.closed:not(.transition) > .children {
  display: none;
}
.lil-gui.transition > .children {
  transition-duration: 300ms;
  transition-property: height, opacity, transform;
  transition-timing-function: cubic-bezier(0.2, 0.6, 0.35, 1);
  overflow: hidden;
  pointer-events: none;
}
.lil-gui .children:empty:before {
  content: "Empty";
  padding: 0 var(--padding);
  margin: var(--spacing) 0;
  display: block;
  height: var(--widget-height);
  font-style: italic;
  line-height: var(--widget-height);
  opacity: 0.5;
}
.lil-gui.root > .children > .lil-gui > .title {
  border: 0 solid var(--widget-color);
  border-width: 1px 0;
  transition: border-color 300ms;
}
.lil-gui.root > .children > .lil-gui.closed > .title {
  border-bottom-color: transparent;
}
.lil-gui + .controller {
  border-top: 1px solid var(--widget-color);
  margin-top: 0;
  padding-top: var(--spacing);
}
.lil-gui .lil-gui .lil-gui > .title {
  border: none;
}
.lil-gui .lil-gui .lil-gui > .children {
  border: none;
  margin-left: var(--folder-indent);
  border-left: 2px solid var(--widget-color);
}
.lil-gui .lil-gui .controller {
  border: none;
}

.lil-gui label, .lil-gui input, .lil-gui button {
  -webkit-tap-highlight-color: transparent;
}
.lil-gui input {
  border: 0;
  outline: none;
  font-family: var(--font-family);
  font-size: var(--input-font-size);
  border-radius: var(--widget-border-radius);
  height: var(--widget-height);
  background: var(--widget-color);
  color: var(--text-color);
  width: 100%;
}
@media (hover: hover) {
  .lil-gui input:hover {
    background: var(--hover-color);
  }
  .lil-gui input:active {
    background: var(--focus-color);
  }
}
.lil-gui input:disabled {
  opacity: 1;
}
.lil-gui input[type=text],
.lil-gui input[type=number] {
  padding: var(--widget-padding);
  -moz-appearance: textfield;
}
.lil-gui input[type=text]:focus,
.lil-gui input[type=number]:focus {
  background: var(--focus-color);
}
.lil-gui input[type=checkbox] {
  appearance: none;
  width: var(--checkbox-size);
  height: var(--checkbox-size);
  border-radius: var(--widget-border-radius);
  text-align: center;
  cursor: pointer;
}
.lil-gui input[type=checkbox]:checked:before {
  font-family: "lil-gui";
  content: "✓";
  font-size: var(--checkbox-size);
  line-height: var(--checkbox-size);
}
@media (hover: hover) {
  .lil-gui input[type=checkbox]:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button {
  outline: none;
  cursor: pointer;
  font-family: var(--font-family);
  font-size: var(--font-size);
  color: var(--text-color);
  width: 100%;
  height: var(--widget-height);
  text-transform: none;
  background: var(--widget-color);
  border-radius: var(--widget-border-radius);
  border: none;
}
@media (hover: hover) {
  .lil-gui button:hover {
    background: var(--hover-color);
  }
  .lil-gui button:focus {
    box-shadow: inset 0 0 0 1px var(--focus-color);
  }
}
.lil-gui button:active {
  background: var(--focus-color);
}

@font-face {
  font-family: "lil-gui";
  src: url("data:application/font-woff;charset=utf-8;base64,d09GRgABAAAAAAUsAAsAAAAACJwAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAABHU1VCAAABCAAAAH4AAADAImwmYE9TLzIAAAGIAAAAPwAAAGBKqH5SY21hcAAAAcgAAAD0AAACrukyyJBnbHlmAAACvAAAAF8AAACEIZpWH2hlYWQAAAMcAAAAJwAAADZfcj2zaGhlYQAAA0QAAAAYAAAAJAC5AHhobXR4AAADXAAAABAAAABMAZAAAGxvY2EAAANsAAAAFAAAACgCEgIybWF4cAAAA4AAAAAeAAAAIAEfABJuYW1lAAADoAAAASIAAAIK9SUU/XBvc3QAAATEAAAAZgAAAJCTcMc2eJxVjbEOgjAURU+hFRBK1dGRL+ALnAiToyMLEzFpnPz/eAshwSa97517c/MwwJmeB9kwPl+0cf5+uGPZXsqPu4nvZabcSZldZ6kfyWnomFY/eScKqZNWupKJO6kXN3K9uCVoL7iInPr1X5baXs3tjuMqCtzEuagm/AAlzQgPAAB4nGNgYRBlnMDAysDAYM/gBiT5oLQBAwuDJAMDEwMrMwNWEJDmmsJwgCFeXZghBcjlZMgFCzOiKOIFAB71Bb8AeJy1kjFuwkAQRZ+DwRAwBtNQRUGKQ8OdKCAWUhAgKLhIuAsVSpWz5Bbkj3dEgYiUIszqWdpZe+Z7/wB1oCYmIoboiwiLT2WjKl/jscrHfGg/pKdMkyklC5Zs2LEfHYpjcRoPzme9MWWmk3dWbK9ObkWkikOetJ554fWyoEsmdSlt+uR0pCJR34b6t/TVg1SY3sYvdf8vuiKrpyaDXDISiegp17p7579Gp3p++y7HPAiY9pmTibljrr85qSidtlg4+l25GLCaS8e6rRxNBmsnERunKbaOObRz7N72ju5vdAjYpBXHgJylOAVsMseDAPEP8LYoUHicY2BiAAEfhiAGJgZWBgZ7RnFRdnVJELCQlBSRlATJMoLV2DK4glSYs6ubq5vbKrJLSbGrgEmovDuDJVhe3VzcXFwNLCOILB/C4IuQ1xTn5FPilBTj5FPmBAB4WwoqAHicY2BkYGAA4sk1sR/j+W2+MnAzpDBgAyEMQUCSg4EJxAEAwUgFHgB4nGNgZGBgSGFggJMhDIwMqEAYAByHATJ4nGNgAIIUNEwmAABl3AGReJxjYAACIQYlBiMGJ3wQAEcQBEV4nGNgZGBgEGZgY2BiAAEQyQWEDAz/wXwGAAsPATIAAHicXdBNSsNAHAXwl35iA0UQXYnMShfS9GPZA7T7LgIu03SSpkwzYTIt1BN4Ak/gKTyAeCxfw39jZkjymzcvAwmAW/wgwHUEGDb36+jQQ3GXGot79L24jxCP4gHzF/EIr4jEIe7wxhOC3g2TMYy4Q7+Lu/SHuEd/ivt4wJd4wPxbPEKMX3GI5+DJFGaSn4qNzk8mcbKSR6xdXdhSzaOZJGtdapd4vVPbi6rP+cL7TGXOHtXKll4bY1Xl7EGnPtp7Xy2n00zyKLVHfkHBa4IcJ2oD3cgggWvt/V/FbDrUlEUJhTn/0azVWbNTNr0Ens8de1tceK9xZmfB1CPjOmPH4kitmvOubcNpmVTN3oFJyjzCvnmrwhJTzqzVj9jiSX911FjeAAB4nG3HMRKCMBBA0f0giiKi4DU8k0V2GWbIZDOh4PoWWvq6J5V8If9NVNQcaDhyouXMhY4rPTcG7jwYmXhKq8Wz+p762aNaeYXom2n3m2dLTVgsrCgFJ7OTmIkYbwIbC6vIB7WmFfAAAA==") format("woff");
}`;function Rz(n){const e=document.createElement("style");e.innerHTML=n;const t=document.querySelector("head link[rel=stylesheet], head style");t?document.head.insertBefore(e,t):document.head.appendChild(e)}let J1=!1;class x0{constructor({parent:e,autoPlace:t=e===void 0,container:r,width:i,title:s="Controls",closeFolders:a=!1,injectStyles:o=!0,touchStyles:c=!0}={}){if(this.parent=e,this.root=e?e.root:this,this.children=[],this.controllers=[],this.folders=[],this._closed=!1,this._hidden=!1,this.domElement=document.createElement("div"),this.domElement.classList.add("lil-gui"),this.$title=document.createElement("div"),this.$title.classList.add("title"),this.$title.setAttribute("role","button"),this.$title.setAttribute("aria-expanded",!0),this.$title.setAttribute("tabindex",0),this.$title.addEventListener("click",()=>this.openAnimated(this._closed)),this.$title.addEventListener("keydown",l=>{(l.code==="Enter"||l.code==="Space")&&(l.preventDefault(),this.$title.click())}),this.$title.addEventListener("touchstart",()=>{},{passive:!0}),this.$children=document.createElement("div"),this.$children.classList.add("children"),this.domElement.appendChild(this.$title),this.domElement.appendChild(this.$children),this.title(s),this.parent){this.parent.children.push(this),this.parent.folders.push(this),this.parent.$children.appendChild(this.domElement);return}this.domElement.classList.add("root"),c&&this.domElement.classList.add("allow-touch-styles"),!J1&&o&&(Rz(Mz),J1=!0),r?r.appendChild(this.domElement):t&&(this.domElement.classList.add("autoPlace"),document.body.appendChild(this.domElement)),i&&this.domElement.style.setProperty("--width",i+"px"),this._closeFolders=a}add(e,t,r,i,s){if(Object(r)===r)return new Cz(this,e,t,r);const a=e[t];switch(typeof a){case"number":return new Az(this,e,t,r,i,s);case"boolean":return new bz(this,e,t);case"string":return new Iz(this,e,t);case"function":return new Nv(this,e,t)}console.error(`gui.add failed
	property:`,t,`
	object:`,e,`
	value:`,a)}addColor(e,t,r=1){return new Tz(this,e,t,r)}addFolder(e){const t=new x0({parent:this,title:e});return this.root._closeFolders&&t.close(),t}load(e,t=!0){return e.controllers&&this.controllers.forEach(r=>{r instanceof Nv||r._name in e.controllers&&r.load(e.controllers[r._name])}),t&&e.folders&&this.folders.forEach(r=>{r._title in e.folders&&r.load(e.folders[r._title])}),this}save(e=!0){const t={controllers:{},folders:{}};return this.controllers.forEach(r=>{if(!(r instanceof Nv)){if(r._name in t.controllers)throw new Error(`Cannot save GUI with duplicate property "${r._name}"`);t.controllers[r._name]=r.save()}}),e&&this.folders.forEach(r=>{if(r._title in t.folders)throw new Error(`Cannot save GUI with duplicate folder "${r._title}"`);t.folders[r._title]=r.save()}),t}open(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),this.domElement.classList.toggle("closed",this._closed),this}close(){return this.open(!1)}_setClosed(e){this._closed!==e&&(this._closed=e,this._callOnOpenClose(this))}show(e=!0){return this._hidden=!e,this.domElement.style.display=this._hidden?"none":"",this}hide(){return this.show(!1)}openAnimated(e=!0){return this._setClosed(!e),this.$title.setAttribute("aria-expanded",!this._closed),requestAnimationFrame(()=>{const t=this.$children.clientHeight;this.$children.style.height=t+"px",this.domElement.classList.add("transition");const r=s=>{s.target===this.$children&&(this.$children.style.height="",this.domElement.classList.remove("transition"),this.$children.removeEventListener("transitionend",r))};this.$children.addEventListener("transitionend",r);const i=e?this.$children.scrollHeight:0;this.domElement.classList.toggle("closed",!e),requestAnimationFrame(()=>{this.$children.style.height=i+"px"})}),this}title(e){return this._title=e,this.$title.textContent=e,this}reset(e=!0){return(e?this.controllersRecursive():this.controllers).forEach(r=>r.reset()),this}onChange(e){return this._onChange=e,this}_callOnChange(e){this.parent&&this.parent._callOnChange(e),this._onChange!==void 0&&this._onChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onFinishChange(e){return this._onFinishChange=e,this}_callOnFinishChange(e){this.parent&&this.parent._callOnFinishChange(e),this._onFinishChange!==void 0&&this._onFinishChange.call(this,{object:e.object,property:e.property,value:e.getValue(),controller:e})}onOpenClose(e){return this._onOpenClose=e,this}_callOnOpenClose(e){this.parent&&this.parent._callOnOpenClose(e),this._onOpenClose!==void 0&&this._onOpenClose.call(this,e)}destroy(){this.parent&&(this.parent.children.splice(this.parent.children.indexOf(this),1),this.parent.folders.splice(this.parent.folders.indexOf(this),1)),this.domElement.parentElement&&this.domElement.parentElement.removeChild(this.domElement),Array.from(this.children).forEach(e=>e.destroy())}controllersRecursive(){let e=Array.from(this.controllers);return this.folders.forEach(t=>{e=e.concat(t.controllersRecursive())}),e}foldersRecursive(){let e=Array.from(this.folders);return this.folders.forEach(t=>{e=e.concat(t.foldersRecursive())}),e}}const Nz=x0;class kz{constructor(){this.active=window.location.hash==="#debug",this.active&&(this.ui=new Nz)}getController(e,t){for(const r of e.controllersRecursive())if(r._name===t)return r;return null}getFolder(e,t){for(const r of e.foldersRecursive())if(r._title===t)return r;return null}destroy(){this.active&&this.ui&&(this.ui.destroy(),this.ui=null),console.log("Debug destroyed")}}class Dz extends Js{constructor(){super(),this.width=window.innerWidth,this.height=window.innerHeight,this.pixelRatio=Math.min(window.devicePixelRatio,1),this.onResize=this.onResize.bind(this),window.addEventListener("resize",this.onResize)}onResize(){this.width=window.innerWidth,this.height=window.innerHeight,this.pixelRatio=Math.min(window.devicePixelRatio,1),this.trigger("resize",{width:this.width,height:this.height,pixelRatio:this.pixelRatio})}destroy(){window.removeEventListener("resize",this.onResize),this.width=null,this.height=null,this.pixelRatio=null,console.log("Sizes destroyed")}}class Lz extends Js{constructor(){super(),this.start=Date.now(),this.current=this.start,this.elapsed=0,this.delta=16,this.animationFrameId=null,this.tick=this.tick.bind(this),this.animationFrameId=window.requestAnimationFrame(this.tick)}tick(){const e=Date.now();this.delta=e-this.current,this.current=e,this.elapsed=this.current-this.start,this.trigger("tick",{elapsed:this.elapsed,delta:this.delta}),this.animationFrameId=window.requestAnimationFrame(this.tick)}destroy(){this.animationFrameId!==null&&(window.cancelAnimationFrame(this.animationFrameId),this.animationFrameId=null),this.start=null,this.current=null,this.elapsed=null,this.delta=null,console.log("Time destroyed")}}class Oz extends Js{constructor(){super(),this.screenPosition=new Ye,this.ndcPosition=new Ye,this.onMouseMove=this.onMouseMove.bind(this),this.onMouseDown=this.onMouseDown.bind(this),this.onMouseUp=this.onMouseUp.bind(this),window.addEventListener("mousemove",this.onMouseMove),window.addEventListener("mousedown",this.onMouseDown),window.addEventListener("mouseup",this.onMouseUp)}onMouseMove(e){this.screenPosition.x=e.clientX,this.screenPosition.y=e.clientY,this.ndcPosition.x=this.screenPosition.x/window.innerWidth*2-1,this.ndcPosition.y=this.screenPosition.y/window.innerHeight*2-1,this.ndcPosition.y*=-1,this.trigger("move",{x:this.screenPosition.x,y:this.screenPosition.y,ndcX:this.ndcPosition.x,ndcY:this.ndcPosition.y})}onMouseDown(e){this.trigger("down",{button:e.button,x:this.screenPosition.x,y:this.screenPosition.y,ndcX:this.ndcPosition.x,ndcY:this.ndcPosition.y})}onMouseUp(e){this.trigger("up",{button:e.button,x:this.screenPosition.x,y:this.screenPosition.y,ndcX:this.ndcPosition.x,ndcY:this.ndcPosition.y})}destroy(){window.removeEventListener("mousemove",this.onMouseMove),window.removeEventListener("mousedown",this.onMouseDown),window.removeEventListener("mouseup",this.onMouseUp),this.screenPosition=null,this.ndcPosition=null,console.log("Mouse destroyed")}}var $r=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function OE(n){return n&&n.__esModule&&Object.prototype.hasOwnProperty.call(n,"default")?n.default:n}function zz(n){if(n.__esModule)return n;var e=n.default;if(typeof e=="function"){var t=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};t.prototype=e.prototype}else t={};return Object.defineProperty(t,"__esModule",{value:!0}),Object.keys(n).forEach(function(r){var i=Object.getOwnPropertyDescriptor(n,r);Object.defineProperty(t,r,i.get?i:{enumerable:!0,get:function(){return n[r]}})}),t}var zE={exports:{}};(function(n,e){(function(t,r){n.exports=r()})($r,function(){var t=function(){function r(h){return a.appendChild(h.dom),h}function i(h){for(var p=0;p<a.children.length;p++)a.children[p].style.display=p===h?"block":"none";s=h}var s=0,a=document.createElement("div");a.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000",a.addEventListener("click",function(h){h.preventDefault(),i(++s%a.children.length)},!1);var o=(performance||Date).now(),c=o,l=0,u=r(new t.Panel("FPS","#0ff","#002")),f=r(new t.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var d=r(new t.Panel("MB","#f08","#201"));return i(0),{REVISION:16,dom:a,addPanel:r,showPanel:i,begin:function(){o=(performance||Date).now()},end:function(){l++;var h=(performance||Date).now();if(f.update(h-o,200),h>c+1e3&&(u.update(1e3*l/(h-c),100),c=h,l=0,d)){var p=performance.memory;d.update(p.usedJSHeapSize/1048576,p.jsHeapSizeLimit/1048576)}return h},update:function(){o=this.end()},domElement:a,setMode:i}};return t.Panel=function(r,i,s){var a=1/0,o=0,c=Math.round,l=c(window.devicePixelRatio||1),u=80*l,f=48*l,d=3*l,h=2*l,p=3*l,g=15*l,m=74*l,v=30*l,x=document.createElement("canvas");x.width=u,x.height=f,x.style.cssText="width:80px;height:48px";var b=x.getContext("2d");return b.font="bold "+9*l+"px Helvetica,Arial,sans-serif",b.textBaseline="top",b.fillStyle=s,b.fillRect(0,0,u,f),b.fillStyle=i,b.fillText(r,d,h),b.fillRect(p,g,m,v),b.fillStyle=s,b.globalAlpha=.9,b.fillRect(p,g,m,v),{dom:x,update:function(_,w){a=Math.min(a,_),o=Math.max(o,_),b.fillStyle=s,b.globalAlpha=1,b.fillRect(0,0,u,g),b.fillStyle=i,b.fillText(c(_)+" "+r+" ("+c(a)+"-"+c(o)+")",d,h),b.drawImage(x,p+l,g,m-l,v,p,g,m-l,v),b.fillRect(p+m-l,g,l,v),b.fillStyle=s,b.globalAlpha=.9,b.fillRect(p+m-l,g,l,c((1-_/w)*v))}}},t})})(zE);var Pz=zE.exports;const e2=OE(Pz);class Fz{constructor(e){this.instance=new e2,this.instance.showPanel(0),this.active=!1,this.max=40,this.ignoreMaxed=!0,e&&this.activate()}activate(){this.active=!0,document.body.appendChild(this.instance.dom)}deactivate(){this.active=!1,document.body.removeChild(this.instance.dom)}setRenderPanel(e){this.render={},this.render.context=e,this.render.extension=this.render.context.getExtension("EXT_disjoint_timer_query_webgl2"),this.render.panel=this.instance.addPanel(new e2.Panel("Render (ms)","#f8f","#212")),(!(typeof WebGL2RenderingContext<"u"&&e instanceof WebGL2RenderingContext)||!this.render.extension)&&this.deactivate()}beforeRender(){if(!this.active)return;this.queryCreated=!1;let e=!1;if(this.render.query){e=this.render.context.getQueryParameter(this.render.query,this.render.context.QUERY_RESULT_AVAILABLE);const t=this.render.context.getParameter(this.render.extension.GPU_DISJOINT_EXT);if(e&&!t){const r=this.render.context.getQueryParameter(this.render.query,this.render.context.QUERY_RESULT),i=Math.min(r/1e3/1e3,this.max);i===this.max&&this.ignoreMaxed||this.render.panel.update(i,this.max)}}(e||!this.render.query)&&(this.queryCreated=!0,this.render.query=this.render.context.createQuery(),this.render.context.beginQuery(this.render.extension.TIME_ELAPSED_EXT,this.render.query))}afterRender(){this.active&&this.queryCreated&&this.render.context.endQuery(this.render.extension.TIME_ELAPSED_EXT)}update(){this.active&&this.instance.update()}destroy(){this.deactivate()}}const t2={type:"change"},b0={type:"start"},PE={type:"end"},Wd=new vl,n2=new ma,$z=Math.cos(70*Ih.DEG2RAD),Fn=new $,Or=2*Math.PI,Yt={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6},kv=1e-6;class Uz extends LE{constructor(e,t=null){super(e,t),this.state=Yt.NONE,this.enabled=!0,this.target=new $,this.cursor=new $,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minTargetRadius=0,this.maxTargetRadius=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:_i.ROTATE,MIDDLE:_i.DOLLY,RIGHT:_i.PAN},this.touches={ONE:Cc.ROTATE,TWO:Cc.DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new $,this._lastQuaternion=new Xi,this._lastTargetPosition=new $,this._quat=new Xi().setFromUnitVectors(e.up,new $(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new Q1,this._sphericalDelta=new Q1,this._scale=1,this._panOffset=new $,this._rotateStart=new Ye,this._rotateEnd=new Ye,this._rotateDelta=new Ye,this._panStart=new Ye,this._panEnd=new Ye,this._panDelta=new Ye,this._dollyStart=new Ye,this._dollyEnd=new Ye,this._dollyDelta=new Ye,this._dollyDirection=new $,this._mouse=new Ye,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=Vz.bind(this),this._onPointerDown=Bz.bind(this),this._onPointerUp=Gz.bind(this),this._onContextMenu=Yz.bind(this),this._onMouseWheel=qz.bind(this),this._onKeyDown=Xz.bind(this),this._onTouchStart=Kz.bind(this),this._onTouchMove=jz.bind(this),this._onMouseDown=Hz.bind(this),this._onMouseMove=Wz.bind(this),this._interceptControlDown=Zz.bind(this),this._interceptControlUp=Qz.bind(this),this.domElement!==null&&this.connect(),this.update()}connect(){this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents(),this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(e){e.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=e}stopListenToKeyEvents(){this._domElementKeyEvents!==null&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(t2),this.update(),this.state=Yt.NONE}update(e=null){const t=this.object.position;Fn.copy(t).sub(this.target),Fn.applyQuaternion(this._quat),this._spherical.setFromVector3(Fn),this.autoRotate&&this.state===Yt.NONE&&this._rotateLeft(this._getAutoRotationAngle(e)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let r=this.minAzimuthAngle,i=this.maxAzimuthAngle;isFinite(r)&&isFinite(i)&&(r<-Math.PI?r+=Or:r>Math.PI&&(r-=Or),i<-Math.PI?i+=Or:i>Math.PI&&(i-=Or),r<=i?this._spherical.theta=Math.max(r,Math.min(i,this._spherical.theta)):this._spherical.theta=this._spherical.theta>(r+i)/2?Math.max(r,this._spherical.theta):Math.min(i,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),this.enableDamping===!0?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let s=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const a=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),s=a!=this._spherical.radius}if(Fn.setFromSpherical(this._spherical),Fn.applyQuaternion(this._quatInverse),t.copy(this.target).add(Fn),this.object.lookAt(this.target),this.enableDamping===!0?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let a=null;if(this.object.isPerspectiveCamera){const o=Fn.length();a=this._clampDistance(o*this._scale);const c=o-a;this.object.position.addScaledVector(this._dollyDirection,c),this.object.updateMatrixWorld(),s=!!c}else if(this.object.isOrthographicCamera){const o=new $(this._mouse.x,this._mouse.y,0);o.unproject(this.object);const c=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),s=c!==this.object.zoom;const l=new $(this._mouse.x,this._mouse.y,0);l.unproject(this.object),this.object.position.sub(l).add(o),this.object.updateMatrixWorld(),a=Fn.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;a!==null&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(a).add(this.object.position):(Wd.origin.copy(this.object.position),Wd.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(Wd.direction))<$z?this.object.lookAt(this.target):(n2.setFromNormalAndCoplanarPoint(this.object.up,this.target),Wd.intersectPlane(n2,this.target))))}else if(this.object.isOrthographicCamera){const a=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),a!==this.object.zoom&&(this.object.updateProjectionMatrix(),s=!0)}return this._scale=1,this._performCursorZoom=!1,s||this._lastPosition.distanceToSquared(this.object.position)>kv||8*(1-this._lastQuaternion.dot(this.object.quaternion))>kv||this._lastTargetPosition.distanceToSquared(this.target)>kv?(this.dispatchEvent(t2),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0):!1}_getAutoRotationAngle(e){return e!==null?Or/60*this.autoRotateSpeed*e:Or/60/60*this.autoRotateSpeed}_getZoomScale(e){const t=Math.abs(e*.01);return Math.pow(.95,this.zoomSpeed*t)}_rotateLeft(e){this._sphericalDelta.theta-=e}_rotateUp(e){this._sphericalDelta.phi-=e}_panLeft(e,t){Fn.setFromMatrixColumn(t,0),Fn.multiplyScalar(-e),this._panOffset.add(Fn)}_panUp(e,t){this.screenSpacePanning===!0?Fn.setFromMatrixColumn(t,1):(Fn.setFromMatrixColumn(t,0),Fn.crossVectors(this.object.up,Fn)),Fn.multiplyScalar(e),this._panOffset.add(Fn)}_pan(e,t){const r=this.domElement;if(this.object.isPerspectiveCamera){const i=this.object.position;Fn.copy(i).sub(this.target);let s=Fn.length();s*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*e*s/r.clientHeight,this.object.matrix),this._panUp(2*t*s/r.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(e*(this.object.right-this.object.left)/this.object.zoom/r.clientWidth,this.object.matrix),this._panUp(t*(this.object.top-this.object.bottom)/this.object.zoom/r.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(e){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=e:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(e,t){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const r=this.domElement.getBoundingClientRect(),i=e-r.left,s=t-r.top,a=r.width,o=r.height;this._mouse.x=i/a*2-1,this._mouse.y=-(s/o)*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(e){return Math.max(this.minDistance,Math.min(this.maxDistance,e))}_handleMouseDownRotate(e){this._rotateStart.set(e.clientX,e.clientY)}_handleMouseDownDolly(e){this._updateZoomParameters(e.clientX,e.clientX),this._dollyStart.set(e.clientX,e.clientY)}_handleMouseDownPan(e){this._panStart.set(e.clientX,e.clientY)}_handleMouseMoveRotate(e){this._rotateEnd.set(e.clientX,e.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(Or*this._rotateDelta.x/t.clientHeight),this._rotateUp(Or*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(e){this._dollyEnd.set(e.clientX,e.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(e){this._panEnd.set(e.clientX,e.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(e){this._updateZoomParameters(e.clientX,e.clientY),e.deltaY<0?this._dollyIn(this._getZoomScale(e.deltaY)):e.deltaY>0&&this._dollyOut(this._getZoomScale(e.deltaY)),this.update()}_handleKeyDown(e){let t=!1;switch(e.code){case this.keys.UP:e.ctrlKey||e.metaKey||e.shiftKey?this._rotateUp(Or*this.rotateSpeed/this.domElement.clientHeight):this._pan(0,this.keyPanSpeed),t=!0;break;case this.keys.BOTTOM:e.ctrlKey||e.metaKey||e.shiftKey?this._rotateUp(-Or*this.rotateSpeed/this.domElement.clientHeight):this._pan(0,-this.keyPanSpeed),t=!0;break;case this.keys.LEFT:e.ctrlKey||e.metaKey||e.shiftKey?this._rotateLeft(Or*this.rotateSpeed/this.domElement.clientHeight):this._pan(this.keyPanSpeed,0),t=!0;break;case this.keys.RIGHT:e.ctrlKey||e.metaKey||e.shiftKey?this._rotateLeft(-Or*this.rotateSpeed/this.domElement.clientHeight):this._pan(-this.keyPanSpeed,0),t=!0;break}t&&(e.preventDefault(),this.update())}_handleTouchStartRotate(e){if(this._pointers.length===1)this._rotateStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),r=.5*(e.pageX+t.x),i=.5*(e.pageY+t.y);this._rotateStart.set(r,i)}}_handleTouchStartPan(e){if(this._pointers.length===1)this._panStart.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),r=.5*(e.pageX+t.x),i=.5*(e.pageY+t.y);this._panStart.set(r,i)}}_handleTouchStartDolly(e){const t=this._getSecondPointerPosition(e),r=e.pageX-t.x,i=e.pageY-t.y,s=Math.sqrt(r*r+i*i);this._dollyStart.set(0,s)}_handleTouchStartDollyPan(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enablePan&&this._handleTouchStartPan(e)}_handleTouchStartDollyRotate(e){this.enableZoom&&this._handleTouchStartDolly(e),this.enableRotate&&this._handleTouchStartRotate(e)}_handleTouchMoveRotate(e){if(this._pointers.length==1)this._rotateEnd.set(e.pageX,e.pageY);else{const r=this._getSecondPointerPosition(e),i=.5*(e.pageX+r.x),s=.5*(e.pageY+r.y);this._rotateEnd.set(i,s)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const t=this.domElement;this._rotateLeft(Or*this._rotateDelta.x/t.clientHeight),this._rotateUp(Or*this._rotateDelta.y/t.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(e){if(this._pointers.length===1)this._panEnd.set(e.pageX,e.pageY);else{const t=this._getSecondPointerPosition(e),r=.5*(e.pageX+t.x),i=.5*(e.pageY+t.y);this._panEnd.set(r,i)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(e){const t=this._getSecondPointerPosition(e),r=e.pageX-t.x,i=e.pageY-t.y,s=Math.sqrt(r*r+i*i);this._dollyEnd.set(0,s),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const a=(e.pageX+t.x)*.5,o=(e.pageY+t.y)*.5;this._updateZoomParameters(a,o)}_handleTouchMoveDollyPan(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enablePan&&this._handleTouchMovePan(e)}_handleTouchMoveDollyRotate(e){this.enableZoom&&this._handleTouchMoveDolly(e),this.enableRotate&&this._handleTouchMoveRotate(e)}_addPointer(e){this._pointers.push(e.pointerId)}_removePointer(e){delete this._pointerPositions[e.pointerId];for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId){this._pointers.splice(t,1);return}}_isTrackingPointer(e){for(let t=0;t<this._pointers.length;t++)if(this._pointers[t]==e.pointerId)return!0;return!1}_trackPointer(e){let t=this._pointerPositions[e.pointerId];t===void 0&&(t=new Ye,this._pointerPositions[e.pointerId]=t),t.set(e.pageX,e.pageY)}_getSecondPointerPosition(e){const t=e.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[t]}_customWheelEvent(e){const t=e.deltaMode,r={clientX:e.clientX,clientY:e.clientY,deltaY:e.deltaY};switch(t){case 1:r.deltaY*=16;break;case 2:r.deltaY*=100;break}return e.ctrlKey&&!this._controlActive&&(r.deltaY*=10),r}}function Bz(n){this.enabled!==!1&&(this._pointers.length===0&&(this.domElement.setPointerCapture(n.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),!this._isTrackingPointer(n)&&(this._addPointer(n),n.pointerType==="touch"?this._onTouchStart(n):this._onMouseDown(n)))}function Vz(n){this.enabled!==!1&&(n.pointerType==="touch"?this._onTouchMove(n):this._onMouseMove(n))}function Gz(n){switch(this._removePointer(n),this._pointers.length){case 0:this.domElement.releasePointerCapture(n.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(PE),this.state=Yt.NONE;break;case 1:const e=this._pointers[0],t=this._pointerPositions[e];this._onTouchStart({pointerId:e,pageX:t.x,pageY:t.y});break}}function Hz(n){let e;switch(n.button){case 0:e=this.mouseButtons.LEFT;break;case 1:e=this.mouseButtons.MIDDLE;break;case 2:e=this.mouseButtons.RIGHT;break;default:e=-1}switch(e){case _i.DOLLY:if(this.enableZoom===!1)return;this._handleMouseDownDolly(n),this.state=Yt.DOLLY;break;case _i.ROTATE:if(n.ctrlKey||n.metaKey||n.shiftKey){if(this.enablePan===!1)return;this._handleMouseDownPan(n),this.state=Yt.PAN}else{if(this.enableRotate===!1)return;this._handleMouseDownRotate(n),this.state=Yt.ROTATE}break;case _i.PAN:if(n.ctrlKey||n.metaKey||n.shiftKey){if(this.enableRotate===!1)return;this._handleMouseDownRotate(n),this.state=Yt.ROTATE}else{if(this.enablePan===!1)return;this._handleMouseDownPan(n),this.state=Yt.PAN}break;default:this.state=Yt.NONE}this.state!==Yt.NONE&&this.dispatchEvent(b0)}function Wz(n){switch(this.state){case Yt.ROTATE:if(this.enableRotate===!1)return;this._handleMouseMoveRotate(n);break;case Yt.DOLLY:if(this.enableZoom===!1)return;this._handleMouseMoveDolly(n);break;case Yt.PAN:if(this.enablePan===!1)return;this._handleMouseMovePan(n);break}}function qz(n){this.enabled===!1||this.enableZoom===!1||this.state!==Yt.NONE||(n.preventDefault(),this.dispatchEvent(b0),this._handleMouseWheel(this._customWheelEvent(n)),this.dispatchEvent(PE))}function Xz(n){this.enabled===!1||this.enablePan===!1||this._handleKeyDown(n)}function Kz(n){switch(this._trackPointer(n),this._pointers.length){case 1:switch(this.touches.ONE){case Cc.ROTATE:if(this.enableRotate===!1)return;this._handleTouchStartRotate(n),this.state=Yt.TOUCH_ROTATE;break;case Cc.PAN:if(this.enablePan===!1)return;this._handleTouchStartPan(n),this.state=Yt.TOUCH_PAN;break;default:this.state=Yt.NONE}break;case 2:switch(this.touches.TWO){case Cc.DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchStartDollyPan(n),this.state=Yt.TOUCH_DOLLY_PAN;break;case Cc.DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchStartDollyRotate(n),this.state=Yt.TOUCH_DOLLY_ROTATE;break;default:this.state=Yt.NONE}break;default:this.state=Yt.NONE}this.state!==Yt.NONE&&this.dispatchEvent(b0)}function jz(n){switch(this._trackPointer(n),this.state){case Yt.TOUCH_ROTATE:if(this.enableRotate===!1)return;this._handleTouchMoveRotate(n),this.update();break;case Yt.TOUCH_PAN:if(this.enablePan===!1)return;this._handleTouchMovePan(n),this.update();break;case Yt.TOUCH_DOLLY_PAN:if(this.enableZoom===!1&&this.enablePan===!1)return;this._handleTouchMoveDollyPan(n),this.update();break;case Yt.TOUCH_DOLLY_ROTATE:if(this.enableZoom===!1&&this.enableRotate===!1)return;this._handleTouchMoveDollyRotate(n),this.update();break;default:this.state=Yt.NONE}}function Yz(n){this.enabled!==!1&&n.preventDefault()}function Zz(n){n.key==="Control"&&(this._controlActive=!0,this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}function Qz(n){n.key==="Control"&&(this._controlActive=!1,this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0}))}const Dv={type:"change"},_0={type:"start"},y0={type:"end"},r2=1e-6,Ut={NONE:-1,ROTATE:0,ZOOM:1,PAN:2,TOUCH_ROTATE:3,TOUCH_ZOOM_PAN:4},qd=new Ye,fa=new Ye,Jz=new $,Xd=new $,Lv=new $,xc=new Xi,i2=new $,Kd=new $,Ov=new $,jd=new $;class eP extends LE{constructor(e,t=null){super(e,t),this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.keys=["KeyA","KeyS","KeyD"],this.mouseButtons={LEFT:_i.ROTATE,MIDDLE:_i.DOLLY,RIGHT:_i.PAN},this.state=Ut.NONE,this.keyState=Ut.NONE,this.target=new $,this._lastPosition=new $,this._lastZoom=1,this._touchZoomDistanceStart=0,this._touchZoomDistanceEnd=0,this._lastAngle=0,this._eye=new $,this._movePrev=new Ye,this._moveCurr=new Ye,this._lastAxis=new $,this._zoomStart=new Ye,this._zoomEnd=new Ye,this._panStart=new Ye,this._panEnd=new Ye,this._pointers=[],this._pointerPositions={},this._onPointerMove=nP.bind(this),this._onPointerDown=tP.bind(this),this._onPointerUp=rP.bind(this),this._onPointerCancel=iP.bind(this),this._onContextMenu=fP.bind(this),this._onMouseWheel=uP.bind(this),this._onKeyDown=aP.bind(this),this._onKeyUp=sP.bind(this),this._onTouchStart=dP.bind(this),this._onTouchMove=hP.bind(this),this._onTouchEnd=pP.bind(this),this._onMouseDown=oP.bind(this),this._onMouseMove=cP.bind(this),this._onMouseUp=lP.bind(this),this._target0=this.target.clone(),this._position0=this.object.position.clone(),this._up0=this.object.up.clone(),this._zoom0=this.object.zoom,t!==null&&(this.connect(),this.handleResize()),this.update()}connect(){window.addEventListener("keydown",this._onKeyDown),window.addEventListener("keyup",this._onKeyUp),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerCancel),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1}),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.style.touchAction="none"}disconnect(){window.removeEventListener("keydown",this._onKeyDown),window.removeEventListener("keyup",this._onKeyUp),this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerCancel),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}handleResize(){const e=this.domElement.getBoundingClientRect(),t=this.domElement.ownerDocument.documentElement;this.screen.left=e.left+window.pageXOffset-t.clientLeft,this.screen.top=e.top+window.pageYOffset-t.clientTop,this.screen.width=e.width,this.screen.height=e.height}update(){this._eye.subVectors(this.object.position,this.target),this.noRotate||this._rotateCamera(),this.noZoom||this._zoomCamera(),this.noPan||this._panCamera(),this.object.position.addVectors(this.target,this._eye),this.object.isPerspectiveCamera?(this._checkDistances(),this.object.lookAt(this.target),this._lastPosition.distanceToSquared(this.object.position)>r2&&(this.dispatchEvent(Dv),this._lastPosition.copy(this.object.position))):this.object.isOrthographicCamera?(this.object.lookAt(this.target),(this._lastPosition.distanceToSquared(this.object.position)>r2||this._lastZoom!==this.object.zoom)&&(this.dispatchEvent(Dv),this._lastPosition.copy(this.object.position),this._lastZoom=this.object.zoom)):console.warn("THREE.TrackballControls: Unsupported camera type.")}reset(){this.state=Ut.NONE,this.keyState=Ut.NONE,this.target.copy(this._target0),this.object.position.copy(this._position0),this.object.up.copy(this._up0),this.object.zoom=this._zoom0,this.object.updateProjectionMatrix(),this._eye.subVectors(this.object.position,this.target),this.object.lookAt(this.target),this.dispatchEvent(Dv),this._lastPosition.copy(this.object.position),this._lastZoom=this.object.zoom}_panCamera(){if(fa.copy(this._panEnd).sub(this._panStart),fa.lengthSq()){if(this.object.isOrthographicCamera){const e=(this.object.right-this.object.left)/this.object.zoom/this.domElement.clientWidth,t=(this.object.top-this.object.bottom)/this.object.zoom/this.domElement.clientWidth;fa.x*=e,fa.y*=t}fa.multiplyScalar(this._eye.length()*this.panSpeed),Xd.copy(this._eye).cross(this.object.up).setLength(fa.x),Xd.add(Jz.copy(this.object.up).setLength(fa.y)),this.object.position.add(Xd),this.target.add(Xd),this.staticMoving?this._panStart.copy(this._panEnd):this._panStart.add(fa.subVectors(this._panEnd,this._panStart).multiplyScalar(this.dynamicDampingFactor))}}_rotateCamera(){jd.set(this._moveCurr.x-this._movePrev.x,this._moveCurr.y-this._movePrev.y,0);let e=jd.length();e?(this._eye.copy(this.object.position).sub(this.target),i2.copy(this._eye).normalize(),Kd.copy(this.object.up).normalize(),Ov.crossVectors(Kd,i2).normalize(),Kd.setLength(this._moveCurr.y-this._movePrev.y),Ov.setLength(this._moveCurr.x-this._movePrev.x),jd.copy(Kd.add(Ov)),Lv.crossVectors(jd,this._eye).normalize(),e*=this.rotateSpeed,xc.setFromAxisAngle(Lv,e),this._eye.applyQuaternion(xc),this.object.up.applyQuaternion(xc),this._lastAxis.copy(Lv),this._lastAngle=e):!this.staticMoving&&this._lastAngle&&(this._lastAngle*=Math.sqrt(1-this.dynamicDampingFactor),this._eye.copy(this.object.position).sub(this.target),xc.setFromAxisAngle(this._lastAxis,this._lastAngle),this._eye.applyQuaternion(xc),this.object.up.applyQuaternion(xc)),this._movePrev.copy(this._moveCurr)}_zoomCamera(){let e;this.state===Ut.TOUCH_ZOOM_PAN?(e=this._touchZoomDistanceStart/this._touchZoomDistanceEnd,this._touchZoomDistanceStart=this._touchZoomDistanceEnd,this.object.isPerspectiveCamera?this._eye.multiplyScalar(e):this.object.isOrthographicCamera?(this.object.zoom=Ih.clamp(this.object.zoom/e,this.minZoom,this.maxZoom),this._lastZoom!==this.object.zoom&&this.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")):(e=1+(this._zoomEnd.y-this._zoomStart.y)*this.zoomSpeed,e!==1&&e>0&&(this.object.isPerspectiveCamera?this._eye.multiplyScalar(e):this.object.isOrthographicCamera?(this.object.zoom=Ih.clamp(this.object.zoom/e,this.minZoom,this.maxZoom),this._lastZoom!==this.object.zoom&&this.object.updateProjectionMatrix()):console.warn("THREE.TrackballControls: Unsupported camera type")),this.staticMoving?this._zoomStart.copy(this._zoomEnd):this._zoomStart.y+=(this._zoomEnd.y-this._zoomStart.y)*this.dynamicDampingFactor)}_getMouseOnScreen(e,t){return qd.set((e-this.screen.left)/this.screen.width,(t-this.screen.top)/this.screen.height),qd}_getMouseOnCircle(e,t){return qd.set((e-this.screen.width*.5-this.screen.left)/(this.screen.width*.5),(this.screen.height+2*(this.screen.top-t))/this.screen.width),qd}_addPointer(e){this._pointers.push(e)}_removePointer(e){delete this._pointerPositions[e.pointerId];for(let t=0;t<this._pointers.length;t++)if(this._pointers[t].pointerId==e.pointerId){this._pointers.splice(t,1);return}}_trackPointer(e){let t=this._pointerPositions[e.pointerId];t===void 0&&(t=new Ye,this._pointerPositions[e.pointerId]=t),t.set(e.pageX,e.pageY)}_getSecondPointerPosition(e){const t=e.pointerId===this._pointers[0].pointerId?this._pointers[1]:this._pointers[0];return this._pointerPositions[t.pointerId]}_checkDistances(){(!this.noZoom||!this.noPan)&&(this._eye.lengthSq()>this.maxDistance*this.maxDistance&&(this.object.position.addVectors(this.target,this._eye.setLength(this.maxDistance)),this._zoomStart.copy(this._zoomEnd)),this._eye.lengthSq()<this.minDistance*this.minDistance&&(this.object.position.addVectors(this.target,this._eye.setLength(this.minDistance)),this._zoomStart.copy(this._zoomEnd)))}}function tP(n){this.enabled!==!1&&(this._pointers.length===0&&(this.domElement.setPointerCapture(n.pointerId),this.domElement.addEventListener("pointermove",this._onPointerMove),this.domElement.addEventListener("pointerup",this._onPointerUp)),this._addPointer(n),n.pointerType==="touch"?this._onTouchStart(n):this._onMouseDown(n))}function nP(n){this.enabled!==!1&&(n.pointerType==="touch"?this._onTouchMove(n):this._onMouseMove(n))}function rP(n){this.enabled!==!1&&(n.pointerType==="touch"?this._onTouchEnd(n):this._onMouseUp(),this._removePointer(n),this._pointers.length===0&&(this.domElement.releasePointerCapture(n.pointerId),this.domElement.removeEventListener("pointermove",this._onPointerMove),this.domElement.removeEventListener("pointerup",this._onPointerUp)))}function iP(n){this._removePointer(n)}function sP(){this.enabled!==!1&&(this.keyState=Ut.NONE,window.addEventListener("keydown",this._onKeyDown))}function aP(n){this.enabled!==!1&&(window.removeEventListener("keydown",this._onKeyDown),this.keyState===Ut.NONE&&(n.code===this.keys[Ut.ROTATE]&&!this.noRotate?this.keyState=Ut.ROTATE:n.code===this.keys[Ut.ZOOM]&&!this.noZoom?this.keyState=Ut.ZOOM:n.code===this.keys[Ut.PAN]&&!this.noPan&&(this.keyState=Ut.PAN)))}function oP(n){let e;switch(n.button){case 0:e=this.mouseButtons.LEFT;break;case 1:e=this.mouseButtons.MIDDLE;break;case 2:e=this.mouseButtons.RIGHT;break;default:e=-1}switch(e){case _i.DOLLY:this.state=Ut.ZOOM;break;case _i.ROTATE:this.state=Ut.ROTATE;break;case _i.PAN:this.state=Ut.PAN;break;default:this.state=Ut.NONE}const t=this.keyState!==Ut.NONE?this.keyState:this.state;t===Ut.ROTATE&&!this.noRotate?(this._moveCurr.copy(this._getMouseOnCircle(n.pageX,n.pageY)),this._movePrev.copy(this._moveCurr)):t===Ut.ZOOM&&!this.noZoom?(this._zoomStart.copy(this._getMouseOnScreen(n.pageX,n.pageY)),this._zoomEnd.copy(this._zoomStart)):t===Ut.PAN&&!this.noPan&&(this._panStart.copy(this._getMouseOnScreen(n.pageX,n.pageY)),this._panEnd.copy(this._panStart)),this.dispatchEvent(_0)}function cP(n){const e=this.keyState!==Ut.NONE?this.keyState:this.state;e===Ut.ROTATE&&!this.noRotate?(this._movePrev.copy(this._moveCurr),this._moveCurr.copy(this._getMouseOnCircle(n.pageX,n.pageY))):e===Ut.ZOOM&&!this.noZoom?this._zoomEnd.copy(this._getMouseOnScreen(n.pageX,n.pageY)):e===Ut.PAN&&!this.noPan&&this._panEnd.copy(this._getMouseOnScreen(n.pageX,n.pageY))}function lP(){this.state=Ut.NONE,this.dispatchEvent(y0)}function uP(n){if(this.enabled!==!1&&this.noZoom!==!0){switch(n.preventDefault(),n.deltaMode){case 2:this._zoomStart.y-=n.deltaY*.025;break;case 1:this._zoomStart.y-=n.deltaY*.01;break;default:this._zoomStart.y-=n.deltaY*25e-5;break}this.dispatchEvent(_0),this.dispatchEvent(y0)}}function fP(n){this.enabled!==!1&&n.preventDefault()}function dP(n){switch(this._trackPointer(n),this._pointers.length){case 1:this.state=Ut.TOUCH_ROTATE,this._moveCurr.copy(this._getMouseOnCircle(this._pointers[0].pageX,this._pointers[0].pageY)),this._movePrev.copy(this._moveCurr);break;default:this.state=Ut.TOUCH_ZOOM_PAN;const e=this._pointers[0].pageX-this._pointers[1].pageX,t=this._pointers[0].pageY-this._pointers[1].pageY;this._touchZoomDistanceEnd=this._touchZoomDistanceStart=Math.sqrt(e*e+t*t);const r=(this._pointers[0].pageX+this._pointers[1].pageX)/2,i=(this._pointers[0].pageY+this._pointers[1].pageY)/2;this._panStart.copy(this._getMouseOnScreen(r,i)),this._panEnd.copy(this._panStart);break}this.dispatchEvent(_0)}function hP(n){switch(this._trackPointer(n),this._pointers.length){case 1:this._movePrev.copy(this._moveCurr),this._moveCurr.copy(this._getMouseOnCircle(n.pageX,n.pageY));break;default:const e=this._getSecondPointerPosition(n),t=n.pageX-e.x,r=n.pageY-e.y;this._touchZoomDistanceEnd=Math.sqrt(t*t+r*r);const i=(n.pageX+e.x)/2,s=(n.pageY+e.y)/2;this._panEnd.copy(this._getMouseOnScreen(i,s));break}}function pP(n){switch(this._pointers.length){case 0:this.state=Ut.NONE;break;case 1:this.state=Ut.TOUCH_ROTATE,this._moveCurr.copy(this._getMouseOnCircle(n.pageX,n.pageY)),this._movePrev.copy(this._moveCurr);break;case 2:this.state=Ut.TOUCH_ZOOM_PAN;for(let e=0;e<this._pointers.length;e++)if(this._pointers[e].pointerId!==n.pointerId){const t=this._pointerPositions[this._pointers[e].pointerId];this._moveCurr.copy(this._getMouseOnCircle(t.x,t.y)),this._movePrev.copy(this._moveCurr);break}break}this.dispatchEvent(y0)}class mP{constructor(){this.experience=new Uo,this.sizes=this.experience.sizes,this.scene=this.experience.scene,this.canvas=this.experience.canvas,this.setInstance(),this.setTrackball()}setInstance(){this.instance=new Er(35,this.sizes.width/this.sizes.height,.001,10),this.instance.position.set(1,1,1),this.scene.add(this.instance)}setOrbit(){this.orbit=new Uz(this.instance,this.canvas),this.orbit.enableDamping=!0,this.orbit.enableZoom=!0,this.orbit.zoomToCursor=!0,this.orbit.zoomSpeed=2}setTrackball(){this.trackball=new eP(this.instance,this.canvas),this.trackball.staticMoving=!1,this.trackball.dynamicDampingFactor=.3,this.trackball.zoomSpeed=2,this.trackball.panSpeed=.05,this.trackball.rotateSpeed=1}setRaycaster(){this.raycaster=new xz,this.raycaster.setFromCamera(this.mouse.ndcPosition,this.instance)}resize(){this.instance.aspect=this.sizes.width/this.sizes.height,this.instance.updateProjectionMatrix()}update(){this.orbit&&this.orbit.update(),this.trackball&&this.trackball.update(),this.raycaster&&this.raycaster.setFromCamera(this.mouse.ndcPosition,this.instance)}destroy(){this.scene.remove(this.instance),this.orbit&&(this.orbit.dispose(),this.orbit=null),this.trackball&&(this.trackball.dispose(),this.trackball=null),this.raycaster&&(this.raycaster=null),this.instance&&(this.instance=null),this.experience=null,this.sizes=null,this.scene=null,this.canvas=null,console.log("Camera destroyed")}}class vP{constructor(){this.experience=new Uo,this.canvas=this.experience.canvas,this.context=this.experience.context,this.sizes=this.experience.sizes,this.scene=this.experience.scene,this.camera=this.experience.camera,this.setInstance()}setInstance(){this.instance=new kO({canvas:this.canvas,context:this.context,antialias:!1,depth:!1}),this.instance.setClearColor("#000000",1),this.instance.setSize(this.sizes.width,this.sizes.height),this.instance.setPixelRatio(this.sizes.pixelRatio),this.instance.shadowMap.enabled=!1}resize(){this.instance.setSize(this.sizes.width,this.sizes.height),this.instance.setPixelRatio(this.sizes.pixelRatio)}update(){this.instance.render(this.scene,this.camera.instance)}destroy(){this.instance&&(this.instance.dispose(),this.instance=null),this.experience=null,this.canvas=null,this.sizes=null,this.scene=null,this.camera=null,console.log("Renderer destroyed")}}const Mc={binary:{x_start:.5/256,x_end:255.5/256,y:.5/256},hsv:{x_start:.5/256,x_end:255.5/256,y:1.5/256},cividis:{x_start:.5/256,x_end:255.5/256,y:2.5/256},inferno:{x_start:.5/256,x_end:255.5/256,y:3.5/256},magma:{x_start:.5/256,x_end:255.5/256,y:4.5/256},plasma:{x_start:.5/256,x_end:255.5/256,y:5.5/256},viridis:{x_start:.5/256,x_end:255.5/256,y:6.5/256},blues:{x_start:.5/256,x_end:255.5/256,y:7.5/256},bugn:{x_start:.5/256,x_end:255.5/256,y:8.5/256},bupu:{x_start:.5/256,x_end:255.5/256,y:9.5/256},gnbu:{x_start:.5/256,x_end:255.5/256,y:10.5/256},greens:{x_start:.5/256,x_end:255.5/256,y:11.5/256},greys:{x_start:.5/256,x_end:255.5/256,y:12.5/256},oranges:{x_start:.5/256,x_end:255.5/256,y:13.5/256},orrd:{x_start:.5/256,x_end:255.5/256,y:14.5/256},pubu:{x_start:.5/256,x_end:255.5/256,y:15.5/256},pubugn:{x_start:.5/256,x_end:255.5/256,y:16.5/256},purples:{x_start:.5/256,x_end:255.5/256,y:17.5/256},rdpu:{x_start:.5/256,x_end:255.5/256,y:18.5/256},reds:{x_start:.5/256,x_end:255.5/256,y:19.5/256},ylgn:{x_start:.5/256,x_end:255.5/256,y:20.5/256},ylgnbu:{x_start:.5/256,x_end:255.5/256,y:21.5/256},ylorbr:{x_start:.5/256,x_end:255.5/256,y:22.5/256},ylorrd:{x_start:.5/256,x_end:255.5/256,y:23.5/256},afmhot:{x_start:.5/256,x_end:255.5/256,y:24.5/256},autumn:{x_start:.5/256,x_end:255.5/256,y:25.5/256},bone:{x_start:.5/256,x_end:255.5/256,y:26.5/256},cool:{x_start:.5/256,x_end:255.5/256,y:27.5/256},copper:{x_start:.5/256,x_end:255.5/256,y:28.5/256},gist_heat:{x_start:.5/256,x_end:255.5/256,y:29.5/256},gray:{x_start:.5/256,x_end:255.5/256,y:30.5/256},hot:{x_start:.5/256,x_end:255.5/256,y:31.5/256},pink:{x_start:.5/256,x_end:255.5/256,y:32.5/256},spring:{x_start:.5/256,x_end:255.5/256,y:33.5/256},summer:{x_start:.5/256,x_end:255.5/256,y:34.5/256},winter:{x_start:.5/256,x_end:255.5/256,y:35.5/256},wistia:{x_start:.5/256,x_end:255.5/256,y:36.5/256},brbg:{x_start:.5/256,x_end:255.5/256,y:37.5/256},bwr:{x_start:.5/256,x_end:255.5/256,y:38.5/256},coolwarm:{x_start:.5/256,x_end:255.5/256,y:39.5/256},piyg:{x_start:.5/256,x_end:255.5/256,y:40.5/256},prgn:{x_start:.5/256,x_end:255.5/256,y:41.5/256},puor:{x_start:.5/256,x_end:255.5/256,y:42.5/256},rdbu:{x_start:.5/256,x_end:255.5/256,y:43.5/256},rdgy:{x_start:.5/256,x_end:255.5/256,y:44.5/256},rdylbu:{x_start:.5/256,x_end:255.5/256,y:45.5/256},rdylgn:{x_start:.5/256,x_end:255.5/256,y:46.5/256},seismic:{x_start:.5/256,x_end:255.5/256,y:47.5/256},spectral:{x_start:.5/256,x_end:255.5/256,y:48.5/256},twilight_shifted:{x_start:.5/256,x_end:255.5/256,y:49.5/256},twilight:{x_start:.5/256,x_end:255.5/256,y:50.5/256},brg:{x_start:.5/256,x_end:255.5/256,y:51.5/256},cmrmap:{x_start:.5/256,x_end:255.5/256,y:52.5/256},cubehelix:{x_start:.5/256,x_end:255.5/256,y:53.5/256},flag:{x_start:.5/256,x_end:255.5/256,y:54.5/256},gist_earth:{x_start:.5/256,x_end:255.5/256,y:55.5/256},gist_ncar:{x_start:.5/256,x_end:255.5/256,y:56.5/256},gist_rainbow:{x_start:.5/256,x_end:255.5/256,y:57.5/256},gist_stern:{x_start:.5/256,x_end:255.5/256,y:58.5/256},gnuplot2:{x_start:.5/256,x_end:255.5/256,y:59.5/256},gnuplot:{x_start:.5/256,x_end:255.5/256,y:60.5/256},jet:{x_start:.5/256,x_end:255.5/256,y:61.5/256},nipy_spectral:{x_start:.5/256,x_end:255.5/256,y:62.5/256},ocean:{x_start:.5/256,x_end:255.5/256,y:63.5/256},prism:{x_start:.5/256,x_end:255.5/256,y:64.5/256},rainbow:{x_start:.5/256,x_end:255.5/256,y:65.5/256},terrain:{x_start:.5/256,x_end:255.5/256,y:66.5/256},bkr:{x_start:.5/256,x_end:255.5/256,y:67.5/256},bky:{x_start:.5/256,x_end:255.5/256,y:68.5/256},cet_d10:{x_start:.5/256,x_end:255.5/256,y:69.5/256},cet_d11:{x_start:.5/256,x_end:255.5/256,y:70.5/256},cet_d8:{x_start:.5/256,x_end:255.5/256,y:71.5/256},cet_d13:{x_start:.5/256,x_end:255.5/256,y:72.5/256},cet_d3:{x_start:.5/256,x_end:255.5/256,y:73.5/256},cet_d1a:{x_start:.5/256,x_end:255.5/256,y:74.5/256},bjy:{x_start:.5/256,x_end:255.5/256,y:75.5/256},gwv:{x_start:.5/256,x_end:255.5/256,y:76.5/256},bwy:{x_start:.5/256,x_end:255.5/256,y:77.5/256},cet_d12:{x_start:.5/256,x_end:255.5/256,y:78.5/256},cet_r3:{x_start:.5/256,x_end:255.5/256,y:79.5/256},cet_d9:{x_start:.5/256,x_end:255.5/256,y:80.5/256},cwr:{x_start:.5/256,x_end:255.5/256,y:81.5/256},cet_cbc1:{x_start:.5/256,x_end:255.5/256,y:82.5/256},cet_cbc2:{x_start:.5/256,x_end:255.5/256,y:83.5/256},cet_cbl1:{x_start:.5/256,x_end:255.5/256,y:84.5/256},cet_cbl2:{x_start:.5/256,x_end:255.5/256,y:85.5/256},cet_cbtc1:{x_start:.5/256,x_end:255.5/256,y:86.5/256},cet_cbtc2:{x_start:.5/256,x_end:255.5/256,y:87.5/256},cet_cbtl1:{x_start:.5/256,x_end:255.5/256,y:88.5/256},bgy:{x_start:.5/256,x_end:255.5/256,y:89.5/256},bgyw:{x_start:.5/256,x_end:255.5/256,y:90.5/256},bmw:{x_start:.5/256,x_end:255.5/256,y:91.5/256},cet_c1:{x_start:.5/256,x_end:255.5/256,y:92.5/256},cet_c1s:{x_start:.5/256,x_end:255.5/256,y:93.5/256},cet_c2:{x_start:.5/256,x_end:255.5/256,y:94.5/256},cet_c4:{x_start:.5/256,x_end:255.5/256,y:95.5/256},cet_c4s:{x_start:.5/256,x_end:255.5/256,y:96.5/256},cet_c5:{x_start:.5/256,x_end:255.5/256,y:97.5/256},cet_i1:{x_start:.5/256,x_end:255.5/256,y:98.5/256},cet_i3:{x_start:.5/256,x_end:255.5/256,y:99.5/256},cet_l10:{x_start:.5/256,x_end:255.5/256,y:100.5/256},cet_l11:{x_start:.5/256,x_end:255.5/256,y:101.5/256},cet_l12:{x_start:.5/256,x_end:255.5/256,y:102.5/256},cet_l16:{x_start:.5/256,x_end:255.5/256,y:103.5/256},cet_l17:{x_start:.5/256,x_end:255.5/256,y:104.5/256},cet_l18:{x_start:.5/256,x_end:255.5/256,y:105.5/256},cet_l19:{x_start:.5/256,x_end:255.5/256,y:106.5/256},cet_l4:{x_start:.5/256,x_end:255.5/256,y:107.5/256},cet_l7:{x_start:.5/256,x_end:255.5/256,y:108.5/256},cet_l8:{x_start:.5/256,x_end:255.5/256,y:109.5/256},cet_l9:{x_start:.5/256,x_end:255.5/256,y:110.5/256},cet_r1:{x_start:.5/256,x_end:255.5/256,y:111.5/256},cet_r2:{x_start:.5/256,x_end:255.5/256,y:112.5/256},colorwheel:{x_start:.5/256,x_end:255.5/256,y:113.5/256},fire:{x_start:.5/256,x_end:255.5/256,y:114.5/256},isolum:{x_start:.5/256,x_end:255.5/256,y:115.5/256},kb:{x_start:.5/256,x_end:255.5/256,y:116.5/256},kbc:{x_start:.5/256,x_end:255.5/256,y:117.5/256},kg:{x_start:.5/256,x_end:255.5/256,y:118.5/256},kgy:{x_start:.5/256,x_end:255.5/256,y:119.5/256},kr:{x_start:.5/256,x_end:255.5/256,y:120.5/256},black_body:{x_start:.5/256,x_end:255.5/256,y:121.5/256},kindlmann:{x_start:.5/256,x_end:255.5/256,y:122.5/256},extended_kindlmann:{x_start:.5/256,x_end:255.5/256,y:123.5/256},glasbey:{x_start:.5/256,x_end:255.5/256,y:176.5/256},glasbey_cool:{x_start:.5/256,x_end:255.5/256,y:177.5/256},glasbey_dark:{x_start:.5/256,x_end:255.5/256,y:178.5/256},glasbey_hv:{x_start:.5/256,x_end:255.5/256,y:179.5/256},glasbey_light:{x_start:.5/256,x_end:255.5/256,y:180.5/256},glasbey_warm:{x_start:.5/256,x_end:255.5/256,y:181.5/256},accent:{x_start:.5/256,x_end:7.5/256,y:240.5/256},dark2:{x_start:32.5/256,x_end:39.5/256,y:240.5/256},paired:{x_start:64.5/256,x_end:75.5/256,y:240.5/256},pastel1:{x_start:96.5/256,x_end:103.5/256,y:240.5/256},pastel2:{x_start:128.5/256,x_end:135.5/256,y:240.5/256},set1:{x_start:160.5/256,x_end:167.5/256,y:240.5/256},set2:{x_start:192.5/256,x_end:199.5/256,y:240.5/256},set3:{x_start:224.5/256,x_end:231.5/256,y:240.5/256},tab10:{x_start:.5/256,x_end:9.5/256,y:241.5/256},tab20:{x_start:32.5/256,x_end:51.5/256,y:241.5/256},tab20b:{x_start:64.5/256,x_end:83.5/256,y:241.5/256},tab20c:{x_start:96.5/256,x_end:115.5/256,y:241.5/256},category10_10:{x_start:128.5/256,x_end:137.5/256,y:241.5/256},category20_20:{x_start:160.5/256,x_end:179.5/256,y:241.5/256},category20b_20:{x_start:192.5/256,x_end:211.5/256,y:241.5/256},category20c_20:{x_start:224.5/256,x_end:243.5/256,y:241.5/256},colorblind8:{x_start:.5/256,x_end:7.5/256,y:242.5/256}};var gP=`out vec3 v_position;\r
out vec3 v_camera_position;\r
out vec3 v_camera_direction;\r
out vec3 v_ray_direction;

#ifndef UNIFORMS_VOLUME\r
#define UNIFORMS_VOLUME

struct UniformsVolume \r
{\r
    ivec3 dimensions;    \r
    vec3  inv_dimensions;   \r
    vec3  size; \r
    vec3  spacing;           \r
    vec3  anisotropy;           \r
    int   stride;\r
    ivec3 blocks;        \r
    mat4  grid_matrix;                 \r
};

uniform UniformsVolume u_volume;

#endif

void main() \r
{	\r
    const vec3 cameraDirection = vec3(0.0, 0.0, -1.0);\r
  \r
    
    v_position = vec3(u_volume.grid_matrix * vec4(position, 1.0));

    
    v_camera_position = vec3(u_volume.grid_matrix * inverse(modelMatrix) * vec4(cameraPosition, 1.0));   

    
    v_camera_direction = vec3(u_volume.grid_matrix * inverse(modelViewMatrix) * vec4(cameraDirection, 0.0));

    
    v_ray_direction = v_position - v_camera_position; 

    
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\r
}`,xP=`in vec3 v_position;\r
in vec3 v_camera_position;\r
in vec3 v_camera_direction;\r
in vec3 v_ray_direction;

out vec4 fragColor;

#ifndef MATH_CONSTANTS\r
#define MATH_CONSTANTS

struct MathConstants {\r
    float QTR_PI;\r
    float HALF_PI;\r
    float PI;\r
    float TWO_PI;\r
    float TAU;\r
    float INV_PI;\r
    float INV_SQRT_TAU;\r
    float SQRT_HALF_PI;\r
    float PHI;\r
    float GOLDEN_RATIO;\r
    float GOLDEN_RATIO_CONJUGATE;\r
    float GOLDEN_ANGLE;\r
    float EULER;\r
    float SQRT_2;         \r
    float SQRT_3;         \r
    float SQRT_5;         \r
    float LN_2;           \r
    float LN_10;          \r
    float LOG2_E;         \r
    float LOG10_E;        \r
    float DEG_TO_RAD;     \r
    float RAD_TO_DEG;     \r
    float CATALAN;        \r
    float APERY;   \r
};

const MathConstants MATH = MathConstants(\r
    0.78539816339,   \r
    1.57079632679,   \r
    3.14159265359,   \r
    6.28318530718,   \r
    6.28318530718,   \r
    0.31830988618,   \r
    0.39894228040,   \r
    1.25331413732,   \r
    1.61803398875,   \r
    1.61803398875,   \r
    0.61803398875,   \r
    2.39996323,      \r
    2.71828182846,   \r
    1.41421356237,   \r
    1.73205080757,   \r
    2.23606797750,   \r
    0.69314718056,   \r
    2.30258509299,   \r
    1.44269504089,   \r
    0.43429448190,   \r
    0.01745329252,   \r
    57.2957795131,   \r
    0.91596559417,   \r
    1.20205690316\r
);

#endif
#ifndef TOLERANCE_CONSTANTS
#define TOLERANCE_CONSTANTS

struct ToleranceConstants {
    float QUETTA;
    float RONNA;
    float YOTTA;
    float ZETTA;
    float EXA;
    float PETA;
    float TERA;
    float GIGA;
    float MEGA;
    float KILO;
    float HECTO;
    float DEKA;
    float DECI;
    float CENTI;
    float MILLI;
    float MICRO;
    float NANO;
    float PICO;
    float FEMTO;
    float ATTO;
    float ZEPTO;
    float YOCTO;
    float RONTO;
    float QUECTO;
    float HIGHP_MAX;
    float HIGHP_MIN;
    float MEDIUMP_MAX;
    float MEDIUMP_MIN;
    float LOWP_MAX;
    float LOWP_MIN;
};

const ToleranceConstants TOLERANCE = ToleranceConstants(
    1e30,
    1e27,
    1e24,
    1e21,
    1e18,
    1e15,
    1e12,
    1e9,
    1e6,
    1e3,
    1e2,
    1e1,
    1e-1,
    1e-2,
    1e-3,
    1e-6,
    1e-9,
    1e-12,
    1e-15,
    1e-18,
    1e-21,
    1e-24,
    1e-27,
    1e-30,
    3.402823e38,
    1.175494e-38,
    16.384,
    0.000061035,
    256.0,
    0.00390625
);

#endif
#ifndef COLOR_CONSTANTS\r
#define COLOR_CONSTANTS

struct ColorConstants {\r
    
    vec3 BLACK;\r
    vec3 WHITE;\r
    vec3 GRAY;\r
    vec3 LIGHT_GRAY;\r
    vec3 DARK_GRAY;\r
    vec3 TRANSPARENT;

    
    vec3 RED;\r
    vec3 GREEN;\r
    vec3 BLUE;

    vec3 LIGHT_RED;\r
    vec3 LIGHT_GREEN;\r
    vec3 LIGHT_BLUE;\r
    \r
    vec3 DARK_RED;\r
    vec3 DARK_GREEN;\r
    vec3 DARK_BLUE;

    
    vec3 CYAN;\r
    vec3 MAGENTA;\r
    vec3 YELLOW;\r
    vec3 LIGHT_CYAN;\r
    vec3 LIGHT_MAGENTA;\r
    vec3 LIGHT_YELLOW;\r
    vec3 DARK_CYAN;\r
    vec3 DARK_MAGENTA;\r
    vec3 DARK_YELLOW;

    
    vec3 PASTEL_RED;\r
    vec3 PASTEL_GREEN;\r
    vec3 PASTEL_BLUE;\r
    vec3 PASTEL_CYAN;\r
    vec3 PASTEL_MAGENTA;\r
    vec3 PASTEL_YELLOW;\r
    vec3 PASTEL_ORANGE;\r
    vec3 PASTEL_PINK;\r
    vec3 PASTEL_PURPLE;

    
    vec3 ORANGE;\r
    vec3 PINK;\r
    vec3 PURPLE;\r
    vec3 BROWN;\r
    vec3 TEAL;\r
    vec3 INDIGO;

    vec3 LIGHT_ORANGE;\r
    vec3 LIGHT_PINK;\r
    vec3 LIGHT_PURPLE;\r
    vec3 LIGHT_BROWN;\r
    vec3 LIGHT_TEAL;\r
    vec3 LIGHT_INDIGO;

    vec3 DARK_ORANGE;\r
    vec3 DARK_PINK;\r
    vec3 DARK_PURPLE;\r
    vec3 DARK_BROWN;\r
    vec3 DARK_TEAL;\r
    vec3 DARK_INDIGO;

    
    vec3 NAVY;\r
    vec3 LIME;\r
    vec3 SAND;\r
    vec3 SKY;\r
    vec3 MAROON;\r
    vec3 FOREST;

    
    vec3 GOLD;\r
    vec3 SILVER;\r
};

const ColorConstants COLOR = ColorConstants(\r
    
    vec3(0.0, 0.0, 0.0),       
    vec3(1.0, 1.0, 1.0),       
    vec3(0.5, 0.5, 0.5),       
    vec3(0.8, 0.8, 0.8),       
    vec3(0.3, 0.3, 0.3),       
    vec3(0.0, 0.0, 0.0),       

    
    vec3(1.0, 0.0, 0.0),       
    vec3(0.0, 1.0, 0.0),       
    vec3(0.0, 0.0, 1.0),       

    vec3(1.0, 0.4, 0.4),       
    vec3(0.5, 1.0, 0.5),       
    vec3(0.4, 0.6, 1.0),       

    vec3(0.4, 0.05, 0.05),     
    vec3(0.0, 0.3, 0.0),       
    vec3(0.05, 0.05, 0.4),     

    
    vec3(0.0, 1.0, 1.0),       
    vec3(1.0, 0.0, 1.0),       
    vec3(1.0, 1.0, 0.0),       

    vec3(0.6, 1.0, 1.0),       
    vec3(1.0, 0.6, 1.0),       
    vec3(1.0, 1.0, 0.6),       

    vec3(0.0, 0.4, 0.4),       
    vec3(0.4, 0.0, 0.4),       
    vec3(0.5, 0.5, 0.0),       

    
    vec3(1.0, 0.6, 0.6),       
    vec3(0.6, 1.0, 0.6),       
    vec3(0.6, 0.6, 1.0),       
    vec3(0.6, 1.0, 1.0),       
    vec3(1.0, 0.6, 1.0),       
    vec3(1.0, 1.0, 0.6),       
    vec3(1.0, 0.8, 0.6),       
    vec3(1.0, 0.8, 0.9),       
    vec3(0.8, 0.6, 1.0),       

    
    vec3(1.0, 0.5, 0.0),    
    vec3(1.0, 0.75, 0.8),   
    vec3(0.5, 0.0, 0.5),    
    vec3(0.6, 0.3, 0.0),    
    vec3(0.0, 0.5, 0.5),    
    vec3(0.3, 0.0, 0.5),    

    vec3(1.0, 0.7, 0.3),    
    vec3(1.0, 0.85, 0.9),   
    vec3(0.8, 0.6, 1.0),    
    vec3(0.8, 0.6, 0.4),    
    vec3(0.4, 0.8, 0.8),    
    vec3(0.6, 0.4, 0.9),    

    vec3(0.7, 0.3, 0.0),    
    vec3(0.8, 0.4, 0.5),    
    vec3(0.3, 0.0, 0.3),    
    vec3(0.4, 0.2, 0.0),    
    vec3(0.0, 0.3, 0.3),    
    vec3(0.2, 0.0, 0.4),     

    
    vec3(0.0, 0.0, 0.3),       
    vec3(0.6, 1.0, 0.4),       
    vec3(0.94, 0.87, 0.72),    
    vec3(0.6, 0.8, 1.0),       
    vec3(0.5, 0.0, 0.0),       
    vec3(0.13, 0.55, 0.13),    

    
    vec3(1.0, 0.84, 0.0),      
    vec3(0.75, 0.75, 0.75)     
);

#endif\r
#ifndef INTERSECTED_PLANE\r
#define INTERSECTED_PLANE

#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif

bool intersected_plane(vec4 hessian, vec3 origin, vec3 direction) \r
{\r
    float denominator = dot(hessian.xyz, direction);\r
    if ( abs(denominator) < MICRO_TOLERANCE ) \r
    {\r
        return false;\r
    }

    float distance = -dot(hessian, vec4(origin, 1.0)) / denominator;\r
    return distance > 0.0;\r
}

#endif
#ifndef INTERSECTED_BOX\r
#define INTERSECTED_BOX

#ifndef MMIN\r
#ifndef MMIN\r
#define MMIN

float mmin(in float a) { return a; }\r
float mmin(in float a,in float b) { return min(a, b); }\r
float mmin(in float a,in float b, in float c) { return min(a, min(b, c)); }\r
float mmin(in float a,in float b, in float c, in float d) { return min(min(a,b), min(c, d)); }

float mmin(vec2 v) { return min(v.x, v.y); }\r
float mmin(vec3 v) { return mmin(v.x, v.y, v.z); }\r
float mmin(vec4 v) { return mmin(v.x, v.y, v.z, v.w); }\r
float mmin(float v[5]) \r
{\r
    float r = v[0];\r
    r = min(r, v[1]);\r
    r = min(r, v[2]);\r
    r = min(r, v[3]);\r
    r = min(r, v[4]);\r
    return r;\r
}\r
float mmin(float v[6]) \r
{\r
    float r = v[0];\r
    r = min(r, v[1]);\r
    r = min(r, v[2]);\r
    r = min(r, v[3]);\r
    r = min(r, v[4]);\r
    r = min(r, v[5]);\r
    return r;\r
}

#endif\r
#endif\r
#ifndef MMAX\r
#ifndef MMAX\r
#define MMAX

float mmax(in float a) { return a; }\r
float mmax(in float a, in float b) { return max(a, b); }\r
float mmax(in float a, in float b, in float c) { return max(a, max(b, c)); }\r
float mmax(in float a, in float b, in float c, in float d) { return max(max(a, b), max(c, d)); }\r
float mmax(vec2 v) { return max(v.x, v.y); }\r
float mmax(vec3 v) { return mmax(v.x, v.y, v.z); }\r
float mmax(vec4 v) { return mmax(v.x, v.y, v.z, v.w); }\r
float mmax(float v[5]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    return r;\r
}\r
float mmax(float v[6]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    r = max(r, v[5]);\r
    return r;\r
}

vec2 mmax(mat2 A)\r
{\r
    vec2 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    return r;\r
}\r
vec3 mmax(mat3 A)\r
{\r
    vec3 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    return r;\r
}\r
vec4 mmax(mat4 A)\r
{\r
    vec4 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    r[3] = mmax(A[3]);\r
    return r;\r
}

#endif\r
#endif

bool intersected_box(vec3 box_min, vec3 box_max, vec3 start, vec3 dir) \r
{\r
    vec3 inv_dir = 1.0 / dir;\r
    vec3 b_min = (box_min - start) * inv_dir;\r
    vec3 b_max = (box_max - start) * inv_dir;\r
    float t_entry = mmax(min(b_min, b_max));\r
    float t_exit  = mmin(max(b_min, b_max));\r
    return t_exit >= max(t_entry, 0.0);\r
}

#endif
#ifndef INTERSECT_PLANE
#define INTERSECT_PLANE

#ifndef MICRO_TOLERANCE
#define MICRO_TOLERANCE 1e-6
#endif

float intersect_plane(vec4 hessian, vec3 origin, vec3 direction) 
{
    float denominator = dot(hessian.xyz, direction);
    if ( abs(denominator) < MICRO_TOLERANCE ) 
    {
        return -1.0;
    }

    float distance = -dot(hessian, vec4(origin, 1.0)) / denominator;
    return distance;
}

#endif
#ifndef INTERSECT_BOX\r
#define INTERSECT_BOX

#ifndef MMIN\r
#ifndef MMIN\r
#define MMIN

float mmin(in float a) { return a; }\r
float mmin(in float a,in float b) { return min(a, b); }\r
float mmin(in float a,in float b, in float c) { return min(a, min(b, c)); }\r
float mmin(in float a,in float b, in float c, in float d) { return min(min(a,b), min(c, d)); }

float mmin(vec2 v) { return min(v.x, v.y); }\r
float mmin(vec3 v) { return mmin(v.x, v.y, v.z); }\r
float mmin(vec4 v) { return mmin(v.x, v.y, v.z, v.w); }\r
float mmin(float v[5]) \r
{\r
    float r = v[0];\r
    r = min(r, v[1]);\r
    r = min(r, v[2]);\r
    r = min(r, v[3]);\r
    r = min(r, v[4]);\r
    return r;\r
}\r
float mmin(float v[6]) \r
{\r
    float r = v[0];\r
    r = min(r, v[1]);\r
    r = min(r, v[2]);\r
    r = min(r, v[3]);\r
    r = min(r, v[4]);\r
    r = min(r, v[5]);\r
    return r;\r
}

#endif\r
#endif\r
#ifndef MMAX\r
#ifndef MMAX\r
#define MMAX

float mmax(in float a) { return a; }\r
float mmax(in float a, in float b) { return max(a, b); }\r
float mmax(in float a, in float b, in float c) { return max(a, max(b, c)); }\r
float mmax(in float a, in float b, in float c, in float d) { return max(max(a, b), max(c, d)); }\r
float mmax(vec2 v) { return max(v.x, v.y); }\r
float mmax(vec3 v) { return mmax(v.x, v.y, v.z); }\r
float mmax(vec4 v) { return mmax(v.x, v.y, v.z, v.w); }\r
float mmax(float v[5]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    return r;\r
}\r
float mmax(float v[6]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    r = max(r, v[5]);\r
    return r;\r
}

vec2 mmax(mat2 A)\r
{\r
    vec2 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    return r;\r
}\r
vec3 mmax(mat3 A)\r
{\r
    vec3 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    return r;\r
}\r
vec4 mmax(mat4 A)\r
{\r
    vec4 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    r[3] = mmax(A[3]);\r
    return r;\r
}

#endif\r
#endif\r
#ifndef ARGMIN\r
#ifndef ARGMIN
#define ARGMIN

int argmin(in float x) 
{ 
    return 0; 
}

int argmin(in vec2 v) 
{ 
    return int(v.x > v.y); 
}

int argmin(in vec3 v) 
{ 
    int i = int(v.x > v.y);
    i += int(v[i] > v.z) * (2 - i);
    return i;
}

int argmin(in vec4 v) 
{ 
    int i = int(v.x > v.y);
    i += int(v[i] > v.z) * (2 - i);
    i += int(v[i] > v.w) * (3 - i);
    return i;
}

int argmin(in float x, in float y) 
{ 
    return argmin(vec2(x, y)); 
}

int argmin(in float x, in float y, in float z) 
{ 
    return argmin(vec3(x, y, z));
}

int argmin(in float x, in float y, in float z, in float w) 
{ 
    return argmin(vec4(x, y, z, w));
}

#endif\r
#endif\r
#ifndef ARGMAX\r
#ifndef ARGMAX
#define ARGMAX

int argmax(in float x) 
{ 
    return 0; 
}

int argmax(in vec2 v) 
{ 
    return int(v.x < v.y); 
}

int argmax(in vec3 v) 
{ 
    int i = int(v.x < v.y);
    i += int(v[i] < v.z) * (2 - i);
    return i;
}

int argmax(in vec4 v) 
{ 
    int i = int(v.x < v.y);
    i += int(v[i] < v.z) * (2 - i);
    i += int(v[i] < v.w) * (3 - i);
    return i;
}

int argmax(in float x, in float y) 
{ 
    return argmax(vec2(x, y)); 
}

int argmax(in float x, in float y, in float z) 
{ 
    return argmax(vec3(x, y, z));
}

int argmax(in float x, in float y, in float z, in float w) 
{ 
    return argmax(vec4(x, y, z, w));
}

#endif\r
#endif

vec2 intersect_box(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir) \r
{\r
    vec3 b_min = (box_min - start) * inv_dir;\r
    vec3 b_max = (box_max - start) * inv_dir;\r
    float t_entry = mmax(min(b_min, b_max));\r
    float t_exit  = mmin(max(b_min, b_max));\r
    return vec2(t_entry, t_exit);\r
}

vec2 intersect_box(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir, out int entry_axis, out int exit_axis) \r
{\r
    vec3 b_min = (box_min - start) * inv_dir;\r
    vec3 b_max = (box_max - start) * inv_dir;\r
    vec3 t_min = min(b_min, b_max);\r
    vec3 t_max = max(b_min, b_max);\r
    float t_entry = mmax(t_min);\r
    float t_exit  = mmin(t_max);\r
    entry_axis = argmax(t_min);\r
    exit_axis = argmin(t_max);\r
    return vec2(t_entry, t_exit);\r
}

vec2 intersect_box(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir, out ivec3 entry_normal, out ivec3 exit_normal) \r
{\r
    vec3 b_min = (box_min - start) * inv_dir;\r
    vec3 b_max = (box_max - start) * inv_dir;\r
    vec3 t_min = min(b_min, b_max);\r
    vec3 t_max = max(b_min, b_max);\r
    float t_entry = mmax(t_min);\r
    float t_exit  = mmin(t_max);\r
    entry_normal = ivec3(equal(t_min, vec3(t_entry)));\r
    exit_normal = ivec3(equal(t_max, vec3(t_exit)));\r
    return vec2(t_entry, t_exit);\r
}

#endif
#ifndef INTERSECT_BOX_MIN\r
#define INTERSECT_BOX_MIN

#ifndef MMAX\r
#ifndef MMAX\r
#define MMAX

float mmax(in float a) { return a; }\r
float mmax(in float a, in float b) { return max(a, b); }\r
float mmax(in float a, in float b, in float c) { return max(a, max(b, c)); }\r
float mmax(in float a, in float b, in float c, in float d) { return max(max(a, b), max(c, d)); }\r
float mmax(vec2 v) { return max(v.x, v.y); }\r
float mmax(vec3 v) { return mmax(v.x, v.y, v.z); }\r
float mmax(vec4 v) { return mmax(v.x, v.y, v.z, v.w); }\r
float mmax(float v[5]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    return r;\r
}\r
float mmax(float v[6]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    r = max(r, v[5]);\r
    return r;\r
}

vec2 mmax(mat2 A)\r
{\r
    vec2 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    return r;\r
}\r
vec3 mmax(mat3 A)\r
{\r
    vec3 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    return r;\r
}\r
vec4 mmax(mat4 A)\r
{\r
    vec4 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    r[3] = mmax(A[3]);\r
    return r;\r
}

#endif\r
#endif\r
#ifndef ARGMAX\r
#ifndef ARGMAX
#define ARGMAX

int argmax(in float x) 
{ 
    return 0; 
}

int argmax(in vec2 v) 
{ 
    return int(v.x < v.y); 
}

int argmax(in vec3 v) 
{ 
    int i = int(v.x < v.y);
    i += int(v[i] < v.z) * (2 - i);
    return i;
}

int argmax(in vec4 v) 
{ 
    int i = int(v.x < v.y);
    i += int(v[i] < v.z) * (2 - i);
    i += int(v[i] < v.w) * (3 - i);
    return i;
}

int argmax(in float x, in float y) 
{ 
    return argmax(vec2(x, y)); 
}

int argmax(in float x, in float y, in float z) 
{ 
    return argmax(vec3(x, y, z));
}

int argmax(in float x, in float y, in float z, in float w) 
{ 
    return argmax(vec4(x, y, z, w));
}

#endif\r
#endif

float intersect_box_entry(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir) \r
{\r
    vec3 t_min_tmp = (box_min - start) * inv_dir;\r
    vec3 t_max_tmp = (box_max - start) * inv_dir;\r
    vec3 t_min = min(t_min_tmp, t_max_tmp);\r
    float t_entry = mmax(t_min);\r
    return t_entry;\r
}

float intersect_box_entry(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir, out int axis) \r
{\r
    vec3 t_min_tmp = (box_min - start) * inv_dir;\r
    vec3 t_max_tmp = (box_max - start) * inv_dir;\r
    vec3 t_min = min(t_min_tmp, t_max_tmp);\r
    float t_entry = mmax(t_min);\r
    axis = argmax(t_min);\r
    return t_entry;\r
}

float intersect_box_entry(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir, out ivec3 normal) \r
{\r
    vec3 t_min_tmp = (box_min - start) * inv_dir;\r
    vec3 t_max_tmp = (box_max - start) * inv_dir;\r
    vec3 t_min = min(t_min_tmp, t_max_tmp);\r
    float t_entry = mmax(t_min);\r
    normal = ivec3(equal(t_min, vec3(t_entry)));\r
    return t_entry;\r
}

#endif
#ifndef INTERSECT_BOX_EXIT\r
#define INTERSECT_BOX_EXIT

#ifndef MILLI_TOLERANCE\r
#define MILLI_TOLERANCE 1e-3\r
#endif\r
#ifndef MMIN\r
#ifndef MMIN\r
#define MMIN

float mmin(in float a) { return a; }\r
float mmin(in float a,in float b) { return min(a, b); }\r
float mmin(in float a,in float b, in float c) { return min(a, min(b, c)); }\r
float mmin(in float a,in float b, in float c, in float d) { return min(min(a,b), min(c, d)); }

float mmin(vec2 v) { return min(v.x, v.y); }\r
float mmin(vec3 v) { return mmin(v.x, v.y, v.z); }\r
float mmin(vec4 v) { return mmin(v.x, v.y, v.z, v.w); }\r
float mmin(float v[5]) \r
{\r
    float r = v[0];\r
    r = min(r, v[1]);\r
    r = min(r, v[2]);\r
    r = min(r, v[3]);\r
    r = min(r, v[4]);\r
    return r;\r
}\r
float mmin(float v[6]) \r
{\r
    float r = v[0];\r
    r = min(r, v[1]);\r
    r = min(r, v[2]);\r
    r = min(r, v[3]);\r
    r = min(r, v[4]);\r
    r = min(r, v[5]);\r
    return r;\r
}

#endif\r
#endif\r
#ifndef ARGMIN\r
#ifndef ARGMIN
#define ARGMIN

int argmin(in float x) 
{ 
    return 0; 
}

int argmin(in vec2 v) 
{ 
    return int(v.x > v.y); 
}

int argmin(in vec3 v) 
{ 
    int i = int(v.x > v.y);
    i += int(v[i] > v.z) * (2 - i);
    return i;
}

int argmin(in vec4 v) 
{ 
    int i = int(v.x > v.y);
    i += int(v[i] > v.z) * (2 - i);
    i += int(v[i] > v.w) * (3 - i);
    return i;
}

int argmin(in float x, in float y) 
{ 
    return argmin(vec2(x, y)); 
}

int argmin(in float x, in float y, in float z) 
{ 
    return argmin(vec3(x, y, z));
}

int argmin(in float x, in float y, in float z, in float w) 
{ 
    return argmin(vec4(x, y, z, w));
}

#endif\r
#endif

float intersect_box_exit(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir) \r
{\r
    vec3 b_min = (box_min - start) * inv_dir;\r
    vec3 b_max = (box_max - start) * inv_dir;\r
    vec3 t_max = max(b_min, b_max);\r
    float t_exit = mmin(t_max);\r
    return t_exit;\r
}

float intersect_box_exit(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir, out int axis) \r
{\r
    vec3 b_min = (box_min - start) * inv_dir;\r
    vec3 b_max = (box_max - start) * inv_dir;\r
    vec3 t_max = max(b_min, b_max);\r
    float t_exit = mmin(t_max);\r
    axis = argmin(t_max);\r
    return t_exit;\r
}

float intersect_box_exit(vec3 box_min, vec3 box_max, vec3 start, vec3 inv_dir, out ivec3 normal) \r
{\r
    vec3 b_min = (box_min - start) * inv_dir;\r
    vec3 b_max = (box_max - start) * inv_dir;\r
    vec3 t_max = max(b_min, b_max);\r
    float t_exit = mmin(t_max);\r
    normal = ivec3(equal(t_max, vec3(t_exit)));\r
    return t_exit;\r
}

#endif\r
#ifndef INSIDE_OPEN
#define INSIDE_OPEN

#ifndef AND
#ifndef AND
#define AND

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  and(in bool  a, in bool  b) { return (a && b); }
bvec2 and(in bvec2 a, in bvec2 b) { return bvec2(a.x && b.x, a.y && b.y); }
bvec3 and(in bvec3 a, in bvec3 b) { return bvec3(a.x && b.x, a.y && b.y, a.z && b.z); }
bvec4 and(in bvec4 a, in bvec4 b) { return bvec4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool  and(in int   a, in int   b) { return and(on(a), on(b)); }
bvec2 and(in ivec2 a, in ivec2 b) { return and(on(a), on(b)); }
bvec3 and(in ivec3 a, in ivec3 b) { return and(on(a), on(b)); }
bvec4 and(in ivec4 a, in ivec4 b) { return and(on(a), on(b)); }

bool  and(in float a, in float b) { return and(on(a), on(b)); }
bvec2 and(in vec2  a, in vec2  b) { return and(on(a), on(b)); }
bvec3 and(in vec3  a, in vec3  b) { return and(on(a), on(b)); }
bvec4 and(in vec4  a, in vec4  b) { return and(on(a), on(b)); }

#endif
#endif

bool   inside_open(in float a, in float b, in float x) { return and(x > a, x < b); }
bvec2  inside_open(in float a, in float b, in vec2  x) { return and(greaterThan(x, vec2(a)), lessThan(x, vec2(b))); }
bvec3  inside_open(in float a, in float b, in vec3  x) { return and(greaterThan(x, vec3(a)), lessThan(x, vec3(b))); }
bvec4  inside_open(in float a, in float b, in vec4  x) { return and(greaterThan(x, vec4(a)), lessThan(x, vec4(b))); }
bvec2  inside_open(in vec2  a, in vec2  b, in vec2  x) { return and(greaterThan(x, a), lessThan(x, b)); }
bvec3  inside_open(in vec3  a, in vec3  b, in vec3  x) { return and(greaterThan(x, a), lessThan(x, b)); }
bvec4  inside_open(in vec4  a, in vec4  b, in vec4  x) { return and(greaterThan(x, a), lessThan(x, b)); }

bool   inside_open(in int   a, in int   b, in int   x) { return and(x > a, x < b); }
bvec2  inside_open(in int   a, in int   b, in ivec2 x) { return and(greaterThan(x, ivec2(a)), lessThan(x, ivec2(b))); }
bvec3  inside_open(in int   a, in int   b, in ivec3 x) { return and(greaterThan(x, ivec3(a)), lessThan(x, ivec3(b))); }
bvec4  inside_open(in int   a, in int   b, in ivec4 x) { return and(greaterThan(x, ivec4(a)), lessThan(x, ivec4(b))); }
bvec2  inside_open(in ivec2 a, in ivec2 b, in ivec2 x) { return and(greaterThan(x, a), lessThan(x, b)); }
bvec3  inside_open(in ivec3 a, in ivec3 b, in ivec3 x) { return and(greaterThan(x, a), lessThan(x, b)); }
bvec4  inside_open(in ivec4 a, in ivec4 b, in ivec4 x) { return and(greaterThan(x, a), lessThan(x, b)); }

#endif
#ifndef INSIDE_CLOSED
#define INSIDE_CLOSED

#ifndef AND
#ifndef AND
#define AND

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  and(in bool  a, in bool  b) { return (a && b); }
bvec2 and(in bvec2 a, in bvec2 b) { return bvec2(a.x && b.x, a.y && b.y); }
bvec3 and(in bvec3 a, in bvec3 b) { return bvec3(a.x && b.x, a.y && b.y, a.z && b.z); }
bvec4 and(in bvec4 a, in bvec4 b) { return bvec4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool  and(in int   a, in int   b) { return and(on(a), on(b)); }
bvec2 and(in ivec2 a, in ivec2 b) { return and(on(a), on(b)); }
bvec3 and(in ivec3 a, in ivec3 b) { return and(on(a), on(b)); }
bvec4 and(in ivec4 a, in ivec4 b) { return and(on(a), on(b)); }

bool  and(in float a, in float b) { return and(on(a), on(b)); }
bvec2 and(in vec2  a, in vec2  b) { return and(on(a), on(b)); }
bvec3 and(in vec3  a, in vec3  b) { return and(on(a), on(b)); }
bvec4 and(in vec4  a, in vec4  b) { return and(on(a), on(b)); }

#endif
#endif

bool   inside_closed(in float a, in float b, in float x) { return and(x >= a, x <= b); }
bvec2  inside_closed(in float a, in float b, in vec2  x) { return and(greaterThanEqual(x, vec2(a)), lessThanEqual(x, vec2(b))); }
bvec3  inside_closed(in float a, in float b, in vec3  x) { return and(greaterThanEqual(x, vec3(a)), lessThanEqual(x, vec3(b))); }
bvec4  inside_closed(in float a, in float b, in vec4  x) { return and(greaterThanEqual(x, vec4(a)), lessThanEqual(x, vec4(b))); }
bvec2  inside_closed(in vec2  a, in vec2  b, in vec2  x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }
bvec3  inside_closed(in vec3  a, in vec3  b, in vec3  x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }
bvec4  inside_closed(in vec4  a, in vec4  b, in vec4  x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }

bool   inside_closed(in int   a, in int   b, in int   x) { return and(x >= a, x <= b); }
bvec2  inside_closed(in int   a, in int   b, in ivec2 x) { return and(greaterThanEqual(x, ivec2(a)), lessThanEqual(x, ivec2(b))); }
bvec3  inside_closed(in int   a, in int   b, in ivec3 x) { return and(greaterThanEqual(x, ivec3(a)), lessThanEqual(x, ivec3(b))); }
bvec4  inside_closed(in int   a, in int   b, in ivec4 x) { return and(greaterThanEqual(x, ivec4(a)), lessThanEqual(x, ivec4(b))); }
bvec2  inside_closed(in ivec2 a, in ivec2 b, in ivec2 x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }
bvec3  inside_closed(in ivec3 a, in ivec3 b, in ivec3 x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }
bvec4  inside_closed(in ivec4 a, in ivec4 b, in ivec4 x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }

#endif
#ifndef INSIDE_OPEN_CLOSED
#define INSIDE_OPEN_CLOSED

#ifndef AND
#ifndef AND
#define AND

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  and(in bool  a, in bool  b) { return (a && b); }
bvec2 and(in bvec2 a, in bvec2 b) { return bvec2(a.x && b.x, a.y && b.y); }
bvec3 and(in bvec3 a, in bvec3 b) { return bvec3(a.x && b.x, a.y && b.y, a.z && b.z); }
bvec4 and(in bvec4 a, in bvec4 b) { return bvec4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool  and(in int   a, in int   b) { return and(on(a), on(b)); }
bvec2 and(in ivec2 a, in ivec2 b) { return and(on(a), on(b)); }
bvec3 and(in ivec3 a, in ivec3 b) { return and(on(a), on(b)); }
bvec4 and(in ivec4 a, in ivec4 b) { return and(on(a), on(b)); }

bool  and(in float a, in float b) { return and(on(a), on(b)); }
bvec2 and(in vec2  a, in vec2  b) { return and(on(a), on(b)); }
bvec3 and(in vec3  a, in vec3  b) { return and(on(a), on(b)); }
bvec4 and(in vec4  a, in vec4  b) { return and(on(a), on(b)); }

#endif
#endif

bool   inside_open_closed(in float a, in float b, in float x) { return and(x > a, x <= b); }
bvec2  inside_open_closed(in float a, in float b, in vec2  x) { return and(greaterThan(x, vec2(a)), lessThanEqual(x, vec2(b))); }
bvec3  inside_open_closed(in float a, in float b, in vec3  x) { return and(greaterThan(x, vec3(a)), lessThanEqual(x, vec3(b))); }
bvec4  inside_open_closed(in float a, in float b, in vec4  x) { return and(greaterThan(x, vec4(a)), lessThanEqual(x, vec4(b))); }
bvec2  inside_open_closed(in vec2  a, in vec2  b, in vec2  x) { return and(greaterThan(x, a), lessThanEqual(x, b)); }
bvec3  inside_open_closed(in vec3  a, in vec3  b, in vec3  x) { return and(greaterThan(x, a), lessThanEqual(x, b)); }
bvec4  inside_open_closed(in vec4  a, in vec4  b, in vec4  x) { return and(greaterThan(x, a), lessThanEqual(x, b)); }

bool   inside_open_closed(in int   a, in int   b, in int   x) { return and(x > a, x <= b); }
bvec2  inside_open_closed(in int   a, in int   b, in ivec2 x) { return and(greaterThan(x, ivec2(a)), lessThanEqual(x, ivec2(b))); }
bvec3  inside_open_closed(in int   a, in int   b, in ivec3 x) { return and(greaterThan(x, ivec3(a)), lessThanEqual(x, ivec3(b))); }
bvec4  inside_open_closed(in int   a, in int   b, in ivec4 x) { return and(greaterThan(x, ivec4(a)), lessThanEqual(x, ivec4(b))); }
bvec2  inside_open_closed(in ivec2 a, in ivec2 b, in ivec2 x) { return and(greaterThan(x, a), lessThanEqual(x, b)); }
bvec3  inside_open_closed(in ivec3 a, in ivec3 b, in ivec3 x) { return and(greaterThan(x, a), lessThanEqual(x, b)); }
bvec4  inside_open_closed(in ivec4 a, in ivec4 b, in ivec4 x) { return and(greaterThan(x, a), lessThanEqual(x, b)); }

#endif
#ifndef INSIDE_CLOSED_OPEN
#define INSIDE_CLOSED_OPEN

#ifndef AND
#ifndef AND
#define AND

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  and(in bool  a, in bool  b) { return (a && b); }
bvec2 and(in bvec2 a, in bvec2 b) { return bvec2(a.x && b.x, a.y && b.y); }
bvec3 and(in bvec3 a, in bvec3 b) { return bvec3(a.x && b.x, a.y && b.y, a.z && b.z); }
bvec4 and(in bvec4 a, in bvec4 b) { return bvec4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool  and(in int   a, in int   b) { return and(on(a), on(b)); }
bvec2 and(in ivec2 a, in ivec2 b) { return and(on(a), on(b)); }
bvec3 and(in ivec3 a, in ivec3 b) { return and(on(a), on(b)); }
bvec4 and(in ivec4 a, in ivec4 b) { return and(on(a), on(b)); }

bool  and(in float a, in float b) { return and(on(a), on(b)); }
bvec2 and(in vec2  a, in vec2  b) { return and(on(a), on(b)); }
bvec3 and(in vec3  a, in vec3  b) { return and(on(a), on(b)); }
bvec4 and(in vec4  a, in vec4  b) { return and(on(a), on(b)); }

#endif
#endif

bool   inside_closed_open(in float a, in float b, in float x) { return and(x >= a, x < b); }
bvec2  inside_closed_open(in float a, in float b, in vec2  x) { return and(greaterThanEqual(x, vec2(a)), lessThan(x, vec2(b))); }
bvec3  inside_closed_open(in float a, in float b, in vec3  x) { return and(greaterThanEqual(x, vec3(a)), lessThan(x, vec3(b))); }
bvec4  inside_closed_open(in float a, in float b, in vec4  x) { return and(greaterThanEqual(x, vec4(a)), lessThan(x, vec4(b))); }
bvec2  inside_closed_open(in vec2  a, in vec2  b, in vec2  x) { return and(greaterThanEqual(x, a), lessThan(x, b)); }
bvec3  inside_closed_open(in vec3  a, in vec3  b, in vec3  x) { return and(greaterThanEqual(x, a), lessThan(x, b)); }
bvec4  inside_closed_open(in vec4  a, in vec4  b, in vec4  x) { return and(greaterThanEqual(x, a), lessThan(x, b)); }

bool   inside_closed_open(in int   a, in int   b, in int   x) { return and(x >= a, x < b); }
bvec2  inside_closed_open(in int   a, in int   b, in ivec2 x) { return and(greaterThanEqual(x, ivec2(a)), lessThan(x, ivec2(b))); }
bvec3  inside_closed_open(in int   a, in int   b, in ivec3 x) { return and(greaterThanEqual(x, ivec3(a)), lessThan(x, ivec3(b))); }
bvec4  inside_closed_open(in int   a, in int   b, in ivec4 x) { return and(greaterThanEqual(x, ivec4(a)), lessThan(x, ivec4(b))); }
bvec2  inside_closed_open(in ivec2 a, in ivec2 b, in ivec2 x) { return and(greaterThanEqual(x, a), lessThan(x, b)); }
bvec3  inside_closed_open(in ivec3 a, in ivec3 b, in ivec3 x) { return and(greaterThanEqual(x, a), lessThan(x, b)); }
bvec4  inside_closed_open(in ivec4 a, in ivec4 b, in ivec4 x) { return and(greaterThanEqual(x, a), lessThan(x, b)); }

#endif
#ifndef OUTSIDE_OPEN
#define OUTSIDE_OPEN

#ifndef OR
#ifndef OR
#define OR

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  or(in bool  a, in bool  b) { return (a || b); }
bvec2 or(in bvec2 a, in bvec2 b) { return bvec2(a.x || b.x, a.y || b.y); }
bvec3 or(in bvec3 a, in bvec3 b) { return bvec3(a.x || b.x, a.y || b.y, a.z || b.z); }
bvec4 or(in bvec4 a, in bvec4 b) { return bvec4(a.x || b.x, a.y || b.y, a.z || b.z, a.w || b.w); }

bool  or(in int   a, in int   b) { return or(on(a), on(b)); }
bvec2 or(in ivec2 a, in ivec2 b) { return or(on(a), on(b)); }
bvec3 or(in ivec3 a, in ivec3 b) { return or(on(a), on(b)); }
bvec4 or(in ivec4 a, in ivec4 b) { return or(on(a), on(b)); }

bool  or(in float a, in float b) { return or(on(a), on(b)); }
bvec2 or(in vec2  a, in vec2  b) { return or(on(a), on(b)); }
bvec3 or(in vec3  a, in vec3  b) { return or(on(a), on(b)); }
bvec4 or(in vec4  a, in vec4  b) { return or(on(a), on(b)); }

#endif
#endif

bool   outside_open(in float a, in float b, in float x) { return or(x < a, x > b); }
bvec2  outside_open(in float a, in float b, in vec2  x) { return or(lessThan(x, vec2(a)), greaterThan(x, vec2(b))); }
bvec3  outside_open(in float a, in float b, in vec3  x) { return or(lessThan(x, vec3(a)), greaterThan(x, vec3(b))); }
bvec4  outside_open(in float a, in float b, in vec4  x) { return or(lessThan(x, vec4(a)), greaterThan(x, vec4(b))); }
bvec2  outside_open(in vec2  a, in vec2  b, in vec2  x) { return or(lessThan(x, a), greaterThan(x, b)); }
bvec3  outside_open(in vec3  a, in vec3  b, in vec3  x) { return or(lessThan(x, a), greaterThan(x, b)); }
bvec4  outside_open(in vec4  a, in vec4  b, in vec4  x) { return or(lessThan(x, a), greaterThan(x, b)); }

bool   outside_open(in int   a, in int   b, in int   x) { return or(x > a, x < b); }
bvec2  outside_open(in int   a, in int   b, in ivec2 x) { return or(lessThan(x, ivec2(a)), greaterThan(x, ivec2(b))); }
bvec3  outside_open(in int   a, in int   b, in ivec3 x) { return or(lessThan(x, ivec3(a)), greaterThan(x, ivec3(b))); }
bvec4  outside_open(in int   a, in int   b, in ivec4 x) { return or(lessThan(x, ivec4(a)), greaterThan(x, ivec4(b))); }
bvec2  outside_open(in ivec2 a, in ivec2 b, in ivec2 x) { return or(lessThan(x, a), greaterThan(x, b)); }
bvec3  outside_open(in ivec3 a, in ivec3 b, in ivec3 x) { return or(lessThan(x, a), greaterThan(x, b)); }
bvec4  outside_open(in ivec4 a, in ivec4 b, in ivec4 x) { return or(lessThan(x, a), greaterThan(x, b)); }

#endif
#ifndef OUTSIDE_CLOSED
#define OUTSIDE_CLOSED

#ifndef OR
#ifndef OR
#define OR

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  or(in bool  a, in bool  b) { return (a || b); }
bvec2 or(in bvec2 a, in bvec2 b) { return bvec2(a.x || b.x, a.y || b.y); }
bvec3 or(in bvec3 a, in bvec3 b) { return bvec3(a.x || b.x, a.y || b.y, a.z || b.z); }
bvec4 or(in bvec4 a, in bvec4 b) { return bvec4(a.x || b.x, a.y || b.y, a.z || b.z, a.w || b.w); }

bool  or(in int   a, in int   b) { return or(on(a), on(b)); }
bvec2 or(in ivec2 a, in ivec2 b) { return or(on(a), on(b)); }
bvec3 or(in ivec3 a, in ivec3 b) { return or(on(a), on(b)); }
bvec4 or(in ivec4 a, in ivec4 b) { return or(on(a), on(b)); }

bool  or(in float a, in float b) { return or(on(a), on(b)); }
bvec2 or(in vec2  a, in vec2  b) { return or(on(a), on(b)); }
bvec3 or(in vec3  a, in vec3  b) { return or(on(a), on(b)); }
bvec4 or(in vec4  a, in vec4  b) { return or(on(a), on(b)); }

#endif
#endif

bool   outside_closed(in float a, in float b, in float x) { return or(x <= a, x >= b); }
bvec2  outside_closed(in float a, in float b, in vec2  x) { return or(lessThanEqual(x, vec2(a)), greaterThanEqual(x, vec2(b))); }
bvec3  outside_closed(in float a, in float b, in vec3  x) { return or(lessThanEqual(x, vec3(a)), greaterThanEqual(x, vec3(b))); }
bvec4  outside_closed(in float a, in float b, in vec4  x) { return or(lessThanEqual(x, vec4(a)), greaterThanEqual(x, vec4(b))); }
bvec2  outside_closed(in vec2  a, in vec2  b, in vec2  x) { return or(lessThanEqual(x, a), greaterThanEqual(x, b)); }
bvec3  outside_closed(in vec3  a, in vec3  b, in vec3  x) { return or(lessThanEqual(x, a), greaterThanEqual(x, b)); }
bvec4  outside_closed(in vec4  a, in vec4  b, in vec4  x) { return or(lessThanEqual(x, a), greaterThanEqual(x, b)); }

bool   outside_closed(in int   a, in int   b, in int   x) { return or(x >= a, x <= b); }
bvec2  outside_closed(in int   a, in int   b, in ivec2 x) { return or(lessThanEqual(x, ivec2(a)), greaterThanEqual(x, ivec2(b))); }
bvec3  outside_closed(in int   a, in int   b, in ivec3 x) { return or(lessThanEqual(x, ivec3(a)), greaterThanEqual(x, ivec3(b))); }
bvec4  outside_closed(in int   a, in int   b, in ivec4 x) { return or(lessThanEqual(x, ivec4(a)), greaterThanEqual(x, ivec4(b))); }
bvec2  outside_closed(in ivec2 a, in ivec2 b, in ivec2 x) { return or(lessThanEqual(x, a), greaterThanEqual(x, b)); }
bvec3  outside_closed(in ivec3 a, in ivec3 b, in ivec3 x) { return or(lessThanEqual(x, a), greaterThanEqual(x, b)); }
bvec4  outside_closed(in ivec4 a, in ivec4 b, in ivec4 x) { return or(lessThanEqual(x, a), greaterThanEqual(x, b)); }

#endif
#ifndef INSIDE_OPEN_BOX
#define INSIDE_OPEN_BOX

#ifndef INSIDE_OPEN
#ifndef INSIDE_OPEN
#define INSIDE_OPEN

#ifndef AND
#ifndef AND
#define AND

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  and(in bool  a, in bool  b) { return (a && b); }
bvec2 and(in bvec2 a, in bvec2 b) { return bvec2(a.x && b.x, a.y && b.y); }
bvec3 and(in bvec3 a, in bvec3 b) { return bvec3(a.x && b.x, a.y && b.y, a.z && b.z); }
bvec4 and(in bvec4 a, in bvec4 b) { return bvec4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool  and(in int   a, in int   b) { return and(on(a), on(b)); }
bvec2 and(in ivec2 a, in ivec2 b) { return and(on(a), on(b)); }
bvec3 and(in ivec3 a, in ivec3 b) { return and(on(a), on(b)); }
bvec4 and(in ivec4 a, in ivec4 b) { return and(on(a), on(b)); }

bool  and(in float a, in float b) { return and(on(a), on(b)); }
bvec2 and(in vec2  a, in vec2  b) { return and(on(a), on(b)); }
bvec3 and(in vec3  a, in vec3  b) { return and(on(a), on(b)); }
bvec4 and(in vec4  a, in vec4  b) { return and(on(a), on(b)); }

#endif
#endif

bool   inside_open(in float a, in float b, in float x) { return and(x > a, x < b); }
bvec2  inside_open(in float a, in float b, in vec2  x) { return and(greaterThan(x, vec2(a)), lessThan(x, vec2(b))); }
bvec3  inside_open(in float a, in float b, in vec3  x) { return and(greaterThan(x, vec3(a)), lessThan(x, vec3(b))); }
bvec4  inside_open(in float a, in float b, in vec4  x) { return and(greaterThan(x, vec4(a)), lessThan(x, vec4(b))); }
bvec2  inside_open(in vec2  a, in vec2  b, in vec2  x) { return and(greaterThan(x, a), lessThan(x, b)); }
bvec3  inside_open(in vec3  a, in vec3  b, in vec3  x) { return and(greaterThan(x, a), lessThan(x, b)); }
bvec4  inside_open(in vec4  a, in vec4  b, in vec4  x) { return and(greaterThan(x, a), lessThan(x, b)); }

bool   inside_open(in int   a, in int   b, in int   x) { return and(x > a, x < b); }
bvec2  inside_open(in int   a, in int   b, in ivec2 x) { return and(greaterThan(x, ivec2(a)), lessThan(x, ivec2(b))); }
bvec3  inside_open(in int   a, in int   b, in ivec3 x) { return and(greaterThan(x, ivec3(a)), lessThan(x, ivec3(b))); }
bvec4  inside_open(in int   a, in int   b, in ivec4 x) { return and(greaterThan(x, ivec4(a)), lessThan(x, ivec4(b))); }
bvec2  inside_open(in ivec2 a, in ivec2 b, in ivec2 x) { return and(greaterThan(x, a), lessThan(x, b)); }
bvec3  inside_open(in ivec3 a, in ivec3 b, in ivec3 x) { return and(greaterThan(x, a), lessThan(x, b)); }
bvec4  inside_open(in ivec4 a, in ivec4 b, in ivec4 x) { return and(greaterThan(x, a), lessThan(x, b)); }

#endif
#endif

bool inside_open_box(in float a, in float b, in float x) { return     inside_open(a, b, x) ; }
bool inside_open_box(in float a, in float b, in vec2  x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in float a, in float b, in vec3  x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in float a, in float b, in vec4  x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in vec2  a, in vec2  b, in vec2  x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in vec3  a, in vec3  b, in vec3  x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in vec4  a, in vec4  b, in vec4  x) { return all(inside_open(a, b, x)); }

bool inside_open_box(in int   a, in int   b, in int   x) { return     inside_open(a, b, x) ; }
bool inside_open_box(in int   a, in int   b, in ivec2 x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in int   a, in int   b, in ivec3 x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in int   a, in int   b, in ivec4 x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in ivec2 a, in ivec2 b, in ivec2 x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in ivec3 a, in ivec3 b, in ivec3 x) { return all(inside_open(a, b, x)); }
bool inside_open_box(in ivec4 a, in ivec4 b, in ivec4 x) { return all(inside_open(a, b, x)); }

#endif
#ifndef INSIDE_CLOSED_BOX
#define INSIDE_CLOSED_BOX

#ifndef INSIDE_CLOSED
#ifndef INSIDE_CLOSED
#define INSIDE_CLOSED

#ifndef AND
#ifndef AND
#define AND

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  and(in bool  a, in bool  b) { return (a && b); }
bvec2 and(in bvec2 a, in bvec2 b) { return bvec2(a.x && b.x, a.y && b.y); }
bvec3 and(in bvec3 a, in bvec3 b) { return bvec3(a.x && b.x, a.y && b.y, a.z && b.z); }
bvec4 and(in bvec4 a, in bvec4 b) { return bvec4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool  and(in int   a, in int   b) { return and(on(a), on(b)); }
bvec2 and(in ivec2 a, in ivec2 b) { return and(on(a), on(b)); }
bvec3 and(in ivec3 a, in ivec3 b) { return and(on(a), on(b)); }
bvec4 and(in ivec4 a, in ivec4 b) { return and(on(a), on(b)); }

bool  and(in float a, in float b) { return and(on(a), on(b)); }
bvec2 and(in vec2  a, in vec2  b) { return and(on(a), on(b)); }
bvec3 and(in vec3  a, in vec3  b) { return and(on(a), on(b)); }
bvec4 and(in vec4  a, in vec4  b) { return and(on(a), on(b)); }

#endif
#endif

bool   inside_closed(in float a, in float b, in float x) { return and(x >= a, x <= b); }
bvec2  inside_closed(in float a, in float b, in vec2  x) { return and(greaterThanEqual(x, vec2(a)), lessThanEqual(x, vec2(b))); }
bvec3  inside_closed(in float a, in float b, in vec3  x) { return and(greaterThanEqual(x, vec3(a)), lessThanEqual(x, vec3(b))); }
bvec4  inside_closed(in float a, in float b, in vec4  x) { return and(greaterThanEqual(x, vec4(a)), lessThanEqual(x, vec4(b))); }
bvec2  inside_closed(in vec2  a, in vec2  b, in vec2  x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }
bvec3  inside_closed(in vec3  a, in vec3  b, in vec3  x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }
bvec4  inside_closed(in vec4  a, in vec4  b, in vec4  x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }

bool   inside_closed(in int   a, in int   b, in int   x) { return and(x >= a, x <= b); }
bvec2  inside_closed(in int   a, in int   b, in ivec2 x) { return and(greaterThanEqual(x, ivec2(a)), lessThanEqual(x, ivec2(b))); }
bvec3  inside_closed(in int   a, in int   b, in ivec3 x) { return and(greaterThanEqual(x, ivec3(a)), lessThanEqual(x, ivec3(b))); }
bvec4  inside_closed(in int   a, in int   b, in ivec4 x) { return and(greaterThanEqual(x, ivec4(a)), lessThanEqual(x, ivec4(b))); }
bvec2  inside_closed(in ivec2 a, in ivec2 b, in ivec2 x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }
bvec3  inside_closed(in ivec3 a, in ivec3 b, in ivec3 x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }
bvec4  inside_closed(in ivec4 a, in ivec4 b, in ivec4 x) { return and(greaterThanEqual(x, a), lessThanEqual(x, b)); }

#endif
#endif

bool inside_closed_box(in float a, in float b, in float x) { return     inside_closed(a, b, x) ; }
bool inside_closed_box(in float a, in float b, in vec2  x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in float a, in float b, in vec3  x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in float a, in float b, in vec4  x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in vec2  a, in vec2  b, in vec2  x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in vec3  a, in vec3  b, in vec3  x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in vec4  a, in vec4  b, in vec4  x) { return all(inside_closed(a, b, x)); }

bool inside_closed_box(in int   a, in int   b, in int   x) { return     inside_closed(a, b, x) ; }
bool inside_closed_box(in int   a, in int   b, in ivec2 x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in int   a, in int   b, in ivec3 x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in int   a, in int   b, in ivec4 x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in ivec2 a, in ivec2 b, in ivec2 x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in ivec3 a, in ivec3 b, in ivec3 x) { return all(inside_closed(a, b, x)); }
bool inside_closed_box(in ivec4 a, in ivec4 b, in ivec4 x) { return all(inside_closed(a, b, x)); }

#endif\r
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#ifndef OFF
#define OFF

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  off(in bool  a)  { return !a ; }
bvec2 off(in bvec2 a)  { return not(a); }
bvec3 off(in bvec3 a)  { return not(a); }
bvec4 off(in bvec4 a)  { return not(a); }

bool  off(in int   a)  { return !on(a) ; }
bvec2 off(in ivec2 a)  { return not(on(a)); }
bvec3 off(in ivec3 a)  { return not(on(a)); }
bvec4 off(in ivec4 a)  { return not(on(a)); }

bool  off(in float a) { return !on(a) ; }
bvec2 off(in vec2  a) { return not(on(a)); }
bvec3 off(in vec3  a) { return not(on(a)); }
bvec4 off(in vec4  a) { return not(on(a)); }

#endif
#ifndef AND
#define AND

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  and(in bool  a, in bool  b) { return (a && b); }
bvec2 and(in bvec2 a, in bvec2 b) { return bvec2(a.x && b.x, a.y && b.y); }
bvec3 and(in bvec3 a, in bvec3 b) { return bvec3(a.x && b.x, a.y && b.y, a.z && b.z); }
bvec4 and(in bvec4 a, in bvec4 b) { return bvec4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool  and(in int   a, in int   b) { return and(on(a), on(b)); }
bvec2 and(in ivec2 a, in ivec2 b) { return and(on(a), on(b)); }
bvec3 and(in ivec3 a, in ivec3 b) { return and(on(a), on(b)); }
bvec4 and(in ivec4 a, in ivec4 b) { return and(on(a), on(b)); }

bool  and(in float a, in float b) { return and(on(a), on(b)); }
bvec2 and(in vec2  a, in vec2  b) { return and(on(a), on(b)); }
bvec3 and(in vec3  a, in vec3  b) { return and(on(a), on(b)); }
bvec4 and(in vec4  a, in vec4  b) { return and(on(a), on(b)); }

#endif
#ifndef OR
#define OR

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  or(in bool  a, in bool  b) { return (a || b); }
bvec2 or(in bvec2 a, in bvec2 b) { return bvec2(a.x || b.x, a.y || b.y); }
bvec3 or(in bvec3 a, in bvec3 b) { return bvec3(a.x || b.x, a.y || b.y, a.z || b.z); }
bvec4 or(in bvec4 a, in bvec4 b) { return bvec4(a.x || b.x, a.y || b.y, a.z || b.z, a.w || b.w); }

bool  or(in int   a, in int   b) { return or(on(a), on(b)); }
bvec2 or(in ivec2 a, in ivec2 b) { return or(on(a), on(b)); }
bvec3 or(in ivec3 a, in ivec3 b) { return or(on(a), on(b)); }
bvec4 or(in ivec4 a, in ivec4 b) { return or(on(a), on(b)); }

bool  or(in float a, in float b) { return or(on(a), on(b)); }
bvec2 or(in vec2  a, in vec2  b) { return or(on(a), on(b)); }
bvec3 or(in vec3  a, in vec3  b) { return or(on(a), on(b)); }
bvec4 or(in vec4  a, in vec4  b) { return or(on(a), on(b)); }

#endif
#ifndef XOR
#define XOR

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  xor(in bool  a, in bool  b) { return (a != b); }
bvec2 xor(in bvec2 a, in bvec2 b) { return bvec2(a.x != b.x, a.y != b.y); }
bvec3 xor(in bvec3 a, in bvec3 b) { return bvec3(a.x != b.x, a.y != b.y, a.z != b.z); }
bvec4 xor(in bvec4 a, in bvec4 b) { return bvec4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w); }

bool  xor(in int   a, in int   b) { return xor(on(a), on(b)); }
bvec2 xor(in ivec2 a, in ivec2 b) { return xor(on(a), on(b)); }
bvec3 xor(in ivec3 a, in ivec3 b) { return xor(on(a), on(b)); }
bvec4 xor(in ivec4 a, in ivec4 b) { return xor(on(a), on(b)); }

bool  xor(in float a, in float b) { return xor(on(a), on(b)); }
bvec2 xor(in vec2  a, in vec2  b) { return xor(on(a), on(b)); }
bvec3 xor(in vec3  a, in vec3  b) { return xor(on(a), on(b)); }
bvec4 xor(in vec4  a, in vec4  b) { return xor(on(a), on(b)); }

#endif
#ifndef NAND
#define NAND

#ifndef AND
#ifndef AND
#define AND

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  and(in bool  a, in bool  b) { return (a && b); }
bvec2 and(in bvec2 a, in bvec2 b) { return bvec2(a.x && b.x, a.y && b.y); }
bvec3 and(in bvec3 a, in bvec3 b) { return bvec3(a.x && b.x, a.y && b.y, a.z && b.z); }
bvec4 and(in bvec4 a, in bvec4 b) { return bvec4(a.x && b.x, a.y && b.y, a.z && b.z, a.w && b.w); }

bool  and(in int   a, in int   b) { return and(on(a), on(b)); }
bvec2 and(in ivec2 a, in ivec2 b) { return and(on(a), on(b)); }
bvec3 and(in ivec3 a, in ivec3 b) { return and(on(a), on(b)); }
bvec4 and(in ivec4 a, in ivec4 b) { return and(on(a), on(b)); }

bool  and(in float a, in float b) { return and(on(a), on(b)); }
bvec2 and(in vec2  a, in vec2  b) { return and(on(a), on(b)); }
bvec3 and(in vec3  a, in vec3  b) { return and(on(a), on(b)); }
bvec4 and(in vec4  a, in vec4  b) { return and(on(a), on(b)); }

#endif
#endif
#ifndef OFF
#ifndef OFF
#define OFF

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  off(in bool  a)  { return !a ; }
bvec2 off(in bvec2 a)  { return not(a); }
bvec3 off(in bvec3 a)  { return not(a); }
bvec4 off(in bvec4 a)  { return not(a); }

bool  off(in int   a)  { return !on(a) ; }
bvec2 off(in ivec2 a)  { return not(on(a)); }
bvec3 off(in ivec3 a)  { return not(on(a)); }
bvec4 off(in ivec4 a)  { return not(on(a)); }

bool  off(in float a) { return !on(a) ; }
bvec2 off(in vec2  a) { return not(on(a)); }
bvec3 off(in vec3  a) { return not(on(a)); }
bvec4 off(in vec4  a) { return not(on(a)); }

#endif
#endif

bool  nand(in bool  a, in bool  b) { return off(and(a, b)); }
bvec2 nand(in bvec2 a, in bvec2 b) { return off(and(a, b)); }
bvec3 nand(in bvec3 a, in bvec3 b) { return off(and(a, b)); }
bvec4 nand(in bvec4 a, in bvec4 b) { return off(and(a, b)); }

bool  nand(in int   a, in int   b) { return off(and(a, b)); }
bvec2 nand(in ivec2 a, in ivec2 b) { return off(and(a, b)); }
bvec3 nand(in ivec3 a, in ivec3 b) { return off(and(a, b)); }
bvec4 nand(in ivec4 a, in ivec4 b) { return off(and(a, b)); }

bool  nand(in float a, in float b) { return off(and(a, b)); }
bvec2 nand(in vec2  a, in vec2  b) { return off(and(a, b)); }
bvec3 nand(in vec3  a, in vec3  b) { return off(and(a, b)); }
bvec4 nand(in vec4  a, in vec4  b) { return off(and(a, b)); }

#endif
#ifndef NOR
#define NOR

#ifndef OR
#ifndef OR
#define OR

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  or(in bool  a, in bool  b) { return (a || b); }
bvec2 or(in bvec2 a, in bvec2 b) { return bvec2(a.x || b.x, a.y || b.y); }
bvec3 or(in bvec3 a, in bvec3 b) { return bvec3(a.x || b.x, a.y || b.y, a.z || b.z); }
bvec4 or(in bvec4 a, in bvec4 b) { return bvec4(a.x || b.x, a.y || b.y, a.z || b.z, a.w || b.w); }

bool  or(in int   a, in int   b) { return or(on(a), on(b)); }
bvec2 or(in ivec2 a, in ivec2 b) { return or(on(a), on(b)); }
bvec3 or(in ivec3 a, in ivec3 b) { return or(on(a), on(b)); }
bvec4 or(in ivec4 a, in ivec4 b) { return or(on(a), on(b)); }

bool  or(in float a, in float b) { return or(on(a), on(b)); }
bvec2 or(in vec2  a, in vec2  b) { return or(on(a), on(b)); }
bvec3 or(in vec3  a, in vec3  b) { return or(on(a), on(b)); }
bvec4 or(in vec4  a, in vec4  b) { return or(on(a), on(b)); }

#endif
#endif
#ifndef OFF
#ifndef OFF
#define OFF

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  off(in bool  a)  { return !a ; }
bvec2 off(in bvec2 a)  { return not(a); }
bvec3 off(in bvec3 a)  { return not(a); }
bvec4 off(in bvec4 a)  { return not(a); }

bool  off(in int   a)  { return !on(a) ; }
bvec2 off(in ivec2 a)  { return not(on(a)); }
bvec3 off(in ivec3 a)  { return not(on(a)); }
bvec4 off(in ivec4 a)  { return not(on(a)); }

bool  off(in float a) { return !on(a) ; }
bvec2 off(in vec2  a) { return not(on(a)); }
bvec3 off(in vec3  a) { return not(on(a)); }
bvec4 off(in vec4  a) { return not(on(a)); }

#endif
#endif

bool  nor(in bool  a, in bool  b) { return off(or(a, b)); }
bvec2 nor(in bvec2 a, in bvec2 b) { return off(or(a, b)); }
bvec3 nor(in bvec3 a, in bvec3 b) { return off(or(a, b)); }
bvec4 nor(in bvec4 a, in bvec4 b) { return off(or(a, b)); }

bool  nor(in int   a, in int   b) { return off(or(a, b)); }
bvec2 nor(in ivec2 a, in ivec2 b) { return off(or(a, b)); }
bvec3 nor(in ivec3 a, in ivec3 b) { return off(or(a, b)); }
bvec4 nor(in ivec4 a, in ivec4 b) { return off(or(a, b)); }

bool  nor(in float a, in float b) { return off(or(a, b)); }
bvec2 nor(in vec2  a, in vec2  b) { return off(or(a, b)); }
bvec3 nor(in vec3  a, in vec3  b) { return off(or(a, b)); }
bvec4 nor(in vec4  a, in vec4  b) { return off(or(a, b)); }

#endif
#ifndef XNOR
#define XNOR

#ifndef XOR
#ifndef XOR
#define XOR

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  xor(in bool  a, in bool  b) { return (a != b); }
bvec2 xor(in bvec2 a, in bvec2 b) { return bvec2(a.x != b.x, a.y != b.y); }
bvec3 xor(in bvec3 a, in bvec3 b) { return bvec3(a.x != b.x, a.y != b.y, a.z != b.z); }
bvec4 xor(in bvec4 a, in bvec4 b) { return bvec4(a.x != b.x, a.y != b.y, a.z != b.z, a.w != b.w); }

bool  xor(in int   a, in int   b) { return xor(on(a), on(b)); }
bvec2 xor(in ivec2 a, in ivec2 b) { return xor(on(a), on(b)); }
bvec3 xor(in ivec3 a, in ivec3 b) { return xor(on(a), on(b)); }
bvec4 xor(in ivec4 a, in ivec4 b) { return xor(on(a), on(b)); }

bool  xor(in float a, in float b) { return xor(on(a), on(b)); }
bvec2 xor(in vec2  a, in vec2  b) { return xor(on(a), on(b)); }
bvec3 xor(in vec3  a, in vec3  b) { return xor(on(a), on(b)); }
bvec4 xor(in vec4  a, in vec4  b) { return xor(on(a), on(b)); }

#endif
#endif
#ifndef OFF
#ifndef OFF
#define OFF

#ifndef ON
#ifndef ON
#define ON

bool  on(in bool  a) { return a; }
bvec2 on(in bvec2 a) { return a; }
bvec3 on(in bvec3 a) { return a; }
bvec4 on(in bvec4 a) { return a; }

bool  on(in int   a) { return bool (a); }
bvec2 on(in ivec2 a) { return bvec2(a); }
bvec3 on(in ivec3 a) { return bvec3(a); }
bvec4 on(in ivec4 a) { return bvec4(a); }

bool  on(in float a) { return on(abs(a) > 0.0); }
bvec2 on(in vec2  a) { return on(greaterThan(abs(a), vec2(0.0))); }
bvec3 on(in vec3  a) { return on(greaterThan(abs(a), vec3(0.0))); }
bvec4 on(in vec4  a) { return on(greaterThan(abs(a), vec4(0.0))); }

#endif
#endif

bool  off(in bool  a)  { return !a ; }
bvec2 off(in bvec2 a)  { return not(a); }
bvec3 off(in bvec3 a)  { return not(a); }
bvec4 off(in bvec4 a)  { return not(a); }

bool  off(in int   a)  { return !on(a) ; }
bvec2 off(in ivec2 a)  { return not(on(a)); }
bvec3 off(in ivec3 a)  { return not(on(a)); }
bvec4 off(in ivec4 a)  { return not(on(a)); }

bool  off(in float a) { return !on(a) ; }
bvec2 off(in vec2  a) { return not(on(a)); }
bvec3 off(in vec3  a) { return not(on(a)); }
bvec4 off(in vec4  a) { return not(on(a)); }

#endif
#endif

bool  xnor(in bool  a, in bool  b) { return off(xor(a, b)); }
bvec2 xnor(in bvec2 a, in bvec2 b) { return off(xor(a, b)); }
bvec3 xnor(in bvec3 a, in bvec3 b) { return off(xor(a, b)); }
bvec4 xnor(in bvec4 a, in bvec4 b) { return off(xor(a, b)); }

bool  xnor(in int   a, in int   b) { return off(xor(a, b)); }
bvec2 xnor(in ivec2 a, in ivec2 b) { return off(xor(a, b)); }
bvec3 xnor(in ivec3 a, in ivec3 b) { return off(xor(a, b)); }
bvec4 xnor(in ivec4 a, in ivec4 b) { return off(xor(a, b)); }

bool  xnor(in float a, in float b) { return off(xor(a, b)); }
bvec2 xnor(in vec2  a, in vec2  b) { return off(xor(a, b)); }
bvec3 xnor(in vec3  a, in vec3  b) { return off(xor(a, b)); }
bvec4 xnor(in vec4  a, in vec4  b) { return off(xor(a, b)); }

#endif\r
#ifndef LINEAR_ROOT\r
#define LINEAR_ROOT

#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif

float linear_root(in vec2 c)\r
{\r
    
    float x = - c.x / c.y;\r
    return x;\r
}

#endif\r
#ifndef QUADRATIC_ROOTS\r
#define QUADRATIC_ROOTS

#ifndef SSIGN\r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif\r
#endif

vec2 quadratic_roots(in vec3 c)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    return vec2(xq, n.x / xq);\r
}

vec2 quadratic_roots(in vec3 c, in float xd)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    vec2 x = vec2(xq, n.x / xq);

    
    return (d >= 0.0) ? x : vec2(xd);\r
}

#endif\r
#ifndef CUBIC_ROOTS\r
#define CUBIC_ROOTS

#ifndef QUADRATIC_ROOTS\r
#ifndef QUADRATIC_ROOTS\r
#define QUADRATIC_ROOTS

#ifndef SSIGN\r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif\r
#endif

vec2 quadratic_roots(in vec3 c)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    return vec2(xq, n.x / xq);\r
}

vec2 quadratic_roots(in vec3 c, in float xd)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    vec2 x = vec2(xq, n.x / xq);

    
    return (d >= 0.0) ? x : vec2(xd);\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef CBRT\r
#ifndef CBRT\r
#define CBRT

float cbrt(in float v) \r
{ \r
    return sign(v) * pow(\r
        abs(v), 1.0/3.0\r
    ); \r
}

vec2  cbrt(in vec2 v) \r
{ \r
    return sign(v) * vec2(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0)\r
    ); \r
}

vec3  cbrt(in vec3 v) \r
{ \r
    return sign(v) * vec3(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0),\r
        pow(abs(v.z), 1.0/3.0)\r
    ); \r
}

vec4  cbrt(in vec4 v) \r
{ \r
    return sign(v) * vec4(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0), \r
        pow(abs(v.z), 1.0/3.0), \r
        pow(abs(v.w), 1.0/3.0)\r
    ); \r
}

#endif\r
#endif\r
#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif\r
#ifndef SQRT_3\r
#define SQRT_3 1.73205080757\r
#endif\r
#ifndef NAN\r
#define NAN uintBitsToFloat(0x7fc00000u)\r
#endif

vec3 cubic_roots(in vec4 c)\r
{\r
    
    bool flip = abs(c.z * c.x) >= abs(c.y * c.w);\r
    vec3 n = flip ? c.wzy / c.x : c.xyz / c.w;\r
    n.yz /= 3.0;

    
    vec3 h = vec3(\r
        n.y - n.z * n.z,                          
        n.x - n.y * n.z,                          
        dot(vec2(n.z, -n.y), n.xy)    
    );\r
    h.y /= 2.0;

    
    float d = dot(vec2(h.x, -h.y), h.zy); 
    float sqrt_d = sqrt(abs(d));

    
    vec2 r = vec2(h.y - h.x * n.z, h.x);\r
    \r
    
    vec3 x1 = vec3(cbrt(-r.x + sqrt_d) + cbrt(-r.x - sqrt_d));

    
    float t = atan(sqrt_d, -r.x) / 3.0;\r
    mat2 proj = mat2(-1.0, -SQRT_3, -1.0, SQRT_3);

    
    vec2 x2 = vec2(cos(t), sin(t));\r
    vec3 x3 = vec3(x2 * proj, x2.x * 2.0);

    
    x3 *= sqrt(max(0.0, -r.y)); 

    
    vec3 x = (d > 0.0) ? x3 : x1;\r
    x = x - n.z;\r
    x = flip ? 1.0 / x : x;

    
    vec3 y, dydx;\r
    y = eval_poly(c, x, dydx);\r
    x -= y / dydx; \r
    y = eval_poly(c, x, dydx);\r
    x -= y / dydx; 

    
    return x;\r
}

vec3 cubic_roots_2(in vec4 c)\r
{\r
    
    vec3 n = c.xyz / c.w;\r
    n.yz /= 3.0;

    
    vec3 h = vec3(\r
        n.y - n.z * n.z,                          
        n.x - n.y * n.z,                          
        dot(vec2(n.z, -n.y), n.xy)    
    );\r
    h.y /= 2.0;

    
    float d = dot(vec2(h.x, -h.y), h.zy); 
    float sqrt_d = sqrt(abs(d));

    
    vec2 r = vec2(h.y - h.x * n.z, h.x);\r
    \r
    
    vec3 x1 = vec3(cbrt(-r.x + sqrt_d) + cbrt(-r.x - sqrt_d));

    
    float t = atan(sqrt_d, -r.x) / 3.0;\r
    mat2 proj = mat2(-1.0, -SQRT_3, -1.0, SQRT_3);

    
    vec2 x2 = vec2(cos(t), sin(t));\r
    vec3 x3 = vec3(x2 * proj, x2.x * 2.0);

    
    x3 *= sqrt(max(0.0, -r.y)); 

    
    vec3 x = (d > 0.0) ? x3 : x1;\r
    x = x - n.z;

    
    return x;\r
}

#endif\r
#ifndef QUARTIC_ROOTS\r
#define QUARTIC_ROOTS

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef SSIGN\r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif\r
#endif\r
#ifndef CBRT\r
#ifndef CBRT\r
#define CBRT

float cbrt(in float v) \r
{ \r
    return sign(v) * pow(\r
        abs(v), 1.0/3.0\r
    ); \r
}

vec2  cbrt(in vec2 v) \r
{ \r
    return sign(v) * vec2(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0)\r
    ); \r
}

vec3  cbrt(in vec3 v) \r
{ \r
    return sign(v) * vec3(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0),\r
        pow(abs(v.z), 1.0/3.0)\r
    ); \r
}

vec4  cbrt(in vec4 v) \r
{ \r
    return sign(v) * vec4(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0), \r
        pow(abs(v.z), 1.0/3.0), \r
        pow(abs(v.w), 1.0/3.0)\r
    ); \r
}

#endif\r
#endif\r
#ifndef NAN\r
#define NAN uintBitsToFloat(0x7fc00000u)\r
#endif\r
#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif\r
#ifndef NANO_TOLERANCE\r
#define NANO_TOLERANCE 1e-9\r
#endif

float resolvent_cubic_max_root(in float rc, in float rb, in float ra)\r
{\r
    
    vec4 n = vec4(rc, rb, ra, 1.0);\r
    n.yz /= 3.0;

    
    vec3 h = vec3(\r
        n.y - n.z * n.z,                          
        n.x - n.y * n.z,                          
        dot(vec2(n.z, -n.y), n.xy)    
    );\r
    h.y /= 2.0;

    
    float d = dot(vec2(h.y, -h.x), h.yz); 
    float sqrt_d = sqrt(abs(d));

    
    vec2 r = vec2(h.y - n.z * h.x, h.x);\r
    \r
    
    float U1 = cbrt(-r.x + sqrt_d) + cbrt(-r.x - sqrt_d);\r
       \r
    
    
    float U3_max = cos(atan(sqrt_d, -r.x) / 3.0);\r
    U3_max *= sqrt(max(-r.y, 0.0)); 

    
    float U = (d < 0.0) ? U3_max : U1;\r
    U = U - n.z;

    
    
    
    
    
    

    
    return U;\r
}

vec4 factored_quadratics_roots(in float t, in float s, in float v, in float u)\r
{\r
    
    vec4 tsvu = vec4(t, s, v, u);\r
    tsvu.yw /= -2.0;\r
    \r
    
    
    vec2 d = tsvu.yw * tsvu.yw - tsvu.xz;\r
    vec2 sqrt_d = sqrt(max(d, 0.0));\r
    \r
    
    vec2 xq = vec2(\r
        tsvu.y + sqrt_d.x, \r
        tsvu.w - sqrt_d.y\r
    );

    
    return vec4(xq, tsvu.xz / xq);\r
}

vec4 quartic_roots(in float c[5]) \r
{\r
    
    
    bool flip = abs(c[3] * c[0]) >= abs(c[1] * c[4]);\r
    vec4 n = flip \r
    ? vec4(c[4], c[3], c[2], c[1] / 4.0) / c[0] \r
    : vec4(c[0], c[1], c[2], c[3] / 4.0) / c[4];

    
    
    float w2 = n.w * n.w;\r
    float p = n.z - w2 * 6.0;\r
    float q = n.y - n.w * (n.z - w2 * 4.0) * 2.0;\r
    float r = n.x - n.w * (n.y - n.w * (n.z - w2 * 3.0));

    
    
    float ra =  p * 2.0;\r
    float rb =  p * p - r * 4.0;\r
    float rc = -q * q;

    
    
    float U_max = resolvent_cubic_max_root(rc, rb, ra);\r
    float u = sqrt(abs(U_max));\r
    \r
    
    
    float qu = q / u;\r
    float t = (p + qu + u * u) * 0.5;\r
    float v = t - qu;\r
    float s = - u;

    
    
    vec4 x = factored_quadratics_roots(t, s, v, u);

    
    x = x - n.w;\r
    x = flip ? 1.0 / x : x;

    
    vec4 f, dfdx; \r
    f = eval_poly(c, x, dfdx);\r
    x -= f / dfdx; \r
    f = eval_poly(c, x, dfdx);\r
    x -= f / dfdx; 

    
    return x;\r
}

vec4 quartic_roots_2(in float c[5]) \r
{\r
    
    
    vec4 n = vec4(c[0], c[1], c[2], c[3] / 4.0) / c[4];

    
    
    float w2 = n.w * n.w;\r
    float p = n.z - w2 * 6.0;\r
    float q = n.y - n.w * (n.z - w2 * 4.0) * 2.0;\r
    float r = n.x - n.w * (n.y - n.w * (n.z - w2 * 3.0));

    
    
    float ra =  p * 2.0;\r
    float rb =  p * p - r * 4.0;\r
    float rc = -q * q;

    
    
    float U_max = resolvent_cubic_max_root(rc, rb, ra);\r
    float u = sqrt(abs(U_max));\r
    \r
    
    
    float qu = q / u;\r
    float t = (p + qu + u * u) * 0.5;\r
    float v = t - qu;\r
    float s = - u;

    
    
    vec4 x = factored_quadratics_roots(t, s, v, u);

    
    x = x - n.w;

    
    return x;\r
}

#endif\r
#ifndef POLY3_ROOTS\r
#define POLY3_ROOTS

#define POLY3_NO_INTERSECTION 3.4e38

bool poly3_roots_newton_bisection\r
(\r
    out float out_root, \r
    out float out_end_value,\r
    float poly3[4], \r
    float begin, \r
    float end,\r
    float begin_value, \r
    float error_tolerance\r
){\r
    if (begin == end) \r
    {\r
        out_end_value = begin_value;\r
        return false;\r
    }

    
    out_end_value = poly3[3];\r
    out_end_value = out_end_value * end + poly3[2];\r
    out_end_value = out_end_value * end + poly3[1];\r
    out_end_value = out_end_value * end + poly3[0];

    
    if (begin_value * out_end_value > 0.0) return false;

    
    
    float current = 0.5 * (begin + end);

    #pragma no_unroll\r
    for (int i = 0; i != 10; ++i) \r
    {\r
        
        float derivative = poly3[3];\r
        float value = poly3[3] * current + poly3[2];\r
        #pragma unroll\r
        for (int j = 1; j != -1; --j) \r
        {\r
            derivative = derivative * current + value;\r
            value = value * current + poly3[j];\r
        }\r
    \r
        
        bool right = begin_value * value > 0.0;\r
        begin = right ? current : begin;\r
        end = right ? end : current;

        
        float guess = current - value / derivative;

        
        float middle = 0.5 * (begin + end);\r
        float next = (guess >= begin && guess <= end) ? guess : middle;

        
        bool done = abs(next - current) < error_tolerance;\r
        current = next;\r
        if (done) break;\r
    }

    out_root = current;\r
    return true;\r
}

void poly3_roots\r
(\r
    out vec4 out_roots, \r
    vec4 poly3, \r
    float begin, \r
    float end\r
){\r
    float tolerance = (end - begin) * 1.0e-9;

    
    
    
    
    
    float derivative[4];\r
    derivative[0] = poly3[1];\r
    derivative[1] = poly3[2] * 2.0;\r
    derivative[2] = poly3[3] * 3.0;\r
    derivative[3] = 0.0;

    
    float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];

    if (discriminant >= 0.0) \r
    {\r
        float sqrt_discriminant = sqrt(discriminant);\r
        float scaled_root = derivative[1] + ((derivative[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));\r
        float root_0 = clamp(-2.0 * derivative[0] / scaled_root, begin, end);\r
        float root_1 = clamp(-0.5 * scaled_root / derivative[2], begin, end);\r
        out_roots[1] = min(root_0, root_1);\r
        out_roots[2] = max(root_0, root_1);\r
    }\r
    else \r
    {\r
        
        out_roots[1] = begin;\r
        out_roots[2] = begin;\r
    }

    
    
    out_roots[0] = begin;\r
    out_roots[3] = end;

    
    
    
    
    
    
    
    

    
    
    
    
    derivative[3] = derivative[2] / 3.0;\r
    derivative[2] = derivative[1] / 2.0;\r
    derivative[1] = derivative[0];\r
    derivative[0] = poly3[0];

    
    float begin_value = derivative[3];\r
    begin_value = begin_value * begin + derivative[2];\r
    begin_value = begin_value * begin + derivative[1];\r
    begin_value = begin_value * begin + derivative[0];

    
    #pragma unroll\r
    for (int i = 0; i != 3; ++i) \r
    {\r
        float current_begin = out_roots[i];\r
        float current_end = out_roots[i + 1];

        
        float root;\r
        if (poly3_roots_newton_bisection(root, begin_value, derivative, current_begin, current_end, begin_value, tolerance))\r
        {\r
            out_roots[i] = root;\r
        }\r
        else\r
        {\r
            out_roots[i] = POLY3_NO_INTERSECTION;\r
        }\r
    }\r
 \r
    
    out_roots[3] = POLY3_NO_INTERSECTION;\r
}

#endif\r
#ifndef POLY5_ROOTS\r
#define POLY5_ROOTS

#define POLY5_NO_INTERSECTION 3.4e38

bool poly5_roots_newton_bisection\r
(\r
    out float out_root, \r
    out float out_end_value,\r
    float poly5[6], \r
    float begin, \r
    float end,\r
    float begin_value, \r
    float error_tolerance\r
){\r
    if (begin == end) \r
    {\r
        out_end_value = begin_value;\r
        return false;\r
    }

    
    out_end_value = poly5[5];\r
    out_end_value = out_end_value * end + poly5[4];\r
    out_end_value = out_end_value * end + poly5[3];\r
    out_end_value = out_end_value * end + poly5[2];\r
    out_end_value = out_end_value * end + poly5[1];\r
    out_end_value = out_end_value * end + poly5[0];

    
    if (begin_value * out_end_value > 0.0) return false;

    
    
    float current = 0.5 * (begin + end);

    #pragma no_unroll\r
    for (int i = 0; i != 40; ++i) \r
    {\r
        
        float value = poly5[5] * current + poly5[4];\r
        float derivative = poly5[5];

        #pragma unroll\r
        for (int j = 3; j != -1; --j) \r
        {\r
            derivative = derivative * current + value;\r
            value = value * current + poly5[j];\r
        }

        
        bool right = begin_value * value > 0.0;\r
        begin = right ? current : begin;\r
        end = right ? end : current;

        
        float guess = current - value / derivative;

        
        float middle = 0.5 * (begin + end);\r
        float next = (guess >= begin && guess <= end) ? guess : middle;

        
        bool done = abs(next - current) < error_tolerance;\r
        current = next;\r
        if (done) break;\r
    }

    out_root = current;\r
    return true;\r
}

void poly5_roots\r
(\r
    out float out_roots[6], \r
    float poly5[6], \r
    float begin, \r
    float end\r
){\r
    float tolerance = (end - begin) * 1.0e-9;

    
    
    
    
    
    float derivative[6];\r
    derivative[0] = poly5[3];\r
    derivative[1] = poly5[4] * 4.0;\r
    derivative[2] = poly5[5] * 10.0;\r
    derivative[3] = 0.0;\r
    derivative[4] = 0.0;\r
    derivative[5] = 0.0;

    
    float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];

    if (discriminant >= 0.0) \r
    {\r
        float sqrt_discriminant = sqrt(discriminant);\r
        float scaled_root = derivative[1] + ((derivative[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));\r
        float root_0 = clamp(-2.0 * derivative[0] / scaled_root, begin, end);\r
        float root_1 = clamp(-0.5 * scaled_root / derivative[2], begin, end);\r
        out_roots[3] = min(root_0, root_1);\r
        out_roots[4] = max(root_0, root_1);\r
    }\r
    else \r
    {\r
        
        out_roots[3] = begin;\r
        out_roots[4] = begin;\r
    }

    
    
    out_roots[0] = begin;\r
    out_roots[1] = begin;\r
    out_roots[2] = begin;\r
    out_roots[5] = end;

    
    
    
    
    
    
    
    
    #pragma no_unroll\r
    for (int degree = 3; degree != 6; ++degree) \r
    {\r
        
        
        float prev_derivative_order = float(6 - degree);\r
        derivative[5] = derivative[4] * (prev_derivative_order * (1.0 / 5.0));\r
        derivative[4] = derivative[3] * (prev_derivative_order * (1.0 / 4.0));\r
        derivative[3] = derivative[2] * (prev_derivative_order * (1.0 / 3.0));\r
        derivative[2] = derivative[1] * (prev_derivative_order * (1.0 / 2.0));\r
        derivative[1] = derivative[0] * (prev_derivative_order * (1.0 / 1.0));\r
     \r
        
        
        derivative[0] = (degree == 5) ? poly5[0] : derivative[0];\r
        derivative[0] = (degree == 4) ? poly5[1] : derivative[0];\r
        derivative[0] = (degree == 3) ? poly5[2] : derivative[0];

        
        float begin_value = derivative[5];\r
        begin_value = begin_value * begin + derivative[4];\r
        begin_value = begin_value * begin + derivative[3];\r
        begin_value = begin_value * begin + derivative[2];\r
        begin_value = begin_value * begin + derivative[1];\r
        begin_value = begin_value * begin + derivative[0];

        
        #pragma unroll\r
        for (int i = 0; i != 5; ++i) \r
        {\r
            if (i < 5 - degree)\r
            {\r
                continue;\r
            }

            float current_begin = out_roots[i];\r
            float current_end = out_roots[i + 1];

            
            float root;\r
            if (poly5_roots_newton_bisection(root, begin_value, derivative, current_begin, current_end, begin_value, tolerance))\r
            {\r
                out_roots[i] = root;\r
            }\r
            else if (degree < 5)\r
            {\r
                
                out_roots[i] = out_roots[i - 1];\r
            }\r
            else\r
            {\r
                out_roots[i] = POLY5_NO_INTERSECTION;\r
            }\r
        }\r
    }

    
    out_roots[5] = POLY5_NO_INTERSECTION;\r
}

#endif\r
#ifndef POLY3_HAS_ROOT\r
#define POLY3_HAS_ROOT

bool poly3_has_root_sign_change\r
(\r
    out float out_end_value,\r
    float poly3[4], \r
    float begin, \r
    float end,\r
    float begin_value\r
){\r
    if (begin == end) \r
    {\r
        out_end_value = begin_value;\r
        return false;\r
    }

    
    out_end_value = poly3[3];\r
    out_end_value = out_end_value * end + poly3[2];\r
    out_end_value = out_end_value * end + poly3[1];\r
    out_end_value = out_end_value * end + poly3[0];

    
    if (begin_value * out_end_value > 0.0) return false;

    return true;\r
}

bool poly3_has_root\r
(\r
    vec4 poly3, \r
    float begin, \r
    float end\r
){

    
    
    vec4 critical_roots = vec4(\r
        begin,\r
        begin, 
        begin, 
        end\r
    );

    
    
    
    
    
    float derivative[4];\r
    derivative[0] = poly3[1];\r
    derivative[1] = poly3[2] * 2.0;\r
    derivative[2] = poly3[3] * 3.0;\r
    derivative[3] = 0.0;

    
    float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];

    if (discriminant >= 0.0) \r
    {\r
        float sqrt_discriminant = sqrt(discriminant);\r
        float scaled_root = derivative[1] + ((derivative[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));\r
        float root_0 = clamp(-2.0 * derivative[0] / scaled_root, begin, end);\r
        float root_1 = clamp(-0.5 * scaled_root / derivative[2], begin, end);\r
        critical_roots[1] = min(root_0, root_1);\r
        critical_roots[2] = max(root_0, root_1);\r
    }

    
    
    
    
    
    
    
    

    
    
    
    
    derivative[3] = derivative[2] / 3.0;\r
    derivative[2] = derivative[1] / 2.0;\r
    derivative[1] = derivative[0];\r
    derivative[0] = poly3[0];

    
    float begin_value = derivative[3];\r
    begin_value = begin_value * begin + derivative[2];\r
    begin_value = begin_value * begin + derivative[1];\r
    begin_value = begin_value * begin + derivative[0];

    
    #pragma no_unroll\r
    for (int i = 0; i != 3; ++i) \r
    {\r
        
        if (poly3_has_root_sign_change(begin_value, derivative, critical_roots[i], critical_roots[i + 1], begin_value))\r
        {\r
            return true;\r
        }\r
    }\r
 \r
    return false;\r
}

#endif\r
#ifndef POLY5_HAS_ROOT\r
#define POLY5_HAS_ROOT

bool poly5_has_root_newton_bisection\r
(\r
    out float out_root, \r
    out float out_end_value,\r
    float poly5[6], \r
    float begin, \r
    float end,\r
    float begin_value, \r
    float error_tolerance\r
){\r
    if (begin == end) \r
    {\r
        out_end_value = begin_value;\r
        return false;\r
    }

    
    out_end_value = poly5[5];\r
    out_end_value = out_end_value * end + poly5[4];\r
    out_end_value = out_end_value * end + poly5[3];\r
    out_end_value = out_end_value * end + poly5[2];\r
    out_end_value = out_end_value * end + poly5[1];\r
    out_end_value = out_end_value * end + poly5[0];

    
    if (begin_value * out_end_value > 0.0) return false;

    
    
    float current = 0.5 * (begin + end);

    #pragma no_unroll\r
    for (int i = 0; i != 20; ++i) \r
    {\r
        
        float derivative = poly5[5];\r
        float value = derivative * current + poly5[4];\r
        derivative = derivative * current + value;\r
        value = value * current + poly5[3];\r
        derivative = derivative * current + value;\r
        value = value * current + poly5[2];\r
        derivative = derivative * current + value;\r
        value = value * current + poly5[1];\r
        derivative = derivative * current + value;\r
        value = value * current + poly5[0];

        
        bool right = begin_value * value > 0.0;\r
        begin = right ? current : begin;\r
        end = right ? end : current;

        
        float guess = current - value / derivative;

        
        float middle = 0.5 * (begin + end);\r
        float next = (guess >= begin && guess <= end) ? guess : middle;

        
        bool done = abs(next - current) < error_tolerance;\r
        current = next;\r
        if (done) break;\r
    }

    out_root = current;\r
    return true;\r
}

bool poly5_has_root_sign_change\r
(\r
    out float out_end_value,\r
    float poly5[6], \r
    float begin, \r
    float end,\r
    float begin_value\r
){\r
    if (begin == end) \r
    {\r
        out_end_value = begin_value;\r
        return false;\r
    }

    
    out_end_value = poly5[5];\r
    out_end_value = out_end_value * end + poly5[4];\r
    out_end_value = out_end_value * end + poly5[3];\r
    out_end_value = out_end_value * end + poly5[2];\r
    out_end_value = out_end_value * end + poly5[1];\r
    out_end_value = out_end_value * end + poly5[0];

    
    if ((begin_value < 0.0) == (out_end_value < 0.0)) \r
    {\r
        return false;\r
    }

    return true;\r
}

bool poly5_has_root\r
(\r
    float poly5[6], \r
    float begin, \r
    float end\r
){\r
    float tolerance = (end - begin) * 1.0e-6;

    
    
    float critical_roots[6];\r
    critical_roots[0] = begin;\r
    critical_roots[1] = begin;\r
    critical_roots[2] = begin;\r
    critical_roots[5] = end;

    
    
    
    
    
    float derivative[6];\r
    derivative[0] = poly5[3];\r
    derivative[1] = poly5[4] * 4.0;\r
    derivative[2] = poly5[5] * 10.0;\r
    derivative[3] = 0.0;\r
    derivative[4] = 0.0;\r
    derivative[5] = 0.0;\r
    \r
    
    float discriminant = derivative[1] * derivative[1] - 4.0 * derivative[0] * derivative[2];

    if (discriminant >= 0.0) \r
    {\r
        float sqrt_discriminant = sqrt(discriminant);\r
        float scaled_root = derivative[1] + ((derivative[1] > 0.0) ? sqrt_discriminant : (-sqrt_discriminant));\r
        float root_0 = clamp(-2.0 * derivative[0] / scaled_root, begin, end);\r
        float root_1 = clamp(-0.5 * scaled_root / derivative[2], begin, end);\r
        critical_roots[3] = min(root_0, root_1);\r
        critical_roots[4] = max(root_0, root_1);\r
    }\r
    else \r
    {\r
        
        critical_roots[3] = begin;\r
        critical_roots[4] = begin;\r
    }

    
    
    
    
    
    
    
    
    #pragma no_unroll\r
    for (int degree = 3; degree != 5; ++degree) \r
    {\r
        
        
        float prev_derivative_order = float(6 - degree);\r
        derivative[5] = derivative[4] * (prev_derivative_order * (1.0 / 5.0));\r
        derivative[4] = derivative[3] * (prev_derivative_order * (1.0 / 4.0));\r
        derivative[3] = derivative[2] * (prev_derivative_order * (1.0 / 3.0));\r
        derivative[2] = derivative[1] * (prev_derivative_order * (1.0 / 2.0));\r
        derivative[1] = derivative[0] * (prev_derivative_order * (1.0 / 1.0));\r
     \r
        
        
        derivative[0] = (degree == 5) ? poly5[0] : derivative[0];\r
        derivative[0] = (degree == 4) ? poly5[1] : derivative[0];\r
        derivative[0] = (degree == 3) ? poly5[2] : derivative[0];

        
        float begin_value = derivative[5];\r
        begin_value = begin_value * begin + derivative[4];\r
        begin_value = begin_value * begin + derivative[3];\r
        begin_value = begin_value * begin + derivative[2];\r
        begin_value = begin_value * begin + derivative[1];\r
        begin_value = begin_value * begin + derivative[0];

        
        #pragma unroll\r
        for (int i = 0; i != 5; ++i) \r
        {\r
            if (i < 5 - degree) continue;

            float current_begin = critical_roots[i];\r
            float current_end = critical_roots[i + 1];

            
            float root;\r
            if (poly5_has_root_newton_bisection(root, begin_value, derivative, current_begin, current_end, begin_value, tolerance))\r
            {\r
                critical_roots[i] = root;\r
            }\r
            else if (degree < 5)\r
            {\r
                
                critical_roots[i] = critical_roots[i - 1];\r
            }\r
        }\r
    }

    
    
    
    derivative[5] = derivative[4] / 5.0;\r
    derivative[4] = derivative[3] / 4.0;\r
    derivative[3] = derivative[2] / 3.0;\r
    derivative[2] = derivative[1] / 2.0;\r
    derivative[1] = derivative[0] / 1.0;\r
    derivative[0] = poly5[0];

    
    float begin_value = derivative[5];\r
    begin_value = begin_value * begin + derivative[4];\r
    begin_value = begin_value * begin + derivative[3];\r
    begin_value = begin_value * begin + derivative[2];\r
    begin_value = begin_value * begin + derivative[1];\r
    begin_value = begin_value * begin + derivative[0];

    
    #pragma unroll\r
    for (int i = 0; i != 5; ++i) \r
    {\r
        float current_begin = critical_roots[i];\r
        float current_end = critical_roots[i + 1];

        
        if (poly5_has_root_sign_change(begin_value, derivative, current_begin, current_end, begin_value))\r
        {\r
            return true;\r
        }\r
    }

    return false;\r
}

#endif\r
#ifndef CUBIC_EXTREMA\r
#define CUBIC_EXTREMA

#ifndef QUADRATIC_ROOTS\r
#ifndef QUADRATIC_ROOTS\r
#define QUADRATIC_ROOTS

#ifndef SSIGN\r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif\r
#endif

vec2 quadratic_roots(in vec3 c)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    return vec2(xq, n.x / xq);\r
}

vec2 quadratic_roots(in vec3 c, in float xd)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    vec2 x = vec2(xq, n.x / xq);

    
    return (d >= 0.0) ? x : vec2(xd);\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif

vec2 cubic_extrema(in vec4 c)\r
{\r
    
    vec3 d = vec3(c.y, c.z * 2.0, c.w * 3.0);

    
    vec2 x0_x1 = quadratic_roots(d);

    
    vec2 y0_y1 = eval_poly(c, x0_x1);

    return y0_y1;\r
}

vec2 cubic_extrema(in vec4 c, in vec2 xa_xb)\r
{\r
    
    vec3 d = vec3(c.y, c.z * 2.0, c.w * 3.0);;

    
    vec2 x0_x1 = quadratic_roots(d);\r
    x0_x1 = clamp(x0_x1, xa_xb.x, xa_xb.y);

    
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    return y0_y1;\r
}

#endif\r
#ifndef QUINTIC_EXTREMA\r
#define QUINTIC_EXTREMA

#ifndef QUARTIC_ROOTS\r
#ifndef QUARTIC_ROOTS\r
#define QUARTIC_ROOTS

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef SSIGN\r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif\r
#endif\r
#ifndef CBRT\r
#ifndef CBRT\r
#define CBRT

float cbrt(in float v) \r
{ \r
    return sign(v) * pow(\r
        abs(v), 1.0/3.0\r
    ); \r
}

vec2  cbrt(in vec2 v) \r
{ \r
    return sign(v) * vec2(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0)\r
    ); \r
}

vec3  cbrt(in vec3 v) \r
{ \r
    return sign(v) * vec3(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0),\r
        pow(abs(v.z), 1.0/3.0)\r
    ); \r
}

vec4  cbrt(in vec4 v) \r
{ \r
    return sign(v) * vec4(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0), \r
        pow(abs(v.z), 1.0/3.0), \r
        pow(abs(v.w), 1.0/3.0)\r
    ); \r
}

#endif\r
#endif\r
#ifndef NAN\r
#define NAN uintBitsToFloat(0x7fc00000u)\r
#endif\r
#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif\r
#ifndef NANO_TOLERANCE\r
#define NANO_TOLERANCE 1e-9\r
#endif

float resolvent_cubic_max_root(in float rc, in float rb, in float ra)\r
{\r
    
    vec4 n = vec4(rc, rb, ra, 1.0);\r
    n.yz /= 3.0;

    
    vec3 h = vec3(\r
        n.y - n.z * n.z,                          
        n.x - n.y * n.z,                          
        dot(vec2(n.z, -n.y), n.xy)    
    );\r
    h.y /= 2.0;

    
    float d = dot(vec2(h.y, -h.x), h.yz); 
    float sqrt_d = sqrt(abs(d));

    
    vec2 r = vec2(h.y - n.z * h.x, h.x);\r
    \r
    
    float U1 = cbrt(-r.x + sqrt_d) + cbrt(-r.x - sqrt_d);\r
       \r
    
    
    float U3_max = cos(atan(sqrt_d, -r.x) / 3.0);\r
    U3_max *= sqrt(max(-r.y, 0.0)); 

    
    float U = (d < 0.0) ? U3_max : U1;\r
    U = U - n.z;

    
    
    
    
    
    

    
    return U;\r
}

vec4 factored_quadratics_roots(in float t, in float s, in float v, in float u)\r
{\r
    
    vec4 tsvu = vec4(t, s, v, u);\r
    tsvu.yw /= -2.0;\r
    \r
    
    
    vec2 d = tsvu.yw * tsvu.yw - tsvu.xz;\r
    vec2 sqrt_d = sqrt(max(d, 0.0));\r
    \r
    
    vec2 xq = vec2(\r
        tsvu.y + sqrt_d.x, \r
        tsvu.w - sqrt_d.y\r
    );

    
    return vec4(xq, tsvu.xz / xq);\r
}

vec4 quartic_roots(in float c[5]) \r
{\r
    
    
    bool flip = abs(c[3] * c[0]) >= abs(c[1] * c[4]);\r
    vec4 n = flip \r
    ? vec4(c[4], c[3], c[2], c[1] / 4.0) / c[0] \r
    : vec4(c[0], c[1], c[2], c[3] / 4.0) / c[4];

    
    
    float w2 = n.w * n.w;\r
    float p = n.z - w2 * 6.0;\r
    float q = n.y - n.w * (n.z - w2 * 4.0) * 2.0;\r
    float r = n.x - n.w * (n.y - n.w * (n.z - w2 * 3.0));

    
    
    float ra =  p * 2.0;\r
    float rb =  p * p - r * 4.0;\r
    float rc = -q * q;

    
    
    float U_max = resolvent_cubic_max_root(rc, rb, ra);\r
    float u = sqrt(abs(U_max));\r
    \r
    
    
    float qu = q / u;\r
    float t = (p + qu + u * u) * 0.5;\r
    float v = t - qu;\r
    float s = - u;

    
    
    vec4 x = factored_quadratics_roots(t, s, v, u);

    
    x = x - n.w;\r
    x = flip ? 1.0 / x : x;

    
    vec4 f, dfdx; \r
    f = eval_poly(c, x, dfdx);\r
    x -= f / dfdx; \r
    f = eval_poly(c, x, dfdx);\r
    x -= f / dfdx; 

    
    return x;\r
}

vec4 quartic_roots_2(in float c[5]) \r
{\r
    
    
    vec4 n = vec4(c[0], c[1], c[2], c[3] / 4.0) / c[4];

    
    
    float w2 = n.w * n.w;\r
    float p = n.z - w2 * 6.0;\r
    float q = n.y - n.w * (n.z - w2 * 4.0) * 2.0;\r
    float r = n.x - n.w * (n.y - n.w * (n.z - w2 * 3.0));

    
    
    float ra =  p * 2.0;\r
    float rb =  p * p - r * 4.0;\r
    float rc = -q * q;

    
    
    float U_max = resolvent_cubic_max_root(rc, rb, ra);\r
    float u = sqrt(abs(U_max));\r
    \r
    
    
    float qu = q / u;\r
    float t = (p + qu + u * u) * 0.5;\r
    float v = t - qu;\r
    float s = - u;

    
    
    vec4 x = factored_quadratics_roots(t, s, v, u);

    
    x = x - n.w;

    
    return x;\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif

vec4 quintic_extrema(in float c[6])\r
{\r
    
    float d[5] = float[5](\r
        c[1], \r
        c[2] * 2.0, \r
        c[3] * 3.0, \r
        c[4] * 4.0, \r
        c[5] * 5.0\r
    );

    
    vec4 x0_x1_x2_x3 = quartic_roots(d);

    
    vec4 y0_y1_y2_y3 = eval_poly(c, x0_x1_x2_x3);

    
    return y0_y1_y2_y3;\r
}

vec4 quintic_extrema(in float c[6], in vec2 xa_xb)\r
{\r
    
    float d[5] = float[5](\r
        c[1], \r
        c[2] * 2.0, \r
        c[3] * 3.0, \r
        c[4] * 4.0, \r
        c[5] * 5.0\r
    );

    
    vec4 x0_x1_x2_x3 = quartic_roots(d);\r
    x0_x1_x2_x3 = clamp(x0_x1_x2_x3, xa_xb.x, xa_xb.y);

    
    vec4 y0_y1_y2_y3 = eval_poly(c, x0_x1_x2_x3);

    
    return y0_y1_y2_y3;\r
}

#endif\r
#ifndef BISECTION_ROOT\r
#define BISECTION_ROOT

#ifndef BISECTION_ITERATIONS\r
#define BISECTION_ITERATIONS 3\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif

float bisection_root(in vec4 c, in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);\r
    \r
    float y;\r
    float x = (x0_x1.x + x0_x1.y) * 0.5;

    #pragma unroll\r
    for (int i = 0; i < BISECTION_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x);

        
        if ((y < 0.0) == (y0_y1.y < 0.0))\r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        }\r
        else\r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x = (x0_x1.x + x0_x1.y) * 0.5;\r
    }

    return x;\r
}

float bisection_root(in float c[5], in vec2 x0_x1)\r
{;\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    float y;\r
    float x = (x0_x1.x + x0_x1.y) * 0.5;

    #pragma unroll\r
    for (int i = 0; i < BISECTION_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x);

        
        if ((y < 0.0) == (y0_y1.y < 0.0))\r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        }\r
        else\r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x = (x0_x1.x + x0_x1.y) * 0.5;\r
    }

    return x;\r
}

float bisection_root(in float c[6], in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    float y;\r
    float x = (x0_x1.x + x0_x1.y) * 0.5;

    #pragma unroll\r
    for (int i = 0; i < BISECTION_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x);

        
        if ((y < 0.0) == (y0_y1.y < 0.0))\r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        }\r
        else\r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x = (x0_x1.x + x0_x1.y) * 0.5;\r
    }

    return x;\r
}

#endif\r
#ifndef NEUBAUER_ROOT\r
#define NEUBAUER_ROOT

#ifndef NEUBAUER_ITERATIONS\r
#define NEUBAUER_ITERATIONS 3\r
#endif\r
#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif

float neubauer_root(in vec4 c, in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float dx = x0_x1.y - x0_x1.x;\r
    float dy = y0_y1.y - y0_y1.x;\r
    float y, x = x0_x1.x - (y0_y1.x * dx) / dy;

    #pragma unroll\r
    for (int i = 0; i < NEUBAUER_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x);

        
        if ((y < 0.0) != (y0_y1.y < 0.0))\r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        }\r
        else\r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        dx = x0_x1.y - x0_x1.x;\r
        dy = y0_y1.y - y0_y1.x + MICRO_TOLERANCE;\r
        x = x0_x1.x - (y0_y1.x * dx) / dy;\r
    }

    return x;\r
}

float neubauer_root(in float c[5], in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float dx = x0_x1.y - x0_x1.x;\r
    float dy = y0_y1.y - y0_y1.x;\r
    float y, x = x0_x1.x - (y0_y1.x * dx) / dy;

    #pragma unroll\r
    for (int i = 0; i < NEUBAUER_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x);

        
        if ((y < 0.0) != (y0_y1.y < 0.0))\r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        }\r
        else\r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        dx = x0_x1.y - x0_x1.x;\r
        dy = y0_y1.y - y0_y1.x + MICRO_TOLERANCE;\r
        x = x0_x1.x - (y0_y1.x * dx) / dy;\r
    }

    return x;\r
}

float neubauer_root(in float c[6], in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float dx = x0_x1.y - x0_x1.x;\r
    float dy = y0_y1.y - y0_y1.x;\r
    float y, x = x0_x1.x - (y0_y1.x * dx) / dy;

    #pragma unroll\r
    for (int i = 0; i < NEUBAUER_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x);

        
        if ((y < 0.0) != (y0_y1.y < 0.0))\r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        }\r
        else\r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        dx = x0_x1.y - x0_x1.x;\r
        dy = y0_y1.y - y0_y1.x + MICRO_TOLERANCE;\r
        x = x0_x1.x - (y0_y1.x * dx) / dy;\r
    }

    return x;\r
}

#endif\r
#ifndef NEWTON_ROOT\r
#define NEWTON_ROOT

#ifndef NEWTON_ITERATIONS\r
#define NEWTON_ITERATIONS 3\r
#endif\r
#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif

float newton_root(in vec4 c, in float x)\r
{\r
    float y, dydx;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        x -= y / dydx;\r
    }

    return x;\r
}

float newton_root(in float c[5], in float x)\r
{\r
    float y, dydx;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        x -= y / dydx;\r
    }

    return x;\r
}

float newton_root(in float c[6], in float x)\r
{\r
    float y, dydx;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        x -= y / dydx;\r
    }

    return x;\r
}

#endif\r
#ifndef NEWTON_BISECTION_ROOT\r
#define NEWTON_BISECTION_ROOT

#ifndef NEWTON_BISECTION_ITERATIONS\r
#define NEWTON_BISECTION_ITERATIONS 3\r
#endif\r
#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif

float newton_bisection_root(in vec4 c, in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float y, dydx;       \r
    float x = (x0_x1.x + x0_x1.y) * 0.5;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_BISECTION_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        if ((y < 0.0) != (y0_y1.y < 0.0)) \r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        } \r
        else \r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x -= y / dydx;

        
        if (x < x0_x1.x || x0_x1.y > x)\r
        { \r
            x = (x0_x1.x + x0_x1.y) * 0.5;\r
        }\r
    }

    return x;\r
}

float newton_bisection_root(in float c[5], in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float y, dydx;       \r
    float x = (x0_x1.x + x0_x1.y) * 0.5;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_BISECTION_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        if ((y < 0.0) != (y0_y1.y < 0.0)) \r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        } \r
        else \r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x -= y / dydx;

        
        if (x < x0_x1.x || x0_x1.y > x)\r
        { \r
            x = (x0_x1.x + x0_x1.y) * 0.5;\r
        }\r
    }

    return x;\r
}

float newton_bisection_root(in float c[6], in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float y, dydx;       \r
    float x = (x0_x1.x + x0_x1.y) * 0.5;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_BISECTION_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        if ((y < 0.0) != (y0_y1.y < 0.0)) \r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        } \r
        else \r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x -= y / dydx;

        
        if (x < x0_x1.x || x0_x1.y > x)\r
        { \r
            x = (x0_x1.x + x0_x1.y) * 0.5;\r
        }\r
    }

    return x;\r
}

#endif\r
#ifndef NEWTON_NEUBAUER_ROOT\r
#define NEWTON_NEUBAUER_ROOT

#ifndef NEWTON_NEUBAUER_ITERATIONS\r
#define NEWTON_NEUBAUER_ITERATIONS 3\r
#endif\r
#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif

float newton_neubauer_root(in vec4 c, in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float dx = x0_x1.y - x0_x1.x;\r
    float dy = y0_y1.y - y0_y1.x;\r
    float dydx, y, x = x0_x1.x - (y0_y1.x * dx) / dy;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_NEUBAUER_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        if ((y < 0.0) != (y0_y1.y < 0.0)) \r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        } \r
        else \r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x -= y / dydx;

        
        if (x < x0_x1.x || x0_x1.y > x)\r
        { \r
            dx = x0_x1.y - x0_x1.x;\r
            dy = y0_y1.y - y0_y1.x + MICRO_TOLERANCE;\r
            x = x0_x1.x - (y0_y1.x * dx) / dy;\r
        }\r
    }\r
    \r
    return x;\r
}

float newton_neubauer_root(in float c[5], in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float dx = x0_x1.y - x0_x1.x;\r
    float dy = y0_y1.y - y0_y1.x;\r
    float dydx, y, x = x0_x1.x - (y0_y1.x * dx) / dy;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_NEUBAUER_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        if ((y < 0.0) != (y0_y1.y < 0.0)) \r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        } \r
        else \r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x -= y / dydx;

        
        if (x < x0_x1.x || x0_x1.y > x)\r
        { \r
            dx = x0_x1.y - x0_x1.x;\r
            dy = y0_y1.y - y0_y1.x + MICRO_TOLERANCE;\r
            x = x0_x1.x - (y0_y1.x * dx) / dy;\r
        }\r
    }\r
    \r
    return x;\r
}

float newton_neubauer_root(in float c[6], in vec2 x0_x1)\r
{\r
    vec2 y0_y1 = eval_poly(c, x0_x1);

    
    float dx = x0_x1.y - x0_x1.x;\r
    float dy = y0_y1.y - y0_y1.x;\r
    float dydx, y, x = x0_x1.x - (y0_y1.x * dx) / dy;

    #pragma unroll\r
    for (int i = 0; i < NEWTON_NEUBAUER_ITERATIONS; ++i)\r
    {\r
        
        y = eval_poly(c, x, dydx);

        
        if ((y < 0.0) != (y0_y1.y < 0.0)) \r
        {\r
            x0_x1.x = x;\r
            y0_y1.x = y;\r
        } \r
        else \r
        {\r
            x0_x1.y = x;\r
            y0_y1.y = y;\r
        }

        
        x -= y / dydx;

        
        if (x < x0_x1.x || x0_x1.y > x)\r
        { \r
            dx = x0_x1.y - x0_x1.x;\r
            dy = y0_y1.y - y0_y1.x + MICRO_TOLERANCE;\r
            x = x0_x1.x - (y0_y1.x * dx) / dy;\r
        }\r
    }\r
    \r
    return x;\r
}

#endif\r
#ifndef IS_QUADRATIC_SOLVABLE\r
#define IS_QUADRATIC_SOLVABLE

#ifndef LINEAR_ROOTS\r
#ifndef LINEAR_ROOT\r
#define LINEAR_ROOT

#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif

float linear_root(in vec2 c)\r
{\r
    
    float x = - c.x / c.y;\r
    return x;\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef SIGN_CHANGE\r
#ifndef SIGN_CHANGE\r
#define SIGN_CHANGE

bool sign_change(float a, float b) \r
{\r
    return (a < 0.0) != (b < 0.0);\r
}

bool sign_change(vec2 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0);\r
}

bool sign_change(vec3 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0);\r
}

bool sign_change(vec4 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0) ||\r
           (v.z < 0.0) != (v.w < 0.0);\r
}

bool sign_change(float v[5]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0);\r
}

bool sign_change(float v[6]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0) ||\r
           (v[4] < 0.0) != (v[5] < 0.0);\r
}

#endif\r
#endif

bool is_quadratic_solvable(in vec3 c, in vec2 xa_xb)\r
{\r
    
    vec2 d = vec2(c.y, c.z * 2.0);

    
    float x0 = linear_root(d);\r
    x0 = clamp(x0, xa_xb.x, xa_xb.y);

    
    float y0 = eval_poly(c, x0);

    
    vec2 ya_yb = eval_poly(c, xa_xb);

    
    vec3 ya_y0_yb = vec3(ya_yb.x, y0, ya_yb.y);

    
    return sign_change(ya_y0_yb);\r
}

bool is_quadratic_solvable(in vec3 c, in vec2 xa_xb, in vec2 ya_yb)\r
{\r
    
    vec2 d = vec2(c.y, c.z * 2.0);

    
    float x0 = linear_root(d);\r
    x0 = clamp(x0, xa_xb.x, xa_xb.y);

    
    float y0 = eval_poly(c, x0);

    
    vec3 ya_y0_yb = vec3(ya_yb.x, y0, ya_yb.y);

    
    return sign_change(ya_y0_yb);\r
}

#endif\r
#ifndef IS_CUBIC_SOLVABLE\r
#define IS_CUBIC_SOLVABLE

#ifndef QUADRATIC_ROOTS\r
#ifndef QUADRATIC_ROOTS\r
#define QUADRATIC_ROOTS

#ifndef SSIGN\r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif\r
#endif

vec2 quadratic_roots(in vec3 c)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    return vec2(xq, n.x / xq);\r
}

vec2 quadratic_roots(in vec3 c, in float xd)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    vec2 x = vec2(xq, n.x / xq);

    
    return (d >= 0.0) ? x : vec2(xd);\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef SIGN_CHANGE\r
#ifndef SIGN_CHANGE\r
#define SIGN_CHANGE

bool sign_change(float a, float b) \r
{\r
    return (a < 0.0) != (b < 0.0);\r
}

bool sign_change(vec2 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0);\r
}

bool sign_change(vec3 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0);\r
}

bool sign_change(vec4 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0) ||\r
           (v.z < 0.0) != (v.w < 0.0);\r
}

bool sign_change(float v[5]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0);\r
}

bool sign_change(float v[6]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0) ||\r
           (v[4] < 0.0) != (v[5] < 0.0);\r
}

#endif\r
#endif

bool is_cubic_solvable(in vec4 c, in vec2 xa_xb)\r
{\r
    
    vec3 d = vec3(c.y, c.z * 2.0, c.w * 3.0);;

    
    vec2 x0_x1 = quadratic_roots(d);\r
    x0_x1 = clamp(x0_x1, xa_xb.x, xa_xb.y);

    
    vec2 y0_y1 = eval_poly(c, x0_x1);

  
    vec2 ya_yb = eval_poly(c, xa_xb);

    
    vec4 ya_y0_y1_yb = vec4(ya_yb.x, y0_y1, ya_yb.y);

    
    return sign_change(ya_y0_y1_yb);\r
}

bool is_cubic_solvable(in vec4 c, in vec2 xa_xb, in vec2 ya_yb)\r
{ \r
    
    vec3 d = vec3(c.y, c.z * 2.0, c.w * 3.0);;

    
    vec2 x0_x1 = quadratic_roots(d);\r
    x0_x1 = clamp(x0_x1, xa_xb.x, xa_xb.y);

    
    vec2 y0_y1;\r
    y0_y1 = eval_poly(c, x0_x1);

     
    vec4 ya_y0_y1_yb = vec4(ya_yb.x, y0_y1, ya_yb.y);

    
    return sign_change(ya_y0_y1_yb);\r
}

#endif\r
#ifndef IS_QUARTIC_SOLVABLE\r
#define IS_QUARTIC_SOLVABLE

#ifndef CUBIC_ROOTS\r
#ifndef CUBIC_ROOTS\r
#define CUBIC_ROOTS

#ifndef QUADRATIC_ROOTS\r
#ifndef QUADRATIC_ROOTS\r
#define QUADRATIC_ROOTS

#ifndef SSIGN\r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif\r
#endif

vec2 quadratic_roots(in vec3 c)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    return vec2(xq, n.x / xq);\r
}

vec2 quadratic_roots(in vec3 c, in float xd)\r
{\r
    
    vec2 n = c.xy / c.z;\r
    n.y /= -2.0;

    
    float d = n.y * n.y - n.x;\r
    float sqrt_d = sqrt(max(0.0, d));\r
    float xq = n.y + sqrt_d * ssign(n.y);

    
    vec2 x = vec2(xq, n.x / xq);

    
    return (d >= 0.0) ? x : vec2(xd);\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef CBRT\r
#ifndef CBRT\r
#define CBRT

float cbrt(in float v) \r
{ \r
    return sign(v) * pow(\r
        abs(v), 1.0/3.0\r
    ); \r
}

vec2  cbrt(in vec2 v) \r
{ \r
    return sign(v) * vec2(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0)\r
    ); \r
}

vec3  cbrt(in vec3 v) \r
{ \r
    return sign(v) * vec3(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0),\r
        pow(abs(v.z), 1.0/3.0)\r
    ); \r
}

vec4  cbrt(in vec4 v) \r
{ \r
    return sign(v) * vec4(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0), \r
        pow(abs(v.z), 1.0/3.0), \r
        pow(abs(v.w), 1.0/3.0)\r
    ); \r
}

#endif\r
#endif\r
#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif\r
#ifndef SQRT_3\r
#define SQRT_3 1.73205080757\r
#endif\r
#ifndef NAN\r
#define NAN uintBitsToFloat(0x7fc00000u)\r
#endif

vec3 cubic_roots(in vec4 c)\r
{\r
    
    bool flip = abs(c.z * c.x) >= abs(c.y * c.w);\r
    vec3 n = flip ? c.wzy / c.x : c.xyz / c.w;\r
    n.yz /= 3.0;

    
    vec3 h = vec3(\r
        n.y - n.z * n.z,                          
        n.x - n.y * n.z,                          
        dot(vec2(n.z, -n.y), n.xy)    
    );\r
    h.y /= 2.0;

    
    float d = dot(vec2(h.x, -h.y), h.zy); 
    float sqrt_d = sqrt(abs(d));

    
    vec2 r = vec2(h.y - h.x * n.z, h.x);\r
    \r
    
    vec3 x1 = vec3(cbrt(-r.x + sqrt_d) + cbrt(-r.x - sqrt_d));

    
    float t = atan(sqrt_d, -r.x) / 3.0;\r
    mat2 proj = mat2(-1.0, -SQRT_3, -1.0, SQRT_3);

    
    vec2 x2 = vec2(cos(t), sin(t));\r
    vec3 x3 = vec3(x2 * proj, x2.x * 2.0);

    
    x3 *= sqrt(max(0.0, -r.y)); 

    
    vec3 x = (d > 0.0) ? x3 : x1;\r
    x = x - n.z;\r
    x = flip ? 1.0 / x : x;

    
    vec3 y, dydx;\r
    y = eval_poly(c, x, dydx);\r
    x -= y / dydx; \r
    y = eval_poly(c, x, dydx);\r
    x -= y / dydx; 

    
    return x;\r
}

vec3 cubic_roots_2(in vec4 c)\r
{\r
    
    vec3 n = c.xyz / c.w;\r
    n.yz /= 3.0;

    
    vec3 h = vec3(\r
        n.y - n.z * n.z,                          
        n.x - n.y * n.z,                          
        dot(vec2(n.z, -n.y), n.xy)    
    );\r
    h.y /= 2.0;

    
    float d = dot(vec2(h.x, -h.y), h.zy); 
    float sqrt_d = sqrt(abs(d));

    
    vec2 r = vec2(h.y - h.x * n.z, h.x);\r
    \r
    
    vec3 x1 = vec3(cbrt(-r.x + sqrt_d) + cbrt(-r.x - sqrt_d));

    
    float t = atan(sqrt_d, -r.x) / 3.0;\r
    mat2 proj = mat2(-1.0, -SQRT_3, -1.0, SQRT_3);

    
    vec2 x2 = vec2(cos(t), sin(t));\r
    vec3 x3 = vec3(x2 * proj, x2.x * 2.0);

    
    x3 *= sqrt(max(0.0, -r.y)); 

    
    vec3 x = (d > 0.0) ? x3 : x1;\r
    x = x - n.z;

    
    return x;\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif

bool is_quartic_solvable(in float c[5], in vec2 xa_xb)\r
{\r
    
    vec4 d = vec4(\r
        c[1], \r
        c[2] * 2.0, \r
        c[3] * 3.0, \r
        c[4] * 4.0\r
    );

    
    vec3 x0_x1_x2 = cubic_roots(d);\r
    x0_x1_x2 = clamp(x0_x1_x2, xa_xb.x, xa_xb.y);

    
    vec3 y0_y1_y2 = eval_poly(c, x0_x1_x2);

    
    vec2 ya_yb = eval_poly(c, xa_xb);

    
    vec4 ya_y0_y1_y2 = vec4(ya_yb.x, y0_y1_y2);\r
    vec4 y0_y1_y2_yb = vec4(y0_y1_y2, ya_yb.y);

    
    return sign_change(ya_y0_y1_y2) || sign_change(y0_y1_y2_yb);\r
}

bool is_quartic_solvable(in float c[5], in vec2 xa_xb, in vec2 ya_yb)\r
{\r
    
    vec4 d = vec4(\r
        c[1], \r
        c[2] * 2.0, \r
        c[3] * 3.0, \r
        c[4] * 4.0\r
    );

    
    vec3 x0_x1_x2 = cubic_roots(d);\r
    x0_x1_x2 = clamp(x0_x1_x2, xa_xb.x, xa_xb.y);

    
    vec3 y0_y1_y2 = eval_poly(c, x0_x1_x2);

    
    vec4 ya_y0_y1_y2 = vec4(ya_yb.x, y0_y1_y2);\r
    vec4 y0_y1_y2_yb = vec4(y0_y1_y2, ya_yb.y);

    
    return sign_change(ya_y0_y1_y2) || sign_change(y0_y1_y2_yb);\r
}

#endif\r
#ifndef IS_QUINTIC_SOLVABLE\r
#define IS_QUINTIC_SOLVABLE

#ifndef QUARTIC_ROOTS\r
#ifndef QUARTIC_ROOTS\r
#define QUARTIC_ROOTS

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef SSIGN\r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif\r
#endif\r
#ifndef CBRT\r
#ifndef CBRT\r
#define CBRT

float cbrt(in float v) \r
{ \r
    return sign(v) * pow(\r
        abs(v), 1.0/3.0\r
    ); \r
}

vec2  cbrt(in vec2 v) \r
{ \r
    return sign(v) * vec2(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0)\r
    ); \r
}

vec3  cbrt(in vec3 v) \r
{ \r
    return sign(v) * vec3(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0),\r
        pow(abs(v.z), 1.0/3.0)\r
    ); \r
}

vec4  cbrt(in vec4 v) \r
{ \r
    return sign(v) * vec4(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0), \r
        pow(abs(v.z), 1.0/3.0), \r
        pow(abs(v.w), 1.0/3.0)\r
    ); \r
}

#endif\r
#endif\r
#ifndef NAN\r
#define NAN uintBitsToFloat(0x7fc00000u)\r
#endif\r
#ifndef MICRO_TOLERANCE\r
#define MICRO_TOLERANCE 1e-6\r
#endif\r
#ifndef NANO_TOLERANCE\r
#define NANO_TOLERANCE 1e-9\r
#endif

float resolvent_cubic_max_root(in float rc, in float rb, in float ra)\r
{\r
    
    vec4 n = vec4(rc, rb, ra, 1.0);\r
    n.yz /= 3.0;

    
    vec3 h = vec3(\r
        n.y - n.z * n.z,                          
        n.x - n.y * n.z,                          
        dot(vec2(n.z, -n.y), n.xy)    
    );\r
    h.y /= 2.0;

    
    float d = dot(vec2(h.y, -h.x), h.yz); 
    float sqrt_d = sqrt(abs(d));

    
    vec2 r = vec2(h.y - n.z * h.x, h.x);\r
    \r
    
    float U1 = cbrt(-r.x + sqrt_d) + cbrt(-r.x - sqrt_d);\r
       \r
    
    
    float U3_max = cos(atan(sqrt_d, -r.x) / 3.0);\r
    U3_max *= sqrt(max(-r.y, 0.0)); 

    
    float U = (d < 0.0) ? U3_max : U1;\r
    U = U - n.z;

    
    
    
    
    
    

    
    return U;\r
}

vec4 factored_quadratics_roots(in float t, in float s, in float v, in float u)\r
{\r
    
    vec4 tsvu = vec4(t, s, v, u);\r
    tsvu.yw /= -2.0;\r
    \r
    
    
    vec2 d = tsvu.yw * tsvu.yw - tsvu.xz;\r
    vec2 sqrt_d = sqrt(max(d, 0.0));\r
    \r
    
    vec2 xq = vec2(\r
        tsvu.y + sqrt_d.x, \r
        tsvu.w - sqrt_d.y\r
    );

    
    return vec4(xq, tsvu.xz / xq);\r
}

vec4 quartic_roots(in float c[5]) \r
{\r
    
    
    bool flip = abs(c[3] * c[0]) >= abs(c[1] * c[4]);\r
    vec4 n = flip \r
    ? vec4(c[4], c[3], c[2], c[1] / 4.0) / c[0] \r
    : vec4(c[0], c[1], c[2], c[3] / 4.0) / c[4];

    
    
    float w2 = n.w * n.w;\r
    float p = n.z - w2 * 6.0;\r
    float q = n.y - n.w * (n.z - w2 * 4.0) * 2.0;\r
    float r = n.x - n.w * (n.y - n.w * (n.z - w2 * 3.0));

    
    
    float ra =  p * 2.0;\r
    float rb =  p * p - r * 4.0;\r
    float rc = -q * q;

    
    
    float U_max = resolvent_cubic_max_root(rc, rb, ra);\r
    float u = sqrt(abs(U_max));\r
    \r
    
    
    float qu = q / u;\r
    float t = (p + qu + u * u) * 0.5;\r
    float v = t - qu;\r
    float s = - u;

    
    
    vec4 x = factored_quadratics_roots(t, s, v, u);

    
    x = x - n.w;\r
    x = flip ? 1.0 / x : x;

    
    vec4 f, dfdx; \r
    f = eval_poly(c, x, dfdx);\r
    x -= f / dfdx; \r
    f = eval_poly(c, x, dfdx);\r
    x -= f / dfdx; 

    
    return x;\r
}

vec4 quartic_roots_2(in float c[5]) \r
{\r
    
    
    vec4 n = vec4(c[0], c[1], c[2], c[3] / 4.0) / c[4];

    
    
    float w2 = n.w * n.w;\r
    float p = n.z - w2 * 6.0;\r
    float q = n.y - n.w * (n.z - w2 * 4.0) * 2.0;\r
    float r = n.x - n.w * (n.y - n.w * (n.z - w2 * 3.0));

    
    
    float ra =  p * 2.0;\r
    float rb =  p * p - r * 4.0;\r
    float rc = -q * q;

    
    
    float U_max = resolvent_cubic_max_root(rc, rb, ra);\r
    float u = sqrt(abs(U_max));\r
    \r
    
    
    float qu = q / u;\r
    float t = (p + qu + u * u) * 0.5;\r
    float v = t - qu;\r
    float s = - u;

    
    
    vec4 x = factored_quadratics_roots(t, s, v, u);

    
    x = x - n.w;

    
    return x;\r
}

#endif\r
#endif\r
#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef SIGN_CHANGE\r
#ifndef SIGN_CHANGE\r
#define SIGN_CHANGE

bool sign_change(float a, float b) \r
{\r
    return (a < 0.0) != (b < 0.0);\r
}

bool sign_change(vec2 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0);\r
}

bool sign_change(vec3 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0);\r
}

bool sign_change(vec4 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0) ||\r
           (v.z < 0.0) != (v.w < 0.0);\r
}

bool sign_change(float v[5]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0);\r
}

bool sign_change(float v[6]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0) ||\r
           (v[4] < 0.0) != (v[5] < 0.0);\r
}

#endif\r
#endif

bool is_quintic_solvable(in float c[6], in vec2 xa_xb)\r
{\r
    
    float d[5] = float[5](\r
        c[1], \r
        c[2] * 2.0, \r
        c[3] * 3.0, \r
        c[4] * 4.0, \r
        c[5] * 5.0\r
    );

    
    vec4 x0_x1_x2_x3 = quartic_roots(d);\r
    x0_x1_x2_x3 = clamp(x0_x1_x2_x3, xa_xb.x, xa_xb.y);

    
    vec4 y0_y1_y2_y3 = eval_poly(c, x0_x1_x2_x3);

    
    vec2 ya_yb = eval_poly(c, xa_xb);

    
    vec4 ya_y0_y1_y2 = vec4(ya_yb.x, y0_y1_y2_y3.xyz);\r
    vec3 y2_y3_yb = vec3(y0_y1_y2_y3.zw, ya_yb.y);

    
    return sign_change(ya_y0_y1_y2) || sign_change(y2_y3_yb);\r
}

bool is_quintic_solvable(in float c[6], in vec2 xa_xb, in vec2 ya_yb)\r
{\r
    
    float d[5] = float[5](\r
        c[1], \r
        c[2] * 2.0, \r
        c[3] * 3.0, \r
        c[4] * 4.0, \r
        c[5] * 5.0\r
    );

    
    vec4 x0_x1_x2_x3 = quartic_roots(d);\r
    x0_x1_x2_x3 = clamp(x0_x1_x2_x3, xa_xb.x, xa_xb.y);

    
    vec4 y0_y1_y2_y3 = eval_poly(c, x0_x1_x2_x3);

    
    vec4 ya_y0_y1_y2 = vec4(ya_yb.x, y0_y1_y2_y3.xyz);\r
    vec3 y2_y3_yb = vec3(y0_y1_y2_y3.zw, ya_yb.y);

    
    return sign_change(ya_y0_y1_y2) || sign_change(y2_y3_yb);\r
}

#endif\r
#ifndef ARGMAX
#define ARGMAX

int argmax(in float x) 
{ 
    return 0; 
}

int argmax(in vec2 v) 
{ 
    return int(v.x < v.y); 
}

int argmax(in vec3 v) 
{ 
    int i = int(v.x < v.y);
    i += int(v[i] < v.z) * (2 - i);
    return i;
}

int argmax(in vec4 v) 
{ 
    int i = int(v.x < v.y);
    i += int(v[i] < v.z) * (2 - i);
    i += int(v[i] < v.w) * (3 - i);
    return i;
}

int argmax(in float x, in float y) 
{ 
    return argmax(vec2(x, y)); 
}

int argmax(in float x, in float y, in float z) 
{ 
    return argmax(vec3(x, y, z));
}

int argmax(in float x, in float y, in float z, in float w) 
{ 
    return argmax(vec4(x, y, z, w));
}

#endif \r
#ifndef ARGMIN
#define ARGMIN

int argmin(in float x) 
{ 
    return 0; 
}

int argmin(in vec2 v) 
{ 
    return int(v.x > v.y); 
}

int argmin(in vec3 v) 
{ 
    int i = int(v.x > v.y);
    i += int(v[i] > v.z) * (2 - i);
    return i;
}

int argmin(in vec4 v) 
{ 
    int i = int(v.x > v.y);
    i += int(v[i] > v.z) * (2 - i);
    i += int(v[i] > v.w) * (3 - i);
    return i;
}

int argmin(in float x, in float y) 
{ 
    return argmin(vec2(x, y)); 
}

int argmin(in float x, in float y, in float z) 
{ 
    return argmin(vec3(x, y, z));
}

int argmin(in float x, in float y, in float z, in float w) 
{ 
    return argmin(vec4(x, y, z, w));
}

#endif \r
#ifndef CBRT\r
#define CBRT

float cbrt(in float v) \r
{ \r
    return sign(v) * pow(\r
        abs(v), 1.0/3.0\r
    ); \r
}

vec2  cbrt(in vec2 v) \r
{ \r
    return sign(v) * vec2(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0)\r
    ); \r
}

vec3  cbrt(in vec3 v) \r
{ \r
    return sign(v) * vec3(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0),\r
        pow(abs(v.z), 1.0/3.0)\r
    ); \r
}

vec4  cbrt(in vec4 v) \r
{ \r
    return sign(v) * vec4(\r
        pow(abs(v.x), 1.0/3.0), \r
        pow(abs(v.y), 1.0/3.0), \r
        pow(abs(v.z), 1.0/3.0), \r
        pow(abs(v.w), 1.0/3.0)\r
    ); \r
}

#endif \r
#ifndef CLAMPABS
#define CLAMPABS

#ifndef SSIGN
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif
#endif

float clampabs(in float v, in float a, in float b) { return ssign(v) * clamp(abs(v), a, b); }
vec2  clampabs(in vec2  v, in float a, in float b) { return ssign(v) * clamp(abs(v), a, b); }
vec3  clampabs(in vec3  v, in float a, in float b) { return ssign(v) * clamp(abs(v), a, b); }
vec4  clampabs(in vec4  v, in float a, in float b) { return ssign(v) * clamp(abs(v), a, b); }
vec2  clampabs(in vec2  v, in vec2  a, in vec2  b) { return ssign(v) * clamp(abs(v), a, b); }
vec3  clampabs(in vec3  v, in vec3  a, in vec3  b) { return ssign(v) * clamp(abs(v), a, b); }
vec4  clampabs(in vec4  v, in vec4  a, in vec4  b) { return ssign(v) * clamp(abs(v), a, b); }

#endif \r
#ifndef CUMPROD
#define CUMPROD

vec2 cumprod(in vec2 v) { v.y *= v.x; return v; }
vec3 cumprod(in vec3 v) { v.y *= v.x; v.z *= v.y; return v; }
vec4 cumprod(in vec4 v) { v.y *= v.x; v.z *= v.y; v.w *= v.z; return v; }

ivec2 cumprod(in ivec2 v) { v.y *= v.x; return v; }
ivec3 cumprod(in ivec3 v) { v.y *= v.x; v.z *= v.y; return v; }
ivec4 cumprod(in ivec4 v) { v.y *= v.x; v.z *= v.y; v.w *= v.z; return v; }

#endif \r
#ifndef CUMSUM
#define CUMSUM

vec2 cumsum(in vec2 v) { v.y += v.x; return v; }
vec3 cumsum(in vec3 v) { v.y += v.x; v.z += v.y; return v; }
vec4 cumsum(in vec4 v) { v.y += v.x; v.z += v.y; v.w += v.z; return v; }

ivec2 cumsum(in ivec2 v) { v.y += v.x; return v; }
ivec3 cumsum(in ivec3 v) { v.y += v.x; v.z += v.y; return v; }
ivec4 cumsum(in ivec4 v) { v.y += v.x; v.z += v.y; v.w += v.z; return v; }

#endif \r
#ifndef DECIMATE
#define DECIMATE

float decimate(float v, float p){ return floor(v*p)/p; }
vec2 decimate(vec2 v, float p){ return floor(v*p)/p; }
vec2 decimate(vec2 v, vec2 p){ return floor(v*p)/p; }
vec3 decimate(vec3 v, float p){ return floor(v*p)/p; }
vec3 decimate(vec3 v, vec3 p){ return floor(v*p)/p; }
vec4 decimate(vec4 v, float p){ return floor(v*p)/p; }
vec4 decimate(vec4 v, vec4 p){ return floor(v*p)/p; }

#endif \r
#ifndef DIFF\r
#define DIFF

float diff(in vec2  v) { return v.y   - v.x;   }\r
vec2  diff(in vec3  v) { return v.yz  - v.xy;  }\r
vec3  diff(in vec4  v) { return v.yzw - v.xyz; }

#endif \r
#ifndef MAP\r
#define MAP

float map(in float a, in float b, in float x) {return (x - a) / (b - a);}\r
vec2  map(in float a, in float b, in vec2  x) {return (x - a) / (b - a);}\r
vec3  map(in float a, in float b, in vec3  x) {return (x - a) / (b - a);}\r
vec4  map(in float a, in float b, in vec4  x) {return (x - a) / (b - a);}\r
vec2  map(in vec2  a, in vec2  b, in vec2  x) {return (x - a) / (b - a);}\r
vec3  map(in vec3  a, in vec3  b, in vec3  x) {return (x - a) / (b - a);}\r
vec4  map(in vec4  a, in vec4  b, in vec4  x) {return (x - a) / (b - a);}

#endif \r
#ifndef MAXABS\r
#define MAXABS

float maxabs(in vec2 a) \r
{\r
    return abs(a.x) > abs(a.y) ? a.x : a.y;\r
}

float maxabs(in vec3 a) \r
{\r
    float v = abs(a.x) > abs(a.y) ? a.x : a.y;\r
    return abs(v) > abs(a.z) ? v : a.z;\r
}

float maxabs(in vec4 a) \r
{\r
    float v1 = abs(a.x) > abs(a.y) ? a.x : a.y;\r
    float v2 = abs(a.z) > abs(a.w) ? a.z : a.w;\r
    return abs(v1) > abs(v2) ? v1 : v2;\r
}

float maxabs(in float a, in float b) \r
{\r
    return abs(a) > abs(b) ? a : b;\r
}

vec2 maxabs(in vec2 a, in float b) \r
{\r
    return vec2(maxabs(a.x, b), maxabs(a.y, b));\r
}

vec3 maxabs(in vec3 a, in float b) \r
{\r
    return vec3(maxabs(a.x, b), maxabs(a.y, b), maxabs(a.z, b));\r
}

vec4 maxabs(in vec4 a, in float b) \r
{\r
    return vec4(maxabs(a.x, b), maxabs(a.y, b), maxabs(a.z, b), maxabs(a.w, b));\r
}

vec2 maxabs(in vec2 a, in vec2 b) \r
{\r
    return vec2(maxabs(a.x, b.x), maxabs(a.y, b.y));\r
}

vec3 maxabs(in vec3 a, in vec3 b) \r
{\r
    return vec3(maxabs(a.x, b.x), maxabs(a.y, b.y), maxabs(a.z, b.z));\r
}

vec4 maxabs(in vec4 a, in vec4 b) \r
{\r
    return vec4(maxabs(a.x, b.x), maxabs(a.y, b.y), maxabs(a.z, b.z), maxabs(a.w, b.w));\r
}

#endif \r
#ifndef MEAN\r
#define MEAN

float mean(in vec2 v) { return dot(v, vec2(1.0)) / 2.0; }\r
float mean(in vec3 v) { return dot(v, vec3(1.0)) / 3.0; }\r
float mean(in vec4 v) { return dot(v, vec4(1.0)) / 4.0; }

float mean(in float a, in float b) { return (a + b) / 2.0; }\r
vec2 mean(in vec2 a, in vec2 b) { return (a + b) / 2.0; }\r
vec3 mean(in vec3 a, in vec3 b) { return (a + b) / 2.0; }\r
vec4 mean(in vec4 a, in vec4 b) { return (a + b) / 2.0; }

float mean(in float a, in float b, in float c) { return (a + b + c) / 3.0; }\r
vec2 mean(in vec2 a, in vec2 b, in vec2 c) { return (a + b + c) / 3.0; }\r
vec3 mean(in vec3 a, in vec3 b, in vec3 c) { return (a + b + c) / 3.0; }\r
vec4 mean(in vec4 a, in vec4 b, in vec4 c) { return (a + b + c) / 3.0; }

float mean(in float a, in float b, in float c, in float d) { return (a + b + c + d) / 4.0; }\r
vec2 mean(in vec2 a, in vec2 b, in vec2 c, in vec2 d) { return (a + b + c + d) / 4.0; }\r
vec3 mean(in vec3 a, in vec3 b, in vec3 c, in vec3 d) { return (a + b + c + d) / 4.0; }\r
vec4 mean(in vec4 a, in vec4 b, in vec4 c, in vec4 d) { return (a + b + c + d) / 4.0; }

#endif \r
#ifndef MINABS\r
#define MINABS

float minabs(in vec2 a)\r
{\r
    return abs(a.x) < abs(a.y) ? a.x : a.y;\r
}

float minabs(in vec3 a)\r
{\r
    float v = abs(a.x) < abs(a.y) ? a.x : a.y;\r
    return abs(v) < abs(a.z) ? v : a.z;\r
}

float minabs(in vec4 a)\r
{\r
    float v1 = abs(a.x) < abs(a.y) ? a.x : a.y;\r
    float v2 = abs(a.z) < abs(a.w) ? a.z : a.w;\r
    return abs(v1) < abs(v2) ? v1 : v2;\r
}

float minabs(in float a, in float b)\r
{\r
    return abs(a) < abs(b) ? a : b;\r
}

vec2 minabs(in vec2 a, in float b)\r
{\r
    return vec2(minabs(a.x, b), minabs(a.y, b));\r
}

vec3 minabs(in vec3 a, in float b)\r
{\r
    return vec3(minabs(a.x, b), minabs(a.y, b), minabs(a.z, b));\r
}

vec4 minabs(in vec4 a, in float b)\r
{\r
    return vec4(minabs(a.x, b), minabs(a.y, b), minabs(a.z, b), minabs(a.w, b));\r
}

vec2 minabs(in vec2 a, in vec2 b)\r
{\r
    return vec2(minabs(a.x, b.x), minabs(a.y, b.y));\r
}

vec3 minabs(in vec3 a, in vec3 b)\r
{\r
    return vec3(minabs(a.x, b.x), minabs(a.y, b.y), minabs(a.z, b.z));\r
}

vec4 minabs(in vec4 a, in vec4 b)\r
{\r
    return vec4(minabs(a.x, b.x), minabs(a.y, b.y), minabs(a.z, b.z), minabs(a.w, b.w));\r
}

#endif \r
#ifndef MMAX\r
#define MMAX

float mmax(in float a) { return a; }\r
float mmax(in float a, in float b) { return max(a, b); }\r
float mmax(in float a, in float b, in float c) { return max(a, max(b, c)); }\r
float mmax(in float a, in float b, in float c, in float d) { return max(max(a, b), max(c, d)); }\r
float mmax(vec2 v) { return max(v.x, v.y); }\r
float mmax(vec3 v) { return mmax(v.x, v.y, v.z); }\r
float mmax(vec4 v) { return mmax(v.x, v.y, v.z, v.w); }\r
float mmax(float v[5]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    return r;\r
}\r
float mmax(float v[6]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    r = max(r, v[5]);\r
    return r;\r
}

vec2 mmax(mat2 A)\r
{\r
    vec2 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    return r;\r
}\r
vec3 mmax(mat3 A)\r
{\r
    vec3 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    return r;\r
}\r
vec4 mmax(mat4 A)\r
{\r
    vec4 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    r[3] = mmax(A[3]);\r
    return r;\r
}

#endif \r
#ifndef MMIN\r
#define MMIN

float mmin(in float a) { return a; }\r
float mmin(in float a,in float b) { return min(a, b); }\r
float mmin(in float a,in float b, in float c) { return min(a, min(b, c)); }\r
float mmin(in float a,in float b, in float c, in float d) { return min(min(a,b), min(c, d)); }

float mmin(vec2 v) { return min(v.x, v.y); }\r
float mmin(vec3 v) { return mmin(v.x, v.y, v.z); }\r
float mmin(vec4 v) { return mmin(v.x, v.y, v.z, v.w); }\r
float mmin(float v[5]) \r
{\r
    float r = v[0];\r
    r = min(r, v[1]);\r
    r = min(r, v[2]);\r
    r = min(r, v[3]);\r
    r = min(r, v[4]);\r
    return r;\r
}\r
float mmin(float v[6]) \r
{\r
    float r = v[0];\r
    r = min(r, v[1]);\r
    r = min(r, v[2]);\r
    r = min(r, v[3]);\r
    r = min(r, v[4]);\r
    r = min(r, v[5]);\r
    return r;\r
}

#endif \r
#ifndef MMIX\r
#define MMIX

float mmix(in float a, in float b, in float pct) { return mix(a, b, pct); }\r
vec2  mmix(in vec2  a, in vec2  b, in vec2  pct) { return mix(a, b, pct); }\r
vec3  mmix(in vec3  a, in vec3  b, in vec3  pct) { return mix(a, b, pct); }\r
vec4  mmix(in vec4  a, in vec4  b, in vec4  pct) { return mix(a, b, pct); }\r
vec2  mmix(in vec2  a, in vec2  b, in float pct) { return mix(a, b, pct); }\r
vec3  mmix(in vec3  a, in vec3  b, in float pct) { return mix(a, b, pct); }\r
vec4  mmix(in vec4  a, in vec4  b, in float pct) { return mix(a, b, pct); }

vec2  mmix(in float a, in vec2 b, in vec2  pct) { return mix(vec2(a), b, pct); }\r
vec3  mmix(in float a, in vec3 b, in vec3  pct) { return mix(vec3(a), b, pct); }\r
vec4  mmix(in float a, in vec4 b, in vec4  pct) { return mix(vec4(a), b, pct); }\r
vec2  mmix(in float a, in vec2 b, in float pct) { return mix(vec2(a), b, pct); }\r
vec3  mmix(in float a, in vec3 b, in float pct) { return mix(vec3(a), b, pct); }\r
vec4  mmix(in float a, in vec4 b, in float pct) { return mix(vec4(a), b, pct); }

vec2  mmix(in vec2 a, in float b, in vec2  pct) { return mix(a, vec2(b), pct); }\r
vec3  mmix(in vec3 a, in float b, in vec3  pct) { return mix(a, vec3(b), pct); }\r
vec4  mmix(in vec4 a, in float b, in vec4  pct) { return mix(a, vec4(b), pct); }\r
vec2  mmix(in vec2 a, in float b, in float pct) { return mix(a, vec2(b), pct); }\r
vec3  mmix(in vec3 a, in float b, in float pct) { return mix(a, vec3(b), pct); }\r
vec4  mmix(in vec4 a, in float b, in float pct) { return mix(a, vec4(b), pct); }

vec2  mmix(in float a, in float b, in vec2 pct) { return mix(vec2(a), vec2(b), pct); }\r
vec3  mmix(in float a, in float b, in vec3 pct) { return mix(vec3(a), vec3(b), pct); }\r
vec4  mmix(in float a, in float b, in vec4 pct) { return mix(vec4(a), vec4(b), pct); }

float mmix(in float a, in float b, in float c, in float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec2 mmix(vec2 a, vec2 b, vec2 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec2 mmix(vec2 a, vec2 b, vec2 c, vec2 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec3 mmix(vec3 a, vec3 b, vec3 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec3 mmix(vec3 a, vec3 b, vec3 c, vec3 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec4 mmix(vec4 a, vec4 b, vec4 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec4 mmix(vec4 a, vec4 b, vec4 c, vec4 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

float mmix(in float a, in float b, in float c, in float d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec2 mmix(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec2 mmix(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec3 mmix(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec3 mmix(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec4 mmix(in vec4 a, in vec4 b, in vec4 c, in vec4 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec4 mmix(in vec4 a, in vec4 b, in vec4 c, in vec4 d, in vec4 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

mat2 mmix(mat2 A, mat2 B, float alpha) {\r
    return mat2(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha)\r
    );\r
}

mat3 mmix(mat3 A, mat3 B, float alpha) {\r
    return mat3(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha)\r
    );\r
}

mat4 mmix(mat4 A, mat4 B, float alpha) {\r
    return mat4(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

mat2x3 mmix(mat2x3 A, mat2x3 B, float alpha) {\r
    return mat2x3(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha)  
    );\r
}

mat3x2 mmix(mat3x2 A, mat3x2 B, float alpha) {\r
    return mat3x2(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha), 
        mix(A[2], B[2], alpha)  
    );\r
}

mat2x4 mmix(mat2x4 A, mat2x4 B, float alpha) {\r
    return mat2x4(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha)  
    );\r
}

mat4x2 mmix(mat4x2 A, mat4x2 B, float alpha) {\r
    return mat4x2(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

mat3x4 mmix(mat3x4 A, mat3x4 B, float alpha) {\r
    return mat3x4(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha)\r
    );\r
}

mat4x3 mmix(mat4x3 A, mat4x3 B, float alpha) {\r
    return mat4x3(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

#endif \r
#ifndef MMIX2\r
#define MMIX2

#ifndef MMIX\r
#ifndef MMIX\r
#define MMIX

float mmix(in float a, in float b, in float pct) { return mix(a, b, pct); }\r
vec2  mmix(in vec2  a, in vec2  b, in vec2  pct) { return mix(a, b, pct); }\r
vec3  mmix(in vec3  a, in vec3  b, in vec3  pct) { return mix(a, b, pct); }\r
vec4  mmix(in vec4  a, in vec4  b, in vec4  pct) { return mix(a, b, pct); }\r
vec2  mmix(in vec2  a, in vec2  b, in float pct) { return mix(a, b, pct); }\r
vec3  mmix(in vec3  a, in vec3  b, in float pct) { return mix(a, b, pct); }\r
vec4  mmix(in vec4  a, in vec4  b, in float pct) { return mix(a, b, pct); }

vec2  mmix(in float a, in vec2 b, in vec2  pct) { return mix(vec2(a), b, pct); }\r
vec3  mmix(in float a, in vec3 b, in vec3  pct) { return mix(vec3(a), b, pct); }\r
vec4  mmix(in float a, in vec4 b, in vec4  pct) { return mix(vec4(a), b, pct); }\r
vec2  mmix(in float a, in vec2 b, in float pct) { return mix(vec2(a), b, pct); }\r
vec3  mmix(in float a, in vec3 b, in float pct) { return mix(vec3(a), b, pct); }\r
vec4  mmix(in float a, in vec4 b, in float pct) { return mix(vec4(a), b, pct); }

vec2  mmix(in vec2 a, in float b, in vec2  pct) { return mix(a, vec2(b), pct); }\r
vec3  mmix(in vec3 a, in float b, in vec3  pct) { return mix(a, vec3(b), pct); }\r
vec4  mmix(in vec4 a, in float b, in vec4  pct) { return mix(a, vec4(b), pct); }\r
vec2  mmix(in vec2 a, in float b, in float pct) { return mix(a, vec2(b), pct); }\r
vec3  mmix(in vec3 a, in float b, in float pct) { return mix(a, vec3(b), pct); }\r
vec4  mmix(in vec4 a, in float b, in float pct) { return mix(a, vec4(b), pct); }

vec2  mmix(in float a, in float b, in vec2 pct) { return mix(vec2(a), vec2(b), pct); }\r
vec3  mmix(in float a, in float b, in vec3 pct) { return mix(vec3(a), vec3(b), pct); }\r
vec4  mmix(in float a, in float b, in vec4 pct) { return mix(vec4(a), vec4(b), pct); }

float mmix(in float a, in float b, in float c, in float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec2 mmix(vec2 a, vec2 b, vec2 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec2 mmix(vec2 a, vec2 b, vec2 c, vec2 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec3 mmix(vec3 a, vec3 b, vec3 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec3 mmix(vec3 a, vec3 b, vec3 c, vec3 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec4 mmix(vec4 a, vec4 b, vec4 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec4 mmix(vec4 a, vec4 b, vec4 c, vec4 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

float mmix(in float a, in float b, in float c, in float d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec2 mmix(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec2 mmix(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec3 mmix(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec3 mmix(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec4 mmix(in vec4 a, in vec4 b, in vec4 c, in vec4 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec4 mmix(in vec4 a, in vec4 b, in vec4 c, in vec4 d, in vec4 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

mat2 mmix(mat2 A, mat2 B, float alpha) {\r
    return mat2(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha)\r
    );\r
}

mat3 mmix(mat3 A, mat3 B, float alpha) {\r
    return mat3(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha)\r
    );\r
}

mat4 mmix(mat4 A, mat4 B, float alpha) {\r
    return mat4(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

mat2x3 mmix(mat2x3 A, mat2x3 B, float alpha) {\r
    return mat2x3(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha)  
    );\r
}

mat3x2 mmix(mat3x2 A, mat3x2 B, float alpha) {\r
    return mat3x2(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha), 
        mix(A[2], B[2], alpha)  
    );\r
}

mat2x4 mmix(mat2x4 A, mat2x4 B, float alpha) {\r
    return mat2x4(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha)  
    );\r
}

mat4x2 mmix(mat4x2 A, mat4x2 B, float alpha) {\r
    return mat4x2(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

mat3x4 mmix(mat3x4 A, mat3x4 B, float alpha) {\r
    return mat3x4(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha)\r
    );\r
}

mat4x3 mmix(mat4x3 A, mat4x3 B, float alpha) {\r
    return mat4x3(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

#endif\r
#endif

float mmix2(float a00, float a10, float a01, float a11, vec2 pct) \r
{\r
    float a0 = mix(a00, a10, pct.x);\r
    float a1 = mix(a01, a11, pct.x);\r
    return mix(a0, a1, pct.y);\r
}

vec2 mmix2(vec2 a00, vec2 a10, vec2 a01, vec2 a11, vec2 pct) \r
{\r
    vec2 a0 = mix(a00, a10, pct.x);\r
    vec2 a1 = mix(a01, a11, pct.x);\r
    return mix(a0, a1, pct.y);\r
}

vec3 mmix2(vec3 a00, vec3 a10, vec3 a01, vec3 a11, vec2 pct) \r
{\r
    vec3 a0 = mix(a00, a10, pct.x);\r
    vec3 a1 = mix(a01, a11, pct.x);\r
    return mix(a0, a1, pct.y);\r
}

vec4 mmix2(vec4 a00, vec4 a10, vec4 a01, vec4 a11, vec2 pct) \r
{\r
    vec4 a0 = mix(a00, a10, pct.x);\r
    vec4 a1 = mix(a01, a11, pct.x);\r
    return mix(a0, a1, pct.y);\r
}

float mmix2(float a00, float a10, float a20, float a01, float a11, float a21, float a02, float a12, float a22, vec2 pct) \r
{\r
    float a0 = mmix(a00, a10, a20, pct.x);\r
    float a1 = mmix(a01, a11, a21, pct.x);\r
    float a2 = mmix(a02, a12, a22, pct.x);\r
    return mmix(a0, a1, a2, pct.y);\r
}\r
vec2 mmix2(vec2 a00, vec2 a10, vec2 a20, vec2 a01, vec2 a11, vec2 a21, vec2 a02, vec2 a12, vec2 a22, vec2 pct) \r
{\r
    vec2 a0 = mmix(a00, a10, a20, pct.x);\r
    vec2 a1 = mmix(a01, a11, a21, pct.x);\r
    vec2 a2 = mmix(a02, a12, a22, pct.x);\r
    return mmix(a0, a1, a2, pct.y);\r
}\r
vec3 mmix2(vec3 a00, vec3 a10, vec3 a20, vec3 a01, vec3 a11, vec3 a21, vec3 a02, vec3 a12, vec3 a22, vec2 pct) \r
{\r
    vec3 a0 = mmix(a00, a10, a20, pct.x);\r
    vec3 a1 = mmix(a01, a11, a21, pct.x);\r
    vec3 a2 = mmix(a02, a12, a22, pct.x);\r
    return mmix(a0, a1, a2, pct.y);\r
}\r
vec4 mmix2(vec4 a00, vec4 a10, vec4 a20, vec4 a01, vec4 a11, vec4 a21, vec4 a02, vec4 a12, vec4 a22, vec2 pct) \r
{\r
    vec4 a0 = mmix(a00, a10, a20, pct.x);\r
    vec4 a1 = mmix(a01, a11, a21, pct.x);\r
    vec4 a2 = mmix(a02, a12, a22, pct.x);\r
    return mmix(a0, a1, a2, pct.y);\r
}

#endif \r
#ifndef POWN
#define POWN

int   pow2(in   int v) { return v * v; }
float pow2(in float v) { return v * v; }
vec2  pow2(in  vec2 v) { return v * v; }
vec3  pow2(in  vec3 v) { return v * v; }
vec4  pow2(in  vec4 v) { return v * v; }

int   pow3(in   int v) { return v * v * v; }
float pow3(in float v) { return v * v * v; }
vec2  pow3(in  vec2 v) { return v * v * v; }
vec3  pow3(in  vec3 v) { return v * v * v; }
vec4  pow3(in  vec4 v) { return v * v * v; }

int   pow4(in   int v) { return v * v * v * v; }
float pow4(in float v) { return v * v * v * v; }
vec2  pow4(in  vec2 v) { return v * v * v * v; }
vec3  pow4(in  vec3 v) { return v * v * v * v; }
vec4  pow4(in  vec4 v) { return v * v * v * v; }

int   pow5(in   int v) { return v * v * v * v * v; }
float pow5(in float v) { return v * v * v * v * v; }
vec2  pow5(in  vec2 v) { return v * v * v * v * v; }
vec3  pow5(in  vec3 v) { return v * v * v * v * v; }
vec4  pow5(in  vec4 v) { return v * v * v * v * v; }

#endif \r
#ifndef PROD\r
#define PROD

float prod(in float v) { return v; }\r
float prod(in vec2  v) { return v.x * v.y; }\r
float prod(in vec3  v) { return v.x * v.y * v.z; }\r
float prod(in vec4  v) { return v.x * v.y * v.z * v.w; }\r
  \r
#endif \r
#ifndef SSIGN\r
#define SSIGN

#ifndef PICK\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#endif

float ssign(in float v) \r
{ \r
    return pick(v < 0.0, -1.0, 1.0);\r
}

vec2 ssign(in vec2 v) \r
{ \r
    return pick(\r
        lessThan(v, vec2(0.0)), \r
        vec2(-1.0), \r
        vec2( 1.0)\r
    ); \r
}

vec3 ssign(in vec3 v) \r
{   \r
    return pick(\r
        lessThan(v, vec3(0.0)), \r
        vec3(-1.0), \r
        vec3( 1.0)\r
    );\r
}

vec4 ssign(in vec4 v) \r
{ \r
    return pick(\r
        lessThan(v, vec4(0.0)), \r
        vec4(-1.0), \r
        vec4( 1.0)\r
    ); \r
}

#endif \r
#ifndef SORT\r
#define SORT

#ifndef SORT_MAX_LENGTH\r
#define SORT_MAX_LENGTH 5\r
#endif

void sort(inout vec2 v)\r
{\r
    v =  (v.x > v.y) ? v.yx : v.xy;\r
}

void sort(inout vec3 v)\r
{\r
    v.xy = (v.x > v.y) ? v.yx : v.xy;\r
    v.yz = (v.y > v.z) ? v.zy : v.yz;\r
    v.xy = (v.x > v.y) ? v.yx : v.xy;\r
}

void sort(inout vec4 v)\r
{\r
    v.xy = (v.x > v.y) ? v.yx : v.xy;\r
    v.zw = (v.z > v.w) ? v.wz : v.zw;\r
    v.xz = (v.x > v.z) ? v.zx : v.xz;\r
    v.yw = (v.y > v.w) ? v.wy : v.yw;\r
    v.yz = (v.y > v.z) ? v.zy : v.yz;\r
}

void sort(inout float v[SORT_MAX_LENGTH])\r
{\r
    float t; 

    for (int i = 0; i < SORT_MAX_LENGTH - 1; ++i)\r
    {\r
        for (int j = 0; j < SORT_MAX_LENGTH - 1 - i; ++j)\r
        {\r
            if (v[j] > v[j + 1])\r
            {\r
                t = v[j];\r
                v[j] = v[j + 1];\r
                v[j + 1] = t;\r
            }\r
        }\r
    }\r
}

void sort(inout vec2 v, inout vec2 u)\r
{\r
    bool c = (v.x > v.y);\r
    v = c ? v.yx : v.xy;\r
    u = c ? u.yx : u.xy;\r
}

void sort(inout vec3 v, inout vec3 u)\r
{\r
    bool c = (v.x > v.y);\r
    v.xy = c ? v.yx : v.xy;\r
    u.xy = c ? u.yx : u.xy;

    c = (v.y > v.z);\r
    v.yz = c ? v.zy : v.yz;\r
    u.yz = c ? u.zy : u.yz;

    c = (v.x > v.y);\r
    v.xy = c ? v.yx : v.xy;\r
    u.xy = c ? u.yx : u.xy;\r
}

void sort(inout vec4 v, inout vec4 u)\r
{\r
    bool c = (v.x > v.y);\r
    v.xy = c ? v.yx : v.xy;\r
    u.xy = c ? u.yx : u.xy;

    c = (v.z > v.w);\r
    v.zw = c ? v.wz : v.zw;\r
    u.zw = c ? u.wz : u.zw;

    c = (v.x > v.z);\r
    v.xz = c ? v.zx : v.xz;\r
    u.xz = c ? u.zx : u.xz;

    c = (v.y > v.w);\r
    v.yw = c ? v.wy : v.yw;\r
    u.yw = c ? u.wy : u.yw;

    c = (v.y > v.z);\r
    v.yz = c ? v.zy : v.yz;\r
    u.yz = c ? u.zy : u.yz;\r
}

void sort(inout float v[SORT_MAX_LENGTH], inout float u[SORT_MAX_LENGTH])\r
{\r
    float t; 

    for (int i = 0; i < SORT_MAX_LENGTH - 1; ++i)\r
    {\r
        for (int j = 0; j < SORT_MAX_LENGTH - 1 - i; ++j)\r
        {\r
            if (v[j] > v[j + 1])\r
            {\r
                
                t = v[j];\r
                v[j] = v[j + 1];\r
                v[j + 1] = t;

                
                t = u[j];\r
                u[j] = u[j + 1];\r
                u[j + 1] = t;\r
            }\r
        }\r
    }\r
}

#endif \r
#ifndef SUM
#define SUM

float sum(in vec2 v) 
{ 
    return dot(v, vec2(1.0)); 
}

float sum(in vec3 v) 
{ 
    return dot(v, vec3(1.0));
}

float sum(in vec4 v) 
{ 
    return dot(v, vec4(1.0));
}

#endif\r
#ifndef PICK\r
#define PICK

float pick(in bool cond, in float a, in float b) \r
{ \r
    return (cond ? a : b); \r
}

vec2 pick(in bvec2 cond, in vec2 a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in float a, in vec2 b) \r
{ \r
    return vec2(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y)\r
    );\r
}\r
vec2 pick(in bvec2 cond, in vec2 a, in float b) \r
{ \r
    return vec2(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b)\r
    );\r
}

vec3 pick(in bvec3 cond, in vec3 a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in float a, in vec3 b) \r
{ \r
    return vec3(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z)\r
    );\r
}\r
vec3 pick(in bvec3 cond, in vec3 a, in float b) \r
{ \r
    return vec3(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b)\r
    );\r
}

vec4 pick(in bvec4 cond, in vec4 a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in float a, in vec4 b) \r
{ \r
    return vec4(\r
        (cond.x ? a : b.x),\r
        (cond.y ? a : b.y),\r
        (cond.z ? a : b.z),\r
        (cond.w ? a : b.w)\r
    );\r
}\r
vec4 pick(in bvec4 cond, in vec4 a, in float b) \r
{ \r
    return vec4(\r
        (cond.x ? a.x : b),\r
        (cond.y ? a.y : b),\r
        (cond.z ? a.z : b),\r
        (cond.w ? a.w : b)\r
    );\r
}

int pick(in bool cond, in int a, in int b) \r
{ \r
    return (cond ? a : b); \r
}

ivec2 pick(in bvec2 cond, in ivec2 a, in ivec2 b) \r
{ \r
    return ivec2(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y)\r
    );\r
}

ivec3 pick(in bvec3 cond, in ivec3 a, in ivec3 b) \r
{ \r
    return ivec3(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z)\r
    );\r
}

ivec4 pick(in bvec4 cond, in ivec4 a, in ivec4 b) \r
{ \r
    return ivec4(\r
        (cond.x ? a.x : b.x),\r
        (cond.y ? a.y : b.y),\r
        (cond.z ? a.z : b.z),\r
        (cond.w ? a.w : b.w)\r
    );\r
}

#endif\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#ifndef SIGN_CHANGE\r
#define SIGN_CHANGE

bool sign_change(float a, float b) \r
{\r
    return (a < 0.0) != (b < 0.0);\r
}

bool sign_change(vec2 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0);\r
}

bool sign_change(vec3 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0);\r
}

bool sign_change(vec4 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0) ||\r
           (v.z < 0.0) != (v.w < 0.0);\r
}

bool sign_change(float v[5]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0);\r
}

bool sign_change(float v[6]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0) ||\r
           (v[4] < 0.0) != (v[5] < 0.0);\r
}

#endif\r
#ifndef SIGN_CHANGES\r
#define SIGN_CHANGES

int sign_changes(vec2 v) \r
{\r
    return int((v.x < 0.0) != (v.y < 0.0));\r
}

int sign_changes(vec3 v) \r
{\r
    return int((v.x < 0.0) != (v.y < 0.0)) +\r
           int((v.y < 0.0) != (v.z < 0.0));\r
}

int sign_changes(vec4 v) \r
{\r
    return int((v.x < 0.0) != (v.y < 0.0)) +\r
           int((v.y < 0.0) != (v.z < 0.0)) +\r
           int((v.z < 0.0) != (v.w < 0.0));\r
}

int sign_changes(float v[5]) \r
{\r
    return int((v[0] < 0.0) != (v[1] < 0.0)) +\r
           int((v[1] < 0.0) != (v[2] < 0.0)) +\r
           int((v[2] < 0.0) != (v[3] < 0.0)) +\r
           int((v[3] < 0.0) != (v[4] < 0.0));\r
}

int sign_changes(float v[6]) \r
{\r
    return int((v[0] < 0.0) != (v[1] < 0.0)) +\r
           int((v[1] < 0.0) != (v[2] < 0.0)) +\r
           int((v[2] < 0.0) != (v[3] < 0.0)) +\r
           int((v[3] < 0.0) != (v[4] < 0.0)) +\r
           int((v[4] < 0.0) != (v[5] < 0.0));\r
}

#endif\r
#ifndef EVAL_POLY_SIGN_CHANGE\r
#define EVAL_POLY_SIGN_CHANGE

#ifndef EVAL_POLY\r
#ifndef EVAL_POLY\r
#define EVAL_POLY

#ifndef EVAL_POLY_MAX_DEGREE\r
#define EVAL_POLY_MAX_DEGREE 6\r
#endif

#ifndef EVAL_POLY_MAX_DERIVATIVE\r
#define EVAL_POLY_MAX_DERIVATIVE 5\r
#endif

float eval_poly(in vec2 c, in float t) \r
{\r
    float f = c.x + c.y * t;        
    return f;\r
}\r
vec2 eval_poly(in vec2 c, in vec2 t) \r
{\r
    vec2 f = c.x + c.y * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec2 c, in vec3 t) \r
{\r
    vec3 f = c.x + c.y * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec2 c, in vec4 t) \r
{\r
    vec4 f = c.x + c.y * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t; 
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}

float eval_poly(in vec3 c, in float t, out float f1) \r
{\r
    float a1 = c.y + c.z * t; 
    float f = c.x + a1 * t;        
    f1 = a1 + c.z * t;        
    return f;\r
}\r
vec2 eval_poly(in vec3 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a1 = c.y + c.z * t;\r
    vec2 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec3 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a1 = c.y + c.z * t;\r
    vec3 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec3 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a1 = c.y + c.z * t;\r
    vec4 f = c.x + a1 * t;\r
    f1 = a1 + c.z * t;\r
    return f;\r
}

float eval_poly(in vec4 c, in float t) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;\r
    return f;\r
}\r
float eval_poly(in vec4 c, in float t, out float f1, out float f2) \r
{\r
    float a2 = c.z + c.w * t; 
    float a1 = c.y + a2 * t;  
    float f = c.x + a1 * t;         

    float b2 = a2 + c.w * t;  
    f1 = a1 + b2 * t;         
    \r
    float b1 = b2 + c.w * t;  
    f2 = b1 * 2.0;            
    return f;\r
}\r
vec2 eval_poly(in vec4 c, in vec2 t, out vec2 f1, out vec2 f2) \r
{\r
    vec2 a2 = c.z + c.w * t;\r
    vec2 a1 = c.y + a2 * t;\r
    vec2 f = c.x + a1 * t;

    vec2 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec2 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec3 eval_poly(in vec4 c, in vec3 t, out vec3 f1, out vec3 f2) \r
{\r
    vec3 a2 = c.z + c.w * t;\r
    vec3 a1 = c.y + a2 * t;\r
    vec3 f = c.x + a1 * t;

    vec3 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec3 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}\r
vec4 eval_poly(in vec4 c, in vec4 t, out vec4 f1, out vec4 f2) \r
{\r
    vec4 a2 = c.z + c.w * t;\r
    vec4 a1 = c.y + a2 * t;\r
    vec4 f = c.x + a1 * t;

    vec4 b2 = a2 + c.w * t;\r
    f1 = a1 + b2 * t;

    vec4 b1 = b2 + c.w * t;\r
    f2 = b1 * 2.0;\r
    return f;\r
}

float eval_poly(in float c[5], in float t) \r
{\r
    float f = c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t) \r
{\r
    vec2 f = vec2(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t) \r
{\r
    vec3 f = vec3(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t) \r
{\r
    vec4 f = vec4(c[4]);\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[5], in float t, out float f1) \r
{\r
    float f = c[4];\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[5], in vec2 t, out vec2 f1) \r
{\r
    vec2 f = vec2(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[5], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[5], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[4]);\r
    f1 = f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

float eval_poly(in float c[6], in float t) \r
{\r
    float f = c[5];\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t) \r
{\r
    vec2 f = vec2(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t) \r
{\r
    vec3 f = vec3(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t) \r
{\r
    vec4 f = vec4(c[5]);\r
    f = f * t + c[4];\r
    f = f * t + c[3];\r
    f = f * t + c[2];\r
    f = f * t + c[1];\r
    f = f * t + c[0];\r
    return f;\r
}\r
float eval_poly(in float c[6], in float t, out float f1) \r
{\r
    float f  = c[5];\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec2 eval_poly(in float c[6], in vec2 t, out vec2 f1) \r
{\r
    vec2 f  = vec2(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec3 eval_poly(in float c[6], in vec3 t, out vec3 f1) \r
{\r
    vec3 f = vec3(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}\r
vec4 eval_poly(in float c[6], in vec4 t, out vec4 f1) \r
{\r
    vec4 f = vec4(c[5]);\r
    f1 = f;\r
    f  = f * t + c[4];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[3];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[2];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[1];\r
    f1 = f1 * t + f;\r
    f  = f * t + c[0];\r
    return f;\r
}

    

    

    

    

#endif\r
#endif\r
#ifndef SIGN_CHANGE\r
#ifndef SIGN_CHANGE\r
#define SIGN_CHANGE

bool sign_change(float a, float b) \r
{\r
    return (a < 0.0) != (b < 0.0);\r
}

bool sign_change(vec2 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0);\r
}

bool sign_change(vec3 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0);\r
}

bool sign_change(vec4 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0) ||\r
           (v.z < 0.0) != (v.w < 0.0);\r
}

bool sign_change(float v[5]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0);\r
}

bool sign_change(float v[6]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0) ||\r
           (v[4] < 0.0) != (v[5] < 0.0);\r
}

#endif\r
#endif\r
#ifndef MMIX\r
#ifndef MMIX\r
#define MMIX

float mmix(in float a, in float b, in float pct) { return mix(a, b, pct); }\r
vec2  mmix(in vec2  a, in vec2  b, in vec2  pct) { return mix(a, b, pct); }\r
vec3  mmix(in vec3  a, in vec3  b, in vec3  pct) { return mix(a, b, pct); }\r
vec4  mmix(in vec4  a, in vec4  b, in vec4  pct) { return mix(a, b, pct); }\r
vec2  mmix(in vec2  a, in vec2  b, in float pct) { return mix(a, b, pct); }\r
vec3  mmix(in vec3  a, in vec3  b, in float pct) { return mix(a, b, pct); }\r
vec4  mmix(in vec4  a, in vec4  b, in float pct) { return mix(a, b, pct); }

vec2  mmix(in float a, in vec2 b, in vec2  pct) { return mix(vec2(a), b, pct); }\r
vec3  mmix(in float a, in vec3 b, in vec3  pct) { return mix(vec3(a), b, pct); }\r
vec4  mmix(in float a, in vec4 b, in vec4  pct) { return mix(vec4(a), b, pct); }\r
vec2  mmix(in float a, in vec2 b, in float pct) { return mix(vec2(a), b, pct); }\r
vec3  mmix(in float a, in vec3 b, in float pct) { return mix(vec3(a), b, pct); }\r
vec4  mmix(in float a, in vec4 b, in float pct) { return mix(vec4(a), b, pct); }

vec2  mmix(in vec2 a, in float b, in vec2  pct) { return mix(a, vec2(b), pct); }\r
vec3  mmix(in vec3 a, in float b, in vec3  pct) { return mix(a, vec3(b), pct); }\r
vec4  mmix(in vec4 a, in float b, in vec4  pct) { return mix(a, vec4(b), pct); }\r
vec2  mmix(in vec2 a, in float b, in float pct) { return mix(a, vec2(b), pct); }\r
vec3  mmix(in vec3 a, in float b, in float pct) { return mix(a, vec3(b), pct); }\r
vec4  mmix(in vec4 a, in float b, in float pct) { return mix(a, vec4(b), pct); }

vec2  mmix(in float a, in float b, in vec2 pct) { return mix(vec2(a), vec2(b), pct); }\r
vec3  mmix(in float a, in float b, in vec3 pct) { return mix(vec3(a), vec3(b), pct); }\r
vec4  mmix(in float a, in float b, in vec4 pct) { return mix(vec4(a), vec4(b), pct); }

float mmix(in float a, in float b, in float c, in float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec2 mmix(vec2 a, vec2 b, vec2 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec2 mmix(vec2 a, vec2 b, vec2 c, vec2 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec3 mmix(vec3 a, vec3 b, vec3 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec3 mmix(vec3 a, vec3 b, vec3 c, vec3 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec4 mmix(vec4 a, vec4 b, vec4 c, float pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

vec4 mmix(vec4 a, vec4 b, vec4 c, vec4 pct) {\r
    return mix(\r
        mix(a, b, 2. * pct),\r
        mix(b, c, 2. * (max(pct, .5) - .5)),\r
        step(.5, pct)\r
    );\r
}

float mmix(in float a, in float b, in float c, in float d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec2 mmix(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec2 mmix(in vec2 a, in vec2 b, in vec2 c, in vec2 d, in vec2 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec3 mmix(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec3 mmix(in vec3 a, in vec3 b, in vec3 c, in vec3 d, in vec3 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec4 mmix(in vec4 a, in vec4 b, in vec4 c, in vec4 d, in float pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

vec4 mmix(in vec4 a, in vec4 b, in vec4 c, in vec4 d, in vec4 pct) {\r
    return mix(\r
        mix(a, b, 3. * pct),\r
        mix(b,\r
            mix( c,\r
                d,\r
                3. * (max(pct, .66) - .66)),\r
            3. * (clamp(pct, .33, .66) - .33)\r
        ),\r
        step(.33, pct)\r
    );\r
}

mat2 mmix(mat2 A, mat2 B, float alpha) {\r
    return mat2(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha)\r
    );\r
}

mat3 mmix(mat3 A, mat3 B, float alpha) {\r
    return mat3(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha)\r
    );\r
}

mat4 mmix(mat4 A, mat4 B, float alpha) {\r
    return mat4(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

mat2x3 mmix(mat2x3 A, mat2x3 B, float alpha) {\r
    return mat2x3(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha)  
    );\r
}

mat3x2 mmix(mat3x2 A, mat3x2 B, float alpha) {\r
    return mat3x2(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha), 
        mix(A[2], B[2], alpha)  
    );\r
}

mat2x4 mmix(mat2x4 A, mat2x4 B, float alpha) {\r
    return mat2x4(\r
        mix(A[0], B[0], alpha), 
        mix(A[1], B[1], alpha)  
    );\r
}

mat4x2 mmix(mat4x2 A, mat4x2 B, float alpha) {\r
    return mat4x2(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

mat3x4 mmix(mat3x4 A, mat3x4 B, float alpha) {\r
    return mat3x4(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha)\r
    );\r
}

mat4x3 mmix(mat4x3 A, mat4x3 B, float alpha) {\r
    return mat4x3(\r
        mix(A[0], B[0], alpha),\r
        mix(A[1], B[1], alpha),\r
        mix(A[2], B[2], alpha),\r
        mix(A[3], B[3], alpha)\r
    );\r
}

#endif\r
#endif

bool eval_poly_sign_change(vec3 coeffs)\r
{\r
    const int batches = 2;\r
    const int samples = batches * 4;\r
    const float spacing = 1.0 / float(samples - 1);\r
    const vec4 stride = vec4(spacing * 4.0);

    vec4 points = vec4(0, 1, 2, 3) * spacing;\r
    vec4 values = eval_poly(coeffs, points);\r
    bool change = sign_change(values);\r
    float prev = values.w;

    #pragma unroll\r
    for (int i = 1; i < batches; ++i) \r
    {   \r
        points += stride;\r
        values = eval_poly(coeffs, points);\r
        change = change || sign_change(prev, values.x) || sign_change(values);\r
        prev = values.w;\r
    }

    return change;\r
}

bool eval_poly_sign_change(vec4 coeffs)\r
{\r
    const int batches = 3;\r
    const int samples = batches * 4;\r
    const float spacing = 1.0 / float(samples - 1);\r
    const vec4 stride = vec4(spacing * 4.0);

    vec4 points = vec4(0, 1, 2, 3) * spacing;\r
    vec4 values = eval_poly(coeffs, points);\r
    bool change = sign_change(values);\r
    float prev = values.w;

    #pragma unroll\r
    for (int i = 1; i < batches; ++i) \r
    {   \r
        points += stride;\r
        values = eval_poly(coeffs, points);\r
        change = change || sign_change(prev, values.x) || sign_change(values);\r
        prev = values.w;\r
    }

    return change;\r
}

bool eval_poly_sign_change(float[5] coeffs)\r
{\r
    const int batches = 4;\r
    const int samples = batches * 4;\r
    const float spacing = 1.0 / float(samples - 1);\r
    const vec4 stride = vec4(spacing * 4.0);

    vec4 points = vec4(0, 1, 2, 3) * spacing;\r
    vec4 values = eval_poly(coeffs, points);\r
    bool change = sign_change(values);\r
    float prev = values.w;

    #pragma unroll\r
    for (int i = 1; i < batches; ++i) \r
    {   \r
        points += stride;\r
        values = eval_poly(coeffs, points);\r
        change = change || sign_change(prev, values.x) || sign_change(values);\r
        prev = values.w;\r
    }

    return change;\r
}

bool eval_poly_sign_change(float[6] coeffs)\r
{\r
    const int batches = 4;\r
    const int samples = batches * 4;\r
    const float spacing = 1.0 / float(samples - 1);\r
    const vec4 stride = vec4(spacing * 4.0);

    vec4 points = vec4(0, 1, 2, 3) * spacing;\r
    vec4 values = eval_poly(coeffs, points);\r
    bool change = sign_change(values);\r
    float prev = values.w;

    #pragma unroll\r
    for (int i = 1; i < batches; ++i) \r
    {   \r
        points += stride;\r
        values = eval_poly(coeffs, points);\r
        change = change || sign_change(prev, values.x) || sign_change(values);\r
        prev = values.w;\r
    }

    return change;\r
}

#endif\r
#ifndef SPLIT_BERNSTEIN\r
#define SPLIT_BERNSTEIN

void split_bernstein(in vec3 b, out vec3 left, out vec3 right)\r
{\r
    
    vec2 m = mix(b.xy, b.yz, 0.5); 

    
    float n = mix(m.x, m.y, 0.5); 

    
    left = vec3(b.x, m.x, n);

    
    right = vec3(n, m.y, b.z);\r
}

void split_bernstein(in vec4 b, out vec4 left, out vec4 right) \r
{\r
    
    vec3 m = mix(b.xyz, b.yzw, 0.5); 

    
    vec2 n = mix(m.xy, m.yz, 0.5);   

    
    float p = mix(n.x, n.y, 0.5);

    
    left = vec4(b.x, m.x, n.x, p);   

    
    right = vec4(p, n.y, m.z, b.w);  \r
}

void split_bernstein(in float b[5], out float left[5], out float right[5]) \r
{\r
    
    vec4 b0 = vec4(b[0], b[1], b[2], b[3]);\r
    vec4 b1 = vec4(b[1], b[2], b[3], b[4]);

    
    vec4 m = mix(b0, b1, 0.5);

    
    vec3 n = mix(m.xyz, m.yzw, 0.5);

    
    vec2 o = mix(n.xy, n.yz, 0.5);

    
    float p = mix(o.x, o.y, 0.5);

    
    left[0] = b[0];\r
    left[1] = m.x;\r
    left[2] = n.x;\r
    left[3] = o.x;\r
    left[4] = p;

    
    right[0] = p;\r
    right[1] = o.y;\r
    right[2] = n.z;\r
    right[3] = m.w;\r
    right[4] = b[4];\r
}

void split_bernstein(in float b[6], out float left[6], out float right[6]) \r
{\r
    
    float m0 = (b[0] + b[1]) * 0.5;\r
    float m1 = (b[1] + b[2]) * 0.5;\r
    float m2 = (b[2] + b[3]) * 0.5;\r
    float m3 = (b[3] + b[4]) * 0.5;\r
    float m4 = (b[4] + b[5]) * 0.5;

    
    vec4 n = vec4(\r
        (m0 + m1) * 0.5,\r
        (m1 + m2) * 0.5,\r
        (m2 + m3) * 0.5,\r
        (m3 + m4) * 0.5\r
    );  

    
    vec3 o = mix(n.xyz, n.yzw, 0.5);

    
    vec2 p = mix(o.xy, o.yz, 0.5);

    
    float q = mix(p.x, p.y, 0.5);

    
    left[0] = b[0];\r
    left[1] = m0;\r
    left[2] = n.x;\r
    left[3] = o.x;\r
    left[4] = p.x;\r
    left[5] = q;

    
    right[0] = q;\r
    right[1] = p.y;\r
    right[2] = o.z;\r
    right[3] = n.w;\r
    right[4] = m4;\r
    right[5] = b[5];\r
}

#endif\r
#ifndef SPLIT_BERNSTEIN_SIGN_CHANGE\r
#define SPLIT_BERNSTEIN_SIGN_CHANGE

#ifndef SPLIT_BERNSTEIN\r
#ifndef SPLIT_BERNSTEIN\r
#define SPLIT_BERNSTEIN

void split_bernstein(in vec3 b, out vec3 left, out vec3 right)\r
{\r
    
    vec2 m = mix(b.xy, b.yz, 0.5); 

    
    float n = mix(m.x, m.y, 0.5); 

    
    left = vec3(b.x, m.x, n);

    
    right = vec3(n, m.y, b.z);\r
}

void split_bernstein(in vec4 b, out vec4 left, out vec4 right) \r
{\r
    
    vec3 m = mix(b.xyz, b.yzw, 0.5); 

    
    vec2 n = mix(m.xy, m.yz, 0.5);   

    
    float p = mix(n.x, n.y, 0.5);

    
    left = vec4(b.x, m.x, n.x, p);   

    
    right = vec4(p, n.y, m.z, b.w);  \r
}

void split_bernstein(in float b[5], out float left[5], out float right[5]) \r
{\r
    
    vec4 b0 = vec4(b[0], b[1], b[2], b[3]);\r
    vec4 b1 = vec4(b[1], b[2], b[3], b[4]);

    
    vec4 m = mix(b0, b1, 0.5);

    
    vec3 n = mix(m.xyz, m.yzw, 0.5);

    
    vec2 o = mix(n.xy, n.yz, 0.5);

    
    float p = mix(o.x, o.y, 0.5);

    
    left[0] = b[0];\r
    left[1] = m.x;\r
    left[2] = n.x;\r
    left[3] = o.x;\r
    left[4] = p;

    
    right[0] = p;\r
    right[1] = o.y;\r
    right[2] = n.z;\r
    right[3] = m.w;\r
    right[4] = b[4];\r
}

void split_bernstein(in float b[6], out float left[6], out float right[6]) \r
{\r
    
    float m0 = (b[0] + b[1]) * 0.5;\r
    float m1 = (b[1] + b[2]) * 0.5;\r
    float m2 = (b[2] + b[3]) * 0.5;\r
    float m3 = (b[3] + b[4]) * 0.5;\r
    float m4 = (b[4] + b[5]) * 0.5;

    
    vec4 n = vec4(\r
        (m0 + m1) * 0.5,\r
        (m1 + m2) * 0.5,\r
        (m2 + m3) * 0.5,\r
        (m3 + m4) * 0.5\r
    );  

    
    vec3 o = mix(n.xyz, n.yzw, 0.5);

    
    vec2 p = mix(o.xy, o.yz, 0.5);

    
    float q = mix(p.x, p.y, 0.5);

    
    left[0] = b[0];\r
    left[1] = m0;\r
    left[2] = n.x;\r
    left[3] = o.x;\r
    left[4] = p.x;\r
    left[5] = q;

    
    right[0] = q;\r
    right[1] = p.y;\r
    right[2] = o.z;\r
    right[3] = n.w;\r
    right[4] = m4;\r
    right[5] = b[5];\r
}

#endif\r
#endif\r
#ifndef SIGN_CHANGE\r
#ifndef SIGN_CHANGE\r
#define SIGN_CHANGE

bool sign_change(float a, float b) \r
{\r
    return (a < 0.0) != (b < 0.0);\r
}

bool sign_change(vec2 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0);\r
}

bool sign_change(vec3 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0);\r
}

bool sign_change(vec4 v) \r
{\r
    return (v.x < 0.0) != (v.y < 0.0) ||\r
           (v.y < 0.0) != (v.z < 0.0) ||\r
           (v.z < 0.0) != (v.w < 0.0);\r
}

bool sign_change(float v[5]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0);\r
}

bool sign_change(float v[6]) \r
{\r
    return (v[0] < 0.0) != (v[1] < 0.0) ||\r
           (v[1] < 0.0) != (v[2] < 0.0) ||\r
           (v[2] < 0.0) != (v[3] < 0.0) ||\r
           (v[3] < 0.0) != (v[4] < 0.0) ||\r
           (v[4] < 0.0) != (v[5] < 0.0);\r
}

#endif\r
#endif

bool split_bernstein_sign_change(in float b[6]) \r
{\r
    float r[6];

    split_bernstein(b, b, r); 

    return sign_change(b) || sign_change(r);\r
}

#endif\r
#ifndef SUM_DIAGS\r
#define SUM_DIAGS

void sum_diags(in mat2 M, out vec3 v) \r
{\r
    v[0] = M[1][0];            
    v[1] = M[0][0] + M[1][1];  
    v[2] = M[0][1];            
}

void sum_diags(in mat3 M, out float v[5]) \r
{\r
    v[0] = M[2][0];                     
    v[1] = M[1][0] + M[2][1];           
    v[2] = M[0][0] + M[1][1] + M[2][2]; 
    v[3] = M[0][1] + M[1][2];           
    v[4] = M[0][2];                     
}

void sum_diags(in mat4 M, out float v[7]) \r
{\r
    v[0] = M[3][0];                                
    v[1] = M[2][0] + M[3][1];                      
    v[2] = M[1][0] + M[2][1] + M[3][2];            
    v[3] = M[0][0] + M[1][1] + M[2][2] + M[3][3];  
    v[4] = M[0][1] + M[1][2] + M[2][3];            
    v[5] = M[0][2] + M[1][3];                      
    v[6] = M[0][3];                                
}

void sum_diags(in mat3x2 M, out vec4 v) \r
{\r
    v[0] = M[2][0];            
    v[1] = M[1][0] + M[2][1];  
    v[2] = M[0][0] + M[1][1];  
    v[3] = M[0][1];            
}

void sum_diags(in mat2x3 M, out vec4 v) \r
{\r
    v[0] = M[1][0];            
    v[1] = M[0][0] + M[1][1];  
    v[2] = M[0][1] + M[1][2];  
    v[3] = M[0][2];            
}

void sum_diags(in mat2x4 M, out float v[5]) \r
{\r
    v[0] = M[1][0];            
    v[1] = M[0][0] + M[1][1];  
    v[2] = M[0][1] + M[1][2];  
    v[3] = M[0][2] + M[1][3];  
    v[4] = M[0][3];            
}

void sum_diags(in mat4x2 M, out float v[5]) \r
{\r
    v[0] = M[3][0];            
    v[1] = M[2][0] + M[3][1];  
    v[2] = M[1][0] + M[2][1];  
    v[3] = M[0][0] + M[1][1];  
    v[4] = M[0][1];            
}

void sum_diags(in mat3x4 M, out float v[6]) \r
{\r
    v[0] = M[2][0];                      
    v[1] = M[1][0] + M[2][1];            
    v[2] = M[0][0] + M[1][1] + M[2][2];  
    v[3] = M[0][1] + M[1][2] + M[2][3];  
    v[4] = M[0][2] + M[1][3];            
    v[5] = M[0][3];                      
}

void sum_diags(in mat4x3 M, out float v[6]) \r
{\r
    v[0] = M[3][0];                      
    v[1] = M[2][0] + M[3][1];            
    v[2] = M[1][0] + M[2][1] + M[3][2];  
    v[3] = M[0][0] + M[1][1] + M[2][2];  
    v[4] = M[0][1] + M[1][2];            
    v[5] = M[0][2];                      
}

#endif \r
#ifndef SUM_ANTI_DIAGS\r
#define SUM_ANTI_DIAGS

void sum_anti_diags(in mat2 M, out vec3 v)\r
{\r
    v[0] = M[0][0];            
    v[1] = M[1][0] + M[0][1];  
    v[2] = M[1][1];            
}

void sum_anti_diags(in mat3 M, out float v[5])\r
{\r
    v[0] = M[0][0];                      
    v[1] = M[1][0] + M[0][1];            
    v[2] = M[2][0] + M[1][1] + M[0][2];  
    v[3] = M[2][1] + M[1][2];            
    v[4] = M[2][2];                      
}

void sum_anti_diags(in mat4 M, out float v[7])\r
{\r
    v[0] = M[0][0];                                
    v[1] = M[1][0] + M[0][1];                      
    v[2] = M[2][0] + M[1][1] + M[0][2];            
    v[3] = M[3][0] + M[2][1] + M[1][2] + M[0][3];  
    v[4] = M[3][1] + M[2][2] + M[1][3];            
    v[5] = M[3][2] + M[2][3];                      
    v[6] = M[3][3];                                
}

void sum_anti_diags(in mat3x2 M, out vec4 v)\r
{\r
    v[0] = M[0][0];            
    v[1] = M[1][0] + M[0][1];  
    v[2] = M[2][0] + M[1][1];  
    v[3] = M[2][1];            
}

void sum_anti_diags(in mat2x3 M, out vec4 v)\r
{\r
    v[0] = M[0][0];            
    v[1] = M[1][0] + M[0][1];  
    v[2] = M[1][1] + M[0][2];  
    v[3] = M[1][2];            
}

void sum_anti_diags(in mat2x4 M, out float v[5])\r
{\r
    v[0] = M[0][0];            
    v[1] = M[1][0] + M[0][1];  
    v[2] = M[1][1] + M[0][2];  
    v[3] = M[1][2] + M[0][3];  
    v[4] = M[1][3];            
}

void sum_anti_diags(in mat4x2 M, out float v[5])\r
{\r
    v[0] = M[0][0];            
    v[1] = M[1][0] + M[0][1];  
    v[2] = M[2][0] + M[1][1];  
    v[3] = M[3][0] + M[2][1];  
    v[4] = M[3][1];            
}

void sum_anti_diags(in mat3x4 M, out float v[6]) \r
{\r
    v[0] = M[0][0];                      
    v[1] = M[1][0] + M[0][1];            
    v[2] = M[2][0] + M[1][1] + M[0][2];  
    v[3] = M[2][1] + M[1][2] + M[0][3];  
    v[4] = M[2][2] + M[1][3];            
    v[5] = M[2][3];                      
}

void sum_anti_diags(in mat4x3 M, out float v[6]) \r
{\r
    v[0] = M[0][0];                      
    v[1] = M[1][0] + M[0][1];            
    v[2] = M[2][0] + M[1][1] + M[0][2];  
    v[3] = M[3][0] + M[2][1] + M[1][2];  
    v[4] = M[3][1] + M[2][2];            
    v[5] = M[3][2];                      
}

#endif\r
#ifndef RANDOM
#define RANDOM

#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)

float random(in float x) {
    x = fract(x * RANDOM_SCALE.x);
    x *= x + 33.33;
    x *= x + x;
    return fract(x);
}

float random(in vec2 st) {
    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);
    p3 += dot(p3, p3.yzx + 33.33);
    return fract((p3.x + p3.y) * p3.z);
}

float random(in vec3 pos) {
    pos  = fract(pos * RANDOM_SCALE.xyz);
    pos += dot(pos, pos.zyx + 31.32);
    return fract((pos.x + pos.y) * pos.z);
}

float random(in vec4 pos) {
    pos = fract(pos * RANDOM_SCALE);
    pos += dot(pos, pos.wzxy + 33.33);
    return fract((pos.x + pos.y) * (pos.z + pos.w));
}

vec2 random2(float p) {
    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.xx + p3.yz) * p3.zy);
}

vec2 random2(vec2 p) {
    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.xx + p3.yz) * p3.zy);
}

vec2 random2(vec3 p3) {
    p3 = fract(p3 * RANDOM_SCALE.xyz);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.xx + p3.yz) * p3.zy);
}

vec3 random3(float p) {
    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);
    p3 += dot(p3, p3.yzx + 19.19);
    return fract((p3.xxy + p3.yzz) * p3.zyx); 
}

vec3 random3(vec2 p) {
    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);
    p3 += dot(p3, p3.yxz + 19.19);
    return fract((p3.xxy + p3.yzz) * p3.zyx);
}

vec3 random3(vec3 p) {
    p = fract(p * RANDOM_SCALE.xyz);
    p += dot(p, p.yxz + 19.19);
    return fract((p.xxy + p.yzz) * p.zyx);
}

vec4 random4(float p) {
    vec4 p4 = fract(p * RANDOM_SCALE);
    p4 += dot(p4, p4.wzxy + 19.19);
    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   
}

vec4 random4(vec2 p) {
    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);
    p4 += dot(p4, p4.wzxy + 19.19);
    return fract((p4.xxyz + p4.yzzw) * p4.zywx);
}

vec4 random4(vec3 p) {
    vec4 p4 = fract(p.xyzx * RANDOM_SCALE);
    p4 += dot(p4, p4.wzxy + 19.19);
    return fract((p4.xxyz + p4.yzzw) * p4.zywx);
}

vec4 random4(vec4 p4) {
    p4 = fract(p4  * RANDOM_SCALE);
    p4 += dot(p4, p4.wzxy + 19.19);
    return fract((p4.xxyz + p4.yzzw) * p4.zywx);
}

#endif\r
#ifndef BOX_BOUNDS
#define BOX_BOUNDS

#ifndef MMAX
#ifndef MMAX\r
#define MMAX

float mmax(in float a) { return a; }\r
float mmax(in float a, in float b) { return max(a, b); }\r
float mmax(in float a, in float b, in float c) { return max(a, max(b, c)); }\r
float mmax(in float a, in float b, in float c, in float d) { return max(max(a, b), max(c, d)); }\r
float mmax(vec2 v) { return max(v.x, v.y); }\r
float mmax(vec3 v) { return mmax(v.x, v.y, v.z); }\r
float mmax(vec4 v) { return mmax(v.x, v.y, v.z, v.w); }\r
float mmax(float v[5]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    return r;\r
}\r
float mmax(float v[6]) \r
{\r
    float r = v[0];\r
    r = max(r, v[1]);\r
    r = max(r, v[2]);\r
    r = max(r, v[3]);\r
    r = max(r, v[4]);\r
    r = max(r, v[5]);\r
    return r;\r
}

vec2 mmax(mat2 A)\r
{\r
    vec2 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    return r;\r
}\r
vec3 mmax(mat3 A)\r
{\r
    vec3 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    return r;\r
}\r
vec4 mmax(mat4 A)\r
{\r
    vec4 r;\r
    r[0] = mmax(A[0]);\r
    r[1] = mmax(A[1]);\r
    r[2] = mmax(A[2]);\r
    r[3] = mmax(A[3]);\r
    return r;\r
}

#endif
#endif

vec2 box_bounds(vec2 b_min, vec2 b_max, vec2 p) 
{
    vec2 c = (b_max + b_min) * 0.5;
    vec2 s = (b_max - b_min) * 0.5;
    vec2 aq = abs(p - c);
    vec2 d_min = aq - s;
    vec2 d_max = aq + s;
    return vec2(length(max(d_min, 0.0) + min(mmax(d_min), 0.0)), length(d_max));
}

vec2 box_bounds(vec2 b_min, vec2 b_max, vec2 p, out vec2 v_min, out vec2 v_max) 
{
    vec2 c = (b_max + b_min) * 0.5;
    vec2 s = (b_max - b_min) * 0.5;
    vec2 q = p - c;
    vec2 aq = abs(q);
    vec2 sq = sign(q);
    vec2 d_min = aq - s;
    vec2 d_max = aq + s;

    v_min = (max(d_min, 0.0) + min(mmax(d_min), 0.0)) * sq;
    v_max = d_max * sq;

    return vec2(length(v_min), length(v_max));
}

vec2 box_bounds(vec3 b_min, vec3 b_max, vec3 p) 
{
    vec3 c = (b_max + b_min) * 0.5;
    vec3 s = (b_max - b_min) * 0.5;
    vec3 aq = abs(p - c);
    vec3 d_min = aq - s;
    vec3 d_max = aq + s;    
    return vec2(length(max(d_min, 0.0) + min(mmax(d_min), 0.0)), length(d_max));
}

vec2 box_bounds(vec3 b_min, vec3 b_max, vec3 p, out vec3 v_min, out vec3 v_max) 
{
    vec3 c = (b_max + b_min) * 0.5;
    vec3 s = (b_max - b_min) * 0.5;
    vec3 q = p - c;
    vec3 aq = abs(q);
    vec3 sq = sign(q);
    vec3 d_min = aq - s;
    vec3 d_max = aq + s;

    v_min = (max(d_min, 0.0) + min(mmax(d_min), 0.0)) * sq;
    v_max = d_max * sq;

    return vec2(length(v_min), length(v_max));
}

#endif\r
#ifndef TO_COLOR
#define TO_COLOR

vec4 to_color(float x) { return vec4(vec3(x), 1.0); }
vec4 to_color(vec3  x) { return vec4(vec3(x), 1.0); }
vec4 to_color(bool  x) { return vec4(vec3(x), 1.0); }
vec4 to_color(bvec3 x) { return vec4(vec3(x), 1.0); }

vec4 to_color(float x, float alpha) { return vec4(vec3(x), alpha); }
vec4 to_color(vec3  x, float alpha) { return vec4(vec3(x), alpha); }
vec4 to_color(bool  x, float alpha) { return vec4(vec3(x), alpha); }
vec4 to_color(bvec3 x, float alpha) { return vec4(vec3(x), alpha); }

#endif\r
#ifndef POSTERIZE
#define POSTERIZE

float posterize(in float grayscale, in float levels)
{
    
    levels = floor(max(levels, 2.0));

    
    grayscale = clamp(grayscale, 0.0, 1.0);

    
    float level = floor(grayscale * levels) / (levels - 1.0);

    return level;
}

vec3 posterize(vec3 color, float levels) {

    float grayscale = max(color.r, max(color.g, color.b));
    float level = posterize(grayscale, levels);
    float adjustment = level / grayscale;

    return color * adjustment;
}

#endif\r
#ifndef PRINCIPAL_CURVATURES\r
#define PRINCIPAL_CURVATURES

vec2 principal_curvatures(in vec3 gradient, in mat3 hessian)\r
{\r
    vec3 normal = normalize(gradient);

    
    vec3 orthogonal = cross(normal, abs(normal.x) < abs(normal.z) ? vec3(1, 0, 0) : vec3(0, 1, 0));

    
    vec3 t0 = normalize(orthogonal);\r
    vec3 t1 = cross(normal, t0);

    
    mat2x3 tangents = mat2x3(t0, t1);

    
    mat2 shape = (transpose(tangents) * hessian * tangents) / length(gradient);

    
    float trace = shape[0][0] + shape[1][1];\r
    float determinant = determinant(shape);\r
    float discriminant = sqrt(max(trace * trace - 4.0 * determinant, 0.0));

    
    vec2 curvatures = vec2(trace - discriminant, trace + discriminant) * 0.5;\r
    return curvatures;\r
}

vec2 principal_curvatures(in vec3 gradient, in mat3 hessian, out vec3 eigenvectors[2])\r
{\r
    vec3 normal = normalize(gradient);

    
    vec3 orthogonal = cross(normal, abs(normal.x) < abs(normal.z) ? vec3(1, 0, 0) : vec3(0, 1, 0));

    
    vec3 t0 = normalize(orthogonal);\r
    vec3 t1 = cross(normal, t0);

    
    mat2x3 tangents = mat2x3(t0, t1);

    
    mat2 shape = (transpose(tangents) * hessian * tangents) / length(gradient);

    
    float trace = shape[0][0] + shape[1][1];\r
    float determinant = determinant(shape);\r
    float discriminant = sqrt(max(trace * trace - 4.0 * determinant, 0.0));

    
    vec2 curvatures = vec2(trace - discriminant, trace + discriminant) * 0.5;

    
    float difference = shape[1][1] - shape[0][0];\r
    eigenvectors[0] = curvatures.x * t0 + (curvatures.x + difference) * t1;\r
    eigenvectors[1] = curvatures.y * t0 + (curvatures.y + difference) * t1;

    
    return curvatures;\r
}

#endif\r
#ifndef DIRECTIONAL_CURVATURE\r
#define DIRECTIONAL_CURVATURE

float directional_curvature(in vec3 direction, in vec3 gradient, in mat3 hessian)\r
{\r
    vec3 normal = normalize(gradient);\r
    vec3 tangent = direction - normal * dot(normal, direction);\r
    if (length(tangent) < 0.001) return 0.0; 

    mat3 P = mat3(1.0) - outerProduct(normal, normal);\r
    mat3 S = (P * hessian * P) / length(gradient);\r
    float curvature = dot(tangent, S * tangent) / dot(tangent, tangent);

    return curvature;\r
}

#endif\r
#ifndef COLORMAP\r
#define COLORMAP

#ifndef PARULA\r
#define PARULA 0

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 parula(float t) \r
{\r
    vec3 a  = vec3(0.541454, 1.968902, 0.559818);\r
    vec3 b1 = vec3(0.460347, 1.998354, 0.429174);\r
    vec3 c1 = vec3(0.645892, 0.330375, 0.763244);\r
    vec3 d1 = vec3(0.309938, 0.387593, -0.187696);\r
    vec3 b2 = vec3(-0.154889, 0.704319, 0.011011);\r
    vec3 c2 = vec3(1.667578, 0.717541, 2.000000);\r
    vec3 d2 = vec3(0.135293, 0.686891, 0.102776);\r
    return palette(t, a, b1, c1, d1, b2, c2, d2);\r
}

#endif\r
#ifndef TURBO\r
#define TURBO 1

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 turbo(float t) \r
{\r
    vec3 a  = vec3(-1.173583, 1.089549, 0.363003);\r
    vec3 b0 = vec3(1.999787, -1.091536, 0.596810);\r
    vec3 c0 = vec3(0.168544, 0.690975, 1.090372);\r
    vec3 d0 = vec3(0.843290, 0.188794, -0.342117);\r
    vec3 b1 = vec3(0.265151, 1.180907, -0.376009);\r
    vec3 c1 = vec3(1.460237, 0.381460, 1.554106);\r
    vec3 d1 = vec3(0.995900, 0.331064, 0.346513);\r
    return palette(t, a, b0, c0, d0, b1, c1, d1);\r
}

#endif\r
#ifndef HSV\r
#define HSV 2

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 hsv(float t) \r
{\r
    vec3 a  = vec3(0.345930, -1.151078, -1.327910);\r
    vec3 b0 = vec3(0.703838, 1.816049, 1.999886);\r
    vec3 c0 = vec3(1.417315, 0.237319, 0.228754);\r
    vec3 d0 = vec3(-0.210907, -0.120510, 0.880709);\r
    vec3 b1 = vec3(0.312792, 0.543745, 0.517213);\r
    vec3 c1 = vec3(2.000000, 0.995237, 1.018500);\r
    vec3 d1 = vec3(-0.003169, 0.719422, 0.269492);\r
    return palette(t, a, b0, c0, d0, b1, c1, d1);\r
}

#endif\r
#ifndef HOT\r
#define HOT 3

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 hot(float t) \r
{\r
    vec3 a  = vec3(0.434751, 0.499201, 0.553319);\r
    vec3 b0 = vec3(0.117871, 0.590260, 1.998983);\r
    vec3 c0 = vec3(1.395636, 0.560375, 0.692793);\r
    vec3 d0 = vec3(0.516179, 0.436002, 0.254912);\r
    vec3 b1 = vec3(0.669133, -0.097445, 1.467678);\r
    vec3 c1 = vec3(0.457411, 1.673730, 0.848067);\r
    vec3 d1 = vec3(0.679382, 0.311157, 0.700754);\r
    return palette(t, a, b0, c0, d0, b1, c1, d1);\r
}

#endif\r
#ifndef COOL\r
#define COOL 4

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 cool(float t) \r
{\r
    vec3 a = vec3(0.500001, 0.500000, 1.000000);\r
    vec3 b = vec3(1.999655, 1.999654, 0.000000);\r
    vec3 c = vec3(0.080099, 0.080099, 0.745176);\r
    vec3 d = vec3(0.709950, 0.209950, 0.127412);\r
    return palette(t, a, b, c, d);\r
}

#endif\r
#ifndef SPRING\r
#define SPRING 5

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 spring(float t) \r
{\r
    vec3 a = vec3(1.000000, 0.500001, 0.500001);\r
    vec3 b = vec3(0.000000, 1.999808, 1.999812);\r
    vec3 c = vec3(0.745176, 0.080093, 0.080093);\r
    vec3 d = vec3(0.127412, 0.709953, 0.209954);\r
    return palette(t, a, b, c, d);\r
}

#endif\r
#ifndef SUMMER\r
#define SUMMER 6

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 summer(float t) \r
{\r
    vec3 a = vec3(0.499979, 0.749503, 0.400000);\r
    vec3 b = vec3(1.998634, 1.447229, -0.000000);\r
    vec3 c = vec3(0.080141, 0.055144, 0.732340);\r
    vec3 d = vec3(0.709931, 0.722482, 0.133830);\r
    return palette(t, a, b, c, d);\r
}

#endif\r
#ifndef AUTUMN\r
#define AUTUMN 7

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 autumn(float t) \r
{\r
    vec3 a = vec3(1.000000, 0.500000, 0.000000);\r
    vec3 b = vec3(-0.000000, 1.999988, 0.000000);\r
    vec3 c = vec3(0.745176, 0.080086, 0.714514);\r
    vec3 d = vec3(0.127412, 0.709957, 0.142743);\r
    return palette(t, a, b, c, d);\r
}

#endif\r
#ifndef WINTER\r
#define WINTER 8

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 winter(float t) \r
{\r
    vec3 a = vec3(-0.000000, 0.500001, 0.750010);\r
    vec3 b = vec3(-0.000000, 1.999953, 1.430454);\r
    vec3 c = vec3(0.714514, 0.080087, 0.055794);\r
    vec3 d = vec3(0.142743, 0.709956, 0.222104);\r
    return palette(t, a, b, c, d);\r
}

#endif\r
#ifndef GRAY\r
#define GRAY 9

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 gray(float t) \r
{\r
    vec3 a = vec3(0.500000, 0.500000, 0.500000);\r
    vec3 b = vec3(1.999993, 1.999993, 1.999993);\r
    vec3 c = vec3(0.080086, 0.080086, 0.080086);\r
    vec3 d = vec3(0.709957, 0.709957, 0.709957);\r
    return palette(t, a, b, c, d);\r
}

#endif\r
#ifndef BONE\r
#define BONE 10

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 bone(float t) \r
{\r
    vec3 a = vec3(1.728560, 0.535898, -0.726993);\r
    vec3 b = vec3(2.000000, 0.583406, 2.000000);\r
    vec3 c = vec3(0.100690, 0.318709, 0.102955);\r
    vec3 d = vec3(0.587366, 0.576509, 0.809972);\r
    return palette(t, a, b, c, d);\r
}

#endif\r
#ifndef COPPER\r
#define COPPER 11

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 copper(float t) \r
{\r
    vec3 a = vec3(0.475474, 0.390606, 0.248753);\r
    vec3 b = vec3(0.545609, 1.863885, 1.362622);\r
    vec3 c = vec3(0.404723, 0.067001, 0.058301);\r
    vec3 d = vec3(0.596710, 0.716499, 0.720849);\r
    return palette(t, a, b, c, d);\r
}

#endif\r
#ifndef PINK\r
#define PINK 12

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 pink(float t) \r
{\r
    vec3 a  = vec3(-0.483794, -0.777930, -0.293682);\r
    vec3 b0 = vec3(1.988198, 1.900866, 1.999968);\r
    vec3 c0 = vec3(0.313872, 0.125783, 0.246824);\r
    vec3 d0 = vec3(-0.242539, 0.825271, 0.729959);\r
    vec3 b1 = vec3(0.593545, 0.029151, 0.736390);\r
    vec3 c1 = vec3(0.583510, 1.776750, 0.478608);\r
    vec3 d1 = vec3(1.077824, 0.775436, 1.088446);\r
    return palette(t, a, b0, c0, d0, b1, c1, d1);\r
}

#endif\r
#ifndef JET\r
#define JET 13

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 jet(float t) \r
{\r
    vec3 a  = vec3(0.276022, 0.527041, 0.353694);\r
    vec3 b0 = vec3(0.597922, -0.201586, 0.559465);\r
    vec3 c0 = vec3(0.512799, 1.045576, 0.596704);\r
    vec3 d0 = vec3(0.573475, -0.103501, -0.104961);\r
    vec3 b1 = vec3(0.238268, 0.399577, -0.201583);\r
    vec3 c1 = vec3(1.424259, 1.047211, 1.500953);\r
    vec3 d1 = vec3(-0.012310, 0.518820, 0.058936);\r
    return palette(t, a, b0, c0, d0, b1, c1, d1);\r
}

#endif\r
#ifndef PASTELJET\r
#define PASTELJET 14

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 pasteljet(float t) \r
{\r
    vec3 a  = vec3(0.677942, 0.350764, 0.469527);\r
    vec3 b0 = vec3(-0.043513, -0.050359, 0.266445);\r
    vec3 c0 = vec3(2.000000, 2.000000, 0.698727);\r
    vec3 d0 = vec3(0.497311, 0.518843, -0.207068);\r
    vec3 b1 = vec3(0.338745, -0.561075, 0.062141);\r
    vec3 c1 = vec3(0.863745, 0.650179, 2.000000);\r
    vec3 d1 = vec3(0.437310, 0.223441, 0.010220);\r
    return palette(t, a, b0, c0, d0, b1, c1, d1);\r
}

#endif\r
#ifndef VIRIDIS\r
#define VIRIDIS 15

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 viridis(float t) \r
{\r
    vec3 a  = vec3(0.425268, -0.364758, 0.418135);\r
    vec3 b1 = vec3(1.125800, 1.306212, -1.205918);\r
    vec3 c1 = vec3(0.778337, 0.165380, 1.148509);\r
    vec3 d1 = vec3(0.296775, 0.795553, 0.047920);\r
    vec3 b2 = vec3(0.937521, 0.012337, -1.069593);\r
    vec3 c2 = vec3(0.891060, 1.453194, 1.217589);\r
    vec3 d2 = vec3(0.781272, 0.775696, 0.520518);\r
    return palette(t, a, b1, c1, d1, b2, c2, d2);\r
}

#endif\r
#ifndef PLASMA\r
#define PLASMA 16

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 plasma(float t) \r
{\r
    vec3 a  = vec3(0.260353, 0.643741, 0.401505);\r
    vec3 b1 = vec3(0.925001, 0.641300, 0.244923);\r
    vec3 c1 = vec3(0.451398, 0.362059, 0.688036);\r
    vec3 d1 = vec3(0.674213, 0.466824, -0.150012);\r
    vec3 b2 = vec3(0.249030, 0.020714, 0.015128);\r
    vec3 c2 = vec3(0.709559, 1.885207, 2.000000);\r
    vec3 d2 = vec3(1.058190, 0.031753, 0.567507);\r
    return palette(t, a, b1, c1, d1, b2, c2, d2);\r
}

#endif\r
#ifndef INFERNO\r
#define INFERNO 17

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 inferno(float t) \r
{\r
    vec3 a  = vec3(-0.575419, 0.417340, 0.285807);\r
    vec3 b1 = vec3(1.543616, 1.325364, 2.000000);\r
    vec3 c1 = vec3(0.174341, 0.656644, 1.696938);\r
    vec3 d1 = vec3(0.815911, 0.396624, -0.608185);\r
    vec3 b2 = vec3(0.095489, 0.951299, 1.871821);\r
    vec3 c2 = vec3(0.907917, 0.757037, 1.749972);\r
    vec3 d2 = vec3(0.380506, 0.870792, -0.130654);\r
    return palette(t, a, b1, c1, d1, b2, c2, d2);\r
}

#endif\r
#ifndef MAGMA\r
#define MAGMA 18

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 magma(float t) \r
{\r
    vec3 a  = vec3(-0.386429, 0.394408, 0.409720);\r
    vec3 b1 = vec3(1.414174, 1.143924, 1.416815);\r
    vec3 c1 = vec3(0.189647, 0.676940, 0.641115);\r
    vec3 d1 = vec3(0.793470, 0.388450, -0.568490);\r
    vec3 b2 = vec3(0.079624, 0.813267, 1.330803);\r
    vec3 c2 = vec3(1.052351, 0.800573, 0.764647);\r
    vec3 d2 = vec3(0.286256, 0.854038, 0.863334);\r
    return palette(t, a, b1, c1, d1, b2, c2, d2);\r
}

#endif\r
#ifndef CIVIDIS\r
#define CIVIDIS 19

#ifndef PALETTE\r
#ifndef PALETTE\r
#define PALETTE

vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\r
{\r
    return a + b*cos( 6.283185*(c*t+d) );\r
}

vec3 palette(float t, vec3 a, vec3 b0, vec3 c0, vec3 d0, vec3 b1, vec3 c1, vec3 d1)\r
{\r
    return a + b0 * cos(6.283185 * (c0 * t + d0)) + b1 * cos(6.283185 * (c1 * t + d1));\r
}

#endif\r
#endif

vec3 cividis(float t) \r
{\r
    vec3 a  = vec3(0.471158, 0.894980, -1.390197);\r
    vec3 b1 = vec3(1.441757, 1.133394, 1.864691);\r
    vec3 c1 = vec3(0.670921, 0.196915, 0.145757);\r
    vec3 d1 = vec3(0.424741, 0.578773, -0.064678);\r
    vec3 b2 = vec3(1.085652, 0.238494, 0.032514);\r
    vec3 c2 = vec3(0.768613, 0.378699, 1.467550);\r
    vec3 d2 = vec3(0.876007, 0.999533, -0.060326);\r
    return palette(t, a, b1, c1, d1, b2, c2, d2);\r
}

#endif

vec3 colormap(in float t, in int type)\r
{\r
    if (type == PARULA) return parula(t);\r
    else if (type == TURBO) return turbo(t);\r
    else if (type == HSV) return hsv(t);\r
    else if (type == HOT) return hot(t);\r
    else if (type == COOL) return cool(t);\r
    else if (type == SPRING) return spring(t);\r
    else if (type == SUMMER) return summer(t);\r
    else if (type == AUTUMN) return autumn(t);\r
    else if (type == WINTER) return winter(t);\r
    else if (type == GRAY) return gray(t);\r
    else if (type == BONE) return bone(t);\r
    else if (type == COPPER) return copper(t);\r
    else if (type == PINK) return pink(t);\r
    else if (type == JET) return jet(t);\r
    else if (type == PASTELJET) return pasteljet(t);\r
    else if (type == VIRIDIS) return viridis(t);\r
    else if (type == PLASMA) return plasma(t);\r
    else if (type == INFERNO) return inferno(t);\r
    else if (type == MAGMA) return magma(t);\r
    else if (type == CIVIDIS) return cividis(t);

    else return vec3(0.0); \r
}

#endif\r
const vec4 sampling_points = vec4(0, 1, 2, 3) / 3.0;

const mat3 quad_inv_vander = mat3(\r
    6, -15, 9,    \r
   -6, 24, -18,   \r
    2, -9, 9      \r
) / 2.0;

const mat3 quad_bernstein = mat3(\r
    12, -3, 0,    \r
   -12, 12, 0,    \r
    4, -5, 4      \r
) / 4.0;

const mat4 cubic_inv_vander = mat4(\r
    2,   0,   0,  0,   \r
    -11,  18,  -9,  2,   \r
    18, -45,  36, -9, \r
    -9,  27, -27,  9\r
) / 2.0;

const mat4 cubic_bernstein = mat4(\r
    6, 0, 0, 0,  \r
    -5, 18, -9, 2, \r
    2, -9, 18, -5,\r
    0, 0, 0, 6   \r
) / 6.0;

const mat4x3 quintic_bernstein_weights = mat4x3(\r
    10, 4, 1,  \r
     6, 6, 3,  \r
     3, 6, 6,  \r
     1, 4,10   \r
) / 10.0;\r
#ifndef UNIFORMS_VOLUME\r
#define UNIFORMS_VOLUME

struct UniformsVolume \r
{\r
    ivec3 dimensions;    \r
    vec3  inv_dimensions;   \r
    vec3  size; \r
    vec3  spacing;           \r
    vec3  anisotropy;           \r
    int   stride;\r
    ivec3 blocks;        \r
    mat4  grid_matrix;                 \r
};

uniform UniformsVolume u_volume;

#endif\r
#ifndef UNIFORMS_TEXTURES\r
#define UNIFORMS_TEXTURES

struct UniformsTextures \r
{\r
    sampler2D colormaps;      \r
    sampler3D trilinear_volume;\r
    sampler3D tricubic_volume;\r
    usampler3D occupancy;\r
    usampler3D isotropic_distance;\r
    usampler3D anisotropic_distance;\r
    usampler3D extended_distance;\r
};

uniform UniformsTextures u_textures;

#endif\r
#ifndef UNIFORMS_COLORMAP\r
#define UNIFORMS_COLORMAP

struct UniformsColormap \r
{\r
    int  levels;      \r
    int  name;        \r
    vec2 thresholds;  \r
    vec2 start_coords;\r
    vec2 end_coords;  \r
};

uniform UniformsColormap u_colormap;

#endif\r
#ifndef UNIFORMS_RENDERING\r
#define UNIFORMS_RENDERING

struct UniformsRendering \r
{\r
    float isovalue;  \r
    int   max_groups;         \r
    int   max_cells;     \r
    int   max_blocks;   \r
};

uniform UniformsRendering u_rendering;

#endif\r
#ifndef UNIFORMS_SHADING\r
#define UNIFORMS_SHADING

struct UniformsShading\r
{\r
    float reflect_ambient; \r
    float reflect_diffuse; \r
    float reflect_specular;\r
    float shininess;           \r
    float modulate_edges;       \r
    float modulate_gradient;       \r
    float modulate_curvature;       \r
};

uniform UniformsShading u_shading;

#endif\r
#ifndef UNIFORMS_LIGHTING\r
#define UNIFORMS_LIGHTING

struct UniformsLighting \r
{\r
    float intensity;          \r
    float shadows;            \r
    vec3  color_ambient;      \r
    vec3  color_diffuse;      \r
    vec3  color_specular;     \r
    vec3  position_offset;    \r
};

uniform UniformsLighting u_lighting;

#endif\r
#ifndef UNIFORMS_DEBUG\r
#define UNIFORMS_DEBUG

struct UniformsDebug\r
{\r
    int option;    \r
    float variable1; \r
    float variable2; \r
    float variable3; \r
    float variable4; \r
    float variable5; \r
};

uniform UniformsDebug u_debug;

#endif\r
#ifndef STRUCT_CAMERA\r
#define STRUCT_CAMERA

struct Camera \r
{\r
    vec3  position;       
    vec3  direction;      
};

Camera camera; 

void set_camera()\r
{\r
    camera.position = v_camera_position;\r
    camera.direction = normalize(v_camera_direction);\r
}

#endif\r
#ifndef STRUCT_FRAG\r
#define STRUCT_FRAG

struct Frag \r
{\r
    float depth;             
    vec3  position;          
    vec3  color_material;      
    vec3  color_ambient;\r
    vec3  color_diffuse;\r
    vec3  color_specular;\r
    vec3  color_directional;\r
    vec3  color;           
};

Frag frag; 

void set_frag()\r
{\r
    frag.depth             = 0.0;\r
    frag.position          = vec3(0.0);\r
    frag.color_material    = vec3(0.0);\r
    frag.color_ambient     = vec3(0.0);\r
    frag.color_diffuse     = vec3(0.0);\r
    frag.color_specular    = vec3(0.0);\r
    frag.color_directional = vec3(0.0);\r
    frag.color             = vec3(0.0);\r
}

#endif\r
#ifndef STRUCT_BOX\r
#define STRUCT_BOX

struct Box \r
{  \r
    vec3  entry_position;   \r
    float entry_distance;   \r
    vec3  exit_position;     \r
    float exit_distance;     \r
    float span_distance;\r
    vec3  min_position;     \r
    vec3  max_position;   \r
    float min_entry_distance;\r
    float max_exit_distance;     \r
    float max_span_distance;   \r
   \r
};

Box box; 

void set_box()\r
{\r
    box.entry_position     = vec3(0.0);\r
    box.exit_position      = vec3(0.0);\r
    box.entry_distance     = 0.0;\r
    box.exit_distance      = 0.0;\r
    box.span_distance      = 0.0;\r
    box.min_position       = vec3(0.0);\r
    box.max_position       = vec3(0.0);\r
    box.min_entry_distance = 0.0;\r
    box.max_exit_distance  = 0.0;\r
    box.max_span_distance  = 0.0;\r
}

#endif\r
#ifndef STRUCT_RAY\r
#define STRUCT_RAY

struct Ray \r
{\r
    bool  discarded;       
    vec3  direction;       
    vec3  inv_direction;   
    float spacing;         
    ivec3 signs;           
    int   octant;          
    float start_distance;  
    vec3  start_position;  
    float end_distance;    
    vec3  end_position;    
    float span_distance;   
};

Ray ray; 

void set_ray()\r
{\r
    ray.discarded      = false;\r
    ray.direction      = vec3(0.0);\r
    ray.inv_direction  = vec3(0.0);\r
    ray.signs          = ivec3(0);\r
    ray.octant         = 0;\r
    ray.spacing        = 0.0;\r
    ray.start_position = vec3(0.0);\r
    ray.end_position   = vec3(0.0);\r
    ray.start_distance = 0.0;\r
    ray.end_distance   = 0.0;\r
    ray.span_distance  = 0.0;\r
}

#endif\r
#ifndef STRUCT_TRACE\r
#define STRUCT_TRACE

struct Trace \r
{\r
    bool  intersected;          
    bool  terminated;           
    vec3  position;             
    float distance;             
    float residue;           \r
    float prev_distance;           \r
    float prev_residue;         \r
};

Trace trace; 

void set_trace()\r
{\r
    trace.intersected   = false;\r
    trace.terminated    = false;\r
    trace.position      = vec3(0.0);\r
    trace.distance      = 0.0;\r
    trace.residue       = 0.0;\r
    trace.prev_distance = 0.0;\r
    trace.prev_residue  = 0.0;\r
}

#endif\r
#ifndef STRUCT_HIT\r
#define STRUCT_HIT

struct Hit \r
{\r
    bool  discarded;          \r
    bool  escaped;          \r
    bool  undefined;\r
    vec3  position;           \r
    float distance;   \r
    float value;        \r
    float residue;\r
    float derivative;\r
    float orientation;   \r
    vec3  gradient;   \r
    mat3  hessian;   \r
    vec3  normal;   \r
    vec2  curvatures;    \r
};

Hit hit; 

void set_hit()\r
{\r
    hit.discarded   = false;\r
    hit.escaped     = false;\r
    hit.undefined   = false;\r
    hit.position    = vec3(0.0);\r
    hit.distance    = 0.0;\r
    hit.value       = 0.0;\r
    hit.residue     = 0.0;\r
    hit.derivative  = 0.0;\r
    hit.orientation = 0.0;\r
    hit.gradient    = vec3(0.0);\r
    hit.hessian     = mat3(0.0);\r
    hit.normal      = vec3(0.0);\r
    hit.curvatures  = vec2(0.0);\r
}

#endif\r
#ifndef STRUCT_CELL\r
#define STRUCT_CELL

struct Cell \r
{\r
    bool  intersected;\r
    bool  terminated;\r
    ivec3 coords;\r
    ivec3 exit_normal;\r
    vec3  min_position;\r
    vec3  max_position;\r
    float entry_distance;\r
    float exit_distance;\r
    float span_distance;\r
    vec3  entry_position;\r
    vec3  exit_position;\r
};

Cell cell; 

void set_cell()\r
{\r
    cell.intersected    = false;\r
    cell.terminated     = false;\r
    cell.coords         = ivec3(0);\r
    cell.exit_normal    = ivec3(0);\r
    cell.min_position   = vec3(0.0);\r
    cell.max_position   = vec3(0.0);\r
    cell.entry_distance = 0.0;\r
    cell.exit_distance  = 0.0;\r
    cell.span_distance  = 0.0;\r
    cell.entry_position = vec3(0.0);\r
    cell.exit_position  = vec3(0.0);\r
}

#endif\r
#ifndef STRUCT_BLOCK\r
#define STRUCT_BLOCK

struct Block\r
{\r
    ivec3 skip_distance;\r
    bool  occupied;\r
    bool  terminated;\r
    ivec3 coords;  \r
    ivec3 exit_normal;\r
    ivec3 min_coords;\r
    ivec3 max_coords;\r
    vec3  min_position;\r
    vec3  max_position;\r
    float entry_distance;\r
    float exit_distance;\r
    float span_distance;\r
    vec3  entry_position;\r
    vec3  exit_position;\r
};

Block block; 

void set_block()\r
{\r
    block.skip_distance  = ivec3(0);\r
    block.occupied       = false;\r
    block.terminated     = false;\r
    block.coords         = ivec3(0);\r
    block.exit_normal    = ivec3(0);\r
    block.min_coords     = ivec3(0);\r
    block.max_coords     = ivec3(0);\r
    block.min_position   = vec3(0.0);\r
    block.max_position   = vec3(0.0);\r
    block.entry_distance = 0.0;\r
    block.exit_distance  = 0.0;\r
    block.span_distance  = 0.0;\r
    block.entry_position = vec3(0.0);\r
    block.exit_position  = vec3(0.0);\r
}

#endif\r
#ifndef STRUCT_CUBIC\r
#define STRUCT_CUBIC

struct Cubic \r
{\r
    vec4  residuals;\r
    vec4  distances;\r
    vec4  coeffs;    \r
    vec4  bernstein_coeffs; \r
    vec4  roots;\r
    float root;\r
};

Cubic cubic; 

void set_cubic()\r
{\r
    cubic.roots = vec4(0);\r
    cubic.residuals = vec4(0);\r
    cubic.distances = vec4(0);\r
    cubic.coeffs = vec4(0);\r
    cubic.bernstein_coeffs = vec4(0);\r
    cubic.root = 0.0;\r
}

#endif\r
#ifndef STRUCT_QUINTIC\r
#define STRUCT_QUINTIC

struct Quintic \r
{\r
    vec4 residuals;\r
    float coeffs[6];  \r
    float bernstein_coeffs[6];  \r
    float roots[6];\r
    mat4 features;\r
    mat3x4 biases;\r
    float root;\r
};

Quintic quintic; 

void set_quintic()\r
{\r
    quintic.residuals = vec4(0.0);\r
    quintic.coeffs = float[6](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\r
    quintic.bernstein_coeffs = float[6](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\r
    quintic.roots = float[6](0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\r
    quintic.biases = mat3x4(0);\r
    quintic.features = mat4(0);\r
    quintic.root = 0.0;\r
}

#endif

#if DEBUG_ENABLED == 1\r
#ifndef STRUCT_DEBUG\r
#define STRUCT_DEBUG

struct Debug \r
{\r
    vec4 variable0;\r
    vec4 variable1;\r
    vec4 variable2;\r
    vec4 variable3;\r
    vec4 variable4;\r
    vec4 variable5;\r
    vec4 variable6;\r
    vec4 variable7;\r
    vec4 variable8;\r
    vec4 variable9;\r
};

Debug debug; 

void set_debug()\r
{\r
    debug.variable0 = to_color(0.0);\r
    debug.variable1 = to_color(0.0);\r
    debug.variable2 = to_color(0.0);\r
    debug.variable3 = to_color(0.0);\r
    debug.variable4 = to_color(0.0);\r
    debug.variable5 = to_color(0.0);\r
    debug.variable6 = to_color(0.0);\r
    debug.variable7 = to_color(0.0);\r
    debug.variable8 = to_color(0.0);\r
    debug.variable9 = to_color(0.0);\r
}

#endif\r
#endif

#if STATS_ENABLED == 1\r
#ifndef STRUCT_STATS\r
#define STRUCT_STATS

struct Stats\r
{\r
    int num_fetches; 
    int num_cells;\r
    int num_blocks;\r
    int num_traces;\r
    int num_tests;\r
};

Stats stats; 

void set_stats()\r
{\r
    stats.num_fetches = 0;\r
    stats.num_cells   = 0;\r
    stats.num_traces  = 0;\r
    stats.num_blocks  = 0;\r
    stats.num_tests  = 0;\r
}

#endif\r
#endif\r
#ifndef SAMPLE_COLORMAP\r
#define SAMPLE_COLORMAP

vec3 sample_colormap(in float x)\r
{\r
    
    float s = map(u_colormap.thresholds.x, u_colormap.thresholds.y, x);

    
    vec2 texture_coords = vec2(\r
        mix(u_colormap.start_coords.x, u_colormap.end_coords.x, s),\r
        u_colormap.start_coords.y\r
    );

    return texture(u_textures.colormaps, texture_coords).rgb;\r
}

#endif\r
#ifndef SAMPLE_OCCUPANCY\r
#define SAMPLE_OCCUPANCY

bool sample_occupancy(in ivec3 block_coords)\r
{\r
    
    uint texture_sample = texelFetch(u_textures.occupancy, block_coords, 0).r;

    
    bool occupancy = (texture_sample > 0u);\r
    \r
    return occupancy;\r
}

#endif\r
#ifndef SAMPLE_VALUE_TRILINEAR\r
#define SAMPLE_VALUE_TRILINEAR

float sample_value_trilinear(in vec3 coords)\r
{\r
    
    coords *= u_volume.inv_dimensions;

    
    #if INTERPOLATION_METHOD == 1\r
    float value = texture(u_textures.trilinear_volume, coords).r;\r
    #endif

    
    #if INTERPOLATION_METHOD == 2\r
    float value = texture(u_textures.tricubic_volume, coords).a;\r
    #endif

    return value;\r
}

#endif\r
#ifndef SAMPLE_VALUE_TRICUBIC\r
#define SAMPLE_VALUE_TRICUBIC

vec4 tricubic_bias(vec3 coords)\r
{\r
    vec3 r = fract(coords - 0.5);;\r
    vec3 bias = r * (r - 1.0) * 0.5;\r
    \r
    return vec4(bias, 1.0);\r
}

vec4 tricubic_features(in vec3 coords)\r
{\r
    
    vec3 texture_coords = coords * u_volume.inv_dimensions;

    
    return texture(u_textures.tricubic_volume, texture_coords);\r
}

float sample_value_tricubic(in vec3 coords)\r
{\r
    
    vec4 features = tricubic_features(coords);

    
    vec4 bias = tricubic_bias(coords);

    
    float value = dot(bias, features);

    return value;\r
}       

float sample_value_tricubic(in vec3 coords, out vec4 features)\r
{\r
    
    features = tricubic_features(coords);

    
    vec4 bias = tricubic_bias(coords);

    
    float value = dot(bias, features);

    return value;\r
}    

#endif\r
#ifndef SAMPLE_RESIDUE_TRILINEAR\r
#define SAMPLE_RESIDUE_TRILINEAR

#ifndef SAMPLE_VALUE_TRILINEAR\r
#ifndef SAMPLE_VALUE_TRILINEAR\r
#define SAMPLE_VALUE_TRILINEAR

float sample_value_trilinear(in vec3 coords)\r
{\r
    
    coords *= u_volume.inv_dimensions;

    
    #if INTERPOLATION_METHOD == 1\r
    float value = texture(u_textures.trilinear_volume, coords).r;\r
    #endif

    
    #if INTERPOLATION_METHOD == 2\r
    float value = texture(u_textures.tricubic_volume, coords).a;\r
    #endif

    return value;\r
}

#endif\r
#endif

float sample_residue_trilinear(in vec3 coords)\r
{\r
    return sample_value_trilinear(coords) - u_rendering.isovalue;\r
}

#endif\r
#ifndef SAMPLE_RESIDUE_TRICUBIC\r
#define SAMPLE_RESIDUE_TRICUBIC

#ifndef SAMPLE_VALUE_TRICUBIC\r
#ifndef SAMPLE_VALUE_TRICUBIC\r
#define SAMPLE_VALUE_TRICUBIC

vec4 tricubic_bias(vec3 coords)\r
{\r
    vec3 r = fract(coords - 0.5);;\r
    vec3 bias = r * (r - 1.0) * 0.5;\r
    \r
    return vec4(bias, 1.0);\r
}

vec4 tricubic_features(in vec3 coords)\r
{\r
    
    vec3 texture_coords = coords * u_volume.inv_dimensions;

    
    return texture(u_textures.tricubic_volume, texture_coords);\r
}

float sample_value_tricubic(in vec3 coords)\r
{\r
    
    vec4 features = tricubic_features(coords);

    
    vec4 bias = tricubic_bias(coords);

    
    float value = dot(bias, features);

    return value;\r
}       

float sample_value_tricubic(in vec3 coords, out vec4 features)\r
{\r
    
    features = tricubic_features(coords);

    
    vec4 bias = tricubic_bias(coords);

    
    float value = dot(bias, features);

    return value;\r
}    

#endif\r
#endif

float sample_residue_tricubic(in vec3 coords)\r
{\r
    return sample_value_tricubic(coords) - u_rendering.isovalue;\r
}

float sample_residue_tricubic(in vec3 coords, out vec4 features)\r
{\r
    return sample_value_tricubic(coords, features) - u_rendering.isovalue;\r
}

#endif\r
#ifndef SAMPLE_DISTANCE_ISOTROPIC\r
#define SAMPLE_DISTANCE_ISOTROPIC

ivec3 sample_distance_isotropic(in ivec3 block_coords, out bool occupancy)\r
{\r
    
    uint texture_sample = texelFetch(u_textures.isotropic_distance, block_coords, 0).r;

    
    int distance = int(texture_sample);

    
    occupancy = (distance == 0);

    return ivec3(distance);\r
}

#endif\r
#ifndef SAMPLE_DISTANCE_ANISOTROPIC\r
#define SAMPLE_DISTANCE_ANISOTROPIC

ivec3 sample_distance_anisotropic(in ivec3 block_coords, in int octant, out bool occupancy)\r
{    \r
    
    ivec3 slab_coords = block_coords;\r
    slab_coords.z += octant * u_volume.blocks.z;

    
    uint texture_sample = texelFetch(u_textures.anisotropic_distance, slab_coords, 0).r;

    
    int distance = int(texture_sample);

    
    occupancy = (distance == 0);

    return ivec3(distance);\r
}

#endif\r
#ifndef SAMPLE_DISTANCE_EXTENDED\r
#define SAMPLE_DISTANCE_EXTENDED

uvec4 unpack_sample(in uint packed_sample)\r
{\r
    return uvec4(\r
        (packed_sample >> 11u) & 0x1Fu, 
        (packed_sample >>  6u) & 0x1Fu, 
        (packed_sample >>  1u) & 0x1Fu, 
        (packed_sample >>  0u) & 0x01u  
    );\r
}

ivec3 sample_distance_extended(in ivec3 block_coords, in int octant, out bool occupancy)\r
{\r
    
    ivec3 slab_coords = block_coords;\r
    slab_coords.z += octant * u_volume.blocks.z;

    
    uint packed_sample = texelFetch(u_textures.extended_distance, slab_coords, 0).r;

    
    uvec4 unpacked_sample = unpack_sample(packed_sample);

    
    ivec3 distances = ivec3(unpacked_sample.rgb);

    
    occupancy = bool(unpacked_sample.a);

    return distances;\r
}

#endif\r
#ifndef COMPUTE_GRADIENT\r
#define COMPUTE_GRADIENT

#if GRADIENTS_METHOD == 1\r
#if INTERPOLATION_METHOD == 1\r
    #ifndef COMPUTE_GRADIENT_TRILINEAR_ANALYTIC\r
#define COMPUTE_GRADIENT_TRILINEAR_ANALYTIC

#ifndef SAMPLE_TRILINEAR_VOLUME\r
#ifndef SAMPLE_VALUE_TRILINEAR\r
#define SAMPLE_VALUE_TRILINEAR

float sample_value_trilinear(in vec3 coords)\r
{\r
    
    coords *= u_volume.inv_dimensions;

    
    #if INTERPOLATION_METHOD == 1\r
    float value = texture(u_textures.trilinear_volume, coords).r;\r
    #endif

    
    #if INTERPOLATION_METHOD == 2\r
    float value = texture(u_textures.tricubic_volume, coords).a;\r
    #endif

    return value;\r
}

#endif\r
#endif

vec3 compute_gradient_trilinear_analytic(in vec3 p)\r
{\r
    
    vec3 x = p - 0.5;     
    vec3 i = floor(x); 

    vec3 a0 = x - i; 

    vec3 p0 = i + 0.5;\r
    vec3 p1 = i + 1.5;

    
    float f_x0y0z0 = sample_value_trilinear(vec3(p0.x, p0.y, p0.z));\r
    float f_x0y1z0 = sample_value_trilinear(vec3(p0.x, p1.y, p0.z));\r
    float f_x0y0z1 = sample_value_trilinear(vec3(p0.x, p0.y, p1.z));\r
    float f_x0y1z1 = sample_value_trilinear(vec3(p0.x, p1.y, p1.z));\r
    float f_x1y0z0 = sample_value_trilinear(vec3(p1.x, p0.y, p0.z));\r
    float f_x1y1z0 = sample_value_trilinear(vec3(p1.x, p1.y, p0.z));\r
    float f_x1y0z1 = sample_value_trilinear(vec3(p1.x, p0.y, p1.z));\r
    float f_x1y1z1 = sample_value_trilinear(vec3(p1.x, p1.y, p1.z));

    
    float f_xy0z0 = mix(f_x0y0z0, f_x1y0z0, a0.x);\r
    float f_xy1z0 = mix(f_x0y1z0, f_x1y1z0, a0.x);\r
    float f_xy0z1 = mix(f_x0y0z1, f_x1y0z1, a0.x);\r
    float f_xy1z1 = mix(f_x0y1z1, f_x1y1z1, a0.x);

    
    float f_dxy0z0 = f_x1y0z0 - f_x0y0z0;\r
    float f_dxy1z0 = f_x1y1z0 - f_x0y1z0;\r
    float f_dxy0z1 = f_x1y0z1 - f_x0y0z1;\r
    float f_dxy1z1 = f_x1y1z1 - f_x0y1z1;

    
    float f_xyz0  = mix(f_xy0z0,  f_xy1z0,  a0.y);\r
    float f_xyz1  = mix(f_xy0z1,  f_xy1z1,  a0.y);\r
    float f_dxyz0 = mix(f_dxy0z0, f_dxy1z0, a0.y);\r
    float f_dxyz1 = mix(f_dxy0z1, f_dxy1z1, a0.y);

    
    float f_xdyz0 = f_xy1z0 - f_xy0z0;\r
    float f_xdyz1 = f_xy1z1 - f_xy0z1;

    
    float f_dxyz = mix(f_dxyz0, f_dxyz1, a0.z);\r
    float f_xdyz = mix(f_xdyz0, f_xdyz1, a0.z);

    
    float f_xydz = f_xyz1 - f_xyz0;

    
    vec3 gradient = vec3(f_dxyz, f_xdyz, f_xydz);

    
    gradient /= u_volume.anisotropy;

    return gradient;\r
}

vec3 compute_gradient_trilinear_analytic(in vec3 p, out mat3 hessian)\r
{\r
    
    vec3 x = p - 0.5; 
    vec3 i = floor(x); 

    vec3 a0 = x - i; 

    vec3 p0 = i + 0.5;\r
    vec3 p1 = i + 1.5;

    
    float f_x0y0z0 = sample_value_trilinear(vec3(p0.x, p0.y, p0.z));\r
    float f_x0y1z0 = sample_value_trilinear(vec3(p0.x, p1.y, p0.z));\r
    float f_x0y0z1 = sample_value_trilinear(vec3(p0.x, p0.y, p1.z));\r
    float f_x0y1z1 = sample_value_trilinear(vec3(p0.x, p1.y, p1.z));\r
    float f_x1y0z0 = sample_value_trilinear(vec3(p1.x, p0.y, p0.z));\r
    float f_x1y1z0 = sample_value_trilinear(vec3(p1.x, p1.y, p0.z));\r
    float f_x1y0z1 = sample_value_trilinear(vec3(p1.x, p0.y, p1.z));\r
    float f_x1y1z1 = sample_value_trilinear(vec3(p1.x, p1.y, p1.z));

    
    float f_xy0z0 = mix(f_x0y0z0, f_x1y0z0, a0.x);\r
    float f_xy1z0 = mix(f_x0y1z0, f_x1y1z0, a0.x);\r
    float f_xy0z1 = mix(f_x0y0z1, f_x1y0z1, a0.x);\r
    float f_xy1z1 = mix(f_x0y1z1, f_x1y1z1, a0.x);

    
    float f_dxy0z0 = f_x1y0z0 - f_x0y0z0;\r
    float f_dxy1z0 = f_x1y1z0 - f_x0y1z0;\r
    float f_dxy0z1 = f_x1y0z1 - f_x0y0z1;\r
    float f_dxy1z1 = f_x1y1z1 - f_x0y1z1;

    
    float f_xyz0  = mix(f_xy0z0,  f_xy1z0,  a0.y);\r
    float f_xyz1  = mix(f_xy0z1,  f_xy1z1,  a0.y);\r
    float f_dxyz0 = mix(f_dxy0z0, f_dxy1z0, a0.y);\r
    float f_dxyz1 = mix(f_dxy0z1, f_dxy1z1, a0.y);

    
    float f_xdyz0  = f_xy1z0  - f_xy0z0;\r
    float f_xdyz1  = f_xy1z1  - f_xy0z1;\r
    float f_dxdyz0 = f_dxy1z0 - f_dxy0z0;\r
    float f_dxdyz1 = f_dxy1z1 - f_dxy0z1;

    
    float f_xyz   = mix(f_xyz0,   f_xyz1,   a0.z);\r
    float f_dxyz  = mix(f_dxyz0,  f_dxyz1,  a0.z);\r
    float f_xdyz  = mix(f_xdyz0,  f_xdyz1,  a0.z);\r
    float f_dxdyz = mix(f_dxdyz0, f_dxdyz1, a0.z);

    
    float f_xydz  = f_xyz1  - f_xyz0;\r
    float f_dxydz = f_dxyz1 - f_dxyz0;\r
    float f_xdydz = f_xdyz1 - f_xdyz0;

    
    vec3 gradient = vec3(f_dxyz, f_xdyz, f_xydz);

    
    hessian = mat3(\r
        0.0, f_dxdyz, f_dxydz,  \r
        f_dxdyz, 0.0, f_xdydz,  \r
        f_dxydz, f_xdydz, 0.0     \r
    );

    
    hessian /= outerProduct(u_volume.anisotropy, u_volume.anisotropy);\r
    gradient /= u_volume.anisotropy;

    return gradient;\r
}

#endif\r
    #endif\r
    #if INTERPOLATION_METHOD == 2\r
    #ifndef COMPUTE_GRADIENT_TRICUBIC_ANALYTIC\r
#define COMPUTE_GRADIENT_TRICUBIC_ANALYTIC

#ifndef SAMPLE_TRICUBIC_VOLUME\r
#ifndef SAMPLE_VALUE_TRICUBIC\r
#define SAMPLE_VALUE_TRICUBIC

vec4 tricubic_bias(vec3 coords)\r
{\r
    vec3 r = fract(coords - 0.5);;\r
    vec3 bias = r * (r - 1.0) * 0.5;\r
    \r
    return vec4(bias, 1.0);\r
}

vec4 tricubic_features(in vec3 coords)\r
{\r
    
    vec3 texture_coords = coords * u_volume.inv_dimensions;

    
    return texture(u_textures.tricubic_volume, texture_coords);\r
}

float sample_value_tricubic(in vec3 coords)\r
{\r
    
    vec4 features = tricubic_features(coords);

    
    vec4 bias = tricubic_bias(coords);

    
    float value = dot(bias, features);

    return value;\r
}       

float sample_value_tricubic(in vec3 coords, out vec4 features)\r
{\r
    
    features = tricubic_features(coords);

    
    vec4 bias = tricubic_bias(coords);

    
    float value = dot(bias, features);

    return value;\r
}    

#endif\r
#endif

/*\r
    This function produces analytic gradients and curvatures directly from the \r
    interpolation function described in "Beyond Trilinear Interpolation: Higher Quality for Free".\r
    There are some visible boundary artifacts between cells because gradients are C^0 piecewise continuous \r
*/\r
vec3 compute_gradient_tricubic_analytic(in vec3 p)\r
{\r
    
    vec3 x = p - 0.5; 
    vec3 i = floor(x); 

    vec3 a0 = x - i; 
    vec3 a1 = a0 - 0.5;

    vec3 p0 = i + 0.5;\r
    vec3 p1 = i + 1.5;

    vec4 bias = vec4(a0 * (a0 - 1.0) * 0.5, 1.0);

    
    vec4 f    = tricubic_features(p);\r
    vec4 f_x0 = tricubic_features(vec3(p0.x, p.y,  p.z));\r
    vec4 f_x1 = tricubic_features(vec3(p1.x, p.y,  p.z));\r
    vec4 f_y0 = tricubic_features(vec3(p.x,  p0.y, p.z));\r
    vec4 f_y1 = tricubic_features(vec3(p.x,  p1.y, p.z));\r
    vec4 f_z0 = tricubic_features(vec3(p.x,  p.y,  p0.z));\r
    vec4 f_z1 = tricubic_features(vec3(p.x,  p.y,  p1.z));

    
    vec4 f_dx = f_x1 - f_x0;\r
    vec4 f_dy = f_y1 - f_y0;\r
    vec4 f_dz = f_z1 - f_z0;

    
    float F_dx = dot(f_dx, bias) + f.x * a1.x;\r
    float F_dy = dot(f_dy, bias) + f.y * a1.y;\r
    float F_dz = dot(f_dz, bias) + f.z * a1.z;

    
    vec3 gradient = vec3(F_dx, F_dy, F_dz);

    
    gradient /= u_volume.anisotropy;

    return gradient;\r
}

vec3 compute_gradient_tricubic_analytic(in vec3 p, out mat3 hessian)\r
{\r
    
    vec3 x = p - 0.5; 
    vec3 i = floor(x); 

    vec3 a0 = x - i; 
    vec3 a1 = a0 - 0.5;

    vec3 p0 = i + 0.5;\r
    vec3 p1 = i + 1.5;

    vec4 bias = vec4(a0 * (a0 - 1.0) * 0.5, 1.0);

    
    vec4 f_x0y0z0 = tricubic_features(vec3(p0.x, p0.y, p0.z));\r
    vec4 f_x0y1z0 = tricubic_features(vec3(p0.x, p1.y, p0.z));\r
    vec4 f_x0y0z1 = tricubic_features(vec3(p0.x, p0.y, p1.z));\r
    vec4 f_x0y1z1 = tricubic_features(vec3(p0.x, p1.y, p1.z));\r
    vec4 f_x1y0z0 = tricubic_features(vec3(p1.x, p0.y, p0.z));\r
    vec4 f_x1y1z0 = tricubic_features(vec3(p1.x, p1.y, p0.z));\r
    vec4 f_x1y0z1 = tricubic_features(vec3(p1.x, p0.y, p1.z));\r
    vec4 f_x1y1z1 = tricubic_features(vec3(p1.x, p1.y, p1.z));

    
    vec4 f_xy0z0 = mix(f_x0y0z0, f_x1y0z0, a0.x);\r
    vec4 f_xy1z0 = mix(f_x0y1z0, f_x1y1z0, a0.x);\r
    vec4 f_xy0z1 = mix(f_x0y0z1, f_x1y0z1, a0.x);\r
    vec4 f_xy1z1 = mix(f_x0y1z1, f_x1y1z1, a0.x);

    
    vec4 f_dxy0z0 = f_x1y0z0 - f_x0y0z0;\r
    vec4 f_dxy1z0 = f_x1y1z0 - f_x0y1z0;\r
    vec4 f_dxy0z1 = f_x1y0z1 - f_x0y0z1;\r
    vec4 f_dxy1z1 = f_x1y1z1 - f_x0y1z1;

    
    vec4 f_xyz0  = mix(f_xy0z0,  f_xy1z0,  a0.y);\r
    vec4 f_xyz1  = mix(f_xy0z1,  f_xy1z1,  a0.y);\r
    vec4 f_dxyz0 = mix(f_dxy0z0, f_dxy1z0, a0.y);\r
    vec4 f_dxyz1 = mix(f_dxy0z1, f_dxy1z1, a0.y);

    
    vec4 f_xdyz0  = f_xy1z0  - f_xy0z0;\r
    vec4 f_xdyz1  = f_xy1z1  - f_xy0z1;\r
    vec4 f_dxdyz0 = f_dxy1z0 - f_dxy0z0;\r
    vec4 f_dxdyz1 = f_dxy1z1 - f_dxy0z1;

    
    vec4 f_xyz   = mix(f_xyz0,   f_xyz1,   a0.z);\r
    vec4 f_dxyz  = mix(f_dxyz0,  f_dxyz1,  a0.z);\r
    vec4 f_xdyz  = mix(f_xdyz0,  f_xdyz1,  a0.z);\r
    vec4 f_dxdyz = mix(f_dxdyz0, f_dxdyz1, a0.z);

    
    vec4 f_xydz  = f_xyz1  - f_xyz0;\r
    vec4 f_dxydz = f_dxyz1 - f_dxyz0;\r
    vec4 f_xdydz = f_xdyz1 - f_xdyz0;

    
    float Fx_xyz = dot(f_dxyz, bias) + f_xyz.x * a1.x;\r
    float Fy_xyz = dot(f_xdyz, bias) + f_xyz.y * a1.y;\r
    float Fz_xyz = dot(f_xydz, bias) + f_xyz.z * a1.z;

    
    float Fxy_xyz = dot(f_dxdyz, bias) + dot(vec2(f_xdyz.x, f_dxyz.y), a1.xy);\r
    float Fyz_xyz = dot(f_xdydz, bias) + dot(vec2(f_xydz.y, f_xdyz.z), a1.yz);\r
    float Fxz_xyz = dot(f_dxydz, bias) + dot(vec2(f_dxyz.z, f_xydz.x), a1.zx);

    
    float Fxx_xyz = f_xyz.x + f_dxyz.x * a1.x * 2.0;\r
    float Fyy_xyz = f_xyz.y + f_xdyz.y * a1.y * 2.0;\r
    float Fzz_xyz = f_xyz.z + f_xydz.z * a1.z * 2.0;

    
    vec3 gradient = vec3(Fx_xyz, Fy_xyz, Fz_xyz);

    
    hessian = mat3(\r
        Fxx_xyz, Fxy_xyz, Fxz_xyz,  \r
        Fxy_xyz, Fyy_xyz, Fyz_xyz,  \r
        Fxz_xyz, Fyz_xyz, Fzz_xyz     \r
    );

    
    hessian /= outerProduct(u_volume.anisotropy, u_volume.anisotropy);\r
    gradient /= u_volume.anisotropy;

    return gradient;\r
}

#endif\r
    #endif\r
#endif\r
#if GRADIENTS_METHOD == 2\r
#ifndef COMPUTE_GRADIENT_TRILINEAR_SOBEL\r
#define COMPUTE_GRADIENT_TRILINEAR_SOBEL

#ifndef SAMPLE_TRILINEAR_VOLUME\r
#ifndef SAMPLE_VALUE_TRILINEAR\r
#define SAMPLE_VALUE_TRILINEAR

float sample_value_trilinear(in vec3 coords)\r
{\r
    
    coords *= u_volume.inv_dimensions;

    
    #if INTERPOLATION_METHOD == 1\r
    float value = texture(u_textures.trilinear_volume, coords).r;\r
    #endif

    
    #if INTERPOLATION_METHOD == 2\r
    float value = texture(u_textures.tricubic_volume, coords).a;\r
    #endif

    return value;\r
}

#endif\r
#endif\r
#ifndef SAMPLE_SECOND_DERIVATIVES\r
#ifndef SAMPLE_SECOND_DERIVATIVES\r
#define SAMPLE_SECOND_DERIVATIVES

#ifndef SAMPLE_TRILINEAR_VOLUME\r
#ifndef SAMPLE_VALUE_TRILINEAR\r
#define SAMPLE_VALUE_TRILINEAR

float sample_value_trilinear(in vec3 coords)\r
{\r
    
    coords *= u_volume.inv_dimensions;

    
    #if INTERPOLATION_METHOD == 1\r
    float value = texture(u_textures.trilinear_volume, coords).r;\r
    #endif

    
    #if INTERPOLATION_METHOD == 2\r
    float value = texture(u_textures.tricubic_volume, coords).a;\r
    #endif

    return value;\r
}

#endif\r
#endif

vec3 sample_second_derivatives(in vec3 p)\r
{\r
    #if INTERPOLATION_METHOD == 1

        
        vec3 s_x0yz_xy0z_xyz0 = vec3(\r
            sample_value_trilinear(vec3(p.x - 1.0, p.y, p.z)),\r
            sample_value_trilinear(vec3(p.x, p.y - 1.0, p.z)),\r
            sample_value_trilinear(vec3(p.x, p.y, p.z - 1.0))\r
        );

        vec3 s_x1yz_xy1z_xyz1 = vec3(\r
            sample_value_trilinear(vec3(p.x + 1.0, p.y, p.z)),\r
            sample_value_trilinear(vec3(p.x, p.y + 1.0, p.z)),\r
            sample_value_trilinear(vec3(p.x, p.y, p.z + 1.0))\r
        );

        
        return s_x0yz_xy0z_xyz0 + s_x1yz_xy1z_xyz1 - sample_value_trilinear(p) * 2.0;

    #endif

    #if INTERPOLATION_METHOD == 2

        return tricubic_features(p).xyz;

    #endif\r
}

#endif\r
#endif

vec3 compute_gradient_trilinear_sobel(in vec3 p)\r
{\r
    
    vec3 p0 = p - 0.5;\r
    vec3 p1 = p + 0.5;

    
    vec4 s_x0y0z0_x0y1z0_x0y0z1_x0y1z1 = vec4(\r
        sample_value_trilinear(vec3(p0.x, p0.y, p0.z)), 
        sample_value_trilinear(vec3(p0.x, p1.y, p0.z)), 
        sample_value_trilinear(vec3(p0.x, p0.y, p1.z)), 
        sample_value_trilinear(vec3(p0.x, p1.y, p1.z))  
    );

    vec4 s_x1y0z0_x1y1z0_x1y0z1_x1y1z1 = vec4(\r
        sample_value_trilinear(vec3(p1.x, p0.y, p0.z)), 
        sample_value_trilinear(vec3(p1.x, p1.y, p0.z)), 
        sample_value_trilinear(vec3(p1.x, p0.y, p1.z)), 
        sample_value_trilinear(vec3(p1.x, p1.y, p1.z))  
    );

    
    vec4 s_xy0z0_xy1z0_xy0z1_xy1z1 = mix(\r
        s_x1y0z0_x1y1z0_x1y0z1_x1y1z1, \r
        s_x0y0z0_x0y1z0_x0y0z1_x0y1z1, \r
    0.5);

    
    vec4 s_dxy0z0_dxy1z0_dxy0z1_dxy1z1 = (\r
        s_x1y0z0_x1y1z0_x1y0z1_x1y1z1 - \r
        s_x0y0z0_x0y1z0_x0y0z1_x0y1z1\r
    );

    
    vec4 s_xyz0_xyz1_dxyz0_dxyz1 = mix(\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.yw, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.yw),\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.xz, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.xz),\r
    0.5);

    
    vec2 s_xdyz0_xdyz1 = (\r
        s_xy0z0_xy1z0_xy0z1_xy1z1.yw - \r
        s_xy0z0_xy1z0_xy0z1_xy1z1.xz\r
    );

    
    vec2 s_dxyz_xdyz = mix(\r
        vec2(s_xyz0_xyz1_dxyz0_dxyz1.w, s_xdyz0_xdyz1.y),\r
        vec2(s_xyz0_xyz1_dxyz0_dxyz1.z, s_xdyz0_xdyz1.x), \r
    0.5);

    
    float s_xydz = (\r
        s_xyz0_xyz1_dxyz0_dxyz1.y - \r
        s_xyz0_xyz1_dxyz0_dxyz1.x\r
    );

    
    vec3 gradient = vec3(s_dxyz_xdyz, s_xydz);

    
    gradient /= u_volume.anisotropy;

    return gradient;\r
}

vec3 compute_gradient_trilinear_sobel(in vec3 p, out mat3 hessian)\r
{\r
    
    vec3 p0 = p - 0.5;\r
    vec3 p1 = p + 0.5;

    
    vec4 s_x0y0z0_x0y1z0_x0y0z1_x0y1z1 = vec4(\r
        sample_value_trilinear(vec3(p0.x, p0.y, p0.z)), 
        sample_value_trilinear(vec3(p0.x, p1.y, p0.z)), 
        sample_value_trilinear(vec3(p0.x, p0.y, p1.z)), 
        sample_value_trilinear(vec3(p0.x, p1.y, p1.z))  
    );

    vec4 s_x1y0z0_x1y1z0_x1y0z1_x1y1z1 = vec4(\r
        sample_value_trilinear(vec3(p1.x, p0.y, p0.z)), 
        sample_value_trilinear(vec3(p1.x, p1.y, p0.z)), 
        sample_value_trilinear(vec3(p1.x, p0.y, p1.z)), 
        sample_value_trilinear(vec3(p1.x, p1.y, p1.z))  
    );

    
    vec4 s_xy0z0_xy1z0_xy0z1_xy1z1 = mix(\r
        s_x1y0z0_x1y1z0_x1y0z1_x1y1z1, \r
        s_x0y0z0_x0y1z0_x0y0z1_x0y1z1, \r
    0.5);

    
    vec4 s_dxy0z0_dxy1z0_dxy0z1_dxy1z1 = (\r
        s_x1y0z0_x1y1z0_x1y0z1_x1y1z1 - \r
        s_x0y0z0_x0y1z0_x0y0z1_x0y1z1\r
    );

    
    vec4 s_xyz0_xyz1_dxyz0_dxyz1 = mix(\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.yw, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.yw),\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.xz, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.xz),\r
    0.5);

    
    vec4 s_xdyz0_xdyz1_dxdyz0_dxdyz1 = (\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.yw, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.yw) -\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.xz, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.xz)\r
    );

    
    vec3 s_dxyz_xdyz_dxdyz = mix(\r
        vec3(s_xyz0_xyz1_dxyz0_dxyz1.w, s_xdyz0_xdyz1_dxdyz0_dxdyz1.yw),\r
        vec3(s_xyz0_xyz1_dxyz0_dxyz1.z, s_xdyz0_xdyz1_dxdyz0_dxdyz1.xz), \r
    0.5);

    
    vec3 s_xydz_dxydz_xdydz = (\r
        vec3(s_xyz0_xyz1_dxyz0_dxyz1.yw, s_xdyz0_xdyz1_dxdyz0_dxdyz1.y) -\r
        vec3(s_xyz0_xyz1_dxyz0_dxyz1.xz, s_xdyz0_xdyz1_dxdyz0_dxdyz1.x)\r
    );

    
    vec3 s_d2x_d2y_d2z = sample_second_derivatives(p);

    
    vec3 gradient = vec3(s_dxyz_xdyz_dxdyz.xy, s_xydz_dxydz_xdydz.x);

    
    hessian = mat3(\r
       s_d2x_d2y_d2z.x, s_dxyz_xdyz_dxdyz.z, s_xydz_dxydz_xdydz.y,  \r
       s_dxyz_xdyz_dxdyz.z, s_d2x_d2y_d2z.y, s_xydz_dxydz_xdydz.z,  \r
       s_xydz_dxydz_xdydz.y, s_xydz_dxydz_xdydz.z, s_d2x_d2y_d2z.z     \r
    );

    
    hessian /= outerProduct(u_volume.anisotropy, u_volume.anisotropy);\r
    gradient /= u_volume.anisotropy;

    return gradient;\r
}

#endif\r
#endif\r
#if GRADIENTS_METHOD == 3\r
#ifndef COMPUTE_GRADIENT_TRIQUADRATIC_BSPLINE\r
#define COMPUTE_GRADIENT_TRIQUADRATIC_BSPLINE

#ifndef SAMPLE_TRILINEAR_VOLUME\r
#ifndef SAMPLE_VALUE_TRILINEAR\r
#define SAMPLE_VALUE_TRILINEAR

float sample_value_trilinear(in vec3 coords)\r
{\r
    
    coords *= u_volume.inv_dimensions;

    
    #if INTERPOLATION_METHOD == 1\r
    float value = texture(u_textures.trilinear_volume, coords).r;\r
    #endif

    
    #if INTERPOLATION_METHOD == 2\r
    float value = texture(u_textures.tricubic_volume, coords).a;\r
    #endif

    return value;\r
}

#endif\r
#endif\r
#ifndef SAMPLE_TRICUBIC_VOLUME\r
#ifndef SAMPLE_VALUE_TRICUBIC\r
#define SAMPLE_VALUE_TRICUBIC

vec4 tricubic_bias(vec3 coords)\r
{\r
    vec3 r = fract(coords - 0.5);;\r
    vec3 bias = r * (r - 1.0) * 0.5;\r
    \r
    return vec4(bias, 1.0);\r
}

vec4 tricubic_features(in vec3 coords)\r
{\r
    
    vec3 texture_coords = coords * u_volume.inv_dimensions;

    
    return texture(u_textures.tricubic_volume, texture_coords);\r
}

float sample_value_tricubic(in vec3 coords)\r
{\r
    
    vec4 features = tricubic_features(coords);

    
    vec4 bias = tricubic_bias(coords);

    
    float value = dot(bias, features);

    return value;\r
}       

float sample_value_tricubic(in vec3 coords, out vec4 features)\r
{\r
    
    features = tricubic_features(coords);

    
    vec4 bias = tricubic_bias(coords);

    
    float value = dot(bias, features);

    return value;\r
}    

#endif\r
#endif\r
#ifndef SAMPLE_SECOND_DERIVATIVES\r
#ifndef SAMPLE_SECOND_DERIVATIVES\r
#define SAMPLE_SECOND_DERIVATIVES

#ifndef SAMPLE_TRILINEAR_VOLUME\r
#ifndef SAMPLE_VALUE_TRILINEAR\r
#define SAMPLE_VALUE_TRILINEAR

float sample_value_trilinear(in vec3 coords)\r
{\r
    
    coords *= u_volume.inv_dimensions;

    
    #if INTERPOLATION_METHOD == 1\r
    float value = texture(u_textures.trilinear_volume, coords).r;\r
    #endif

    
    #if INTERPOLATION_METHOD == 2\r
    float value = texture(u_textures.tricubic_volume, coords).a;\r
    #endif

    return value;\r
}

#endif\r
#endif

vec3 sample_second_derivatives(in vec3 p)\r
{\r
    #if INTERPOLATION_METHOD == 1

        
        vec3 s_x0yz_xy0z_xyz0 = vec3(\r
            sample_value_trilinear(vec3(p.x - 1.0, p.y, p.z)),\r
            sample_value_trilinear(vec3(p.x, p.y - 1.0, p.z)),\r
            sample_value_trilinear(vec3(p.x, p.y, p.z - 1.0))\r
        );

        vec3 s_x1yz_xy1z_xyz1 = vec3(\r
            sample_value_trilinear(vec3(p.x + 1.0, p.y, p.z)),\r
            sample_value_trilinear(vec3(p.x, p.y + 1.0, p.z)),\r
            sample_value_trilinear(vec3(p.x, p.y, p.z + 1.0))\r
        );

        
        return s_x0yz_xy0z_xyz0 + s_x1yz_xy1z_xyz1 - sample_value_trilinear(p) * 2.0;

    #endif

    #if INTERPOLATION_METHOD == 2

        return tricubic_features(p).xyz;

    #endif\r
}

#endif\r
#endif

/*\r
    The gradients produced are C^1 continuous\r
*/\r
vec3 compute_gradient_triquadratic_bspline(in vec3 p)\r
{\r
    
    vec3 x = p - 0.5;\r
    vec3 b = x - round(x);

    
    vec3 g0 = 0.5 - b;

    
    vec3 h0 = (0.5 + b) * 0.5;

    
    vec3 p0 = p - h0;\r
    vec3 p1 = p0 + 0.5;\r
 \r
    
    vec4 s_x0y0z0_x0y1z0_x0y0z1_x0y1z1 = vec4(\r
        sample_value_trilinear(vec3(p0.x, p0.y, p0.z)), \r
        sample_value_trilinear(vec3(p0.x, p1.y, p0.z)), \r
        sample_value_trilinear(vec3(p0.x, p0.y, p1.z)), \r
        sample_value_trilinear(vec3(p0.x, p1.y, p1.z))  \r
    );

    vec4 s_x1y0z0_x1y1z0_x1y0z1_x1y1z1 = vec4(\r
        sample_value_trilinear(vec3(p1.x, p0.y, p0.z)), \r
        sample_value_trilinear(vec3(p1.x, p1.y, p0.z)), \r
        sample_value_trilinear(vec3(p1.x, p0.y, p1.z)), \r
        sample_value_trilinear(vec3(p1.x, p1.y, p1.z))  \r
    );

    
    vec4 s_xy0z0_xy1z0_xy0z1_xy1z1 = mix(\r
        s_x1y0z0_x1y1z0_x1y0z1_x1y1z1, \r
        s_x0y0z0_x0y1z0_x0y0z1_x0y1z1, \r
    g0.x);

    
    vec4 s_dxy0z0_dxy1z0_dxy0z1_dxy1z1 = (\r
        s_x1y0z0_x1y1z0_x1y0z1_x1y1z1 - \r
        s_x0y0z0_x0y1z0_x0y0z1_x0y1z1\r
    ) * 2.0;

    
    vec4 s_xyz0_xyz1_dxyz0_dxyz1 = mix(\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.yw, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.yw),\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.xz, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.xz),\r
    g0.y);

    
    vec2 s_xdyz0_xdyz1 = (\r
        s_xy0z0_xy1z0_xy0z1_xy1z1.yw - \r
        s_xy0z0_xy1z0_xy0z1_xy1z1.xz\r
    ) * 2.0;

    
    vec2 s_dxyz_xdyz = mix(\r
        vec2(s_xyz0_xyz1_dxyz0_dxyz1.w, s_xdyz0_xdyz1.y),\r
        vec2(s_xyz0_xyz1_dxyz0_dxyz1.z, s_xdyz0_xdyz1.x), \r
    g0.z);

    
    float s_xydz = (\r
        s_xyz0_xyz1_dxyz0_dxyz1.y - \r
        s_xyz0_xyz1_dxyz0_dxyz1.x\r
    ) * 2.0;

    
    vec3 gradient = vec3(s_dxyz_xdyz, s_xydz);

    
    gradient /= u_volume.anisotropy;

    return gradient;\r
}\r
 \r
vec3 compute_gradient_triquadratic_bspline(in vec3 p, out mat3 hessian)\r
{\r
    
    vec3 x = p - 0.5;\r
    vec3 b = x - round(x);

    
    vec3 g0 = 0.5 - b;

    
    vec3 h0 = (0.5 + b) * 0.5;

    
    vec3 p0 = p - h0;\r
    vec3 p1 = p0 + 0.5;

    
    vec4 s_x0y0z0_x0y1z0_x0y0z1_x0y1z1 = vec4(\r
        sample_value_trilinear(vec3(p0.x, p0.y, p0.z)), \r
        sample_value_trilinear(vec3(p0.x, p1.y, p0.z)), \r
        sample_value_trilinear(vec3(p0.x, p0.y, p1.z)), \r
        sample_value_trilinear(vec3(p0.x, p1.y, p1.z))  \r
    );

    vec4 s_x1y0z0_x1y1z0_x1y0z1_x1y1z1 = vec4(\r
        sample_value_trilinear(vec3(p1.x, p0.y, p0.z)), \r
        sample_value_trilinear(vec3(p1.x, p1.y, p0.z)), \r
        sample_value_trilinear(vec3(p1.x, p0.y, p1.z)), \r
        sample_value_trilinear(vec3(p1.x, p1.y, p1.z))  \r
    );

    
    vec4 s_xy0z0_xy1z0_xy0z1_xy1z1 = mix(\r
        s_x1y0z0_x1y1z0_x1y0z1_x1y1z1, \r
        s_x0y0z0_x0y1z0_x0y0z1_x0y1z1, \r
    g0.x);

    
    vec4 s_dxy0z0_dxy1z0_dxy0z1_dxy1z1 = (\r
        s_x1y0z0_x1y1z0_x1y0z1_x1y1z1 - \r
        s_x0y0z0_x0y1z0_x0y0z1_x0y1z1\r
    ) * 2.0;

    
    vec4 s_xyz0_xyz1_dxyz0_dxyz1 = mix(\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.yw, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.yw),\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.xz, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.xz),\r
    g0.y);

    
    vec4 s_xdyz0_xdyz1_dxdyz0_dxdyz1 = (\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.yw, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.yw) -\r
        vec4(s_xy0z0_xy1z0_xy0z1_xy1z1.xz, s_dxy0z0_dxy1z0_dxy0z1_dxy1z1.xz)\r
    ) * 2.0;

    
    vec3 s_dxyz_xdyz_dxdyz = mix(\r
        vec3(s_xyz0_xyz1_dxyz0_dxyz1.w, s_xdyz0_xdyz1_dxdyz0_dxdyz1.yw),\r
        vec3(s_xyz0_xyz1_dxyz0_dxyz1.z, s_xdyz0_xdyz1_dxdyz0_dxdyz1.xz), \r
    g0.z);

    
    vec3 s_xydz_dxydz_xdydz = (\r
        vec3(s_xyz0_xyz1_dxyz0_dxyz1.yw, s_xdyz0_xdyz1_dxdyz0_dxdyz1.y) -\r
        vec3(s_xyz0_xyz1_dxyz0_dxyz1.xz, s_xdyz0_xdyz1_dxdyz0_dxdyz1.x)\r
    ) * 2.0;

    
    vec3 s_d2x_d2y_d2z = sample_second_derivatives(p);

    
    vec3 gradient = vec3(s_dxyz_xdyz_dxdyz.xy, s_xydz_dxydz_xdydz.x);

    
    hessian = mat3(\r
        s_d2x_d2y_d2z.x, s_dxyz_xdyz_dxdyz.z, s_xydz_dxydz_xdydz.y,  \r
        s_dxyz_xdyz_dxdyz.z, s_d2x_d2y_d2z.y, s_xydz_dxydz_xdydz.z,  \r
        s_xydz_dxydz_xdydz.y, s_xydz_dxydz_xdydz.z, s_d2x_d2y_d2z.z     \r
    );

    
    hessian /= outerProduct(u_volume.anisotropy, u_volume.anisotropy);\r
    gradient /= u_volume.anisotropy;

    
    return gradient;\r
}

#endif\r
#endif

vec3 compute_gradient(in vec3 coords)\r
{\r
    #if GRADIENTS_METHOD == 1

        #if INTERPOLATION_METHOD == 1

            return compute_gradient_trilinear_analytic(coords);

        #elif INTERPOLATION_METHOD == 2

            return compute_gradient_tricubic_analytic(coords);

        #endif

    #elif GRADIENTS_METHOD == 2\r
    \r
        return compute_gradient_trilinear_sobel(coords);

    #elif GRADIENTS_METHOD == 3

        return compute_gradient_triquadratic_bspline(coords);

    #else

        return vec3(0.0); 

    #endif\r
}

vec3 compute_gradient(in vec3 coords, out mat3 hessian)\r
{\r
    #if GRADIENTS_METHOD == 1

        #if INTERPOLATION_METHOD == 1

            return compute_gradient_trilinear_analytic(coords, hessian);\r
            \r
        #elif INTERPOLATION_METHOD == 2

            return compute_gradient_tricubic_analytic(coords, hessian);

        #endif

    #elif GRADIENTS_METHOD == 2

        return compute_gradient_trilinear_sobel(coords, hessian);

    #elif GRADIENTS_METHOD == 3

        return compute_gradient_triquadratic_bspline(coords, hessian);

    #else\r
    \r
        hessian = vec2(0.0);\r
        return vec3(0.0); 

    #endif\r
}

#endif

void main() \r
{\r
    set_camera();\r
set_box();\r
set_ray();\r
set_trace();\r
set_hit();\r
set_cell();\r
set_block();\r
set_frag();\r
set_cubic();\r
set_quintic();

#if DEBUG_ENABLED == 1\r
set_debug();\r
#endif

#if STATS_ENABLED == 1\r
set_stats();\r
#endif\r
    ray.direction = normalize(v_ray_direction);\r
ray.inv_direction = 1.0 / ray.direction;

ray.signs = ivec3(ssign(ray.direction));

ivec3 bits = (ray.signs + 1) / 2; \r
ray.octant = (bits.z << 2) | (bits.y << 1) | (bits.x << 0);

ray.spacing = 1.0 / sum(abs(ray.direction));\r
ray.spacing /= 5.0;

box.min_position = vec3(0.0);\r
box.max_position = vec3(u_volume.dimensions);

vec2 bounds = box_bounds(box.min_position, box.max_position, camera.position);\r
box.min_entry_distance = bounds.x;\r
box.max_exit_distance = bounds.y;\r
box.max_span_distance = bounds.y - bounds.x;

vec2 entry_exit = intersect_box(box.min_position, box.max_position, camera.position, ray.inv_direction);

entry_exit = max(entry_exit, 0.0); 

if (entry_exit.x < entry_exit.y)\r
{\r
    
    box.entry_distance = entry_exit.x;\r
    box.entry_position = entry_exit.x * ray.direction + camera.position;\r
    box.exit_distance  = entry_exit.y;\r
    box.exit_position  = entry_exit.y * ray.direction + camera.position;\r
    box.span_distance  = entry_exit.y - entry_exit.x;\r
    \r
    
    ray.start_distance = box.entry_distance;\r
    ray.start_position = box.entry_position;\r
    ray.end_distance   = box.exit_distance;\r
    ray.end_position   = box.exit_position;\r
    ray.span_distance  = box.span_distance;\r
}\r
    #if MARCHING_METHOD == 1

    #if SKIPPING_ENABLED == 1

        block.exit_distance = ray.start_distance;\r
block.exit_position = camera.position + ray.direction * block.exit_distance; 

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position; 

block.coords = ivec3(round(block.exit_position)) / u_volume.stride;

for (int k = 0; k < MAX_GROUPS; k++) \r
{\r
    for (int j = 0; j < MAX_BLOCKS_PER_GROUP; j++) \r
    {\r
        #if SKIPPING_METHOD == 1

    block.occupied = sample_occupancy(block.coords);

block.min_coords = block.coords;\r
block.max_coords = block.coords + 1;

block.min_position = vec3(block.min_coords * u_volume.stride) - 0.5;\r
block.max_position = vec3(block.max_coords * u_volume.stride) - 0.5;  

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position;

block.exit_distance = intersect_box_exit(block.min_position, block.max_position, camera.position, ray.inv_direction, block.exit_normal);\r
block.exit_position = camera.position + ray.direction * block.exit_distance;

block.span_distance = block.exit_distance - block.entry_distance;

block.coords += block.exit_normal * ray.signs;

block.terminated = block.exit_distance > ray.end_distance;

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
stats.num_blocks += 1;\r
#endif

#endif\r
#if SKIPPING_METHOD == 2

    block.skip_distance = sample_distance_isotropic(block.coords, block.occupied);\r
block.skip_distance = max(block.skip_distance, 1);

block.min_coords = (block.coords - block.skip_distance) + 1;\r
block.max_coords = (block.coords + block.skip_distance);

block.min_position = vec3(block.min_coords * u_volume.stride) - 0.5;\r
block.max_position = vec3(block.max_coords * u_volume.stride) - 0.5;  

block.min_position -= 0.001;\r
block.max_position += 0.001; 

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position;

block.exit_distance = intersect_box_exit(block.min_position, block.max_position, camera.position, ray.inv_direction, block.exit_normal);\r
block.exit_position = camera.position + ray.direction * block.exit_distance;

block.span_distance = block.exit_distance - block.entry_distance;

ivec3 coords = block.coords + block.skip_distance * ray.signs;\r
block.coords = ivec3(round(block.exit_position)) / u_volume.stride;\r
block.coords += block.exit_normal * (coords - block.coords);

block.terminated = block.exit_distance > ray.end_distance;

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
stats.num_blocks += 1;\r
#endif\r
    \r
#endif\r
#if SKIPPING_METHOD == 3

    block.skip_distance = sample_distance_anisotropic(block.coords, ray.octant, block.occupied);\r
block.skip_distance = max(block.skip_distance, 1);

block.min_coords = (block.coords - block.skip_distance) + 1;\r
block.max_coords = (block.coords + block.skip_distance);

block.min_position = vec3(block.min_coords * u_volume.stride) - 0.5;\r
block.max_position = vec3(block.max_coords * u_volume.stride) - 0.5;  

block.min_position -= 0.001;\r
block.max_position += 0.001; 

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position;

block.exit_distance = intersect_box_exit(block.min_position, block.max_position, camera.position, ray.inv_direction, block.exit_normal);\r
block.exit_position = camera.position + ray.direction * block.exit_distance;

block.span_distance = block.exit_distance - block.entry_distance;

ivec3 coords = block.coords + block.skip_distance * ray.signs;\r
block.coords = ivec3(round(block.exit_position)) / u_volume.stride;\r
block.coords += block.exit_normal * (coords - block.coords);

block.terminated = block.exit_distance > ray.end_distance;

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
stats.num_blocks += 1;\r
#endif

#endif\r
#if SKIPPING_METHOD == 4

    block.skip_distance = sample_distance_extended(block.coords, ray.octant, block.occupied);\r
block.skip_distance = max(block.skip_distance, 1);

block.min_coords = (block.coords - block.skip_distance) + 1;\r
block.max_coords = (block.coords + block.skip_distance);

block.min_position = vec3(block.min_coords * u_volume.stride) - 0.5;\r
block.max_position = vec3(block.max_coords * u_volume.stride) - 0.5;  

block.min_position -= 0.001;\r
block.max_position += 0.001; 

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position;

block.exit_distance = intersect_box_exit(block.min_position, block.max_position, camera.position, ray.inv_direction, block.exit_normal);\r
block.exit_position = camera.position + ray.direction * block.exit_distance;

block.span_distance = block.exit_distance - block.entry_distance;

ivec3 coords = block.coords + block.skip_distance * ray.signs;\r
block.coords = ivec3(round(block.exit_position)) / u_volume.stride;\r
block.coords += block.exit_normal * (coords - block.coords);

block.terminated = block.exit_distance > ray.end_distance;

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
stats.num_blocks += 1;\r
#endif

#endif

        if (block.occupied || block.terminated) \r
        {\r
            break;\r
        }  \r
    }

    if (!(block.occupied || block.terminated)) \r
    {\r
        continue;\r
    }

    #if SKIPPING_ENABLED == 1

    cell.exit_distance = block.entry_distance;\r
    cell.exit_position = block.entry_position;\r
    cell.coords = ivec3(round(cell.exit_position));

#else

    cell.exit_distance = ray.start_distance;\r
    cell.exit_position = ray.start_position;\r
    cell.coords = ivec3(round(cell.exit_position)); 

#endif

#if INTERPOLATION_METHOD == 1

    cubic.residuals[3] = sample_residue_trilinear(cell.exit_position);

#endif\r
#if INTERPOLATION_METHOD == 2

    quintic.residuals[3] = sample_residue_tricubic(cell.exit_position, quintic.features[3]);

#endif

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
#endif

    for (int i = 0; i < MAX_CELLS_PER_BLOCK; i++) \r
    {\r
        cell.min_position = vec3(cell.coords) - 0.5;\r
cell.max_position = vec3(cell.coords) + 0.5;

cell.entry_distance = cell.exit_distance;\r
cell.entry_position = cell.exit_position;

cell.exit_distance = intersect_box_exit(cell.min_position, cell.max_position, camera.position, ray.inv_direction, cell.exit_normal);\r
cell.exit_position = camera.position + ray.direction * cell.exit_distance; 

cell.span_distance = cell.exit_distance - cell.entry_distance;

cell.coords += cell.exit_normal * ray.signs;

cell.terminated = cell.exit_distance > ray.end_distance; 

#if STATS_ENABLED == 1\r
stats.num_cells += 1;\r
#endif\r
        \r
        #if INTERPOLATION_METHOD == 1

    #if BERNSTEIN_ENABLED == 1

        cubic.residuals[0] = cubic.residuals[3];

#pragma unroll\r
for (int i = 1; i < 4; i++) \r
{\r
    vec3 position = mix(cell.entry_position, cell.exit_position, sampling_points[i]);

    cubic.residuals[i] = sample_residue_trilinear(position);\r
}

cubic.bernstein_coeffs = cubic.residuals * cubic_bernstein;

if (sign_change(cubic.bernstein_coeffs))\r
{\r
    
    cubic.coeffs = cubic.residuals * cubic_inv_vander;

    
    cell.intersected = sign_change(cubic.residuals) || is_cubic_solvable(cubic.coeffs, sampling_points.xw, cubic.residuals.xw);

    #if STATS_ENABLED == 1\r
    stats.num_tests += 1;\r
    #endif\r
}

#if STATS_ENABLED == 1\r
stats.num_fetches += 3;\r
#endif

    #else

        cubic.residuals[0] = cubic.residuals[3];

#pragma unroll\r
for (int i = 1; i < 4; i++) \r
{\r
    vec3 position = mix(cell.entry_position, cell.exit_position, sampling_points[i]);

    cubic.residuals[i] = sample_residue_trilinear(position);\r
}

cubic.coeffs = cubic.residuals * cubic_inv_vander;

cell.intersected = sign_change(cubic.residuals) || is_cubic_solvable(cubic.coeffs, sampling_points.xw, cubic.residuals.xw);

#if STATS_ENABLED == 1\r
stats.num_fetches += 3;\r
stats.num_tests += 1;\r
#endif

    #endif

#endif\r
#if INTERPOLATION_METHOD == 2

    #if BERNSTEIN_ENABLED == 1

        quintic.features[0] = quintic.features[3];

#pragma unroll\r
for (int i = 1; i < 4; i++) \r
{\r
    
    vec3 position = mix(cell.entry_position, cell.exit_position, sampling_points[i]);

    
    quintic.features[i] = tricubic_features(position);

    
    quintic.biases[i - 1] = tricubic_bias(position);\r
}

mat4x3 residuals = transpose(quintic.biases) * quintic.features - u_rendering.isovalue;

quintic.residuals = vec4(quintic.residuals[3], residuals[1][0], residuals[2][1], residuals[3][2]);

mat4x3 bernstein_coeffs = matrixCompMult(quad_bernstein * residuals * cubic_bernstein, quintic_bernstein_weights);

sum_anti_diags(bernstein_coeffs, quintic.bernstein_coeffs);

if (sign_change(quintic.bernstein_coeffs))\r
{\r
    
    mat4x3 coeffs = quad_inv_vander * residuals * cubic_inv_vander;\r
    sum_anti_diags(coeffs, quintic.coeffs);

    
    cell.intersected = sign_change(quintic.residuals) || eval_poly_sign_change(quintic.coeffs);

    #if STATS_ENABLED == 1\r
    stats.num_tests += 1;\r
    #endif\r
}

#if STATS_ENABLED == 1\r
stats.num_fetches += 3;\r
#endif\r
            \r
    #else

        quintic.features[0] = quintic.features[3];

#pragma unroll\r
for (int i = 1; i < 4; i++) \r
{\r
    
    vec3 position = mix(cell.entry_position, cell.exit_position, sampling_points[i]);

    
    quintic.features[i] = tricubic_features(position);

    
    quintic.biases[i - 1] = tricubic_bias(position);\r
}

mat4x3 residuals = transpose(quintic.biases) * quintic.features - u_rendering.isovalue;

quintic.residuals = vec4(quintic.residuals[3], residuals[1][0], residuals[2][1], residuals[3][2]);

mat4x3 coeffs = quad_inv_vander * residuals * cubic_inv_vander;

sum_anti_diags(coeffs, quintic.coeffs);

cell.intersected = sign_change(quintic.residuals) || eval_poly_sign_change(quintic.coeffs);

#if STATS_ENABLED == 1\r
stats.num_fetches += 3;\r
stats.num_tests += 1;\r
#endif

    #endif

#endif

        if (cell.intersected || cell.terminated || cell.exit_distance > block.exit_distance) \r
        {\r
            break;\r
        }\r
    }   

    if (cell.intersected || cell.terminated) \r
    {\r
        break;\r
    }\r
}

hit.undefined = !(cell.intersected || cell.terminated);\r
hit.discarded = !cell.intersected;\r
hit.escaped = false;

if (cell.intersected) \r
{\r
    
    #if INTERPOLATION_METHOD == 1

    poly3_roots(cubic.roots, cubic.coeffs, 0.0, 1.0);\r
cubic.root = mmin(cubic.roots);

eval_poly(cubic.coeffs, cubic.root, hit.derivative);\r
hit.derivative /= cell.span_distance;

hit.orientation = -ssign(hit.derivative); 

hit.distance = mix(cell.entry_distance, cell.exit_distance, cubic.root);\r
hit.position = camera.position + ray.direction * hit.distance;

hit.value = sample_value_trilinear(hit.position);\r
hit.residue = hit.value - u_rendering.isovalue;

hit.gradient = compute_gradient(hit.position, hit.hessian);\r
hit.gradient *= hit.orientation; \r
hit.hessian *= hit.orientation;

hit.normal = normalize(hit.gradient);

hit.curvatures = principal_curvatures(hit.gradient, hit.hessian);

#endif\r
#if INTERPOLATION_METHOD == 2

    poly5_roots(quintic.roots, quintic.coeffs, 0.0, 1.0);\r
quintic.root = mmin(quintic.roots);

eval_poly(quintic.coeffs, quintic.root, hit.derivative);\r
hit.derivative /= cell.span_distance;

hit.orientation = -ssign(hit.derivative); 

hit.distance = mix(cell.entry_distance, cell.exit_distance, quintic.root);\r
hit.position = camera.position + ray.direction * hit.distance;

hit.value = sample_value_tricubic(hit.position);\r
hit.residue = hit.value - u_rendering.isovalue;

hit.gradient = compute_gradient(hit.position, hit.hessian);\r
hit.gradient *= hit.orientation; \r
hit.hessian *= hit.orientation;

hit.normal = normalize(hit.gradient);

hit.curvatures = principal_curvatures(hit.gradient, hit.hessian);

#endif

    
    hit.escaped = (hit.distance < ray.start_distance || hit.distance > ray.end_distance);

    
    hit.discarded = hit.escaped;\r
}

    #else

        #if SKIPPING_ENABLED == 1

    cell.exit_distance = block.entry_distance;\r
    cell.exit_position = block.entry_position;\r
    cell.coords = ivec3(round(cell.exit_position));

#else

    cell.exit_distance = ray.start_distance;\r
    cell.exit_position = ray.start_position;\r
    cell.coords = ivec3(round(cell.exit_position)); 

#endif

#if INTERPOLATION_METHOD == 1

    cubic.residuals[3] = sample_residue_trilinear(cell.exit_position);

#endif\r
#if INTERPOLATION_METHOD == 2

    quintic.residuals[3] = sample_residue_tricubic(cell.exit_position, quintic.features[3]);

#endif

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
#endif

for (int i = 0; i < MAX_CELLS; i++) \r
{\r
    cell.min_position = vec3(cell.coords) - 0.5;\r
cell.max_position = vec3(cell.coords) + 0.5;

cell.entry_distance = cell.exit_distance;\r
cell.entry_position = cell.exit_position;

cell.exit_distance = intersect_box_exit(cell.min_position, cell.max_position, camera.position, ray.inv_direction, cell.exit_normal);\r
cell.exit_position = camera.position + ray.direction * cell.exit_distance; 

cell.span_distance = cell.exit_distance - cell.entry_distance;

cell.coords += cell.exit_normal * ray.signs;

cell.terminated = cell.exit_distance > ray.end_distance; 

#if STATS_ENABLED == 1\r
stats.num_cells += 1;\r
#endif

    #if INTERPOLATION_METHOD == 1

    #if BERNSTEIN_ENABLED == 1

        cubic.residuals[0] = cubic.residuals[3];

#pragma unroll\r
for (int i = 1; i < 4; i++) \r
{\r
    vec3 position = mix(cell.entry_position, cell.exit_position, sampling_points[i]);

    cubic.residuals[i] = sample_residue_trilinear(position);\r
}

cubic.bernstein_coeffs = cubic.residuals * cubic_bernstein;

if (sign_change(cubic.bernstein_coeffs))\r
{\r
    
    cubic.coeffs = cubic.residuals * cubic_inv_vander;

    
    cell.intersected = sign_change(cubic.residuals) || is_cubic_solvable(cubic.coeffs, sampling_points.xw, cubic.residuals.xw);

    #if STATS_ENABLED == 1\r
    stats.num_tests += 1;\r
    #endif\r
}

#if STATS_ENABLED == 1\r
stats.num_fetches += 3;\r
#endif

    #else

        cubic.residuals[0] = cubic.residuals[3];

#pragma unroll\r
for (int i = 1; i < 4; i++) \r
{\r
    vec3 position = mix(cell.entry_position, cell.exit_position, sampling_points[i]);

    cubic.residuals[i] = sample_residue_trilinear(position);\r
}

cubic.coeffs = cubic.residuals * cubic_inv_vander;

cell.intersected = sign_change(cubic.residuals) || is_cubic_solvable(cubic.coeffs, sampling_points.xw, cubic.residuals.xw);

#if STATS_ENABLED == 1\r
stats.num_fetches += 3;\r
stats.num_tests += 1;\r
#endif

    #endif

#endif\r
#if INTERPOLATION_METHOD == 2

    #if BERNSTEIN_ENABLED == 1

        quintic.features[0] = quintic.features[3];

#pragma unroll\r
for (int i = 1; i < 4; i++) \r
{\r
    
    vec3 position = mix(cell.entry_position, cell.exit_position, sampling_points[i]);

    
    quintic.features[i] = tricubic_features(position);

    
    quintic.biases[i - 1] = tricubic_bias(position);\r
}

mat4x3 residuals = transpose(quintic.biases) * quintic.features - u_rendering.isovalue;

quintic.residuals = vec4(quintic.residuals[3], residuals[1][0], residuals[2][1], residuals[3][2]);

mat4x3 bernstein_coeffs = matrixCompMult(quad_bernstein * residuals * cubic_bernstein, quintic_bernstein_weights);

sum_anti_diags(bernstein_coeffs, quintic.bernstein_coeffs);

if (sign_change(quintic.bernstein_coeffs))\r
{\r
    
    mat4x3 coeffs = quad_inv_vander * residuals * cubic_inv_vander;\r
    sum_anti_diags(coeffs, quintic.coeffs);

    
    cell.intersected = sign_change(quintic.residuals) || eval_poly_sign_change(quintic.coeffs);

    #if STATS_ENABLED == 1\r
    stats.num_tests += 1;\r
    #endif\r
}

#if STATS_ENABLED == 1\r
stats.num_fetches += 3;\r
#endif\r
            \r
    #else

        quintic.features[0] = quintic.features[3];

#pragma unroll\r
for (int i = 1; i < 4; i++) \r
{\r
    
    vec3 position = mix(cell.entry_position, cell.exit_position, sampling_points[i]);

    
    quintic.features[i] = tricubic_features(position);

    
    quintic.biases[i - 1] = tricubic_bias(position);\r
}

mat4x3 residuals = transpose(quintic.biases) * quintic.features - u_rendering.isovalue;

quintic.residuals = vec4(quintic.residuals[3], residuals[1][0], residuals[2][1], residuals[3][2]);

mat4x3 coeffs = quad_inv_vander * residuals * cubic_inv_vander;

sum_anti_diags(coeffs, quintic.coeffs);

cell.intersected = sign_change(quintic.residuals) || eval_poly_sign_change(quintic.coeffs);

#if STATS_ENABLED == 1\r
stats.num_fetches += 3;\r
stats.num_tests += 1;\r
#endif

    #endif

#endif

    if (cell.intersected || cell.terminated) \r
    {\r
        break;\r
    }\r
}

hit.undefined = !(cell.intersected || cell.terminated);\r
hit.discarded = !cell.intersected;\r
hit.escaped = false;

if (cell.intersected) \r
{\r
    
    #if INTERPOLATION_METHOD == 1

    poly3_roots(cubic.roots, cubic.coeffs, 0.0, 1.0);\r
cubic.root = mmin(cubic.roots);

eval_poly(cubic.coeffs, cubic.root, hit.derivative);\r
hit.derivative /= cell.span_distance;

hit.orientation = -ssign(hit.derivative); 

hit.distance = mix(cell.entry_distance, cell.exit_distance, cubic.root);\r
hit.position = camera.position + ray.direction * hit.distance;

hit.value = sample_value_trilinear(hit.position);\r
hit.residue = hit.value - u_rendering.isovalue;

hit.gradient = compute_gradient(hit.position, hit.hessian);\r
hit.gradient *= hit.orientation; \r
hit.hessian *= hit.orientation;

hit.normal = normalize(hit.gradient);

hit.curvatures = principal_curvatures(hit.gradient, hit.hessian);

#endif\r
#if INTERPOLATION_METHOD == 2

    poly5_roots(quintic.roots, quintic.coeffs, 0.0, 1.0);\r
quintic.root = mmin(quintic.roots);

eval_poly(quintic.coeffs, quintic.root, hit.derivative);\r
hit.derivative /= cell.span_distance;

hit.orientation = -ssign(hit.derivative); 

hit.distance = mix(cell.entry_distance, cell.exit_distance, quintic.root);\r
hit.position = camera.position + ray.direction * hit.distance;

hit.value = sample_value_tricubic(hit.position);\r
hit.residue = hit.value - u_rendering.isovalue;

hit.gradient = compute_gradient(hit.position, hit.hessian);\r
hit.gradient *= hit.orientation; \r
hit.hessian *= hit.orientation;

hit.normal = normalize(hit.gradient);

hit.curvatures = principal_curvatures(hit.gradient, hit.hessian);

#endif

    
    hit.escaped = (hit.distance < ray.start_distance || hit.distance > ray.end_distance);

    
    hit.discarded = hit.escaped;\r
}\r
        \r
    #endif

#endif

#if MARCHING_METHOD == 2

    #if SKIPPING_ENABLED == 1

        block.exit_distance = ray.start_distance;\r
block.exit_position = camera.position + ray.direction * block.exit_distance; 

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position; 

block.coords = ivec3(round(block.exit_position)) / u_volume.stride;

for (int k = 0; k < MAX_GROUPS; k++) \r
{\r
    for (int j = 0; j < MAX_BLOCKS_PER_GROUP; j++) \r
    {\r
        #if SKIPPING_METHOD == 1

    block.occupied = sample_occupancy(block.coords);

block.min_coords = block.coords;\r
block.max_coords = block.coords + 1;

block.min_position = vec3(block.min_coords * u_volume.stride) - 0.5;\r
block.max_position = vec3(block.max_coords * u_volume.stride) - 0.5;  

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position;

block.exit_distance = intersect_box_exit(block.min_position, block.max_position, camera.position, ray.inv_direction, block.exit_normal);\r
block.exit_position = camera.position + ray.direction * block.exit_distance;

block.span_distance = block.exit_distance - block.entry_distance;

block.coords += block.exit_normal * ray.signs;

block.terminated = block.exit_distance > ray.end_distance;

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
stats.num_blocks += 1;\r
#endif

#endif\r
#if SKIPPING_METHOD == 2

    block.skip_distance = sample_distance_isotropic(block.coords, block.occupied);\r
block.skip_distance = max(block.skip_distance, 1);

block.min_coords = (block.coords - block.skip_distance) + 1;\r
block.max_coords = (block.coords + block.skip_distance);

block.min_position = vec3(block.min_coords * u_volume.stride) - 0.5;\r
block.max_position = vec3(block.max_coords * u_volume.stride) - 0.5;  

block.min_position -= 0.001;\r
block.max_position += 0.001; 

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position;

block.exit_distance = intersect_box_exit(block.min_position, block.max_position, camera.position, ray.inv_direction, block.exit_normal);\r
block.exit_position = camera.position + ray.direction * block.exit_distance;

block.span_distance = block.exit_distance - block.entry_distance;

ivec3 coords = block.coords + block.skip_distance * ray.signs;\r
block.coords = ivec3(round(block.exit_position)) / u_volume.stride;\r
block.coords += block.exit_normal * (coords - block.coords);

block.terminated = block.exit_distance > ray.end_distance;

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
stats.num_blocks += 1;\r
#endif\r
    \r
#endif\r
#if SKIPPING_METHOD == 3

    block.skip_distance = sample_distance_anisotropic(block.coords, ray.octant, block.occupied);\r
block.skip_distance = max(block.skip_distance, 1);

block.min_coords = (block.coords - block.skip_distance) + 1;\r
block.max_coords = (block.coords + block.skip_distance);

block.min_position = vec3(block.min_coords * u_volume.stride) - 0.5;\r
block.max_position = vec3(block.max_coords * u_volume.stride) - 0.5;  

block.min_position -= 0.001;\r
block.max_position += 0.001; 

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position;

block.exit_distance = intersect_box_exit(block.min_position, block.max_position, camera.position, ray.inv_direction, block.exit_normal);\r
block.exit_position = camera.position + ray.direction * block.exit_distance;

block.span_distance = block.exit_distance - block.entry_distance;

ivec3 coords = block.coords + block.skip_distance * ray.signs;\r
block.coords = ivec3(round(block.exit_position)) / u_volume.stride;\r
block.coords += block.exit_normal * (coords - block.coords);

block.terminated = block.exit_distance > ray.end_distance;

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
stats.num_blocks += 1;\r
#endif

#endif\r
#if SKIPPING_METHOD == 4

    block.skip_distance = sample_distance_extended(block.coords, ray.octant, block.occupied);\r
block.skip_distance = max(block.skip_distance, 1);

block.min_coords = (block.coords - block.skip_distance) + 1;\r
block.max_coords = (block.coords + block.skip_distance);

block.min_position = vec3(block.min_coords * u_volume.stride) - 0.5;\r
block.max_position = vec3(block.max_coords * u_volume.stride) - 0.5;  

block.min_position -= 0.001;\r
block.max_position += 0.001; 

block.entry_distance = block.exit_distance;\r
block.entry_position = block.exit_position;

block.exit_distance = intersect_box_exit(block.min_position, block.max_position, camera.position, ray.inv_direction, block.exit_normal);\r
block.exit_position = camera.position + ray.direction * block.exit_distance;

block.span_distance = block.exit_distance - block.entry_distance;

ivec3 coords = block.coords + block.skip_distance * ray.signs;\r
block.coords = ivec3(round(block.exit_position)) / u_volume.stride;\r
block.coords += block.exit_normal * (coords - block.coords);

block.terminated = block.exit_distance > ray.end_distance;

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
stats.num_blocks += 1;\r
#endif

#endif

        if (block.occupied || block.terminated) \r
        {\r
            break;\r
        }  \r
    }\r
    \r
    if (!(block.occupied || block.terminated)) \r
    {\r
        continue;\r
    }

    #if SKIPPING_ENABLED == 1

    trace.distance = block.entry_distance - ray.spacing * random(block.entry_position);\r
    trace.position = camera.position + ray.direction * trace.distance;

#else

    trace.distance = ray.start_distance - ray.spacing * random(ray.start_position);\r
    trace.position = camera.position + ray.direction * trace.distance; 

#endif

#if INTERPOLATION_METHOD == 1

    trace.residue = sample_residue_trilinear(trace.position);

#endif\r
#if INTERPOLATION_METHOD == 2

    trace.residue = sample_residue_tricubic(trace.position);

#endif

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
#endif

    for (int i = 0; i < MAX_TRACES_PER_BLOCK; i++) \r
    {\r
        trace.prev_distance = trace.distance;

trace.distance += ray.spacing;

trace.position = camera.position + ray.direction * trace.distance; 

trace.terminated = trace.distance > ray.end_distance; 

#if STATS_ENABLED == 1\r
stats.num_traces += 1;\r
#endif\r
        \r
        #if INTERPOLATION_METHOD == 1

    trace.prev_residue = trace.residue;

trace.residue = sample_residue_trilinear(trace.position);

trace.intersected = sign_change(trace.residue, trace.prev_residue);

#endif\r
#if INTERPOLATION_METHOD == 2

    trace.prev_residue = trace.residue;

trace.residue = sample_residue_tricubic(trace.position);

trace.intersected = sign_change(trace.residue, trace.prev_residue);

#endif

        if (trace.intersected || trace.terminated || trace.distance > block.exit_distance) \r
        {\r
            break;\r
        }\r
    }   

    if (trace.intersected || trace.terminated) \r
    {\r
        break;\r
    }\r
}

hit.undefined = !(trace.intersected || trace.terminated);\r
hit.discarded = !trace.intersected;\r
hit.escaped = false;

if (trace.intersected) \r
{\r
    
    #if INTERPOLATION_METHOD == 1

    vec2 distances = vec2(trace.prev_distance, trace.distance);\r
vec2 residues = vec2(trace.prev_residue, trace.residue);

#pragma unroll\r
for (int i = 0; i < 10; ++i)\r
{\r
    
    hit.derivative = diff(residues) / diff(distances);\r
    hit.distance = distances.x - residues.x / hit.derivative;\r
    hit.position = camera.position + ray.direction * hit.distance; 

    
    hit.residue = sample_value_trilinear(hit.position) - u_rendering.isovalue;\r
    \r
    
    if (sign_change(residues.x, hit.residue))\r
    {\r
        distances.y = hit.distance;\r
        residues.y = hit.residue;\r
    }\r
    else\r
    {\r
        distances.x = hit.distance;\r
        residues.x = hit.residue;\r
    }\r
}

hit.value = hit.residue + u_rendering.isovalue;

hit.orientation = -ssign(hit.derivative);

hit.gradient = compute_gradient(hit.position, hit.hessian);\r
hit.gradient *= hit.orientation; \r
hit.hessian *= hit.orientation;

hit.normal = normalize(hit.gradient);

hit.curvatures = principal_curvatures(hit.gradient, hit.hessian);

#endif\r
#if INTERPOLATION_METHOD == 2

    vec2 distances = vec2(trace.prev_distance, trace.distance);\r
vec2 residues = vec2(trace.prev_residue, trace.residue);

#pragma unroll\r
for (int i = 0; i < 10; ++i)\r
{\r
    
    hit.derivative = diff(residues) / diff(distances);\r
    hit.distance = distances.x - residues.x / hit.derivative;\r
    hit.position = camera.position + ray.direction * hit.distance; 

    
    hit.residue = sample_value_tricubic(hit.position) - u_rendering.isovalue;\r
    \r
    
    if (sign_change(residues.x, hit.residue))\r
    {\r
        distances.y = hit.distance;\r
        residues.y = hit.residue;\r
    }\r
    else\r
    {\r
        distances.x = hit.distance;\r
        residues.x = hit.residue;\r
    }\r
}

hit.value = hit.residue + u_rendering.isovalue;

hit.orientation = -ssign(hit.derivative);

hit.gradient = compute_gradient(hit.position, hit.hessian);\r
hit.gradient *= hit.orientation; \r
hit.hessian *= hit.orientation;

hit.normal = normalize(hit.gradient);

hit.curvatures = principal_curvatures(hit.gradient, hit.hessian);

#endif

    
    hit.escaped = (hit.distance < ray.start_distance || hit.distance > ray.end_distance);

    
    hit.discarded = hit.escaped;\r
}

    #else

        #if SKIPPING_ENABLED == 1

    trace.distance = block.entry_distance - ray.spacing * random(block.entry_position);\r
    trace.position = camera.position + ray.direction * trace.distance;

#else

    trace.distance = ray.start_distance - ray.spacing * random(ray.start_position);\r
    trace.position = camera.position + ray.direction * trace.distance; 

#endif

#if INTERPOLATION_METHOD == 1

    trace.residue = sample_residue_trilinear(trace.position);

#endif\r
#if INTERPOLATION_METHOD == 2

    trace.residue = sample_residue_tricubic(trace.position);

#endif

#if STATS_ENABLED == 1\r
stats.num_fetches += 1;\r
#endif

for (int i = 0; i < MAX_TRACES; i++) \r
{\r
    trace.prev_distance = trace.distance;

trace.distance += ray.spacing;

trace.position = camera.position + ray.direction * trace.distance; 

trace.terminated = trace.distance > ray.end_distance; 

#if STATS_ENABLED == 1\r
stats.num_traces += 1;\r
#endif

    #if INTERPOLATION_METHOD == 1

    trace.prev_residue = trace.residue;

trace.residue = sample_residue_trilinear(trace.position);

trace.intersected = sign_change(trace.residue, trace.prev_residue);

#endif\r
#if INTERPOLATION_METHOD == 2

    trace.prev_residue = trace.residue;

trace.residue = sample_residue_tricubic(trace.position);

trace.intersected = sign_change(trace.residue, trace.prev_residue);

#endif

    if (trace.intersected || trace.terminated) \r
    {\r
        break;\r
    }\r
}

hit.undefined = !(trace.intersected || trace.terminated);\r
hit.discarded = !trace.intersected;\r
hit.escaped = false;

if (trace.intersected) \r
{\r
    
    #if INTERPOLATION_METHOD == 1

    vec2 distances = vec2(trace.prev_distance, trace.distance);\r
vec2 residues = vec2(trace.prev_residue, trace.residue);

#pragma unroll\r
for (int i = 0; i < 10; ++i)\r
{\r
    
    hit.derivative = diff(residues) / diff(distances);\r
    hit.distance = distances.x - residues.x / hit.derivative;\r
    hit.position = camera.position + ray.direction * hit.distance; 

    
    hit.residue = sample_value_trilinear(hit.position) - u_rendering.isovalue;\r
    \r
    
    if (sign_change(residues.x, hit.residue))\r
    {\r
        distances.y = hit.distance;\r
        residues.y = hit.residue;\r
    }\r
    else\r
    {\r
        distances.x = hit.distance;\r
        residues.x = hit.residue;\r
    }\r
}

hit.value = hit.residue + u_rendering.isovalue;

hit.orientation = -ssign(hit.derivative);

hit.gradient = compute_gradient(hit.position, hit.hessian);\r
hit.gradient *= hit.orientation; \r
hit.hessian *= hit.orientation;

hit.normal = normalize(hit.gradient);

hit.curvatures = principal_curvatures(hit.gradient, hit.hessian);

#endif\r
#if INTERPOLATION_METHOD == 2

    vec2 distances = vec2(trace.prev_distance, trace.distance);\r
vec2 residues = vec2(trace.prev_residue, trace.residue);

#pragma unroll\r
for (int i = 0; i < 10; ++i)\r
{\r
    
    hit.derivative = diff(residues) / diff(distances);\r
    hit.distance = distances.x - residues.x / hit.derivative;\r
    hit.position = camera.position + ray.direction * hit.distance; 

    
    hit.residue = sample_value_tricubic(hit.position) - u_rendering.isovalue;\r
    \r
    
    if (sign_change(residues.x, hit.residue))\r
    {\r
        distances.y = hit.distance;\r
        residues.y = hit.residue;\r
    }\r
    else\r
    {\r
        distances.x = hit.distance;\r
        residues.x = hit.residue;\r
    }\r
}

hit.value = hit.residue + u_rendering.isovalue;

hit.orientation = -ssign(hit.derivative);

hit.gradient = compute_gradient(hit.position, hit.hessian);\r
hit.gradient *= hit.orientation; \r
hit.hessian *= hit.orientation;

hit.normal = normalize(hit.gradient);

hit.curvatures = principal_curvatures(hit.gradient, hit.hessian);

#endif

    
    hit.escaped = (hit.distance < ray.start_distance || hit.distance > ray.end_distance);

    
    hit.discarded = hit.escaped;\r
}\r
        \r
    #endif

#endif\r
    vec3 light_position = camera.position + u_lighting.position_offset * 100.0;\r
vec3 light_vector = light_position - hit.position;\r
vec3 view_vector = camera.position - hit.position;

vec3 light_direction = normalize(light_vector * u_volume.anisotropy);\r
vec3 view_direction = normalize(view_vector * u_volume.anisotropy);\r
vec3 halfway_direction = normalize(light_direction + view_direction);

float light_angle = dot(light_direction, hit.normal);\r
float view_angle = dot(view_direction, hit.normal);\r
float halfway_angle = dot(halfway_direction, hit.normal);

float lambertian = clamp(light_angle, 0.0, 1.0);\r
float specular = clamp(halfway_angle, 0.0, 1.0);\r
specular = pow(specular, u_shading.shininess);

frag.color_material = sample_colormap(hit.value);\r
frag.color_ambient = frag.color_material * u_shading.reflect_ambient;\r
frag.color_diffuse = frag.color_material * u_shading.reflect_diffuse  * lambertian;\r
frag.color_specular = frag.color_material + (1.0 - frag.color_material) * u_shading.reflect_specular * specular;\r
frag.color_directional = mix(frag.color_diffuse, frag.color_specular, specular);

float edges_modulation = smoothstep(0.0, 0.5, abs(view_angle));\r
float gradient_modulation = mix(0.2, 1.0, smoothstep(0.0, 0.1, length(hit.gradient)));\r
float curvature_modulation = mean(smoothstep(-1.2, 0.0, hit.curvatures.x), smoothstep(-1.2, 0.0, hit.curvatures.y)); 

edges_modulation = mix(1.0, edges_modulation, u_shading.modulate_edges);\r
gradient_modulation = mix(1.0, gradient_modulation, u_shading.modulate_gradient);\r
curvature_modulation = mix(1.0, curvature_modulation, u_shading.modulate_curvature);

frag.color_directional *= mmin(edges_modulation, gradient_modulation);\r
frag.color_ambient *= curvature_modulation;

frag.color = frag.color_ambient + frag.color_directional;\r
frag.color *= u_lighting.intensity;

fragColor = vec4(frag.color, 1.0);

#if DISCARDING_ENABLED == 1\r
fragColor.rgb *= hit.discarded ? 0.0 : 1.0;\r
#endif

    #if DEBUG_ENABLED == 1\r
    vec4 debug_ray_discarded = to_color(ray.discarded);

vec4 debug_ray_direction = to_color(ray.direction * 0.5 + 0.5);

vec4 debug_ray_signs = to_color(vec3(ray.signs) * 0.5 + 0.5);

vec4 debug_ray_spacing = to_color(ray.spacing);

vec4 debug_ray_start_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, ray.start_distance));

vec4 debug_ray_end_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, ray.end_distance));

vec4 debug_ray_span_distance = to_color(map(0.0, box.max_span_distance, ray.span_distance));

vec4 debug_ray_start_position = to_color(map(box.min_position, box.max_position, ray.start_position));

vec4 debug_ray_end_position = to_color(map(box.min_position, box.max_position, ray.end_position));

switch (u_debug.option - 100)\r
{\r
    case  1: fragColor = debug_ray_discarded;       break;\r
    case  2: fragColor = debug_ray_direction;       break;\r
    case  3: fragColor = debug_ray_signs;           break;\r
    case  4: fragColor = debug_ray_spacing;         break;\r
    case  5: fragColor = debug_ray_start_distance;  break;\r
    case  6: fragColor = debug_ray_end_distance;    break;\r
    case  7: fragColor = debug_ray_span_distance;   break;\r
    case  8: fragColor = debug_ray_start_position;  break;\r
    case  9: fragColor = debug_ray_end_position;    break;\r
} \r
vec4 debug_cell_intersected = to_color(cell.intersected);

vec4 debug_cell_terminated = to_color(cell.terminated);

vec4 debug_cell_coords = to_color(vec3(cell.coords) * u_volume.inv_dimensions);

vec4 debug_cell_exit_normal = to_color(vec3(cell.exit_normal));

vec4 debug_cell_entry_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, cell.entry_distance)); 

vec4 debug_cell_exit_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, cell.exit_distance)); 

vec4 debug_cell_span_distance = to_color(cell.span_distance / length(cell.max_position - cell.min_position)); 

vec4 debug_cell_min_position = to_color(map(box.min_position, box.max_position, cell.min_position)); 

vec4 debug_cell_max_position = to_color(map(box.min_position, box.max_position, cell.max_position)); 

switch (u_debug.option - 200)\r
{ \r
    case 1: fragColor = debug_cell_intersected;        break;\r
    case 2: fragColor = debug_cell_terminated;         break;\r
    case 3: fragColor = debug_cell_coords;             break;\r
    case 4: fragColor = debug_cell_exit_normal;        break;\r
    case 5: fragColor = debug_cell_max_position;       break;\r
    case 6: fragColor = debug_cell_min_position;       break;\r
    case 7: fragColor = debug_cell_entry_distance;     break;\r
    case 8: fragColor = debug_cell_exit_distance;      break;\r
    case 9: fragColor = debug_cell_span_distance;      break;\r
}  \r
vec4 debug_trace_intersected = to_color(trace.intersected);

vec4 debug_trace_terminated = to_color(trace.terminated);

vec4 debug_trace_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, trace.distance));

vec4 debug_trace_position = to_color(map(box.min_position, box.max_position, trace.position));

vec4 debug_trace_residue = to_color(mmix(COLOR.BLUE, COLOR.BLACK, COLOR.RED, map(-1.0, 1.0, trace.residue / MILLI_TOLERANCE)));

vec4 debug_trace_span_residue = to_color(mmix(COLOR.BLUE, COLOR.BLACK, COLOR.RED, map(-1.0, 1.0, (trace.residue - trace.prev_residue) / MILLI_TOLERANCE)));

switch (u_debug.option - 300)\r
{ \r
    case  1: fragColor = debug_trace_intersected;     break;\r
    case  2: fragColor = debug_trace_terminated;      break;\r
    case  3: fragColor = debug_trace_distance;        break;\r
    case  4: fragColor = debug_trace_position;        break;\r
    case  5: fragColor = debug_trace_residue;         break;\r
    case  6: fragColor = debug_trace_span_residue;    break;\r
}  \r
vec4 debug_block_skip_distance = to_color(vec3(block.skip_distance) / 31.0);

vec4 debug_block_occupied = to_color(block.occupied);

vec4 debug_block_terminated = to_color(block.terminated);

vec4 debug_block_coords = to_color(vec3(block.coords) / vec3(u_volume.blocks - 1));

vec4 debug_block_exit_normal = to_color(vec3(block.exit_normal));

vec4 debug_block_entry_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, block.entry_distance));

vec4 debug_block_exit_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, block.exit_distance));

vec4 debug_block_span_distance = to_color(block.span_distance / length(block.max_position - block.min_position)); 

vec4 debug_block_min_position = to_color(map(box.min_position, box.max_position, block.min_position));

vec4 debug_block_max_position = to_color(map(box.min_position, box.max_position, block.max_position));

switch (u_debug.option - 400)\r
{\r
    case  1: fragColor = debug_block_skip_distance;  break;\r
    case  2: fragColor = debug_block_occupied;       break;\r
    case  3: fragColor = debug_block_terminated;     break;\r
    case  4: fragColor = debug_block_coords;         break;\r
    case  5: fragColor = debug_block_exit_normal;    break;\r
    case  6: fragColor = debug_block_entry_distance; break;\r
    case  7: fragColor = debug_block_exit_distance;  break;\r
    case  8: fragColor = debug_block_span_distance;  break;\r
    case  9: fragColor = debug_block_min_position;   break;\r
    case 10: fragColor = debug_block_max_position;   break;\r
}  \r
vec4 debug_hit_discarded = to_color(hit.discarded);

vec4 debug_hit_escaped = to_color(hit.escaped);

vec4 debug_hit_undefined = to_color(hit.undefined);

vec4 debug_hit_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, hit.distance));

vec4 debug_hit_position = to_color(map(box.min_position, box.max_position, hit.position));

vec4 debug_hit_residue = to_color(mmix(COLOR.BLUE, COLOR.BLACK, COLOR.RED, map(-0.001, 0.001, hit.residue)));

vec4 debug_hit_derivative = to_color(mmix(COLOR.BLUE, COLOR.BLACK, COLOR.RED, map(-0.1, 0.1, hit.derivative)));

vec4 debug_hit_orientation = to_color(map(-1.0, 1.0, hit.orientation));

vec4 debug_hit_normal = to_color((map(-1.0, 1.0, hit.normal)));

vec4 debug_hit_gradient = to_color(map(-1.0, 1.0, normalize(hit.gradient)) * length(hit.gradient));

vec4 debug_hit_steepness = to_color(map(0.0, 1.0, length(hit.gradient)));

vec4 debug_hit_curvatures = to_color(mmix2(                \r
    COLOR.DARK_CYAN, COLOR.DARK_BLUE, COLOR.MAGENTA, 
    COLOR.DARK_BLUE, COLOR.DARK_GRAY, COLOR.ORANGE,  
    COLOR.MAGENTA,   COLOR.ORANGE,    COLOR.GOLD,    
    map(-2.0, 2.0, hit.curvatures)                   
));                 

switch (u_debug.option - 450)\r
{ \r
    case  1: fragColor = debug_hit_discarded;       break;\r
    case  2: fragColor = debug_hit_escaped;         break;\r
    case  3: fragColor = debug_hit_undefined;       break;\r
    case  4: fragColor = debug_hit_distance;        break;\r
    case  5: fragColor = debug_hit_position;        break;\r
    case  6: fragColor = debug_hit_residue;         break;\r
    case  7: fragColor = debug_hit_derivative;      break;\r
    case  8: fragColor = debug_hit_orientation;     break;\r
    case  9: fragColor = debug_hit_normal;          break;\r
    case 10: fragColor = debug_hit_gradient;        break;\r
    case 11: fragColor = debug_hit_steepness;       break;\r
    case 12: fragColor = debug_hit_curvatures;      break;\r
    
    
    
}  \r
vec4 debug_frag_material_color = to_color(frag.color_material);

vec4 debug_frag_color_ambient = to_color(frag.color_ambient);

vec4 debug_frag_color_diffuse = to_color(frag.color_diffuse);

vec4 debug_frag_color_specular = to_color(frag.color_specular);

vec4 debug_frag_direct_color = to_color(frag.color_directional);

vec4 debug_frag_color = to_color(frag.color);

vec4 debug_frag_luminance = to_color(dot(frag.color, vec3(0.2126, 0.7152, 0.0722)));

switch (u_debug.option - 500)\r
{\r
   \r
    case 11: fragColor = debug_frag_material_color;     break; \r
    case 12: fragColor = debug_frag_color_ambient;      break; \r
    case 13: fragColor = debug_frag_color_diffuse;      break; \r
    case 14: fragColor = debug_frag_color_specular;     break; \r
    case 15: fragColor = debug_frag_direct_color;       break; \r
    case 16: fragColor = debug_frag_color;              break; \r
    case 17: fragColor = debug_frag_luminance;   break; \r
}               \r
vec4 debug_box_entry_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, box.entry_distance));

vec4 debug_box_exit_distance = to_color(map(box.min_entry_distance, box.max_exit_distance, box.exit_distance));

vec4 debug_box_span_distance = to_color(map(0.0, box.max_span_distance, box.span_distance));

vec4 debug_box_entry_position = to_color(map(box.min_position, box.max_position, box.entry_position));

vec4 debug_box_exit_position = to_color(map(box.min_position, box.max_position, box.exit_position));

switch (u_debug.option - 600)\r
{\r
    case 1: fragColor = debug_box_entry_distance;     break;\r
    case 2: fragColor = debug_box_exit_distance;      break;\r
    case 3: fragColor = debug_box_span_distance;      break;\r
    case 4: fragColor = debug_box_entry_position;     break;\r
    case 5: fragColor = debug_box_exit_position;      break;\r
}   \r
vec4 debug_camera_direction = to_color(camera.direction * 0.5 + 0.5);

vec4 debug_camera_position = to_color(map(box.min_position, box.max_position, camera.position));

switch (u_debug.option - 700)\r
{\r
    case 1: fragColor = debug_camera_position;  break;\r
    case 2: fragColor = debug_camera_direction; break;\r
}          \r
vec4 debug_cubic_distances = to_color(map(cell.entry_distance, cell.exit_distance, cubic.distances.xyz)); 

vec4 debug_cubic_coefficients = to_color(cubic.coeffs.xyz / cubic.coeffs.w); 

switch (u_debug.option - 800)\r
{ \r
    case 1: fragColor = debug_cubic_distances;    break;\r
    case 3: fragColor = debug_cubic_coefficients; break;\r
}          

switch (u_debug.option - 1000)\r
{ \r
    case 0  : fragColor = debug.variable0; break;\r
    case 1  : fragColor = debug.variable1; break;\r
    case 2  : fragColor = debug.variable2; break;\r
    case 3  : fragColor = debug.variable3; break;\r
    case 4  : fragColor = debug.variable4; break;\r
    case 5  : fragColor = debug.variable5; break;\r
    case 6  : fragColor = debug.variable6; break;\r
    case 7  : fragColor = debug.variable7; break;\r
    case 8  : fragColor = debug.variable8; break;\r
    case 9  : fragColor = debug.variable9; break;\r
}               

#if STATS_ENABLED == 1\r
vec4 debug_stats_num_fetches = to_color(float(stats.num_fetches) / float(MAX_CELLS * 3));

vec4 debug_stats_num_cells = to_color(float(stats.num_cells) / float(MAX_CELLS));

vec4 debug_stats_num_blocks = to_color(float(stats.num_blocks) / float(MAX_BLOCKS));

vec4 debug_stats_num_tests = to_color(float(stats.num_tests) / float(MAX_BLOCKS) * 100.0);

switch (u_debug.option - 900)\r
{\r
    case 1: fragColor = debug_stats_num_fetches; break;\r
    case 2: fragColor = debug_stats_num_cells;   break;\r
    case 3: fragColor = debug_stats_num_blocks;  break;\r
    case 4: fragColor = debug_stats_num_tests;  break;\r
}  \r
#endif\r
    #endif\r
}`;function bP(){const n={u_volume:new ui({size:new $,spacing:new $,dimensions:new $,inv_dimensions:new $,anisotropy:new $,blocks:new $,stride:0,grid_matrix:new lt}),u_textures:new ui({colormaps:null,trilinear_volume:null,tricubic_volume:null,occupancy:null,isotropic_distance:null,anisotropic_distance:null,extended_distance:null}),u_intensity_map:new ui({dimensions:new $,spacing:new $,size:new $,spacing_length:0,size_length:0,inv_dimensions:new $,inv_spacing:new $,inv_size:new $}),u_bbox:new ui({min_cell_coords:new $,max_cell_coords:new $,min_block_coords:new $,max_block_coords:new $,min_position:new $,max_position:new $}),u_distance_map:new ui({max_distance:0,max_iterations:31,stride:4,dimensions:new $,spacing:new $,size:new $,inv_stride:.25,inv_dimensions:new $,inv_spacing:new $,inv_size:new $}),u_colormap:new ui({levels:255,name:"cet_d9",thresholds:new Ye(0,1),start_coords:new Ye(Mc.cet_d9.x_start,Mc.cet_d9.y),end_coords:new Ye(Mc.cet_d9.x_end,Mc.cet_d9.y)}),u_rendering:new ui({isovalue:.69,max_groups:0,max_cells:0,max_blocks:0}),u_shading:new ui({reflect_ambient:.2,reflect_diffuse:1,reflect_specular:.6,shininess:40,modulate_edges:1,modulate_gradient:1,modulate_curvature:1}),u_lighting:new ui({intensity:1,shadows:0,color_ambient:new ht(16777215),color_diffuse:new ht(16777215),color_specular:new ht(16777215),position_offset:new $}),u_debug:new ui({option:0,variable1:0,variable2:0,variable3:0,variable4:0,variable5:0})},e={VARIATION_ENABLED:1,BERNSTEIN_ENABLED:1,SKIPPING_ENABLED:1,MARCHING_METHOD:1,INTERPOLATION_METHOD:2,SKIPPING_METHOD:2,GRADIENTS_METHOD:3,STATS_ENABLED:1,DEBUG_ENABLED:1,DISCARDING_ENABLED:1,MAX_CELLS:1e3,MAX_TRACES:5e3,MAX_BLOCKS:1e3,MAX_GROUPS:100,MAX_CELLS_PER_BLOCK:10,MAX_TRACES_PER_BLOCK:50,MAX_BLOCKS_PER_GROUP:20};return new qs({side:Ir,transparent:!1,depthTest:!0,depthWrite:!0,glslVersion:Wg,uniforms:n,defines:e,vertexShader:gP,fragmentShader:xP})}class _P{constructor(){this.viewer=new dl,this.debug=this.viewer.debug,this.debug.active&&(this.addFolders(),this.addSubfolders(),this.addControllers())}addFolders(){this.folders={},this.folders.viewer=this.debug.ui.addFolder("ISOViewer").open()}addSubfolders(){this.subfolders={},this.subfolders.rendering=this.folders.viewer.addFolder("rendering").close(),this.subfolders.colormap=this.folders.viewer.addFolder("colormap").close(),this.subfolders.shading=this.folders.viewer.addFolder("shading").close(),this.subfolders.lighting=this.folders.viewer.addFolder("lighting").close(),this.subfolders.debug=this.folders.viewer.addFolder("debug").close(),this.addToggles()}addToggles(){const e=Object.values(this.subfolders),t=r=>{e.forEach(i=>{i!==r&&!i._closed&&i.close()})};e.forEach(r=>{r.onOpenClose(i=>{i._closed||t(i)})})}addControllers(){this.controllers={},this.addControllersRendering(),this.addControllersColormap(),this.addControllersShading(),this.addControllersLighting(),this.addControllersDebugging()}addControllersRendering(){const e=this.subfolders.rendering,t=this.viewer.material,r=this.viewer.material.defines,i=this.viewer.material.uniforms.u_rendering.value,s=this.viewer.material.uniforms.u_distance_map.value,a={isovalue:i.isovalue,stride:s.stride,BERNSTEIN_ENABLED:!!r.BERNSTEIN_ENABLED,VARIATION_ENABLED:!!r.VARIATION_ENABLED,SKIPPING_ENABLED:!!r.SKIPPING_ENABLED,MARCHING_METHOD:Number(r.MARCHING_METHOD),INTERPOLATION_METHOD:Number(r.INTERPOLATION_METHOD),SKIPPING_METHOD:Number(r.SKIPPING_METHOD),GRADIENTS_METHOD:Number(r.GRADIENTS_METHOD)};this.controllers.rendering={isovalue:e.add(a,"isovalue").min(0).max(1).step(1e-4).onFinishChange(o=>{this.viewer.onThresholdChange(o)}),stride:e.add(a,"stride").min(2).max(8).step(1).onFinishChange(o=>{this.viewer.onStrideChange(o)}),maxGroups:e.add(i,"max_groups").min(0).max(1e3).step(1),maxCellCount:e.add(i,"max_cells").min(0).max(1e3).step(1),maxBlockCount:e.add(i,"max_blocks").min(0).max(200).step(1),enableVariation:e.add(a,"VARIATION_ENABLED").name("variation").onFinishChange(o=>{r.VARIATION_ENABLED=Number(o),t.needsUpdate=!0}),enableBernstein:e.add(a,"BERNSTEIN_ENABLED").name("bernstein").onFinishChange(o=>{r.BERNSTEIN_ENABLED=Number(o),t.needsUpdate=!0}),enableSkipping:e.add(a,"SKIPPING_ENABLED").name("skipping").onFinishChange(o=>{r.SKIPPING_ENABLED=Number(o),t.needsUpdate=!0}),marchingMethod:e.add(a,"MARCHING_METHOD").name("marching").options({cells:1,traces:2}).onFinishChange(o=>{r.MARCHING_METHOD=Number(o),t.needsUpdate=!0}),interpolationMethod:e.add(a,"INTERPOLATION_METHOD").name("interpolation").options({trilinear:1,tricubic:2}).onFinishChange(o=>{this.viewer.onInterpolationChange(o)}),skippingMethod:e.add(a,"SKIPPING_METHOD").name("skipping").options({occupancy:1,isotropic:2,anisotropic:3,extended:4}).onFinishChange(o=>{r.SKIPPING_METHOD=Number(o),t.needsUpdate=!0}),gradientsMethod:e.add(a,"GRADIENTS_METHOD").name("gradients").options({analytic:1,sobel:2,bspline:3}).onFinishChange(o=>{r.GRADIENTS_METHOD=Number(o),t.needsUpdate=!0})}}addControllersColormap(){const e=this.subfolders.colormap,t=this.viewer.material.uniforms.u_colormap.value,r={flip:!1};this.controllers.colormap={name:e.add(t,"name").options(Object.keys(Mc)).onChange(()=>this.updateColormap()),minThreshold:e.add(t.thresholds,"x").name("min_threshold").min(0).max(1).step(.001),maxThreshold:e.add(t.thresholds,"y").name("max_threshold").min(0).max(1).step(.001),levels:e.add(t,"levels").min(1).max(255).step(1),flip:e.add(r,"flip").onChange(()=>this.flipColormap())}}addControllersShading(){const e=this.viewer.material.uniforms.u_shading.value,t=this.subfolders.shading;t.add(e,"reflect_ambient").min(0).max(1).step(.001),t.add(e,"reflect_diffuse").min(0).max(1).step(.001),t.add(e,"reflect_specular").min(0).max(1).step(.001),t.add(e,"shininess").min(0).max(40).step(.2),t.add(e,"modulate_edges").min(0).max(1).step(.001),t.add(e,"modulate_gradient").min(0).max(1).step(.001),t.add(e,"modulate_curvature").min(0).max(1).step(.001)}addControllersLighting(){const e=this.subfolders.lighting,t=this.viewer.material.uniforms.u_lighting.value;this.controllers.lighting={intensity:e.add(t,"intensity").min(0).max(2).step(.001),shadows:e.add(t,"shadows").min(0).max(1).step(.001),color_ambient:e.addColor(t,"color_ambient"),color_diffuse:e.addColor(t,"color_diffuse"),color_specular:e.addColor(t,"color_specular"),positionX:e.add(t.position_offset,"x").min(-5).max(5).step(.01).name("position_x"),positionY:e.add(t.position_offset,"y").min(-5).max(5).step(.01).name("position_y"),positionZ:e.add(t.position_offset,"z").min(-5).max(5).step(.01).name("position_z")}}addControllersDebugging(){const e=this.subfolders.debug,t=this.viewer.material.uniforms.u_debug.value,r=this.viewer.material.defines,i=this.viewer.material,s={DISCARDING_ENABLED:!!r.DISCARDING_ENABLED};this.controllers.debug={option:e.add(t,"option").options({default:0,ray_discarded:101,ray_direction:102,ray_signs:103,ray_spacing:104,ray_start_distance:105,ray_end_distance:106,ray_span_distance:107,ray_start_position:108,ray_end_position:109,block_skip_distance:401,block_occupied:402,block_terminated:403,block_coords:404,block_exit_normal:405,block_entry_distance:406,block_exit_distance:407,block_span_distance:408,block_min_position:409,block_max_position:410,cell_intersected:201,cell_terminated:202,cell_coords:203,cell_exit_normal:204,cell_max_position:205,cell_min_position:206,cell_entry_distance:207,cell_exit_distance:208,cell_span_distance:209,trace_intersected:301,trace_terminated:302,trace_distance:303,trace_position:304,trace_residue:305,trace_span_residue:306,hit_discarded:451,hit_escaped:452,hit_undefined:453,hit_distance:454,hit_position:455,hit_residue:456,hit_derivative:457,hit_orientation:458,hit_normal:459,hit_gradient:460,hit_steepness:461,hit_curvatures:462,frag_color_material:511,frag_color_ambient:512,frag_color_diffuse:513,frag_color_specular:514,frag_direct_color:515,frag_color:516,frag_luminance:517,box_entry_distance:601,box_exit_distance:602,box_span_distance:603,box_entry_position:604,box_exit_position:605,camera_position:701,camera_direction:702,cubic_distances:801,cubic_intensities:802,cubic_coefficients:803,stats_num_fetches:901,stats_num_cells:902,stats_num_blocks:903,stats_num_checks:904,debug_variable0:1e3,debug_variable1:1001,debug_variable2:1002,debug_variable3:1003,debug_variable4:1004,debug_variable5:1005,debug_variable6:1006,debug_variable7:1007,debug_variable8:1008,debug_variable9:1009}),variable1:e.add(t,"variable1").min(0).max(1).step(.001),variable2:e.add(t,"variable2").min(0).max(1).step(.001),variable3:e.add(t,"variable3").min(0).max(1).step(.001),variable4:e.add(t,"variable4").min(0).max(1).step(.001),variable5:e.add(t,"variable5").min(0).max(1).step(.001),discarding:e.add(s,"DISCARDING_ENABLED").name("enable_discarding").onFinishChange(a=>{r.DISCARDING_ENABLED=Number(a),i.needsUpdate=!0})}}flipColormap(){[this.viewer.material.uniforms.u_colormap.value.start_coords.x,this.viewer.material.uniforms.u_colormap.value.end_coords.x]=[this.viewer.material.uniforms.u_colormap.value.end_coords.x,this.viewer.material.uniforms.u_colormap.value.start_coords.x]}updateColormap(){let{x_start:e,x_end:t,y:r}=Mc[this.controllers.colormap.name.getValue()];this.viewer.material.uniforms.u_colormap.value.start_coords.set(e,r),this.viewer.material.uniforms.u_colormap.value.end_coords.set(t,r)}destroy(){Object.values(this.controllers).forEach(e=>{Object.values(e).forEach(t=>{t.remove()})}),Object.values(this.subfolders).forEach(e=>{e.close(),e.destroy()}),Object.values(this.folders).forEach(e=>{e.close(),e.destroy()}),this.controllers=null,this.subfolders=null,this.folders=null,this.debug=null,this.viewer=null}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yP=1e-7,wP=1e-4;class FE{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class w0{refCount(e){return zr("refCount")}incRef(e){return zr("incRef")}timerAvailable(){return!0}time(e){return zr("time")}read(e){return zr("read")}readSync(e){return zr("readSync")}readToGPU(e,t){return zr("readToGPU")}numDataIds(){return zr("numDataIds")}disposeData(e,t){return zr("disposeData")}write(e,t,r){return zr("write")}move(e,t,r,i,s){return zr("move")}createTensorFromGPUData(e,t,r){return zr("createTensorFromGPUData")}memory(){return zr("memory")}floatPrecision(){return zr("floatPrecision")}epsilon(){return this.floatPrecision()===32?yP:wP}dispose(){return zr("dispose")}}function zr(n){throw new Error(`'${n}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EP(n){let e=n.length,t=0;for(;e>0;)t=Math.random()*e|0,e--,wc(n,e,t)}function To(n,e,t){return Math.max(n,Math.min(e,t))}function E0(n){return n%2===0?n:n+1}function wc(n,e,t){const r=n[e];n[e]=n[t],n[t]=r}function SP(n){let e=0;for(let t=0;t<n.length;t++)e+=n[t];return e}function R(n,e){if(!n)throw new Error(typeof e=="string"?e:e())}function S0(n,e,t=""){R(Pt(n,e),()=>t+` Shapes ${n} and ${e} must match`)}function T0(n){R(n!=null,()=>"The input to the tensor constructor must be a non-null value.")}function ue(n){if(n.length===0)return 1;let e=n[0];for(let t=1;t<n.length;t++)e*=n[t];return e}function Pt(n,e){if(n===e)return!0;if(n==null||e==null||n.length!==e.length)return!1;for(let t=0;t<n.length;t++)if(n[t]!==e[t])return!1;return!0}function el(n){return n%1===0}function Qg(n){const e=Math.ceil(Math.sqrt(n));return[e,Math.ceil(n/e)]}function Pc(n,e){return e<=n.length?n:n+" ".repeat(e-n.length)}function s2(n,e=i=>0,t,r){return new Promise((i,s)=>{let a=0;const o=()=>{if(n()){i();return}a++;const c=e(a);if(t!=null&&a>=t){s();return}r!=null?r(o,c):setTimeout(o,c)};o()})}function $E(n,e){let t=1,r=-1;for(let s=0;s<n.length;++s)if(n[s]>=0)t*=n[s];else if(n[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(n[s]<0)throw Error(`Shapes can not be < 0. Found ${n[s]} at dim ${s}`);if(r===-1){if(e>0&&e!==t)throw Error(`Size(${e}) must match the product of shape ${n}`);return n}if(t===0)throw Error(`Cannot infer the missing size in [${n}] when there are 0 elements`);if(e%t!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${t}`);const i=n.slice();return i[r]=e/t,i}function St(n,e){const t=e.length;return n=n==null?e.map((r,i)=>i):[].concat(n),R(n.every(r=>r>=-t&&r<t),()=>`All values in axis param must be in range [-${t}, ${t}) but got axis ${n}`),R(n.every(r=>el(r)),()=>`All values in axis param must be integers but got axis ${n}`),n.map(r=>r<0?t+r:r)}function $a(n,e){const t=[],r=[],i=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||i?null:St(e,n).sort();let a=0;for(let o=0;o<n.length;++o){if(s!=null){if(s[a]===o&&n[o]!==1)throw new Error(`Can't squeeze axis ${o} since its dim '${n[o]}' is not 1`);(s[a]==null||s[a]>o)&&n[o]===1&&(t.push(n[o]),r.push(o)),s[a]<=o&&a++}n[o]!==1&&(t.push(n[o]),r.push(o))}return{newShape:t,keptDims:r}}function ir(n,e){return gn(n,e)}function gn(n,e){let t=null;if(n==null||n==="float32")t=new Float32Array(e);else if(n==="int32")t=new Int32Array(e);else if(n==="bool")t=new Uint8Array(e);else if(n==="string")t=new Array(e);else throw new Error(`Unknown data type ${n}`);return t}function TP(n,e){for(let t=0;t<n.length;t++){const r=n[t];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function AP(n){return n==="bool"||n==="complex64"||n==="float32"||n==="int32"||n==="string"}function UE(n,e){return!(e==="complex64"||e==="float32"&&n!=="complex64"||e==="int32"&&n!=="float32"&&n!=="complex64"||e==="bool"&&n==="bool")}function Nh(n){if(n==="float32"||n==="int32")return 4;if(n==="complex64")return 8;if(n==="bool")return 1;throw new Error(`Unknown dtype ${n}`)}function CP(n){if(n==null)return 0;let e=0;return n.forEach(t=>e+=t.length),e}function Gu(n){return typeof n=="string"||n instanceof String}function IP(n){return typeof n=="boolean"}function Jg(n){return typeof n=="number"}function yl(n){return Array.isArray(n)?yl(n[0]):n instanceof Float32Array?"float32":n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray?"int32":Jg(n)?"float32":Gu(n)?"string":IP(n)?"bool":"float32"}function ex(n){return!!(n&&n.constructor&&n.call&&n.apply)}function tx(n,e){for(let t=e;t<n;++t)if(n%t===0)return t;return n}function Qe(n){const e=n.length;if(e<2)return[];const t=new Array(e-1);t[e-2]=n[e-1];for(let r=e-3;r>=0;--r)t[r]=t[r+1]*n[r+1];return t}function BE(n,e,t,r=!1){const i=new Array;if(e.length===1){const s=e[0]*(r?2:1);for(let a=0;a<s;a++)i[a]=t[n+a]}else{const s=e[0],a=e.slice(1),o=a.reduce((c,l)=>c*l)*(r?2:1);for(let c=0;c<s;c++)i[c]=BE(n+c*o,a,t,r)}return i}function Hi(n,e,t=!1){if(n.length===0)return e[0];const r=n.reduce((i,s)=>i*s)*(t?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${n}] does not match the input size ${e.length}${t?" for a complex tensor":""}.`);return BE(0,n,e,t)}function MP(n,e){if(Array.isArray(n))return n;if(e==="float32")return n instanceof Float32Array?n:new Float32Array(n);if(e==="int32")return n instanceof Int32Array?n:new Int32Array(n);if(e==="bool"||e==="string")return Uint8Array.from(new Int32Array(n));throw new Error(`Unknown dtype ${e}`)}function A0(n,e){const t=sr(n,e);for(let r=0;r<t.length;r++)t[r]=1;return t}function sr(n,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool")return new Uint8Array(n);throw new Error(`Unknown data type ${e}`)}function VE(n,e){const t=n.reduce((r,i)=>r*i,1);if(e==null||e==="float32")return Hi(n,new Float32Array(t));if(e==="int32")return Hi(n,new Int32Array(t));if(e==="bool")return Hi(n,new Uint8Array(t));throw new Error(`Unknown data type ${e}`)}function ea(n){n.forEach(e=>{R(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${n}].`)})}function us(n,e,t){if(e===0)return 0;if(e===1)return n[0];let r=n[n.length-1];for(let i=0;i<n.length-1;++i)r+=t[i]*n[i];return r}function wl(n,e,t){if(e===0)return[];if(e===1)return[n];const r=new Array(e);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(n/t[i]),n-=r[i]*t[i];return r[r.length-1]=n,r}function C0(n){return n&&n.then&&typeof n.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a2="tfjsflags";class RP{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=NP,this.populateURLFlags()}setPlatform(e,t){this.platform!=null&&(ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=t}registerFlag(e,t,r){if(this.flagRegistry[e]={evaluationFn:t,setHook:r},this.urlFlags[e]!=null){const i=this.urlFlags[e];ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(C0(t))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=t,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);a2 in e&&e[a2].split(",").forEach(r=>{const[i,s]=r.split(":");this.urlFlags[i]=DP(i,s)})}}function NP(n){const e={};return n.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(t,...r)=>(kP(e,r[0],r[1]),r.join("="))),e}function kP(n,e,t){n[decodeURIComponent(e)]=decodeURIComponent(t||"")}function DP(n,e){const t=e.toLowerCase();return t==="true"||t==="false"?t==="true":`${+t}`===t?+t:e}function ie(){return GE}let GE=null;function LP(n){GE=n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let zv;function HE(){if(zv==null){let n;if(typeof window<"u")n=window;else if(typeof global<"u")n=global;else if(typeof process<"u")n=process;else if(typeof self<"u")n=self;else throw new Error("Could not find a global object");zv=n}return zv}function OP(){const n=HE();return n._tfGlobals==null&&(n._tfGlobals=new Map),n._tfGlobals}function I0(n,e){const t=OP();if(t.has(n))return t.get(n);{const r=e();return t.set(n,r),t.get(n)}}const xp="Abs",Hu="Acos",Wu="Acosh",El="Add",M0="AddN",R0="All",N0="Any",bp="ArgMax",_p="ArgMin",qu="Asin",Xu="Asinh",Ku="Atan",ju="Atanh",Yu="Atan2",yp="AvgPool",k0="AvgPoolGrad",wp="AvgPool3D",D0="AvgPool3DGrad",Ep="BatchMatMul",Sp="BatchToSpaceND",L0="Bincount",O0="BitwiseAnd",zP="BroadcastTo",WE="BroadcastArgs",Zu="Cast",Qu="Ceil",Ju="ClipByValue",z0="Complex",Tp="ComplexAbs",Ap="Concat",Cp="Conv2D",P0="Conv2DBackpropFilter",Ip="Conv2DBackpropInput",Mp="Conv3D",F0="Conv3DBackpropFilterV2",$0="Conv3DBackpropInputV2",ef="Cos",tf="Cosh",U0="Cumprod",Rp="Cumsum",B0="CropAndResize",V0="DenseBincount",G0="DepthToSpace",Np="DepthwiseConv2dNative",H0="DepthwiseConv2dNativeBackpropFilter",W0="DepthwiseConv2dNativeBackpropInput",qE="Diag",kp="Dilation2D",nx="Dilation2DBackpropInput",rx="Dilation2DBackpropFilter",PP="Draw",nf="RealDiv",q0="Einsum",rf="Elu",X0="EluGrad",sf="Erf",Dp="Equal",af="Exp",Lp="ExpandDims",of="Expm1",K0="FFT",j0="Fill",Y0="FlipLeftRight",cf="Floor",lf="FloorDiv",Op="FusedBatchNorm",zp="GatherV2",XE="GatherNd",Pp="Greater",uf="GreaterEqual",ff="Identity",Z0="IFFT",Q0="Imag",df="IsFinite",hf="IsInf",pf="IsNan",Fp="LeakyRelu",$p="Less",Up="LessEqual",KE="LinSpace",mf="Log",vf="Log1p",Bp="LogicalAnd",Vp="LogicalNot",Gp="LogicalOr",FP="LogSoftmax",Hp="LRN",J0="LRNGrad",Wp="Max",gf="Maximum",qp="MaxPool",eb="MaxPoolGrad",Xp="MaxPool3D",tb="MaxPool3DGrad",jE="MaxPoolWithArgmax",Kp="Mean",jp="Min",xf="Minimum",Yp="MirrorPad",bf="Mod",YE="Multinomial",_f="Multiply",Zp="Neg",Qp="NotEqual",nb="NonMaxSuppressionV3",rb="NonMaxSuppressionV4",ib="NonMaxSuppressionV5",Jp="OnesLike",em="OneHot",tm="Pack",nm="PadV2",yf="Pow",rm="Prelu",im="Prod",ZE="RaggedGather",QE="RaggedRange",JE="RaggedTensorToTensor",sb="Range",ab="Real",wf="Reciprocal",Ef="Relu",sm="Reshape",am="ResizeNearestNeighbor",ob="ResizeNearestNeighborGrad",om="ResizeBilinear",cb="ResizeBilinearGrad",Sf="Relu6",cm="Reverse",Tf="Round",Af="Rsqrt",e3="ScatterNd",t3="TensorScatterUpdate",n3="SearchSorted",lm="Select",Cf="Selu",um="Slice",If="Sin",Mf="Sinh",Rf="Sign",Nf="Sigmoid",kf="Softplus",Df="Sqrt",fm="Sum",dm="SpaceToBatchND",hm="SplitV",pm="Softmax",r3="SparseFillEmptyRows",i3="SparseReshape",s3="SparseSegmentMean",a3="SparseSegmentSum",o3="SparseToDense",Lf="SquaredDifference",lb="Square",ub="StaticRegexReplace",fb="StridedSlice",c3="StringNGrams",l3="StringSplit",u3="StringToHashBucketFast",Of="Sub",zf="Tan",Pf="Tanh",Ff="Tile",db="TopK",hb="Transform",Fc="Transpose",pb="Unique",mm="Unpack",vm="UnsortedSegmentSum",gm="ZerosLike",$f="Step",$P="FromPixels",mb="RotateWithOffset",kh="_FusedMatMul",Dh="FusedConv2D",f3="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qr(...n){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.warn(...n)}function UP(...n){ie().getBool("IS_TEST")||ie().getBool("PROD")||console.log(...n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lh=I0("kernelRegistry",()=>new Map),ix=I0("gradRegistry",()=>new Map);function o2(n,e){const t=h3(n,e);return Lh.get(t)}function c2(n){return ix.get(n)}function l2(n){const e=Lh.entries(),t=[];for(;;){const{done:r,value:i}=e.next();if(r)break;const[s,a]=i,[o]=s.split("_");o===n&&t.push(a)}return t}function d3(n){const{kernelName:e,backendName:t}=n,r=h3(e,t);Lh.has(r)&&Qr(`The kernel '${e}' for backend '${t}' is already registered`),Lh.set(r,n)}function BP(n){const{kernelName:e}=n;ix.has(e)&&ie().getBool("DEBUG")&&Qr(`Overriding the gradient for '${e}'`),ix.set(e,n)}function h3(n,e){return`${e}_${n}`}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p3(n){return n instanceof Float32Array||n instanceof Int32Array||n instanceof Uint8Array||n instanceof Uint8ClampedArray}var m3=rn,mi=null;try{mi=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function rn(n,e,t){this.low=n|0,this.high=e|0,this.unsigned=!!t}rn.prototype.__isLong__;Object.defineProperty(rn.prototype,"__isLong__",{value:!0});function Xr(n){return(n&&n.__isLong__)===!0}rn.isLong=Xr;var u2={},f2={};function Vo(n,e){var t,r,i;return e?(n>>>=0,(i=0<=n&&n<256)&&(r=f2[n],r)?r:(t=sn(n,(n|0)<0?-1:0,!0),i&&(f2[n]=t),t)):(n|=0,(i=-128<=n&&n<128)&&(r=u2[n],r)?r:(t=sn(n,n<0?-1:0,!1),i&&(u2[n]=t),t))}rn.fromInt=Vo;function vi(n,e){if(isNaN(n))return e?vo:gi;if(e){if(n<0)return vo;if(n>=v3)return b3}else{if(n<=-h2)return Br;if(n+1>=h2)return x3}return n<0?vi(-n,e).neg():sn(n%tl|0,n/tl|0,e)}rn.fromNumber=vi;function sn(n,e,t){return new rn(n,e,t)}rn.fromBits=sn;var Oh=Math.pow;function vb(n,e,t){if(n.length===0)throw Error("empty string");if(n==="NaN"||n==="Infinity"||n==="+Infinity"||n==="-Infinity")return gi;if(typeof e=="number"?(t=e,e=!1):e=!!e,t=t||10,t<2||36<t)throw RangeError("radix");var r;if((r=n.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return vb(n.substring(1),e,t).neg();for(var i=vi(Oh(t,8)),s=gi,a=0;a<n.length;a+=8){var o=Math.min(8,n.length-a),c=parseInt(n.substring(a,a+o),t);if(o<8){var l=vi(Oh(t,o));s=s.mul(l).add(vi(c))}else s=s.mul(i),s=s.add(vi(c))}return s.unsigned=e,s}rn.fromString=vb;function Qi(n,e){return typeof n=="number"?vi(n,e):typeof n=="string"?vb(n,e):sn(n.low,n.high,typeof e=="boolean"?e:n.unsigned)}rn.fromValue=Qi;var d2=65536,VP=1<<24,tl=d2*d2,v3=tl*tl,h2=v3/2,p2=Vo(VP),gi=Vo(0);rn.ZERO=gi;var vo=Vo(0,!0);rn.UZERO=vo;var Rc=Vo(1);rn.ONE=Rc;var g3=Vo(1,!0);rn.UONE=g3;var sx=Vo(-1);rn.NEG_ONE=sx;var x3=sn(-1,2147483647,!1);rn.MAX_VALUE=x3;var b3=sn(-1,-1,!0);rn.MAX_UNSIGNED_VALUE=b3;var Br=sn(0,-2147483648,!1);rn.MIN_VALUE=Br;var Ce=rn.prototype;Ce.toInt=function(){return this.unsigned?this.low>>>0:this.low};Ce.toNumber=function(){return this.unsigned?(this.high>>>0)*tl+(this.low>>>0):this.high*tl+(this.low>>>0)};Ce.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Br)){var t=vi(e),r=this.div(t),i=r.mul(t).sub(this);return r.toString(e)+i.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=vi(Oh(e,6),this.unsigned),a=this,o="";;){var c=a.div(s),l=a.sub(c.mul(s)).toInt()>>>0,u=l.toString(e);if(a=c,a.isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}};Ce.getHighBits=function(){return this.high};Ce.getHighBitsUnsigned=function(){return this.high>>>0};Ce.getLowBits=function(){return this.low};Ce.getLowBitsUnsigned=function(){return this.low>>>0};Ce.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Br)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,t=31;t>0&&!(e&1<<t);t--);return this.high!=0?t+33:t+1};Ce.isZero=function(){return this.high===0&&this.low===0};Ce.eqz=Ce.isZero;Ce.isNegative=function(){return!this.unsigned&&this.high<0};Ce.isPositive=function(){return this.unsigned||this.high>=0};Ce.isOdd=function(){return(this.low&1)===1};Ce.isEven=function(){return(this.low&1)===0};Ce.equals=function(e){return Xr(e)||(e=Qi(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Ce.eq=Ce.equals;Ce.notEquals=function(e){return!this.eq(e)};Ce.neq=Ce.notEquals;Ce.ne=Ce.notEquals;Ce.lessThan=function(e){return this.comp(e)<0};Ce.lt=Ce.lessThan;Ce.lessThanOrEqual=function(e){return this.comp(e)<=0};Ce.lte=Ce.lessThanOrEqual;Ce.le=Ce.lessThanOrEqual;Ce.greaterThan=function(e){return this.comp(e)>0};Ce.gt=Ce.greaterThan;Ce.greaterThanOrEqual=function(e){return this.comp(e)>=0};Ce.gte=Ce.greaterThanOrEqual;Ce.ge=Ce.greaterThanOrEqual;Ce.compare=function(e){if(Xr(e)||(e=Qi(e)),this.eq(e))return 0;var t=this.isNegative(),r=e.isNegative();return t&&!r?-1:!t&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Ce.comp=Ce.compare;Ce.negate=function(){return!this.unsigned&&this.eq(Br)?Br:this.not().add(Rc)};Ce.neg=Ce.negate;Ce.add=function(e){Xr(e)||(e=Qi(e));var t=this.high>>>16,r=this.high&65535,i=this.low>>>16,s=this.low&65535,a=e.high>>>16,o=e.high&65535,c=e.low>>>16,l=e.low&65535,u=0,f=0,d=0,h=0;return h+=s+l,d+=h>>>16,h&=65535,d+=i+c,f+=d>>>16,d&=65535,f+=r+o,u+=f>>>16,f&=65535,u+=t+a,u&=65535,sn(d<<16|h,u<<16|f,this.unsigned)};Ce.subtract=function(e){return Xr(e)||(e=Qi(e)),this.add(e.neg())};Ce.sub=Ce.subtract;Ce.multiply=function(e){if(this.isZero())return gi;if(Xr(e)||(e=Qi(e)),mi){var t=mi.mul(this.low,this.high,e.low,e.high);return sn(t,mi.get_high(),this.unsigned)}if(e.isZero())return gi;if(this.eq(Br))return e.isOdd()?Br:gi;if(e.eq(Br))return this.isOdd()?Br:gi;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(p2)&&e.lt(p2))return vi(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,i=this.high&65535,s=this.low>>>16,a=this.low&65535,o=e.high>>>16,c=e.high&65535,l=e.low>>>16,u=e.low&65535,f=0,d=0,h=0,p=0;return p+=a*u,h+=p>>>16,p&=65535,h+=s*u,d+=h>>>16,h&=65535,h+=a*l,d+=h>>>16,h&=65535,d+=i*u,f+=d>>>16,d&=65535,d+=s*l,f+=d>>>16,d&=65535,d+=a*c,f+=d>>>16,d&=65535,f+=r*u+i*l+s*c+a*o,f&=65535,sn(h<<16|p,f<<16|d,this.unsigned)};Ce.mul=Ce.multiply;Ce.divide=function(e){if(Xr(e)||(e=Qi(e)),e.isZero())throw Error("division by zero");if(mi){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var t=(this.unsigned?mi.div_u:mi.div_s)(this.low,this.high,e.low,e.high);return sn(t,mi.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?vo:gi;var r,i,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return vo;if(e.gt(this.shru(1)))return g3;s=vo}else{if(this.eq(Br)){if(e.eq(Rc)||e.eq(sx))return Br;if(e.eq(Br))return Rc;var a=this.shr(1);return r=a.div(e).shl(1),r.eq(gi)?e.isNegative()?Rc:sx:(i=this.sub(e.mul(r)),s=r.add(i.div(e)),s)}else if(e.eq(Br))return this.unsigned?vo:gi;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=gi}for(i=this;i.gte(e);){r=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var o=Math.ceil(Math.log(r)/Math.LN2),c=o<=48?1:Oh(2,o-48),l=vi(r),u=l.mul(e);u.isNegative()||u.gt(i);)r-=c,l=vi(r,this.unsigned),u=l.mul(e);l.isZero()&&(l=Rc),s=s.add(l),i=i.sub(u)}return s};Ce.div=Ce.divide;Ce.modulo=function(e){if(Xr(e)||(e=Qi(e)),mi){var t=(this.unsigned?mi.rem_u:mi.rem_s)(this.low,this.high,e.low,e.high);return sn(t,mi.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Ce.mod=Ce.modulo;Ce.rem=Ce.modulo;Ce.not=function(){return sn(~this.low,~this.high,this.unsigned)};Ce.and=function(e){return Xr(e)||(e=Qi(e)),sn(this.low&e.low,this.high&e.high,this.unsigned)};Ce.or=function(e){return Xr(e)||(e=Qi(e)),sn(this.low|e.low,this.high|e.high,this.unsigned)};Ce.xor=function(e){return Xr(e)||(e=Qi(e)),sn(this.low^e.low,this.high^e.high,this.unsigned)};Ce.shiftLeft=function(e){return Xr(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?sn(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):sn(0,this.low<<e-32,this.unsigned)};Ce.shl=Ce.shiftLeft;Ce.shiftRight=function(e){return Xr(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?sn(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):sn(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Ce.shr=Ce.shiftRight;Ce.shiftRightUnsigned=function(e){if(Xr(e)&&(e=e.toInt()),e&=63,e===0)return this;var t=this.high;if(e<32){var r=this.low;return sn(r>>>e|t<<32-e,t>>>e,this.unsigned)}else return e===32?sn(t,0,this.unsigned):sn(t>>>e-32,0,this.unsigned)};Ce.shru=Ce.shiftRightUnsigned;Ce.shr_u=Ce.shiftRightUnsigned;Ce.toSigned=function(){return this.unsigned?sn(this.low,this.high,!1):this};Ce.toUnsigned=function(){return this.unsigned?this:sn(this.low,this.high,!0)};Ce.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Ce.toBytesLE=function(){var e=this.high,t=this.low;return[t&255,t>>>8&255,t>>>16&255,t>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Ce.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,t>>>24,t>>>16&255,t>>>8&255,t&255]};rn.fromBytes=function(e,t,r){return r?rn.fromBytesLE(e,t):rn.fromBytesBE(e,t)};rn.fromBytesLE=function(e,t){return new rn(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)};rn.fromBytesBE=function(e,t){return new rn(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)};const _3=OE(m3),GP=pR({__proto__:null,default:_3},[m3]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uo=_3||GP;function xm(n){return uo.fromString(n,!0,16)}const y3=xm("c3a5c85c97cb3127"),oo=xm("b492b66fbe98f273"),mr=xm("9ae16a3b2f90404f");function ax(n){return n.xor(n.shru(47))}function w3(n,e,t){const r=n.slice(e,e+t);return uo.fromBytes(Array.from(r),!0,!0)}function Qt(n,e){return w3(n,e,8)}function m2(n,e){return w3(n,e,4)}function $n(n,e){return e===0?n:n.shru(e).or(n.shl(64-e))}function Aa(n,e,t=xm("9ddfea08eb382d69")){let r=n.xor(e).mul(t);r=r.xor(r.shru(47));let i=e.xor(r).mul(t);return i=i.xor(i.shru(47)),i=i.mul(t),i}function HP(n,e,t,r,i,s){i=i.add(n),s=$n(s.add(i).add(r),21);const a=i;return i=i.add(e),i=i.add(t),s=s.add($n(i,44)),[i.add(r),s.add(a)]}function Yd(n,e,t,r){return HP(Qt(n,e),Qt(n,e+8),Qt(n,e+16),Qt(n,e+24),t,r)}function WP(n,e=n.length){if(e>=8){const t=mr.add(e*2),r=Qt(n,0).add(mr),i=Qt(n,e-8),s=$n(i,37).mul(t).add(r),a=$n(r,25).add(i).mul(t);return Aa(s,a,t)}if(e>=4){const t=mr.add(e*2),r=m2(n,0);return Aa(r.shl(3).add(e),m2(n,e-4),t)}if(e>0){const t=n[0],r=n[e>>1],i=n[e-1],s=t+(r<<8),a=e+(i<<2);return ax(mr.mul(s).xor(y3.mul(a))).mul(mr)}return mr}function qP(n,e=n.length){const t=mr.add(e*2),r=Qt(n,0).mul(oo),i=Qt(n,8),s=Qt(n,e-8).mul(t),a=Qt(n,e-16).mul(mr);return Aa($n(r.add(i),43).add($n(s,30)).add(a),r.add($n(i.add(mr),18)).add(s),t)}function XP(n,e=n.length){const t=mr.add(e*2),r=Qt(n,0).mul(mr),i=Qt(n,8),s=Qt(n,e-8).mul(t),a=Qt(n,e-16).mul(mr),o=$n(r.add(i),43).add($n(s,30)).add(a),c=Aa(o,r.add($n(i.add(mr),18)).add(s),t),l=Qt(n,16).mul(t),u=Qt(n,24),f=o.add(Qt(n,e-32)).mul(t),d=c.add(Qt(n,e-24)).mul(t);return Aa($n(l.add(u),43).add($n(f,30)).add(d),l.add($n(u.add(r),18)).add(f),t)}function KP(n,e=n.length){const t=uo.fromNumber(81,!0);if(e<=32)return e<=16?WP(n,e):qP(n,e);if(e<=64)return XP(n,e);let r=t,i=t.mul(oo).add(113),s=ax(i.mul(mr).add(113)).mul(mr),a=[uo.UZERO,uo.UZERO],o=[uo.UZERO,uo.UZERO];r=r.mul(mr).add(Qt(n,0));let c=0;const l=(e-1>>6)*64,u=l+(e-1&63)-63;do r=$n(r.add(i).add(a[0]).add(Qt(n,c+8)),37).mul(oo),i=$n(i.add(a[1]).add(Qt(n,c+48)),42).mul(oo),r=r.xor(o[1]),i=i.add(a[0]).add(Qt(n,c+40)),s=$n(s.add(o[0]),33).mul(oo),a=Yd(n,c,a[1].mul(oo),r.add(o[0])),o=Yd(n,c+32,s.add(o[1]),i.add(Qt(n,c+16))),[s,r]=[r,s],c+=64;while(c!==l);const f=oo.add(s.and(255).shl(1));return c=u,o[0]=o[0].add(e-1&63),a[0]=a[0].add(o[0]),o[0]=o[0].add(a[0]),r=$n(r.add(i).add(a[0]).add(Qt(n,c+8)),37).mul(f),i=$n(i.add(a[1]).add(Qt(n,c+48)),42).mul(f),r=r.xor(o[1].mul(9)),i=i.add(a[0].mul(9).add(Qt(n,c+40))),s=$n(s.add(o[0]),33).mul(f),a=Yd(n,c,a[1].mul(f),r.add(o[0])),o=Yd(n,c+32,s.add(o[1]),i.add(Qt(n,c+16))),[s,r]=[r,s],Aa(Aa(a[0],o[0],f).add(ax(i).mul(y3)).add(s),Aa(a[1],o[1],f).add(r),f)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ua(n,e){return e==="string"?Ca(n):Go([n],e)}function jP(n,e){return n instanceof Float32Array&&e==="float32"||n instanceof Int32Array&&e==="int32"||n instanceof Uint8Array&&e==="bool"}function Go(n,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(n)&&(n=Ao(n)),ie().getBool("DEBUG")&&TP(n,e),jP(n,e))return n;if(e==null||e==="float32"||e==="complex64")return new Float32Array(n);if(e==="int32")return new Int32Array(n);if(e==="bool"){const t=new Uint8Array(n.length);for(let r=0;r<t.length;++r)Math.round(n[r])!==0&&(t[r]=1);return t}else throw new Error(`Unknown data type ${e}`)}function wr(){return ie().platform.now()}function Ca(n,e="utf-8"){return e=e||"utf-8",ie().platform.encode(n,e)}function Na(n,e="utf-8"){return e=e||"utf-8",ie().platform.decode(n,e)}function Ti(n){return ie().platform.isTypedArray!=null?ie().platform.isTypedArray(n):p3(n)}function Ao(n,e=[],t=!1){if(e==null&&(e=[]),typeof n=="boolean"||typeof n=="number"||typeof n=="string"||C0(n)||n==null||Ti(n)&&t)e.push(n);else if(Array.isArray(n)||Ti(n))for(let r=0;r<n.length;++r)Ao(n[r],e,t);else{let r=-1;for(const i of Object.keys(n))/^([1-9]+[0-9]*|0)$/.test(i)&&(r=Math.max(r,Number(i)));for(let i=0;i<=r;i++)Ao(n[i],e,t)}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YP{constructor(e,t){this.backendTimer=e,this.logger=t,t==null&&(this.logger=new QP)}profileKernel(e,t,r){let i;const s=()=>{i=r()};let a;const o=wr();if(this.backendTimer.timerAvailable())a=this.backendTimer.time(s);else{s();for(const l of i)l.dataSync();a=Promise.resolve({kernelMs:wr()-o})}if(ie().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let l=0;l<i.length;l++){const u=i[l];u.data().then(f=>{ZP(f,u.dtype,e)})}return{kernelName:e,outputs:i,inputs:t,timeMs:a.then(l=>l.kernelMs),extraInfo:a.then(l=>l.getExtraProfileInfo!=null?l.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:t,outputs:r,timeMs:i,inputs:s,extraInfo:a}=e;r.forEach(o=>{Promise.all([o.data(),i,a]).then(c=>{this.logger.logKernelProfile(t,o,c[0],c[1],s,c[2])})})}}function ZP(n,e,t){if(e!=="float32")return!1;for(let r=0;r<n.length;r++){const i=n[r];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${t}'`),!0}return!1}class QP{logKernelProfile(e,t,r,i,s,a){const o=typeof i=="number"?Pc(`${i}ms`,9):i.error,c=Pc(e,25),l=t.rank,u=t.size,f=Pc(t.shape.toString(),14);let d="";for(const h in s){const p=s[h];if(p!=null){const g=p.shape||t.shape,m=g.length;d+=`${h}: ${m}D ${m>0?g:""} `}}console.log(`%c${c}	%c${o}	%c${l}D ${f}	%c${u}	%c${d}	%c${a}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JP(n,e,t){const r={},i={};for(let c=0;c<e.length;c++)r[e[c].id]=!0;for(let c=0;c<n.length;c++){const l=n[c],u=l.inputs;for(const f in u){const d=u[f];let h=!1;for(let p=0;p<e.length;p++)if(r[d.id]){l.outputs.forEach(g=>r[g.id]=!0),h=!0,i[l.id]=!0;break}if(h)break}}const s={};s[t.id]=!0;const a={};for(let c=n.length-1;c>=0;c--){const l=n[c],u=l.inputs;for(let f=0;f<l.outputs.length;f++)if(s[l.outputs[f].id]){for(const d in u)s[u[d].id]=!0,a[l.id]=!0;break}}const o=[];for(let c=0;c<n.length;c++){const l=n[c];if(i[l.id]&&a[l.id]){const u={};for(const d in l.inputs){const h=l.inputs[d];r[h.id]&&(u[d]=h)}const f=Object.assign({},l);f.inputs=u,f.outputs=l.outputs,o.push(f)}}return o}function eF(n,e,t,r){for(let i=e.length-1;i>=0;i--){const s=e[i],a=[];if(s.outputs.forEach(c=>{const l=n[c.id];l!=null?a.push(l):a.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const o=s.gradient(a);for(const c in s.inputs){if(!(c in o))throw new Error(`Cannot backprop through input ${c}. Available gradients found: ${Object.keys(o)}.`);const l=t(()=>o[c]());if(l.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${c} must have 'float32' dtype, but has '${l.dtype}'`);const u=s.inputs[c];if(!Pt(l.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${c}' has shape '${l.shape}', which does not match the shape of the input '${u.shape}'`);if(n[u.id]==null)n[u.id]=l;else{const f=n[u.id];n[u.id]=r(f,l),f.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v2=20,nu=3,Pv=7;function tF(n,e,t,r){const i=Qe(e),s=nF(n,e,t,i),a=e.length,o=xh(n,e,t,i,s),c=["Tensor"];return r&&(c.push(`  dtype: ${t}`),c.push(`  rank: ${a}`),c.push(`  shape: [${e}]`),c.push("  values:")),c.push(o.map(l=>"    "+l).join(`
`)),c.join(`
`)}function nF(n,e,t,r){const i=ue(e),s=r[r.length-1],a=new Array(s).fill(0),o=e.length,c=t==="complex64"?uu(n):n;if(o>1)for(let l=0;l<i/s;l++){const u=l*s;for(let f=0;f<s;f++)a[f]=Math.max(a[f],lu(c[u+f],0,t).length)}return a}function lu(n,e,t){let r;return Array.isArray(n)?r=`${parseFloat(n[0].toFixed(Pv))} + ${parseFloat(n[1].toFixed(Pv))}j`:Gu(n)?r=`'${n}'`:t==="bool"?r=E3(n):r=parseFloat(n.toFixed(Pv)).toString(),Pc(r,e)}function E3(n){return n===0?"false":"true"}function xh(n,e,t,r,i,s=!0){const a=t==="complex64"?2:1,o=e[0],c=e.length;if(c===0){if(t==="complex64"){const g=uu(n);return[lu(g[0],0,t)]}return t==="bool"?[E3(n[0])]:[n[0].toString()]}if(c===1){if(o>v2){const m=nu*a;let v=Array.from(n.slice(0,m)),x=Array.from(n.slice((o-nu)*a,o*a));return t==="complex64"&&(v=uu(v),x=uu(x)),["["+v.map((b,_)=>lu(b,i[_],t)).join(", ")+", ..., "+x.map((b,_)=>lu(b,i[o-nu+_],t)).join(", ")+"]"]}return["["+(t==="complex64"?uu(n):Array.from(n)).map((m,v)=>lu(m,i[v],t)).join(", ")+"]"]}const l=e.slice(1),u=r.slice(1),f=r[0]*a,d=[];if(o>v2){for(let g=0;g<nu;g++){const m=g*f,v=m+f;d.push(...xh(n.slice(m,v),l,t,u,i,!1))}d.push("...");for(let g=o-nu;g<o;g++){const m=g*f,v=m+f;d.push(...xh(n.slice(m,v),l,t,u,i,g===o-1))}}else for(let g=0;g<o;g++){const m=g*f,v=m+f;d.push(...xh(n.slice(m,v),l,t,u,i,g===o-1))}const h=c===2?",":"";d[0]="["+(o>0?d[0]+h:"");for(let g=1;g<d.length-1;g++)d[g]=" "+d[g]+h;let p=`,
`;for(let g=2;g<c;g++)p+=`
`;return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":p),d}function uu(n){const e=[];for(let t=0;t<n.length;t+=2)e.push([n[t],n[t+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jn{constructor(e,t,r){if(this.dtype=t,this.shape=e.slice(),this.size=ue(e),r!=null){const i=r.length;R(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(t==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||gn(t,this.size),this.strides=Qe(e)}set(e,...t){t.length===0&&(t=[0]),R(t.length===this.rank,()=>`The number of provided coordinates (${t.length}) must match the rank (${this.rank})`);const r=this.locToIndex(t);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let t=0;for(const i of e){if(i<0||i>=this.shape[t]){const s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}t++}let r=e[e.length-1];for(let i=0;i<e.length-1;++i)r+=this.strides[i]*e[i];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let t=e[e.length-1];for(let r=0;r<e.length-1;++r)t+=this.strides[r]*e[r];return t}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const t=new Array(this.shape.length);for(let r=0;r<t.length-1;++r)t[r]=Math.floor(e/this.strides[r]),e-=t[r]*this.strides[r];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Pi().makeTensor(this.values,this.shape,this.dtype)}}let Pi=null,Ec=null;function rF(n){Pi=n}function iF(n){Ec=n}class Nn{constructor(e,t,r,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ue(e),this.strides=Qe(e),this.dataId=r,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Ec.buffer(this.shape,this.dtype,e)}bufferSync(){return Ec.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return Hi(this.shape,e,this.dtype==="complex64")}arraySync(){return Hi(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Pi().read(this.dataId);if(this.dtype==="string"){const t=await e;try{return t.map(r=>Na(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Pi().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Pi().readSync(this.dataId);if(this.dtype==="string")try{return e.map(t=>Na(t))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Pi().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Pi().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Ec.print(this,e)}clone(){return this.throwIfDisposed(),Ec.clone(this)}toString(e=!1){const t=this.dataSync();return tF(t,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Ec.cast(this,e)}variable(e=!0,t,r){return this.throwIfDisposed(),Pi().makeVariable(this,e,t,r)}}Object.defineProperty(Nn,Symbol.hasInstance,{value:n=>!!n&&n.data!=null&&n.dataSync!=null&&n.throwIfDisposed!=null});function ce(){return I0("Tensor",()=>Nn)}ce();class zh extends Nn{constructor(e,t,r,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=t,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Pt(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Pi().disposeTensor(this),this.dataId=e.dataId,Pi().incRef(this,null)}dispose(){Pi().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(zh,Symbol.hasInstance,{value:n=>n instanceof Nn&&n.assign!=null&&n.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var g2;(function(n){n.R0="R0",n.R1="R1",n.R2="R2",n.R3="R3",n.R4="R4",n.R5="R5",n.R6="R6"})(g2||(g2={}));var ox;(function(n){n.float32="float32",n.int32="int32",n.bool="int32",n.complex64="complex64"})(ox||(ox={}));var cx;(function(n){n.float32="float32",n.int32="int32",n.bool="bool",n.complex64="complex64"})(cx||(cx={}));var lx;(function(n){n.float32="float32",n.int32="float32",n.bool="float32",n.complex64="complex64"})(lx||(lx={}));var ux;(function(n){n.float32="complex64",n.int32="complex64",n.bool="complex64",n.complex64="complex64"})(ux||(ux={}));const sF={float32:lx,int32:ox,bool:cx,complex64:ux};function Hr(n,e){if(n==="string"||e==="string"){if(n==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${n} with ${e}`)}return sF[n][e]}function gb(n){return Hr(n,"int32")}function S3(n){return n!=null&&typeof n=="object"&&"texture"in n&&n.texture instanceof WebGLTexture}function T3(n){return typeof GPUBuffer<"u"&&n!=null&&typeof n=="object"&&"buffer"in n&&n.buffer instanceof GPUBuffer}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _n(n,e){if(n.dtype===e.dtype)return[n,e];const t=Hr(n.dtype,e.dtype);return[n.cast(t),e.cast(t)]}function A3(n){const e=[];return C3(n,e,new Set),e}function C3(n,e,t){if(n==null)return;if(n instanceof Nn){e.push(n);return}if(!aF(n))return;const r=n;for(const i in r){const s=r[i];t.has(s)||(t.add(s),C3(s,e,t))}}function aF(n){return Array.isArray(n)||typeof n=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fv(n){return n.kernelName!=null}class x2{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class nl{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new x2}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:t}=this.initializeBackend(e);if(t)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t,r=1){return e in this.registryFactory?(Qr(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:t,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:t,asyncInit:r}=this.initializeBackend(e);if(!(r?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new YP(this.backendInstance),!0}setupRegisteredKernels(){l2(this.backendName).forEach(t=>{t.setupFunc!=null&&t.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){l2(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const t=this.registryFactory[e];if(t==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=t.factory();if(r&&!(r instanceof w0)&&typeof r.then=="function"){const i=++this.pendingBackendInitId,s=r.then(a=>i<this.pendingBackendInitId?!1:(this.registry[e]=a,this.pendingBackendInit=null,!0)).catch(a=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,Qr(`Initialization of backend ${e} failed`),Qr(a.stack||a.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return Qr(`Initialization of backend ${e} failed`),Qr(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const r=e[t],{success:i,asyncInit:s}=this.initializeBackend(r);if(s||i)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const r=this.state.tensorInfo.get(t),i=r.backend,s=this.readSync(t),a=i.refCount(t);i.disposeData(t,!0),r.backend=e,e.move(t,s,r.shape,r.dtype,a),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let r=null;if(t==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");t=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof t!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let i;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(i),()=>(i=t(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,t,r){e();try{const i=r();return t(),i}catch(i){throw t(),i}}nextTensorId(){return nl.nextTensorId++}nextVariableId(){return nl.nextVariableId++}clone(e){const t=X.runKernel(ff,{x:e}),r={x:e},i=a=>({x:()=>{const o="float32",c={x:a},l={dtype:o};return X.runKernel(Zu,c,l)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[t],i,s,{}),t}runKernel(e,t,r){if(this.backendName==null&&this.backend,!(o2(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:t,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,r){const i=this.backend.numDataIds();let s=0;r.forEach(c=>{s+=c.dtype==="complex64"?3:1});const a=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=i-t-s-a;if(o>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${o} data ids) after running '${e}'`)}runKernelFunc(e){let t,r=[];const i=this.isTapeOn(),s=this.state.numBytes,a=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let o;this.backendName==null&&this.backend;let c;const l=Fv(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(Fv(e)){const{kernelName:p,inputs:g,attrs:m}=e;this.backendName==null&&this.backend;const v=o2(p,this.backendName);R(v!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),o=()=>{const x=this.backend.numDataIds();c=v.kernelFunc({inputs:g,attrs:m,backend:this.backend});const b=Array.isArray(c)?c:[c];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,x,b);const _=b.map(w=>w.rank!=null?w:this.makeTensorFromTensorInfo(w));if(i){const w=this.getTensorsForGradient(p,g,_);r=this.saveTensorsForBackwardMode(w)}return _}}else{const{forwardFunc:p}=e,g=m=>{i&&(r=m.map(v=>this.keep(this.clone(v))))};o=()=>{const m=this.backend.numDataIds();c=this.tidy(()=>p(this.backend,g));const v=Array.isArray(c)?c:[c];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(l,m,v),v}}const{inputs:u,attrs:f}=e,d=Fv(e)?null:e.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?t=o():(h=this.profiler.profileKernel(l,u,()=>o()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),t=h.outputs)}),i&&this.addTapeNode(l,u,t,d,r,f),this.state.profiling&&this.state.activeProfile.kernels.push({name:l,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-a,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:t.map(p=>p.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(c)?t:t[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,t,r){const i=c2(e);if(i!=null){const s=i.inputsToSave||[],a=i.outputsToSave||[];let o;i.saveAllInputs?(R(Array.isArray(t),()=>"saveAllInputs is true, expected inputs to be an array."),o=Object.keys(t).map(l=>t[l])):o=s.map(l=>t[l]);const c=r.filter((l,u)=>a[u]);return o.concat(c)}return[]}makeTensor(e,t,r,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",i=i||this.backend;let s=e;r==="string"&&Gu(e[0])&&(s=e.map(c=>Ca(c)));const a=i.write(s,t,r),o=new Nn(t,r,a,this.nextTensorId());if(this.trackTensor(o,i),r==="string"){const c=this.state.tensorInfo.get(a),l=CP(s);this.state.numBytes+=l-c.bytes,c.bytes=l}return o}makeTensorFromDataId(e,t,r,i){r=r||"float32";const s={dataId:e,shape:t,dtype:r};return this.makeTensorFromTensorInfo(s,i)}makeTensorFromTensorInfo(e,t){const{dataId:r,shape:i,dtype:s}=e,a=new Nn(i,s,r,this.nextTensorId());return this.trackTensor(a,t),a}makeVariable(e,t=!0,r,i){r=r||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const s=new zh(e,t,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,t){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*Nh(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof zh||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*Nh(e.dtype);this.state.numBytes-=r}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,t,r,i,s,a){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:r,saved:s},c=c2(e);c!=null&&(i=c.gradFunc),i!=null&&(o.gradient=l=>(l=l.map((u,f)=>{if(u==null){const d=r[f],h=sr(d.size,d.dtype);return this.makeTensor(h,d.shape,d.dtype)}return u}),i(l.length>1?l:l[0],s,a))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=A3(e),r=new Set(t.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const a=this.state.activeScope.track[s];!a.kept&&!r.has(a.id)&&a.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach(s=>{!s.kept&&s.scopeId===i.id&&this.track(s)})}gradients(e,t,r,i=!1){if(R(t.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));R(s instanceof Nn,()=>"The result y returned by f() must be a tensor.");const a=JP(this.state.activeTape,t,s);if(!i&&a.length===0&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const o={};o[s.id]=r??oF(s.shape),eF(o,a,l=>this.tidy(l),cF);const c=t.map(l=>o[l.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(l=>{for(const u of l.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:c}})}customGrad(e){return R(ex(e),()=>"The f passed in customGrad(f) must be a function."),(...t)=>{R(t.every(o=>o instanceof Nn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const i={};t.forEach((o,c)=>{i[c]=o});const s=(o,c)=>(r=e(...t,c),R(r.value instanceof Nn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),R(ex(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),a=(o,c)=>{const l=r.gradFunc(o,c),u=Array.isArray(l)?l:[l];R(u.length===t.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),R(u.every(d=>d instanceof Nn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const f={};return u.forEach((d,h)=>{f[h]=()=>d}),f};return this.runKernelFunc({forwardFunc:s,backwardsFunc:a,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=wr(),r=await this.backend.time(e);return r.wallMs=wr()-t,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new x2;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}nl.nextTensorId=0;nl.nextVariableId=0;function oF(n){const e=A0(ue(n),"float32");return X.makeTensor(e,n,"float32")}function I3(){const n=HE();if(n._tfengine==null){const e=new RP(n);n._tfengine=new nl(e)}return LP(n._tfengine.ENV),rF(()=>n._tfengine),n._tfengine}const X=I3();function cF(n,e){const t={a:n,b:e};return X.runKernel(El,t)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lF(){return typeof navigator<"u"&&navigator!=null}function M3(n){if(n||lF()){if(n||(n=navigator),n.product==="ReactNative")return!0;const e=n.userAgent||n.vendor||(typeof window<"u"?window.opera:"");if(!e){const t=n;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function R3(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Rr=ie();Rr.registerFlag("DEBUG",()=>!1,n=>{n&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});Rr.registerFlag("IS_BROWSER",()=>R3());Rr.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");Rr.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));Rr.registerFlag("IS_SAFARI",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor));Rr.registerFlag("PROD",()=>!1);Rr.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>Rr.getBool("DEBUG"));Rr.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);Rr.registerFlag("IS_TEST",()=>!1);Rr.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>Rr.getBool("DEBUG"));Rr.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);Rr.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);Rr.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uf(n,e){let t=n;if(Ti(n))return e==="string"?[]:[n.length];if(S3(n)){const i=n.channels||"RGBA";return[n.height,n.width*i.length]}else if(T3(n))return[n.buffer.size/(e==null?4:Nh(e))];if(!Array.isArray(n))return[];const r=[];for(;Array.isArray(t)||Ti(t)&&e!=="string";)r.push(t.length),t=t[0];return Array.isArray(n)&&ie().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&N3(n,r,[]),r}function N3(n,e,t){if(t=t||[],!Array.isArray(n)&&!Ti(n)){R(e.length===0,()=>`Element arr[${t.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}R(e.length>0,()=>`Element arr[${t.join("][")}] should be a primitive, but is an array of ${n.length} elements`),R(n.length===e[0],()=>`Element arr[${t.join("][")}] should have ${e[0]} elements, but has ${n.length} elements`);const r=e.slice(1);for(let i=0;i<n.length;++i)N3(n[i],r,t.concat(i))}function b2(n,e,t,r){if(n!=="string_or_numeric"){if(n==null)throw new Error("Expected dtype cannot be null.");if(n!=="numeric"&&n!==e||n==="numeric"&&e==="string")throw new Error(`Argument '${t}' passed to '${r}' must be ${n} tensor, but got ${e} tensor`)}}function U(n,e,t,r="numeric"){if(n instanceof ce())return b2(r,n.dtype,e,t),n;let i=yl(n);if(i!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),b2(r,i,e,t),n==null||!Ti(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string"){const c=n==null?"null":n.constructor.name;throw new Error(`Argument '${e}' passed to '${t}' must be a Tensor or TensorLike, but got '${c}'`)}const s=Uf(n,i);!Ti(n)&&!Array.isArray(n)&&(n=[n]);const o=i!=="string"?Go(n,i):Ao(n,[],!0);return X.makeTensor(o,s,i)}function k3(n,e,t,r="numeric"){if(!Array.isArray(n))throw new Error(`Argument ${e} passed to ${t} must be a \`Tensor[]\` or \`TensorLike[]\``);return n.map((s,a)=>U(s,`${e}[${a}]`,t,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uF="__op";function Y(n){const e=Object.keys(n);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let t=e[0];const r=n[t];t.endsWith("_")&&(t=t.substring(0,t.length-1)),t=t+uF;const i=(...s)=>{X.startScope(t);try{const a=r(...s);return C0(a)&&console.error("Cannot return a Promise inside of tidy."),X.endScope(a),a}catch(a){throw X.endScope(null),a}};return Object.defineProperty(i,"name",{value:t,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fF(n,e){const t=U(n,"real","complex"),r=U(e,"imag","complex");S0(t.shape,r.shape,`real and imag shapes, ${t.shape} and ${r.shape}, must match in call to tf.complex().`);const i={real:t,imag:r};return X.runKernel(z0,i)}const rl=Y({complex_:fF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bf(n,e,t,r){if(r==null)r=yl(n);else if(r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(T3(n)||S3(n)){if(r!=="float32"&&r!=="int32")throw new Error(`Creating tensor from GPU data only supports 'float32'|'int32' dtype, while the dtype is ${r}.`);return X.backend.createTensorFromGPUData(n,e||t,r)}if(!Ti(n)&&!Array.isArray(n)&&typeof n!="number"&&typeof n!="boolean"&&typeof n!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){ea(e);const i=ue(e),s=ue(t);R(i===s,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${s}`);for(let a=0;a<t.length;++a){const o=t[a],c=a===t.length-1?o!==ue(e.slice(a)):!0;R(t[a]===e[a]||!c,()=>`Error creating a new Tensor. Inferred shape (${t}) does not match the provided shape (${e}). `)}}return!Ti(n)&&!Array.isArray(n)&&(n=[n]),e=e||t,n=r!=="string"?Go(n,r):Ao(n,[],!0),X.makeTensor(n,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xb(n,e,t){const r=Uf(n,t);return Bf(n,e,r,t)}class Sl{static join(e){return new Sl(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,e==null||(e instanceof Array||(e=[e]),e=e.map(r=>Ti(r)?r.buffer:r),e.length===0))return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let r=0;r<e.length;r++){const i=e[r];r!==e.length-1&&i.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const s=t+i.byteLength;this.shards.push({buffer:i,start:t,end:s}),t=s}this.shards.length===0&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(e=0,t=this.byteLength){if(this.shards.length===0)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const r=this.findShardForByte(e);if(r===-1)throw new Error(`Could not find start shard for byte ${e}`);const i=t-e,s=new ArrayBuffer(i),a=new Uint8Array(s);let o=0;for(let c=r;c<this.shards.length;c++){const l=this.shards[c],f=e+o-l.start,d=o,p=Math.min(t,l.end)-l.start,g=new Uint8Array(l.buffer,f,p-f);if(a.set(g,d),o+=g.length,t<l.end)break}return s}findShardForByte(e){if(this.shards.length===0||e<0||e>=this.byteLength)return-1;if(this.bufferUniformSize!=null)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(i){return e<i.start?-1:e>=i.end?1:0}if(t(this.shards[this.previousShardIndex])===0)return this.previousShardIndex;const r=dF(this.shards,t);return r===-1?-1:(this.previousShardIndex=r,this.previousShardIndex)}}function dF(n,e){let t=0,r=n.length;for(;t<=r;){const i=Math.floor((r-t)/2)+t,s=e(n[i]);if(s===0)return i;s<0?r=i:t=i+1}return-1}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hF(){ie().set("PROD",!0)}function Fr(){return X}function fx(){return X.memory()}function te(n,e){return X.tidy(n,e)}function He(n){A3(n).forEach(t=>t.dispose())}function fs(n){return X.keep(n)}function pF(n){return X.setBackend(n)}function mF(){return X.ready()}function D3(n,e,t=1){return X.registerBackend(n,e,t)}function Vf(){return X.backend}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _2=4;async function y2(n,e){const t=[],r=[],i=Array.isArray(n)?n.map(a=>a.name):Object.keys(n);for(let a=0;a<i.length;++a){const o=i[a],c=Array.isArray(n)?n[a].tensor:n[o];if(c.dtype!=="float32"&&c.dtype!=="int32"&&c.dtype!=="bool"&&c.dtype!=="string"&&c.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${o}': ${c.dtype}`);const l={name:o,shape:c.shape,dtype:c.dtype};if(c.dtype==="string"){const u=new Promise(async f=>{const d=await c.bytes(),h=d.reduce((m,v)=>m+v.length,0)+_2*d.length,p=new Uint8Array(h);let g=0;for(let m=0;m<d.length;m++){const v=d[m],x=new Uint8Array(new Uint32Array([v.length]).buffer);p.set(x,g),g+=_2,p.set(v,g),g+=v.length}f(p)});r.push(u)}else r.push(c.data());e!=null&&(l.group=e),t.push(l)}const s=await Promise.all(r);return{data:vF(s),specs:t}}function vF(n){if(n===null)throw new Error(`Invalid input value: ${JSON.stringify(n)}`);let e=0;const t=[];n.forEach(s=>{if(e+=s.byteLength,t.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const r=new Uint8Array(e);let i=0;return t.forEach(s=>{r.set(new Uint8Array(s.buffer),i),i+=s.byteLength}),r.buffer}const bb=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function w2(n){return bb?Buffer.byteLength(n,"utf8"):new Blob([n]).size}function gF(n){if(bb)return Buffer.from(n).toString("base64");const e=new Uint8Array(n);let t="";for(let r=0,i=e.length;r<i;r++)t+=String.fromCharCode(e[r]);return btoa(t)}function xF(n){if(bb){const r=Buffer.from(n,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(n),t=new Uint8Array(e.length);for(let r=0;r<e.length;++r)t.set([e.charCodeAt(r)],r);return t.buffer}function bF(n){return Sl.join(n)}function L3(n){if(n.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:n.modelTopology==null?0:w2(JSON.stringify(n.modelTopology)),weightSpecsBytes:n.weightSpecs==null?0:w2(JSON.stringify(n.weightSpecs)),weightDataBytes:n.weightData==null?0:new Sl(n.weightData).byteLength}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hr{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return hr.instance==null&&(hr.instance=new hr),hr.instance}static registerSaveRouter(e){hr.getInstance().saveRouters.push(e)}static registerLoadRouter(e){hr.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return hr.getHandlers(e,"save")}static getLoadHandlers(e,t){return hr.getHandlers(e,"load",t)}static getHandlers(e,t,r){const i=[];return(t==="load"?hr.getInstance().loadRouters:hr.getInstance().saveRouters).forEach(a=>{const o=a(e,r);o!==null&&i.push(o)}),i}}const _F=n=>hr.getSaveHandlers(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dx="tensorflowjs",hx=1,go="models_store",_a="model_info_store";function O3(){if(!ie().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const n=typeof window>"u"?self:window,e=n.indexedDB||n.mozIndexedDB||n.webkitIndexedDB||n.msIndexedDB||n.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function px(n){const e=n.result;e.createObjectStore(go,{keyPath:"modelPath"}),e.createObjectStore(_a,{keyPath:"modelPath"})}class Co{constructor(e){if(this.indexedDB=O3(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise((r,i)=>{const s=this.indexedDB.open(dx,hx);s.onupgradeneeded=()=>px(s),s.onsuccess=()=>{const a=s.result;if(t==null){const o=a.transaction(go,"readonly"),l=o.objectStore(go).get(this.modelPath);l.onsuccess=()=>{if(l.result==null)return a.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(l.result.modelArtifacts)},l.onerror=u=>(a.close(),i(l.error)),o.oncomplete=()=>a.close()}else{t.weightData=Sl.join(t.weightData);const o=L3(t),c=a.transaction(_a,"readwrite");let l=c.objectStore(_a),u;try{u=l.put({modelPath:this.modelPath,modelArtifactsInfo:o})}catch(d){return i(d)}let f;u.onsuccess=()=>{f=a.transaction(go,"readwrite");const d=f.objectStore(go);let h;try{h=d.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:o})}catch(p){return i(p)}h.onsuccess=()=>r({modelArtifactsInfo:o}),h.onerror=p=>{l=c.objectStore(_a);const g=l.delete(this.modelPath);g.onsuccess=()=>(a.close(),i(h.error)),g.onerror=m=>(a.close(),i(h.error))}},u.onerror=d=>(a.close(),i(u.error)),c.oncomplete=()=>{f==null?a.close():f.oncomplete=()=>a.close()}}},s.onerror=a=>i(s.error)})}}Co.URL_SCHEME="indexeddb://";const z3=n=>ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Co.URL_SCHEME)?yF(n.slice(Co.URL_SCHEME.length)):null;hr.registerSaveRouter(z3);hr.registerLoadRouter(z3);function yF(n){return new Co(n)}function wF(n){return n.startsWith(Co.URL_SCHEME)?n.slice(Co.URL_SCHEME.length):n}class EF{constructor(){this.indexedDB=O3()}async listModels(){return new Promise((e,t)=>{const r=this.indexedDB.open(dx,hx);r.onupgradeneeded=()=>px(r),r.onsuccess=()=>{const i=r.result,s=i.transaction(_a,"readonly"),o=s.objectStore(_a).getAll();o.onsuccess=()=>{const c={};for(const l of o.result)c[l.modelPath]=l.modelArtifactsInfo;e(c)},o.onerror=c=>(i.close(),t(o.error)),s.oncomplete=()=>i.close()},r.onerror=i=>t(r.error)})}async removeModel(e){return e=wF(e),new Promise((t,r)=>{const i=this.indexedDB.open(dx,hx);i.onupgradeneeded=()=>px(i),i.onsuccess=()=>{const s=i.result,a=s.transaction(_a,"readwrite"),o=a.objectStore(_a),c=o.get(e);let l;c.onsuccess=()=>{if(c.result==null)return s.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=o.delete(e),f=()=>{l=s.transaction(go,"readwrite");const h=l.objectStore(go).delete(e);h.onsuccess=()=>t(c.result.modelArtifactsInfo),h.onerror=p=>r(c.error)};u.onsuccess=f,u.onerror=d=>(f(),s.close(),r(c.error))}},c.onerror=u=>(s.close(),r(c.error)),a.oncomplete=()=>{l==null?s.close():l.oncomplete=()=>s.close()}},i.onerror=s=>r(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zs="/",Sc="tensorflowjs_models",P3="info",SF="model_topology",TF="weight_specs",AF="weight_data",CF="model_metadata";function F3(n){return{info:[Sc,n,P3].join(zs),topology:[Sc,n,SF].join(zs),weightSpecs:[Sc,n,TF].join(zs),weightData:[Sc,n,AF].join(zs),modelMetadata:[Sc,n,CF].join(zs)}}function $3(n){for(const e of Object.values(n))window.localStorage.removeItem(e)}function IF(n){const e=n.split(zs);if(e.length<3)throw new Error(`Invalid key format: ${n}`);return e.slice(1,e.length-1).join(zs)}function MF(n){return n.startsWith(Io.URL_SCHEME)?n.slice(Io.URL_SCHEME.length):n}class Io{constructor(e){if(!ie().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=F3(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),i=L3(e),s=Sl.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,gF(s));const a={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,initializerSignature:e.initializerSignature!=null?e.initializerSignature:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(a)),{modelArtifactsInfo:i}}catch{throw $3(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);t.modelTopology=r;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);t.weightSpecs=i;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const o=JSON.parse(s);t.format=o.format,t.generatedBy=o.generatedBy,t.convertedBy=o.convertedBy,o.signature!=null&&(t.signature=o.signature),o.userDefinedMetadata!=null&&(t.userDefinedMetadata=o.userDefinedMetadata),o.modelInitializer!=null&&(t.modelInitializer=o.modelInitializer),o.initializerSignature!=null&&(t.initializerSignature=o.initializerSignature),o.trainingConfig!=null&&(t.trainingConfig=o.trainingConfig)}const a=this.LS.getItem(this.keys.weightData);if(a==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return t.weightData=xF(a),t}}Io.URL_SCHEME="localstorage://";const U3=n=>ie().getBool("IS_BROWSER")&&!Array.isArray(n)&&n.startsWith(Io.URL_SCHEME)?RF(n.slice(Io.URL_SCHEME.length)):null;hr.registerSaveRouter(U3);hr.registerLoadRouter(U3);function RF(n){return new Io(n)}class NF{constructor(){R(ie().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),R(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},t=Sc+zs,r=zs+P3;for(let i=0;i<this.LS.length;++i){const s=this.LS.key(i);if(s.startsWith(t)&&s.endsWith(r)){const a=IF(s);e[a]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=MF(e);const t=F3(e);if(this.LS.getItem(t.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(t.info));return $3(t),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E2="://";class ns{constructor(){this.managers={}}static getInstance(){return ns.instance==null&&(ns.instance=new ns),ns.instance}static registerManager(e,t){R(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(E2)&&(e=e.slice(0,e.indexOf(E2))),R(e.length>0,()=>"scheme must not be an empty string.");const r=ns.getInstance();R(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=t}static getManager(e){const t=ns.getInstance().managers[e];if(t==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return t}static getSchemes(){return Object.keys(ns.getInstance().managers)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kF{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${t}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){if(typeof window>"u"||!ie().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,t);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const i=this.functionRefs[r.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}isTypedArray(e){return p3(e)}}if(ie().get("IS_BROWSER")){ie().setPlatform("browser",new kF);try{ns.registerManager(Io.URL_SCHEME,new NF)}catch{}try{ns.registerManager(Co.URL_SCHEME,new EF)}catch{}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DF={importFetch:()=>require("node-fetch")};let $v;class LF{constructor(){this.util=require("util"),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return ie().global.fetch!=null?ie().global.fetch(e,t):($v==null&&($v=DF.importFetch()),$v(e,t))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,t){if(t!=="utf-8"&&t!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${t}`);return this.textEncoder.encode(e)}decode(e,t){return e.length===0?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}ie().get("IS_NODE")&&!ie().get("IS_BROWSER")&&ie().setPlatform("node",new LF);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Et(n,e="float32",t){return e=e||"float32",ea(n),new jn(n,e,t)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OF(n,e){const t=U(n,"x","cast");if(!AP(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&t.dtype!=="string"||e!=="string"&&t.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:t},i={dtype:e};return X.runKernel(Zu,r,i)}const Ie=Y({cast_:OF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zF(n){const t={x:U(n,"x","clone","string_or_numeric")};return X.runKernel(ff,t)}const bo=Y({clone_:zF});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PF(n,e=!1){console.log(n.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */I3();const FF={buffer:Et,cast:Ie,clone:bo,print:PF};iF(FF);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $F(n,e){let t=U(n,"a","add"),r=U(e,"b","add");[t,r]=_n(t,r);const i={a:t,b:r};return X.runKernel(El,i)}const ye=Y({add_:$F});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UF(n,e){let t=U(n,"a","floorDiv"),r=U(e,"b","floorDiv");[t,r]=_n(t,r);const i={a:t,b:r};return X.runKernel(lf,i)}const B3=Y({floorDiv_:UF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BF(n,e){let t=U(n,"a","div"),r=U(e,"b","div");if([t,r]=_n(t,r),t.dtype==="int32"&&r.dtype==="int32")return B3(t,r);const i={a:t,b:r},s={};return X.runKernel(nf,i,s)}const nt=Y({div_:BF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VF(n,e){let t=U(n,"a","mul"),r=U(e,"b","mul");[t,r]=_n(t,r);const i={a:t,b:r};return X.runKernel(_f,i)}const W=Y({mul_:VF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GF(n){const e=U(n,"x","abs");if(e.dtype==="complex64"){const t={x:e};return X.runKernel(Tp,t)}else{const t={x:e};return X.runKernel(xp,t)}}const pr=Y({abs_:GF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HF(n){const t={x:U(n,"x","acos")};return X.runKernel(Hu,t)}const WF=Y({acos_:HF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qF(n){const t={x:U(n,"x","acosh")};return X.runKernel(Wu,t)}const XF=Y({acosh_:qF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KF(n,e=null,t=!1){const i={x:U(n,"x","all","bool")},s={axis:e,keepDims:t};return X.runKernel(R0,i,s)}const V3=Y({all_:KF});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jF(n,e=null,t=!1){const i={x:U(n,"x","any","bool")},s={axis:e,keepDims:t};return X.runKernel(N0,i,s)}const mx=Y({any_:jF});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YF(n,e=0){const r={x:U(n,"x","argMax")},i={axis:e};return X.runKernel(bp,r,i)}const Su=Y({argMax_:YF});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZF(n,e=0){const r={x:U(n,"x","argMin")},i={axis:e};return X.runKernel(_p,r,i)}const QF=Y({argMin_:ZF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JF(n){const t={x:U(n,"x","asin")};return X.runKernel(qu,t)}const e$=Y({asin_:JF});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t$(n){const t={x:U(n,"x","asinh")};return X.runKernel(Xu,t)}const n$=Y({asinh_:t$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r$(n){const t={x:U(n,"x","atan")};return X.runKernel(Ku,t)}const i$=Y({atan_:r$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s$(n,e){let t=U(n,"a","atan2"),r=U(e,"b","atan2");[t,r]=_n(t,r);const i={a:t,b:r};return X.runKernel(Yu,i)}const a$=Y({atan2_:s$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o$(n){const t={x:U(n,"x","atanh")};return X.runKernel(ju,t)}const c$=Y({atanh_:o$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gf(n,e,t,r,i="NHWC",s){const a=n[3],o=[...e,a],c=na(i);return Yn(n,o,t,s,r,null,null,c)}function Ii(n,e,t,r,i,s,a="channelsLast"){const[o,c]=Tu(e);let l;if(a==="channelsLast")l=[o,c,n[3],n[3]];else if(a==="channelsFirst")l=[o,c,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Yn(n,l,t,r,i,s,!1,a)}function ta(n,e,t,r,i,s,a="NDHWC"){const[o,c,l]=vx(e);let u,f;if(a==="NDHWC")f="channelsLast",u=[o,c,l,n[4],n[4]];else if(a==="NCDHW")f="channelsFirst",u=[o,c,l,n[1],n[1]];else throw new Error(`Unknown dataFormat ${a}`);return Ba(n,u,t,r,i,!1,f,s)}function Yn(n,e,t,r,i,s,a=!1,o="channelsLast"){let[c,l,u,f]=[-1,-1,-1,-1];if(o==="channelsLast")[c,l,u,f]=n;else if(o==="channelsFirst")[c,f,l,u]=n;else throw new Error(`Unknown dataFormat ${o}`);const[d,h,,p]=e,[g,m]=Tu(t),[v,x]=Tu(r),b=$c(d,v),_=$c(h,x),{padInfo:w,outHeight:E,outWidth:S}=f$(i,l,u,g,m,b,_,s,o),T=a?p*f:p;let C;return o==="channelsFirst"?C=[c,T,E,S]:o==="channelsLast"&&(C=[c,E,S,T]),{batchSize:c,dataFormat:o,inHeight:l,inWidth:u,inChannels:f,outHeight:E,outWidth:S,outChannels:T,padInfo:w,strideHeight:g,strideWidth:m,filterHeight:d,filterWidth:h,effectiveFilterHeight:b,effectiveFilterWidth:_,dilationHeight:v,dilationWidth:x,inShape:n,outShape:C,filterShape:e}}function Ba(n,e,t,r,i,s=!1,a="channelsLast",o){let[c,l,u,f,d]=[-1,-1,-1,-1,-1];if(a==="channelsLast")[c,l,u,f,d]=n;else if(a==="channelsFirst")[c,d,l,u,f]=n;else throw new Error(`Unknown dataFormat ${a}`);const[h,p,g,,m]=e,[v,x,b]=vx(t),[_,w,E]=vx(r),S=$c(h,_),T=$c(p,w),C=$c(g,E),{padInfo:y,outDepth:A,outHeight:k,outWidth:M}=d$(i,l,u,f,v,x,b,S,T,C,o),L=s?m*d:m;let z;return a==="channelsFirst"?z=[c,L,A,k,M]:a==="channelsLast"&&(z=[c,A,k,M,L]),{batchSize:c,dataFormat:a,inDepth:l,inHeight:u,inWidth:f,inChannels:d,outDepth:A,outHeight:k,outWidth:M,outChannels:L,padInfo:y,strideDepth:v,strideHeight:x,strideWidth:b,filterDepth:h,filterHeight:p,filterWidth:g,effectiveFilterDepth:S,effectiveFilterHeight:T,effectiveFilterWidth:C,dilationDepth:_,dilationHeight:w,dilationWidth:E,inShape:n,outShape:z,filterShape:e}}function l$(n,e,t,r,i){r==null&&(r=_b(n,e,t));const s=n[0],a=n[1],o=Au((s-e+2*r)/t+1,i),c=Au((a-e+2*r)/t+1,i);return[o,c]}function u$(n,e,t,r,i,s){i==null&&(i=_b(n,e[0],r[0]));const a=[0,0,0,t];for(let o=0;o<3;o++)n[o]+2*i>=e[o]&&(a[o]=Au((n[o]-e[o]+2*i)/r[o]+1,s));return a}function _b(n,e,t,r=1){const i=$c(e,r);return Math.floor((n[0]*(t-1)-t+i)/2)}function Tu(n){return typeof n=="number"?[n,n,n]:n.length===2?[n[0],n[1],1]:n}function vx(n){return typeof n=="number"?[n,n,n]:n}function $c(n,e){return e<=1?n:n+(n-1)*(e-1)}function f$(n,e,t,r,i,s,a,o,c){let l,u,f;if(typeof n=="number"){l={top:n,bottom:n,left:n,right:n,type:n===0?"VALID":"NUMBER"};const h=l$([e,t],s,r,n,o);u=h[0],f=h[1]}else if(n==="same"){u=Math.ceil(e/r),f=Math.ceil(t/i);const d=Math.max(0,(u-1)*r+s-e),h=Math.max(0,(f-1)*i+a-t),p=Math.floor(d/2),g=d-p,m=Math.floor(h/2),v=h-m;l={top:p,bottom:g,left:m,right:v,type:"SAME"}}else if(n==="valid")l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),f=Math.ceil((t-a+1)/i);else if(typeof n=="object"){const d=c==="channelsLast"?n[1][0]:n[2][0],h=c==="channelsLast"?n[1][1]:n[2][1],p=c==="channelsLast"?n[2][0]:n[3][0],g=c==="channelsLast"?n[2][1]:n[3][1];l={top:d,bottom:h,left:p,right:g,type:d===0&&h===0&&p===0&&g===0?"VALID":"EXPLICIT"},u=Au((e-s+d+h)/r+1,o),f=Au((t-a+p+g)/i+1,o)}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:l,outHeight:u,outWidth:f}}function d$(n,e,t,r,i,s,a,o,c,l,u){let f,d,h,p;if(n==="valid"&&(n=0),typeof n=="number"){f={top:n,bottom:n,left:n,right:n,front:n,back:n,type:n===0?"VALID":"NUMBER"};const m=u$([e,t,r,1],[o,c,l],1,[i,s,a],n,u);d=m[0],h=m[1],p=m[2]}else if(n==="same"){d=Math.ceil(e/i),h=Math.ceil(t/s),p=Math.ceil(r/a);const g=(d-1)*i+o-e,m=(h-1)*s+c-t,v=(p-1)*a+l-r,x=Math.floor(g/2),b=g-x,_=Math.floor(m/2),w=m-_,E=Math.floor(v/2),S=v-E;f={top:_,bottom:w,left:E,right:S,front:x,back:b,type:"SAME"}}else throw Error(`Unknown padding parameter: ${n}`);return{padInfo:f,outDepth:d,outHeight:h,outWidth:p}}function Au(n,e){if(!e)return Math.trunc(n);switch(e){case"round":return Math.round(n);case"ceil":return Math.ceil(n);case"floor":return Math.floor(n);default:throw new Error(`Unknown roundingMode ${e}`)}}function Mo(n){const[e,t,r]=Tu(n);return e===1&&t===1&&r===1}function or(n,e){return Mo(n)||Mo(e)}function Ro(n){return Tu(n).every(e=>e>0)}function na(n){if(n==="NHWC")return"channelsLast";if(n==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${n}`)}function kr(n,e,t){if(t!=null){if(typeof e=="string")throw Error(`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);if(typeof e=="number")R(el(e),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(i=>{R(el(i),()=>`Error in ${n}: pad must be an integer when using dimRoundingMode ${t} but got pad ${i}.`)})});else throw Error(`Error in ${n}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h$(n,e){const r={x:U(n,"x","reshape","string_or_numeric")},i={shape:e};return X.runKernel(sm,r,i)}const j=Y({reshape_:h$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p$(n,e,t,r,i){const s=U(n,"x","avgPool","float32"),a=1;R(or(t,a),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`);let o=s,c=!1;s.rank===3&&(c=!0,o=j(s,[1,s.shape[0],s.shape[1],s.shape[2]])),R(o.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${o.rank}.`),kr("avgPool",r,i);const l={x:o},u={filterSize:e,strides:t,pad:r,dimRoundingMode:i};let f=X.runKernel(yp,l,u);return f=Ie(f,s.dtype),c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const yb=Y({avgPool_:p$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m$(n,e,t,r,i,s="NDHWC"){const a=U(n,"x","avgPool3d","float32");let o=a,c=!1;a.rank===4&&(c=!0,o=j(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),R(o.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${o.rank}.`),R(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),R(typeof t=="number"&&t>0||Array.isArray(t)&&t[0]>0&&t[1]>0&&t[2]>0,()=>`Error in avgPool3d: Stride must be > 0, but got '${t}'`),kr("avgPool3d",r,i);const l={x:o},u={filterSize:e,strides:t,pad:r,dimRoundingMode:i,dataFormat:s};let f=X.runKernel(wp,l,u);return f=Ie(f,o.dtype),c?j(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const v$=Y({avgPool3d_:m$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g$(n,e=0){R(n.length>=1,()=>"Pass at least one tensor to concat");const t=k3(n,"tensors","concat","string_or_numeric");if(t[0].dtype==="complex64"&&t.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),t.length===1)return bo(t[0]);const r=t,i={axis:e};return X.runKernel(Ap,r,i)}const nr=Y({concat_:g$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x$(n,e,t=!1,r=!1){let i=U(n,"a","matMul"),s=U(e,"b","matMul");[i,s]=_n(i,s);const a={a:i,b:s},o={transposeA:t,transposeB:r};return X.runKernel(Ep,a,o)}const Ot=Y({matMul_:x$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b$(n){const t={x:U(n,"x","sigmoid","float32")};return X.runKernel(Nf,t)}const Tl=Y({sigmoid_:b$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _$(n,e,t){const r=U(n,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const i={x:r},s={begin:e,size:t};return X.runKernel(um,i,s)}const Jt=Y({slice_:_$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y$(n){const t={x:U(n,"x","tanh","float32")};return X.runKernel(Pf,t)}const bm=Y({tanh_:y$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w$(n,e,t){const r=U(n,"x","batchToSpaceND"),i=e.reduce((o,c)=>o*c);R(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),R(t.length===e.length,()=>`crops.length is ${t.length} but should be equal to blockShape.length  ${e.length}`),R(r.shape[0]%i===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const s={x:r},a={blockShape:e,crops:t};return X.runKernel(Sp,s,a)}const wb=Y({batchToSpaceND_:w$});function E$(n){let e;return n.rank===0||n.rank===1?e=j(n,[1,1,1,n.size]):n.rank===2?e=j(n,[1,1,n.shape[0],n.shape[1]]):n.rank===3?e=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]):e=n,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S$(n,e,t,r,i,s){s==null&&(s=.001);const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),c=U(t,"variance","batchNorm");let l;i!=null&&(l=U(i,"scale","batchNorm"));let u;r!=null&&(u=U(r,"offset","batchNorm")),R(o.rank===c.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(u==null||o.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(l==null||o.rank===l.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const d={x:E$(a),scale:l,offset:u,mean:o,variance:c},h={varianceEpsilon:s},p=X.runKernel(Op,d,h);return j(p,a.shape)}const _m=Y({batchNorm_:S$});function T$(n,e,t,r,i,s){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),c=U(t,"variance","batchNorm");let l;i!=null&&(l=U(i,"scale","batchNorm"));let u;return r!=null&&(u=U(r,"offset","batchNorm")),R(a.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${a.rank}.`),R(o.rank===2||o.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${o.rank}.`),R(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${c.rank}.`),l!=null&&R(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${l.rank}.`),u!=null&&R(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),_m(a,o,c,u,l,s)}const A$=Y({batchNorm2d_:T$});function C$(n,e,t,r,i,s){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),c=U(t,"variance","batchNorm");let l;i!=null&&(l=U(i,"scale","batchNorm"));let u;return r!=null&&(u=U(r,"offset","batchNorm")),R(a.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${a.rank}.`),R(o.rank===3||o.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${o.rank}.`),R(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${c.rank}.`),l!=null&&R(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${l.rank}.`),u!=null&&R(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),_m(a,o,c,u,l,s)}const I$=Y({batchNorm3d_:C$});function M$(n,e,t,r,i,s){const a=U(n,"x","batchNorm"),o=U(e,"mean","batchNorm"),c=U(t,"variance","batchNorm");let l;i!=null&&(l=U(i,"scale","batchNorm"));let u;return r!=null&&(u=U(r,"offset","batchNorm")),R(a.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${a.rank}.`),R(o.rank===4||o.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${o.rank}.`),R(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${c.rank}.`),l!=null&&R(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${l.rank}.`),u!=null&&R(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),_m(a,o,c,u,l,s)}const R$=Y({batchNorm4d_:M$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N$(n,e,t){const r=U(n,"x","bincount"),i=U(e,"weights","bincount");R(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),R(t>=0,()=>`size must be non-negative, but got ${t}.`),R(i.size===r.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`);const s={x:r,weights:i},a={size:t};return X.runKernel(L0,s,a)}const k$=Y({bincount_:N$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function D$(n,e){let t=U(n,"broadcastTo","x");const r=t.shape;if(ea(e),e.length<t.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${t.rank}.`);if(e.length>t.rank){const l=t.shape.slice();for(;l.length<e.length;)l.unshift(1);t=j(t,l)}const i=t.shape,s=Array.from(e);for(let l=e.length-1;l>=0;l--)if(i[l]===e[l])s[l]=1;else if(t.shape[l]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(s.map((l,u)=>l>1?u:-1).filter(l=>l>=0).length===0)return bo(t);const o={x:t},c={reps:s};return X.runKernel(Ff,o,c)}const xu=Y({broadcastTo_:D$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L$(n){const t={x:U(n,"x","ceil","float32")};return X.runKernel(Qu,t)}const O$=Y({ceil_:L$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ym(n,e,t){ea(n),t=t||yl(e);const r={shape:n,value:e,dtype:t};return X.runKernel(j0,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z$(n,e,t){const r=U(n,"x","clipByValue");if(R(e<=t,()=>`Error in clip: min (${e}) must be less than or equal to max (${t}).`),e===t)return ym(r.shape,e,r.dtype);const i={x:r},s={clipValueMin:e,clipValueMax:t};return X.runKernel(Ju,i,s)}const ni=Y({clipByValue_:z$});function P$(n){return nr(n,0)}const F$=Y({concat1d_:P$});function $$(n,e){return nr(n,e)}const U$=Y({concat2d_:$$});function B$(n,e){return nr(n,e)}const V$=Y({concat3d_:B$});function G$(n,e){return nr(n,e)}const H$=Y({concat4d_:G$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W$(n,e,t,r,i="NHWC",s=[1,1],a){const o=U(n,"x","conv2d","float32"),c=U(e,"filter","conv2d","float32");let l=o,u=!1;o.rank===3&&(u=!0,l=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(l.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${l.rank}.`),R(c.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${c.rank}.`),kr("conv2d",r,a);const f=i==="NHWC"?l.shape[3]:l.shape[1];R(f===c.shape[2],()=>`Error in conv2d: depth of input (${f}) must match input depth for filter ${c.shape[2]}.`),R(or(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),R(Ro(s),()=>"Error in conv2D: Dilated rates should be larger than 0."),R(Ro(t),()=>"Error in conv2D: Strides should be larger than 0.");const d={x:l,filter:c},h={strides:t,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a},p=X.runKernel(Cp,d,h);return u?j(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const No=Y({conv2d_:W$});function q$(n,e,t,r,i="NWC",s=1,a){const o=U(n,"x","conv1d"),c=U(e,"filter","conv1d");let l=o,u=!1;o.rank===2&&(u=!0,l=j(o,[1,o.shape[0],o.shape[1]])),R(l.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${l.rank}.`),R(c.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${c.rank}.`),kr("conv1d",r,a),R(l.shape[2]===c.shape[1],()=>`Error in conv1d: depth of input (${l.shape[2]}) must match input depth for filter ${c.shape[1]}.`),R(or(t,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${t} and dilation '${s}'`),R(Ro(s),()=>"Error in conv1D: Dilated rates should be larger than 0."),R(Ro(t),()=>"Error in conv1D: Stride should be larger than 0."),R(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const f=j(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=j(l,[l.shape[0],1,l.shape[1],l.shape[2]]),m=No(d,f,[1,t],r,"NHWC",[1,s],a);return u?j(m,[m.shape[2],m.shape[3]]):j(m,[m.shape[0],m.shape[2],m.shape[3]])}const G3=Y({conv1d_:q$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X$(n,e,t,r,i,s="NHWC",a){R(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let o=n,c=e,l=!1;e.rank===3&&(l=!0,c=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]),o=[1,n[0],n[1],n[2]]),R(o.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${o.length}.`),R(c.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${c.rank}`),R(t.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${t.rank}`);const u=s==="NHWC"?o[3]:o[1],f=s==="NHWC"?c.shape[3]:c.shape[1];R(u===t.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${t.shape[2]}.`),R(f===t.shape[3],()=>`Error in conv2dDerInput: depth of output (${f}) must match output depth for filter ${t.shape[3]}.`),kr("conv2dDerInput",i,a);const d={dy:c,filter:t},h={strides:r,pad:i,dataFormat:s,dimRoundingMode:a,inputShape:o},p=X.runKernel(Ip,d,h);return l?j(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Eb=Y({conv2DBackpropInput_:X$});function K$(n,e,t,r,i,s){const a=U(n,"x","conv2dTranspose"),o=U(e,"filter","conv2dTranspose");return Eb(t,a,o,r,i,"NHWC",s)}const H3=Y({conv2dTranspose_:K$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j$(n,e,t,r,i="NDHWC",s=[1,1,1]){const a=U(n,"x","conv3d"),o=U(e,"filter","conv3d");let c=a,l=!1;a.rank===4&&(l=!0,c=j(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),R(c.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${c.rank}.`),R(o.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${o.rank}.`),R(c.shape[4]===o.shape[3],()=>`Error in conv3d: depth of input (${c.shape[4]}) must match input depth for filter ${o.shape[3]}.`),R(or(t,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`),R(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`),R(Ro(s),()=>"Error in conv3D: Dilated rates should be larger than 0."),R(Ro(t),()=>"Error in conv3D: Strides should be larger than 0.");const u={x:c,filter:o},f={strides:t,pad:r,dataFormat:i,dilations:s},d=X.runKernel(Mp,u,f);return l?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const W3=Y({conv3d_:j$});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y$(n,e,t,r,i){R(n.length===e.rank,()=>`Length of inShape (${n.length}) and rank of dy (${e.rank}) must match`);let s=n,a=e,o=!1;e.rank===4&&(o=!0,a=j(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,n[0],n[1],n[2],n[3]]);const c=s[4],l=a.shape[4];R(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),R(a.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${a.rank}`),R(t.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${t.rank}`),R(c===t.shape[3],()=>`Error in conv3dDerInput: depth of input (${c}) must match input depth for filter ${t.shape[3]}.`),R(l===t.shape[4],()=>`Error in conv3dDerInput: depth of output (${l}) must match output depth for filter ${t.shape[4]}.`);const u={dy:a,filter:t},f={pad:i,strides:r,inputShape:s},d=X.runKernel($0,u,f);return o?j(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const q3=Y({conv3DBackpropInput_:Y$});function Z$(n,e,t,r,i){const s=U(n,"x","conv3dTranspose"),a=U(e,"filter","conv3dTranspose");return q3(t,s,a,r,i)}const Q$=Y({conv3dTranspose_:Z$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J$(n){const t={x:U(n,"x","cos","float32")};return X.runKernel(ef,t)}const Sb=Y({cos_:J$});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eU(n){const t={x:U(n,"x","cosh","float32")};return X.runKernel(tf,t)}const X3=Y({cosh_:eU});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tU(n,e=0,t=!1,r=!1){const s={x:U(n,"x","cumprod")},a={axis:e,exclusive:t,reverse:r};return X.runKernel(U0,s,a)}const gx=Y({cumprod_:tU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nU(n,e=0,t=!1,r=!1){const s={x:U(n,"x","cumsum")},a={axis:e,exclusive:t,reverse:r};return X.runKernel(Rp,s,a)}const K3=Y({cumsum_:nU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rU(n,e,t,r=!1){const i=U(n,"x","denseBincount"),s=U(e,"weights","denseBincount");R(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),R(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),R(t>=0,()=>`size must be non-negative, but got ${t}.`),R(s.size===i.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${s.shape}.`);const a={x:i,weights:s},o={size:t,binaryOutput:r};return X.runKernel(V0,a,o)}const S2=Y({denseBincount_:rU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iU(n,e,t="NHWC"){const r=U(n,"x","depthToSpace","float32"),i=t==="NHWC"?r.shape[1]:r.shape[2],s=t==="NHWC"?r.shape[2]:r.shape[3],a=t==="NHWC"?r.shape[3]:r.shape[1];R(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),R(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${r.shape}`),R(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${r.shape}`),R(a%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${a} for depthToSpace with input shape ${r.shape}`);const o={x:r},c={blockSize:e,dataFormat:t};return X.runKernel(G0,o,c)}const sU=Y({depthToSpace_:iU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aU(n,e,t,r,i="NHWC",s=[1,1],a){const o=U(n,"x","depthwiseConv2d","float32"),c=U(e,"filter","depthwiseConv2d","float32");let l=o,u=!1;o.rank===3&&(u=!0,l=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(l.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${l.rank}.`),R(c.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${c.rank}.`);const f=i==="NHWC"?l.shape[3]:l.shape[1];R(f===c.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${f}) must match the inChannels dimension in filter ${c.shape[2]}.`),kr("depthwiseConv2d",r,a);const d={x:l,filter:c},h={strides:t,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a},p=X.runKernel(Np,d,h);return u?j(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const Tb=Y({depthwiseConv2d_:aU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oU(n,e,t,r,i=[1,1],s="NHWC"){const a=U(n,"x","dilation2d"),o=U(e,"filter","dilation2d");R(a.rank===3||a.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${a.rank}.`),R(o.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${o.rank}.`),R(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let c=a,l=!1;a.rank===3&&(c=j(a,[1,a.shape[0],a.shape[1],a.shape[2]]),l=!0),R(c.shape[3]===o.shape[2],()=>`Error in dilation2d:  input and filter must have the same depth: ${c.shape[3]} vs ${o.shape[2]}`);const u={x:c,filter:o},f={strides:t,pad:r,dilations:i},d=X.runKernel(kp,u,f);return l?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const cU=Y({dilation2d_:oU});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function il(n,e){const t=n.length,r=[];for(let i=0;i<t;i++){const s=t-1-i,a=n[s]||1;(e[e.length-1-i]||1)>1&&a===1&&r.unshift(s)}return r}function zn(n,e){const t=[];for(let r=0;r<e.length;r++){const i=n[n.length-r-1],s=e.length-r-1,a=e[s];(i==null||i===1&&a>1)&&t.unshift(s)}return t}function pt(n,e){const t=Math.max(n.length,e.length),r=new Array(t);for(let i=0;i<t;i++){let s=n[n.length-i-1];s==null&&(s=1);let a=e[e.length-i-1];if(a==null&&(a=1),s===1)r[t-i-1]=a;else if(a===1)r[t-i-1]=s;else if(s!==a){const o=`Operands could not be broadcast together with shapes ${n} and ${e}.`;throw Error(o)}else r[t-i-1]=s}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lU(n,e){let t=U(n,"a","equal","string_or_numeric"),r=U(e,"b","equal","string_or_numeric");[t,r]=_n(t,r),pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(Dp,i)}const vs=Y({equal_:lU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uU(n,e,t){const r=U(e,"a","where"),i=U(t,"b","where"),s=U(n,"condition","where","bool"),a=pt(pt(s.shape,r.shape),i.shape),o=xu(s,a),c=xu(r,a),l=xu(i,a),u={condition:o,t:c,e:l};return X.runKernel(lm,u)}const xn=Y({where_:uU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fU(n){const t={x:U(n,"x","zerosLike")};return X.runKernel(gm,t)}const Rt=Y({zerosLike_:fU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dU(n,e){let t=U(n,"a","div"),r=U(e,"b","div");[t,r]=_n(t,r);const i=nt(t,r),s=Rt(i),a=vs(r,s);return xn(a,s,i)}const hU=Y({divNoNan_:dU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pU(n,e){const t=U(n,"t1","dot"),r=U(e,"t2","dot");R((t.rank===1||t.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${t.rank} and ${r.rank}.`);const i=t.rank===1?t.size:t.shape[1],s=r.rank===1?r.size:r.shape[0];if(R(i===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`),t.rank===1&&r.rank===1){const a=j(t,[1,-1]),o=j(r,[-1,1]),c=Ot(a,o);return j(c,[])}else if(t.rank===1&&r.rank===2){const a=j(t,[1,-1]),o=j(r,[r.shape[0],r.shape[1]]),c=Ot(a,o);return j(c,[c.size])}else if(t.rank===2&&r.rank===1){const a=j(r,[-1,1]),o=Ot(t,a);return j(o,[o.size])}else{const a=j(r,[r.shape[0],r.shape[1]]);return Ot(t,a)}}const mU=Y({dot_:pU});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vU(n,...e){const t=e.map((i,s)=>U(i,`tensors${s}`,"einsum")),r={equation:n};return X.runKernel(q0,t,r)}const ru=Y({einsum_:vU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gU(n){const t={x:U(n,"x","elu","float32")};return X.runKernel(rf,t)}const wm=Y({elu_:gU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xU(n){let e=U(n,"x","erf");R(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=Ie(e,"float32"));const t={x:e};return X.runKernel(sf,t)}const j3=Y({erf_:xU});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ab(n,e){for(let t=0;t<n.length;++t)if(n[n.length-t-1]!==e-1-t)return!1;return!0}function Y3(n,e,t){const r=n.length+e.length,i=[];let s=0,a=0;for(let o=0;o<r;o++)t.indexOf(o)===-1?i.push(n[s++]):i.push(e[a++]);return i}function Wn(n,e){const t=[],r=n.length;for(let s=0;s<r;s++)e.indexOf(s)===-1&&t.push(n[s]);const i=e.map(s=>n[s]);return[t,i]}function Cn(n,e){const t=e.map(r=>1);return Y3(n,t,e)}function Zn(n,e,t){R(Ab(e,t),()=>`${n} supports only inner-most axes for now. Got axes ${e} and rank-${t} input.`)}function pn(n,e){if(Ab(n,e))return null;const t=[];for(let r=0;r<e;++r)n.indexOf(r)===-1&&t.push(r);return n.forEach(r=>t.push(r)),t}function Va(n){return n.map((e,t)=>[t,e]).sort((e,t)=>e[1]-t[1]).map(e=>e[0])}function yn(n,e){const t=[];for(let r=e-n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bU(n,e=null,t=!1){const i={x:U(n,"x","max")},s={reductionIndices:e,keepDims:t};return X.runKernel(Wp,i,s)}const Wi=Y({max_:bU});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _U(n,e=null,t=!1){const i={x:U(n,"x","min")},s={axis:e,keepDims:t};return X.runKernel(jp,i,s)}const Ph=Y({min_:_U});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yU(n,e){let t=U(n,"base","pow"),r=U(e,"exp","pow");[t,r]=_n(t,r);const i={a:t,b:r};return X.runKernel(yf,i)}const ko=Y({pow_:yU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zt(n,e){if((Ti(n)&&e!=="string"||Array.isArray(n))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Ti(n)&&!(n instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Bf(n,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wU(n){const t={x:U(n,"x","sqrt","float32")};return X.runKernel(Df,t)}const ar=Y({sqrt_:wU});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EU(n){const e=U(n,"x","square"),t={};return X.runKernel("Square",{x:e},t)}const nn=Y({square_:EU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SU(n,e=null,t=!1){let r=U(n,"x","sum");r.dtype==="bool"&&(r=Ie(r,"int32"));const i={x:r},s={axis:e,keepDims:t};return X.runKernel(fm,i,s)}const et=Y({sum_:SU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TU(n,e="euclidean",t=null,r=!1){n=U(n,"x","norm");const i=Z3(n,e,t);let s=i.shape;if(r){const a=St(t,n.shape);s=Cn(i.shape,a)}return j(i,s)}function Z3(n,e,t=null){if(n.rank===0)return pr(n);if(n.rank!==1&&t===null)return Z3(j(n,[-1]),e,t);if(n.rank===1||typeof t=="number"||Array.isArray(t)&&t.length===1){if(e===1)return et(pr(n),t);if(e===1/0)return Wi(pr(n),t);if(e===-1/0)return Ph(pr(n),t);if(e==="euclidean"||e===2)return ar(et(ko(pr(n),zt(2,"int32")),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(t)&&t.length===2){if(e===1)return Wi(et(pr(n),t[0]),t[1]-1);if(e===1/0)return Wi(et(pr(n),t[1]),t[0]);if(e===-1/0)return Ph(et(pr(n),t[1]),t[0]);if(e==="fro"||e==="euclidean")return ar(et(nn(n),t));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${t}`)}const Em=Y({norm_:TU});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AU(n,e=null,t=!1){return Em(n,"euclidean",e,t)}const CU=Y({euclideanNorm_:AU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IU(n){const t={x:U(n,"x","exp")};return X.runKernel(af,t)}const gs=Y({exp_:IU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MU(n,e=0){const t=U(n,"x","expandDims","string_or_numeric");R(e<=t.rank,()=>"Axis must be <= rank of the tensor");const r={input:t},i={dim:e};return X.runKernel(Lp,r,i)}const Sr=Y({expandDims_:MU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RU(n){const t={x:U(n,"x","expm1")};return X.runKernel(of,t)}const NU=Y({expm1_:RU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kU(n,e){const t=U(n,"x","tile","string_or_numeric");R(t.rank===e.length,()=>`Error in transpose: rank of input ${t.rank} must match length of reps ${e}.`);const r={x:t},i={reps:e};return X.runKernel(Ff,r,i)}const Vi=Y({tile_:kU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DU(n,e,t,r="float32"){e==null&&(e=n);const i=Et([n,e],r),s=n<=e?n:e;for(let o=0;o<s;++o)i.set(1,o,o);const a=j(i.toTensor(),[n,e]);if(t==null)return a;if(t.length===1)return Vi(Sr(a,0),[t[0],1,1]);if(t.length===2)return Vi(Sr(Sr(a,0),0),[t[0],t[1],1,1]);if(t.length===3)return Vi(Sr(Sr(Sr(a,0),0),0),[t[0],t[1],t[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${t.length}D.`)}const Q3=Y({eye_:DU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LU(n){const t={x:U(n,"x","floor","float32")};return X.runKernel(cf,t)}const Sm=Y({floor_:LU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OU(n,e,t=0,r=0){const i=U(n,"x","gather"),s=U(e,"indices","gather","int32"),a={x:i,indices:s},o={axis:t,batchDims:r};return X.runKernel(zp,a,o)}const Cb=Y({gather_:OU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zU(n,e){let t=U(n,"a","greater","string_or_numeric"),r=U(e,"b","greater","string_or_numeric");[t,r]=_n(t,r),pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(Pp,i)}const ri=Y({greater_:zU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PU(n,e){let t=U(n,"a","greaterEqual","string_or_numeric"),r=U(e,"b","greaterEqual","string_or_numeric");[t,r]=_n(t,r),pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(uf,i)}const Ho=Y({greaterEqual_:PU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FU(n){const t={input:U(n,"input","imag")};return X.runKernel(Q0,t)}const Ib=Y({imag_:FU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $U(n){const t={x:U(n,"x","isFinite")};return X.runKernel(df,t)}const UU=Y({isFinite_:$U});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BU(n){const t={x:U(n,"x","isInf")};return X.runKernel(hf,t)}const VU=Y({isInf_:BU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GU(n){const t={x:U(n,"x","isNaN")};return X.runKernel(pf,t)}const HU=Y({isNaN_:GU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WU(n,e=.2){const r={x:U(n,"x","leakyRelu")},i={alpha:e};return X.runKernel(Fp,r,i)}const Mb=Y({leakyRelu_:WU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qU(n,e){let t=U(n,"a","less","string_or_numeric"),r=U(e,"b","less","string_or_numeric");[t,r]=_n(t,r),pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel($p,i)}const Fh=Y({less_:qU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XU(n,e){let t=U(n,"a","lessEqual","string_or_numeric"),r=U(e,"b","lessEqual","string_or_numeric");[t,r]=_n(t,r),pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(Up,i)}const Al=Y({lessEqual_:XU});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KU(n,e=5,t=1,r=1,i=.5){const s=U(n,"x","localResponseNormalization");R(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),R(el(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let a=s,o=!1;s.rank===3&&(o=!0,a=j(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const c={x:a},l={depthRadius:e,bias:t,alpha:r,beta:i},u=X.runKernel(Hp,c,l);return o?j(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const jU=Y({localResponseNormalization_:KU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YU(n){const t={x:U(n,"x","log","float32")};return X.runKernel(mf,t)}const xs=Y({log_:YU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZU(n){const t={x:U(n,"x","log1p")};return X.runKernel(vf,t)}const J3=Y({log1p_:ZU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QU(n,e){R(ex(n),()=>"The f passed in variableGrads(f) must be a function"),R(e==null||Array.isArray(e)&&e.every(l=>l instanceof zh),()=>"The varList passed in variableGrads(f, varList) must be an array of variables");const t=e!=null;if(!t){e=[];for(const l in X.registeredVariables)e.push(X.registeredVariables[l])}const r=t?e.filter(l=>!l.trainable):null,i=e.length;e=e.filter(l=>l.trainable),R(e.length>0,()=>`variableGrads() expects at least one of the input variables to be trainable, but none of the ${i} variables is trainable.`);const s=!0,{value:a,grads:o}=X.gradients(n,e,null,s);R(o.some(l=>l!=null),()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize()."),R(a.rank===0,()=>`The f passed in variableGrads(f) must return a scalar, but it returned a rank-${a.rank} tensor`);const c={};return e.forEach((l,u)=>{o[u]!=null&&(c[l.name]=o[u])}),r!=null&&r.forEach(l=>c[l.name]=null),{value:a,grads:c}}function sl(n){return X.customGrad(n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JU(n){const t={x:U(n,"x","neg")};return X.runKernel(Zp,t)}const bn=Y({neg_:JU});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e5(n){const t={x:U(n,"x","softplus")};return X.runKernel(kf,t)}const Hf=Y({softplus_:e5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t5(n){const e=U(n,"x","logSigmoid");return sl(r=>({value:bn(Hf(bn(r))),gradFunc:a=>W(a,Tl(bn(r)))}))(e)}const n5=Y({logSigmoid_:t5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r5(n,e){let t=U(n,"a","sub"),r=U(e,"b","sub");[t,r]=_n(t,r);const i={a:t,b:r};return X.runKernel(Of,i)}const st=Y({sub_:r5});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i5(n,e=-1){const t=U(n,"logits","logSoftmax");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and axis was ${e}`);return sl((i,s)=>{const o=Wi(i,e,!0),c=st(i,o),l=st(Ie(c,"float32"),xs(et(gs(c),e,!0)));return s([l]),{value:l,gradFunc:(f,d)=>{const[h]=d,p=!0,g=gs(h);return st(f,W(et(f,e,p),g))}}})(t)}const eS=Y({logSoftmax_:i5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s5(n,e=null,t=!1){const r=U(n,"x","logSumExp"),i=St(e,r.shape),s=Wi(r,i,!0),a=st(r,s),o=gs(a),c=et(o,i),l=xs(c),u=ye(j(s,l.shape),l);if(t){const f=Cn(u.shape,i);return j(u,f)}return u}const tS=Y({logSumExp_:s5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a5(n,e){const t=U(n,"a","logicalAnd","bool"),r=U(e,"b","logicalAnd","bool");pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(Bp,i)}const Xs=Y({logicalAnd_:a5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o5(n){const t={x:U(n,"x","logicalNot","bool")};return X.runKernel(Vp,t)}const Rb=Y({logicalNot_:o5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c5(n,e){const t=U(n,"a","logicalOr","bool"),r=U(e,"b","logicalOr","bool");pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(Gp,i)}const nS=Y({logicalOr_:c5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l5(n,e){const t=U(n,"a","logicalXor","bool"),r=U(e,"b","logicalXor","bool");return pt(t.shape,r.shape),Xs(nS(n,e),Rb(Xs(n,e)))}const u5=Y({logicalXor_:l5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f5(n,e,t,r,i){const s=U(n,"x","maxPool"),a=1;let o=s,c=!1;s.rank===3&&(c=!0,o=j(s,[1,s.shape[0],s.shape[1],s.shape[2]])),R(o.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${o.rank}.`),R(or(t,a),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${t} and dilations '${a}'`),kr("maxPool",r,i);const l={x:o},u={filterSize:e,strides:t,pad:r,dimRoundingMode:i},f=X.runKernel(qp,l,u);return c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Nb=Y({maxPool_:f5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function d5(n,e=[1,1,1],t,r,i,s="NDHWC"){const a=U(n,"x","maxPool3d");let o=a,c=!1;a.rank===4&&(c=!0,o=j(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]])),R(o.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${o.rank}.`),R(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),kr("maxPool3d",r,i);const l={x:o},u={filterSize:e,strides:t,pad:r,dimRoundingMode:i,dataFormat:s},f=X.runKernel(Xp,l,u);return c?j(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const kb=Y({maxPool3d_:d5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h5(n,e){let t=U(n,"a","maximum"),r=U(e,"b","maximum");[t,r]=_n(t,r),t.dtype==="bool"&&(t=Ie(t,"int32"),r=Ie(r,"int32")),pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(gf,i)}const Ga=Y({maximum_:h5});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p5(n,e=null,t=!1){const i={x:U(n,"x","mean")},s={axis:e,keepDims:t};return X.runKernel(Kp,i,s)}const An=Y({mean_:p5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Un(n,e="float32"){if(ea(n),e==="complex64"){const r=Un(n,"float32"),i=Un(n,"float32");return rl(r,i)}const t=sr(ue(n),e);return X.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ha(n,e="float32"){if(ea(n),e==="complex64"){const r=Ha(n,"float32"),i=Un(n,"float32");return rl(r,i)}const t=A0(ue(n),e);return X.makeTensor(t,n,e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m5(n,e){let t=U(n,"a","minimum"),r=U(e,"b","minimum");[t,r]=_n(t,r),t.dtype==="bool"&&(t=Ie(t,"int32"),r=Ie(r,"int32")),pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(xf,i)}const Cu=Y({minimum_:m5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v5(n,e,t){R(t==="reflect"||t==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${t}.`);const r=U(n,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");R(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const i=t==="reflect"?1:0;for(let o=0;o<r.rank;o++)R(e[o].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),R(e[o][0]>=0&&e[o][0]<=r.shape[o]-i&&e[o][1]>=0&&e[o][1]<=r.shape[o]-i,()=>`Padding in dimension ${o} cannot be greater than or equal to ${r.shape[o]-i} or less than 0 for input of shape ${r.shape}`);const s={paddings:e,mode:t},a={x:r};return X.runKernel(Yp,a,s)}const g5=Y({mirrorPad_:v5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x5(n,e){let t=U(n,"a","mod"),r=U(e,"b","mod");[t,r]=_n(t,r);const i={a:t,b:r};return X.runKernel(bf,i)}const b5=Y({mod_:x5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _5(n,e=null,t=!1){n=U(n,"x","moments");const r=St(e,n.shape),i=An(n,r,t);let s=i.shape;t||(s=Cn(i.shape,r));const a=nn(st(Ie(n,"float32"),j(i,s))),o=An(a,r,t);return{mean:i,variance:o}}const Db=Y({moments_:_5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y5(n,e){let t=U(n,"a","notEqual","string_or_numeric"),r=U(e,"b","notEqual","string_or_numeric");[t,r]=_n(t,r),pt(t.shape,r.shape);const i={a:t,b:r};return X.runKernel(Qp,i)}const Do=Y({notEqual_:y5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w5(n,e,t=1,r=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const a={indices:U(n,"indices","oneHot","int32")},o={dtype:i,depth:e,onValue:t,offValue:r};return X.runKernel(em,a,o)}const rS=Y({oneHot_:w5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E5(n){const t={x:U(n,"x","onesLike")};return X.runKernel(Jp,t)}const Ai=Y({onesLike_:E5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S5(n,e,t=0){const r=U(n,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:t},s={x:r};return X.runKernel(nm,s,i)}const Lb=Y({pad_:S5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T5(n,e,t){const r=U(n,"x","spaceToBatchND");R(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),R(t.length===e.length,()=>`paddings.shape[0] ${t.length} must be equal to [blockShape] ${e.length}`),R(r.shape.reduce((a,o,c)=>c>0&&c<=e.length?a&&(o+t[c-1][0]+t[c-1][1])%e[c-1]===0:a,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${t.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:r},s={blockShape:e,paddings:t};return X.runKernel(dm,i,s)}const Ob=Y({spaceToBatchND_:T5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A5(n,e,t,r,i,s,a){i==null&&(i=[1,1]),s==null&&(s=1),r===0&&(r="valid");const o=U(n,"x","maxPool");let c=o,l=!1;o.rank===3&&(l=!0,c=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),R(or(s,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`);const u=Ii(c.shape,e,s,i,r),f=[u.dilationHeight,u.dilationWidth];let d;r==="same"?d=I5([u.filterHeight,u.filterWidth],f):d=[[0,0],[0,0]];const h=f[0]===1&&f[1]===1,[p,g]=C5([u.inHeight,u.inWidth],f,d),m=h?r:"valid",v=h?c:Ob(c,f,p),b=(t==="avg"?()=>yb(v,e,s,m,a):()=>Nb(v,e,s,m,a))(),_=h?b:wb(b,f,g);return l?j(_,[_.shape[1],_.shape[2],_.shape[3]]):_}function C5(n,e,t){const r=t.map(u=>u[0]),i=t.map(u=>u[1]),s=n.concat(r,i),a=e.map((u,f)=>(u-s[f]%u)%u),o=i.map((u,f)=>u+a[f]),c=e.map((u,f)=>[r[f],o[f]]),l=e.map((u,f)=>[0,a[f]]);return[c,l]}function I5(n,e){const r=n.map((a,o)=>a+(a-1)*(e[o]-1)).map(a=>a-1),i=r.map(a=>Math.floor(a/2)),s=r.map((a,o)=>a-i[o]);return r.map((a,o)=>[i[o],s[o]])}const M5=Y({pool_:A5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R5(n,e){const t=U(n,"x","prelu"),r=U(e,"alpha","prelu"),i={x:t,alpha:r};return X.runKernel(rm,i)}const zb=Y({prelu_:R5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N5(n,e=null,t=!1){let r=U(n,"x","prod");r.dtype==="bool"&&(r=Ie(r,"int32"));const i={x:r},s={axis:e,keepDims:t};return X.runKernel(im,i,s)}const k5=Y({prod_:N5});var Pb={exports:{}};Pb.exports;(function(n){(function(e,t,r){function i(c){var l=this,u=o();l.next=function(){var f=2091639*l.s0+l.c*23283064365386963e-26;return l.s0=l.s1,l.s1=l.s2,l.s2=f-(l.c=f|0)},l.c=1,l.s0=u(" "),l.s1=u(" "),l.s2=u(" "),l.s0-=u(c),l.s0<0&&(l.s0+=1),l.s1-=u(c),l.s1<0&&(l.s1+=1),l.s2-=u(c),l.s2<0&&(l.s2+=1),u=null}function s(c,l){return l.c=c.c,l.s0=c.s0,l.s1=c.s1,l.s2=c.s2,l}function a(c,l){var u=new i(c),f=l&&l.state,d=u.next;return d.int32=function(){return u.next()*4294967296|0},d.double=function(){return d()+(d()*2097152|0)*11102230246251565e-32},d.quick=d,f&&(typeof f=="object"&&s(f,u),d.state=function(){return s(u,{})}),d}function o(){var c=4022871197,l=function(u){u=String(u);for(var f=0;f<u.length;f++){c+=u.charCodeAt(f);var d=.02519603282416938*c;c=d>>>0,d-=c,d*=c,c=d>>>0,d-=c,c+=d*4294967296}return(c>>>0)*23283064365386963e-26};return l}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.alea=a})($r,n,!1)})(Pb);var D5=Pb.exports,Fb={exports:{}};Fb.exports;(function(n){(function(e,t,r){function i(o){var c=this,l="";c.x=0,c.y=0,c.z=0,c.w=0,c.next=function(){var f=c.x^c.x<<11;return c.x=c.y,c.y=c.z,c.z=c.w,c.w^=c.w>>>19^f^f>>>8},o===(o|0)?c.x=o:l+=o;for(var u=0;u<l.length+64;u++)c.x^=l.charCodeAt(u)|0,c.next()}function s(o,c){return c.x=o.x,c.y=o.y,c.z=o.z,c.w=o.w,c}function a(o,c){var l=new i(o),u=c&&c.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,p=(d+h)/(1<<21);while(p===0);return p},f.int32=l.next,f.quick=f,u&&(typeof u=="object"&&s(u,l),f.state=function(){return s(l,{})}),f}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xor128=a})($r,n,!1)})(Fb);var L5=Fb.exports,$b={exports:{}};$b.exports;(function(n){(function(e,t,r){function i(o){var c=this,l="";c.next=function(){var f=c.x^c.x>>>2;return c.x=c.y,c.y=c.z,c.z=c.w,c.w=c.v,(c.d=c.d+362437|0)+(c.v=c.v^c.v<<4^(f^f<<1))|0},c.x=0,c.y=0,c.z=0,c.w=0,c.v=0,o===(o|0)?c.x=o:l+=o;for(var u=0;u<l.length+64;u++)c.x^=l.charCodeAt(u)|0,u==l.length&&(c.d=c.x<<10^c.x>>>4),c.next()}function s(o,c){return c.x=o.x,c.y=o.y,c.z=o.z,c.w=o.w,c.v=o.v,c.d=o.d,c}function a(o,c){var l=new i(o),u=c&&c.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,p=(d+h)/(1<<21);while(p===0);return p},f.int32=l.next,f.quick=f,u&&(typeof u=="object"&&s(u,l),f.state=function(){return s(l,{})}),f}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xorwow=a})($r,n,!1)})($b);var O5=$b.exports,Ub={exports:{}};Ub.exports;(function(n){(function(e,t,r){function i(o){var c=this;c.next=function(){var u=c.x,f=c.i,d,h;return d=u[f],d^=d>>>7,h=d^d<<24,d=u[f+1&7],h^=d^d>>>10,d=u[f+3&7],h^=d^d>>>3,d=u[f+4&7],h^=d^d<<7,d=u[f+7&7],d=d^d<<13,h^=d^d<<9,u[f]=h,c.i=f+1&7,h};function l(u,f){var d,h=[];if(f===(f|0))h[0]=f;else for(f=""+f,d=0;d<f.length;++d)h[d&7]=h[d&7]<<15^f.charCodeAt(d)+h[d+1&7]<<13;for(;h.length<8;)h.push(0);for(d=0;d<8&&h[d]===0;++d);for(d==8?h[7]=-1:h[d],u.x=h,u.i=0,d=256;d>0;--d)u.next()}l(c,o)}function s(o,c){return c.x=o.x.slice(),c.i=o.i,c}function a(o,c){o==null&&(o=+new Date);var l=new i(o),u=c&&c.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,p=(d+h)/(1<<21);while(p===0);return p},f.int32=l.next,f.quick=f,u&&(u.x&&s(u,l),f.state=function(){return s(l,{})}),f}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xorshift7=a})($r,n,!1)})(Ub);var z5=Ub.exports,Bb={exports:{}};Bb.exports;(function(n){(function(e,t,r){function i(o){var c=this;c.next=function(){var u=c.w,f=c.X,d=c.i,h,p;return c.w=u=u+1640531527|0,p=f[d+34&127],h=f[d=d+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,p=f[d]=p^h,c.i=d,p+(u^u>>>16)|0};function l(u,f){var d,h,p,g,m,v=[],x=128;for(f===(f|0)?(h=f,f=null):(f=f+"\0",h=0,x=Math.max(x,f.length)),p=0,g=-32;g<x;++g)f&&(h^=f.charCodeAt((g+32)%f.length)),g===0&&(m=h),h^=h<<10,h^=h>>>15,h^=h<<4,h^=h>>>13,g>=0&&(m=m+1640531527|0,d=v[g&127]^=h+m,p=d==0?p+1:0);for(p>=128&&(v[(f&&f.length||0)&127]=-1),p=127,g=4*128;g>0;--g)h=v[p+34&127],d=v[p=p+1&127],h^=h<<13,d^=d<<17,h^=h>>>15,d^=d>>>12,v[p]=h^d;u.w=m,u.X=v,u.i=p}l(c,o)}function s(o,c){return c.i=o.i,c.w=o.w,c.X=o.X.slice(),c}function a(o,c){o==null&&(o=+new Date);var l=new i(o),u=c&&c.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,p=(d+h)/(1<<21);while(p===0);return p},f.int32=l.next,f.quick=f,u&&(u.X&&s(u,l),f.state=function(){return s(l,{})}),f}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.xor4096=a})($r,n,!1)})(Bb);var P5=Bb.exports,Vb={exports:{}};Vb.exports;(function(n){(function(e,t,r){function i(o){var c=this,l="";c.next=function(){var f=c.b,d=c.c,h=c.d,p=c.a;return f=f<<25^f>>>7^d,d=d-h|0,h=h<<24^h>>>8^p,p=p-f|0,c.b=f=f<<20^f>>>12^d,c.c=d=d-h|0,c.d=h<<16^d>>>16^p,c.a=p-f|0},c.a=0,c.b=0,c.c=-1640531527,c.d=1367130551,o===Math.floor(o)?(c.a=o/4294967296|0,c.b=o|0):l+=o;for(var u=0;u<l.length+20;u++)c.b^=l.charCodeAt(u)|0,c.next()}function s(o,c){return c.a=o.a,c.b=o.b,c.c=o.c,c.d=o.d,c}function a(o,c){var l=new i(o),u=c&&c.state,f=function(){return(l.next()>>>0)/4294967296};return f.double=function(){do var d=l.next()>>>11,h=(l.next()>>>0)/4294967296,p=(d+h)/(1<<21);while(p===0);return p},f.int32=l.next,f.quick=f,u&&(typeof u=="object"&&s(u,l),f.state=function(){return s(l,{})}),f}t&&t.exports?t.exports=a:r&&r.amd?r(function(){return a}):this.tychei=a})($r,n,!1)})(Vb);var F5=Vb.exports,iS={exports:{}};const $5={},U5=Object.freeze(Object.defineProperty({__proto__:null,default:$5},Symbol.toStringTag,{value:"Module"})),B5=zz(U5);(function(n){(function(e,t,r){var i=256,s=6,a=52,o="random",c=r.pow(i,s),l=r.pow(2,a),u=l*2,f=i-1,d;function h(_,w,E){var S=[];w=w==!0?{entropy:!0}:w||{};var T=v(m(w.entropy?[_,b(t)]:_??x(),3),S),C=new p(S),y=function(){for(var A=C.g(s),k=c,M=0;A<l;)A=(A+M)*i,k*=i,M=C.g(1);for(;A>=u;)A/=2,k/=2,M>>>=1;return(A+M)/k};return y.int32=function(){return C.g(4)|0},y.quick=function(){return C.g(4)/4294967296},y.double=y,v(b(C.S),t),(w.pass||E||function(A,k,M,L){return L&&(L.S&&g(L,C),A.state=function(){return g(C,{})}),M?(r[o]=A,k):A})(y,T,"global"in w?w.global:this==r,w.state)}function p(_){var w,E=_.length,S=this,T=0,C=S.i=S.j=0,y=S.S=[];for(E||(_=[E++]);T<i;)y[T]=T++;for(T=0;T<i;T++)y[T]=y[C=f&C+_[T%E]+(w=y[T])],y[C]=w;(S.g=function(A){for(var k,M=0,L=S.i,z=S.j,D=S.S;A--;)k=D[L=f&L+1],M=M*i+D[f&(D[L]=D[z=f&z+k])+(D[z]=k)];return S.i=L,S.j=z,M})(i)}function g(_,w){return w.i=_.i,w.j=_.j,w.S=_.S.slice(),w}function m(_,w){var E=[],S=typeof _,T;if(w&&S=="object")for(T in _)try{E.push(m(_[T],w-1))}catch{}return E.length?E:S=="string"?_:_+"\0"}function v(_,w){for(var E=_+"",S,T=0;T<E.length;)w[f&T]=f&(S^=w[f&T]*19)+E.charCodeAt(T++);return b(w)}function x(){try{var _;return d&&(_=d.randomBytes)?_=_(i):(_=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(_)),b(_)}catch{var w=e.navigator,E=w&&w.plugins;return[+new Date,e,E,e.screen,b(t)]}}function b(_){return String.fromCharCode.apply(0,_)}if(v(r.random(),t),n.exports){n.exports=h;try{d=B5}catch{}}else r["seed"+o]=h})(typeof self<"u"?self:$r,[],Math)})(iS);var V5=iS.exports,G5=D5,H5=L5,W5=O5,q5=z5,X5=P5,K5=F5,Wo=V5;Wo.alea=G5;Wo.xor128=H5;Wo.xorwow=W5;Wo.xorshift7=q5;Wo.xor4096=X5;Wo.tychei=K5;var Gb=Wo;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sS{constructor(e,t,r,i,s){this.mean=e,this.stdDev=t,this.dtype=r,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const a=s||Math.random();this.random=Gb.alea(a.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,t,r=!1;for(;!r;){let i,s,a;do i=2*this.random()-1,s=2*this.random()-1,a=i*i+s*s;while(a>=1||a===0);const o=Math.sqrt(-2*Math.log(a)/a);e=this.mean+this.stdDev*i*o,t=this.mean+this.stdDev*s*o,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(t))&&(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class j5{constructor(e=0,t=1,r,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=t-e,this.dtype=r,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${t} <= 1 and dtype is not float`);this.random=Gb.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y5(n,e=0,t=1,r,i){if(ea(n),r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const s=new sS(e,t,r,!1,i),a=Et(n,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}const Z5=Y({randomNormal_:Y5});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q5(n,e=0,t=1,r="float32",i){ea(n);const s=Et(n,r),a=new j5(e,t,null,i);for(let o=0;o<s.values.length;o++)s.values[o]=a.nextValue();return s.toTensor()}const Wf=Y({randomUniform_:Q5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Iu(n,e,t=1,r="float32"){if(t===0)throw new Error("Cannot have a step of zero");const i={start:n,stop:e,step:t,dtype:r};return X.runKernel(sb,{},i)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J5(n){const t={input:U(n,"input","real")};return X.runKernel(ab,t)}const $h=Y({real_:J5});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eB(n){const t={x:U(n,"x","reciprocal")};return X.runKernel(wf,t)}const tB=Y({reciprocal_:eB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nB(n){const t={x:U(n,"x","relu")};return X.runKernel(Ef,t)}const qo=Y({relu_:nB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rB(n){const t={x:U(n,"x","relu6")};return X.runKernel(Sf,t)}const aS=Y({relu6_:rB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iB(n,e){const r={x:U(n,"x","reverse")},i={dims:e};return X.runKernel(cm,r,i)}const Ki=Y({reverse_:iB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sB(n){const t={x:U(n,"x","round")};return X.runKernel(Tf,t)}const oS=Y({round_:sB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aB(n){const t={x:U(n,"x","rsqrt","float32")};return X.runKernel(Af,t)}const cS=Y({rsqrt_:aB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(n){const t={x:U(n,"x","selu")};return X.runKernel(Cf,t)}const lS=Y({selu_:oB});function cB(n,e,t,r,i,s=[1,1],a="NHWC"){const o=U(n,"x","separableConv2d"),c=U(e,"depthwiseFilter","separableConv2d"),l=U(t,"pointwiseFilter","separableConv2d");let u=o,f=!1;if(o.rank===3&&(f=!0,u=j(o,[1,o.shape[0],o.shape[1],o.shape[2]])),a==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");R(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),R(c.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${c.rank}.`),R(l.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${c.rank}.`),R(l.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${l.shape[0]}.`),R(l.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${l.shape[1]}.`);const d=c.shape[2],h=c.shape[3];R(l.shape[2]===d*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${d*h}, but got ${l.shape[2]}.`);const p=Tb(u,c,r,i,a,s),m=No(p,l,1,"valid",a);return f?j(m,[m.shape[1],m.shape[2],m.shape[3]]):m}const uS=Y({separableConv2d_:cB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lB(n){const t={x:U(n,"x","sign")};return X.runKernel(Rf,t)}const uB=Y({sign_:lB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fB(n){const t={x:U(n,"x","sin","float32")};return X.runKernel(If,t)}const fS=Y({sin_:fB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dB(n){const t={x:U(n,"x","sinh")};return X.runKernel(Mf,t)}const dS=Y({sinh_:dB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hB(n,e,t){const r=U(n,"x","slice1d");return R(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Jt(r,[e],[t])}const Hb=Y({slice1d_:hB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pB(n,e,t){const r=U(n,"x","slice2d");return R(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Jt(r,e,t)}const hS=Y({slice2d_:pB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mB(n,e,t){const r=U(n,"x","slice3d");return R(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Jt(r,e,t)}const Wb=Y({slice3d_:mB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vB(n,e,t){const r=U(n,"x","slice4d");return R(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Jt(r,e,t)}const Uh=Y({slice4d_:vB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gB(n,e=-1){const t=U(n,"logits","softmax","float32");if(e===-1&&(e=t.rank-1),e!==t.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${t.rank} and dim was ${e}`);const r={logits:t},i={dim:e};return X.runKernel(pm,r,i)}const qb=Y({softmax_:gB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xB(n){R(n.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${n.dtype}.`);const e={input:n};return X.runKernel(K0,e)}const pS=Y({fft_:xB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bB(n){R(n.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${n.dtype}.`);const e={input:n};return X.runKernel(Z0,e)}const xx=Y({ifft_:bB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _B(n){const e=n.shape[n.shape.length-1],t=n.size/e;let r;if(e<=2){const i=j(n,[t,e]);r=xx(i)}else{const i=[t,2*(e-1)],s=j($h(n),[t,e]),a=j(Ib(n),[t,e]),o=Ki(Jt(s,[0,1],[t,e-2]),1),c=W(Ki(Jt(a,[0,1],[t,e-2]),1),zt(-1)),l=nr([s,o],1),u=nr([a,c],1),f=j(rl(l,u),[i[0],i[1]]);r=xx(f)}if(r=$h(r),n.rank===3&&n.shape[0]!==0){const i=r,s=n.shape[0];r=j(r,[s,r.shape[0]/s,r.shape[1]]),i.dispose()}return r}const yB=Y({irfft_:_B});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wB(n,e,t=0){const i={x:U(n,"x","split")},s={numOrSizeSplits:e,axis:t};return X.runKernel(hm,i,s)}const ti=Y({split_:wB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EB(n,e){R(n.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${n.dtype}`);let t=n.shape[n.shape.length-1];const r=n.size/t;let i;if(e!=null&&e<t){const p=n.shape.map(m=>0),g=n.shape.map(m=>m);g[n.shape.length-1]=e,i=Jt(n,p,g),t=e}else if(e!=null&&e>t){const p=n.shape.map(g=>g);p[n.shape.length-1]=e-t,i=nr([n,Un(p)],n.shape.length-1),t=e}else i=n;const s=Rt(i),a=j(rl(i,s),[r,t]),o=pS(a),c=Math.floor(t/2)+1,l=$h(o),u=Ib(o),f=ti(l,[c,t-c],l.shape.length-1),d=ti(u,[c,t-c],u.shape.length-1),h=i.shape.slice();return h[i.shape.length-1]=c,j(rl(f[0],d[0]),h)}const SB=Y({rfft_:EB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TB(n,e){let t=U(n,"a","squaredDifference"),r=U(e,"b","squaredDifference");[t,r]=_n(t,r),pt(t.shape,r.shape);const i={a:t,b:r},s={};return X.runKernel(Lf,i,s)}const AB=Y({squaredDifference_:TB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CB(n,e){const t=U(n,"x","squeeze","string_or_numeric");return j(t,$a(t.shape,e).newShape)}const qf=Y({squeeze_:CB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IB(n,e=0){const t=k3(n,"tensors","stack","string_or_numeric");R(t.length>=1,()=>"Pass at least one tensor to tf.stack"),t.length>0&&R(e<=t[0].rank,()=>"Axis must be <= rank of the tensor");const r=t,i={axis:e};return X.runKernel(tm,r,i)}const Ks=Y({stack_:IB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MB(n,e=0){const r={x:U(n,"x","step")},i={alpha:e};return X.runKernel($f,r,i)}const Xf=Y({step_:MB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RB(n,e,t,r,i=0,s=0,a=0,o=0,c=0){const u={x:U(n,"x","stridedSlice","string_or_numeric")},f={begin:e,end:t,strides:r,beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:c};return X.runKernel(fb,u,f)}const NB=Y({stridedSlice_:RB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kB(n){const t={x:U(n,"x","tan","float32")};return X.runKernel(zf,t)}const DB=Y({tan_:kB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vr(n,e){T0(n);const t=Uf(n,e);if(t.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Bf(n,null,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uv(n,e,t){if(T0(n),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=Uf(n,t);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Bf(n,e,r,t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bv(n,e,t){if(T0(n),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=Uf(n,t);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Bf(n,e,r,t)}function mS(n,e,t){const r=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${t.shape}, indices.shape: ${e.shape}, shape: ${n}, sliceDim: ${r}, and batchDim: ${i}.`;if(t.rank<i)throw new Error(s+` update.rank < ${i}. `);if(n.length<r+(t.rank-i))throw new Error(s+` Output shape length < ${r+(t.rank-i)}`);if(t.rank!==i+n.length-r)throw new Error(s+` update.rank != ${i+n.length-r}`);for(let a=0;a<i;++a)if(t.shape[a]!==e.shape[a])throw new Error(s+` updates.shape[${a}] (${t.shape[a]}) != indices.shape[${a}] (${e.shape[a]}).`);for(let a=0;a<t.rank-i;++a)if(t.shape[a+i]!==n[a+r])throw new Error(s+` updates.shape[${a+i}] (${t.shape[a+i]}) != shape[${a+i}] (${n[a+i]})`)}function LB(n,e,t){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(n.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${n.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(t.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${t}`);if(t.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(n.size===0)throw new Error(`Updates specified for empty output. updates shape: ${n.shape}`)}mS(t,e,n)}function Xo(n,e,t){const r=e.shape.length,i=r>1?e.shape[r-1]:1,s=t.length;let a=1;for(let f=i;f<s;++f)a*=t[f];const o=i<1?1:i,c=ue(e.shape)/o,l=[...Qe(t.slice(0,i)),1],u=ue(t);return{sliceRank:i,numUpdates:c,sliceSize:a,strides:l,outputSize:u}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OB(n,e=1,t=!0){const r=U(n,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const s={x:r},a={k:e,sorted:t},[o,c]=X.runKernel(db,s,a);return{values:o,indices:c}}const zB=Y({topk_:OB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PB(n,e=0,t=1,r,i){if(ea(n),r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new sS(e,t,r,!0,i),a=Et(n,r);for(let o=0;o<a.values.length;o++)a.values[o]=s.nextValue();return a.toTensor()}const vS=Y({truncatedNormal_:PB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FB(n,e=0){const t=U(n,"x","unique","string_or_numeric");R(t.rank>0,()=>"The input tensor must be at least 1D");const r={x:t},i={axis:e},[s,a]=X.runKernel(pb,r,i);return{values:s,indices:a}}const $B=Y({unique_:FB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UB(n,e,t){const r=U(n,"x","unsortedSegmentSum"),i=U(e,"segmentIds","unsortedSegmentSum","int32");R(el(t),()=>"numSegments must be of dtype int");const s={x:r,segmentIds:i},a={numSegments:t};return X.runKernel(vm,s,a)}const gS=Y({unsortedSegmentSum_:UB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BB(n,e=0){const t=U(n,"x","unstack","string_or_numeric");R(e>=-t.shape.length&&e<t.shape.length,()=>`Axis = ${e} is not in [-${t.shape.length}, ${t.shape.length})`);const r={value:t},i={axis:e};return X.runKernel(mm,r,i)}const Lo=Y({unstack_:BB});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VB(n,e=!0,t,r){return X.makeVariable(n,e,t,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xS(n,e){const t=[];for(let s=0;s<e.length;s++)e[s]&&t.push(s);const r=Et(n,"int32"),i=Et([t.length,n.length],"int32");for(let s=0;s<t.length;s++){const a=r.indexToLoc(t[s]),o=s*n.length;i.values.set(a,o)}return i.toTensor()}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GB(n,e,t){const r=U(n,"x","transpose");if(e==null&&(e=r.shape.map((a,o)=>o).reverse()),R(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(a=>{R(a>=0&&a<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const i={x:r},s={perm:e};return r.dtype==="complex64"?te(()=>{let a=$h(r),o=Ib(r);return a=X.runKernel(Fc,{x:a},s),o=X.runKernel(Fc,{x:o},s),t&&(o=bn(o)),rl(a,o)}):X.runKernel(Fc,i,s)}const Mt=Y({transpose_:GB});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HB(n,e){if(e==null)return n.shape.slice();if(Pt(n.shape,e))return e;if(n.shape.length===e.length){const t=[];for(let r=0;r<n.shape.length;r++)e[r]==null&&n.shape[r]!=null?t.push(n.shape[r]):t.push(e[r]);return t}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WB(n,e,t,r){const i=U(n,"x","dropout");if(R(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),R(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return n instanceof Nn?i.clone():i;const s=HB(i,t),a=1-e,o=nt(Sm(ye(Wf(s,0,1,"float32",r),a)),a);return W(i,o)}const qB=Y({dropout_:WB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XB(n,e,t,r,i,s="NHWC",a){let o=n;n.rank===3&&(o=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=j(e,[1,e.shape[0],e.shape[1],e.shape[2]])),R(o.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${o.shape}.`),R(c.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${c.shape}.`),R(t.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${t}.`);const l=s==="NHWC"?o.shape[3]:o.shape[1],u=s==="NHWC"?c.shape[3]:c.shape[1];R(l===t[2],()=>`Error in conv2dDerFilter: depth of input ${l}) must match input depth in filter (${t[2]}.`),R(u===t[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${t[3]}).`),kr("conv2dDerFilter",i,a);const f={x:o,dy:c},d={strides:r,pad:i,dataFormat:s,dimRoundingMode:a,filterShape:t};return X.runKernel(P0,f,d)}const Xb=Y({conv2DBackpropFilter_:XB});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kb(n,e,t){if(t==null||t==="linear")return n;if(t==="relu")return W(n,Xf(e));throw new Error(`Cannot compute gradient for fused activation ${t}.`)}function jb(n,e){let t=e;const r=zn(n.shape,e.shape);return r.length>0&&(t=et(t,r)),j(t,n.shape)}function Yb(n,e,t,r){if(e==="linear")return n;if(e==="relu")return qo(n);if(e==="elu")return wm(n);if(e==="relu6")return aS(n);if(e==="prelu")return zb(n,t);if(e==="leakyrelu")return Mb(n,r);if(e==="sigmoid")return Tl(n);throw new Error(`Unknown fused activation ${e}.`)}const Zb=(n,e)=>!(n>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KB({x:n,filter:e,strides:t,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:a,bias:o,activation:c="linear",preluActivationWeights:l,leakyreluAlpha:u}){if(c=c||"linear",Zb(X.state.gradientDepth,c)===!1){R(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let E=No(n,e,t,r,i,s,a);return o!=null&&(E=ye(E,o)),Yb(E,c,l,u)}const f=U(n,"x","conv2d","float32"),d=U(e,"filter","conv2d","float32");let h=f,p=!1;f.rank===3&&(p=!0,h=j(f,[1,f.shape[0],f.shape[1],f.shape[2]])),R(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),R(d.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${d.rank}.`),kr("fused conv2d",r,a);const g=i==="NHWC"?h.shape[3]:h.shape[1];R(d.shape[2]===g,()=>`Error in conv2d: depth of input (${g}) must match input depth for filter ${d.shape[2]}.`),R(or(t,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${t} and dilations '${s}'`);const m=Yn(h.shape,d.shape,t,s,r,a);let v;o!=null&&(v=U(o,"bias","fused conv2d"),[v]=_n(v,f),i==="NHWC"?pt(m.outShape,v.shape):(R(v.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${v.shape.length}.`),R(v.shape.length===0||v.shape[0]===m.outChannels||v.shape[0]===1,()=>`Error in fused conv2d: bias shape (${v.shape}) is not compatible with the number of output channels (${m.outChannels})`)));let x;if(l!=null){const E=l.shape;if(R(E.length<=1||E.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${E.length}.`),E.length===1)R(E[0]===1||E[0]===m.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the number of output channels (${m.outChannels}).`);else if(E.length===3)try{pt(E,m.outShape)}catch{const T=`Error in fused conv2d: PReLU activation weights (${E}) is not compatible with the output shape of the conv2d (${m.outShape}).`;throw Error(T)}x=U(l,"prelu weights","fused conv2d")}const b=(E,S)=>{R(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[T,C,y,A]=S,k=Kb(E,y,c);R(Mo(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const M=Eb(C.shape,k,T,t,r),L=Xb(C,k,T.shape,t,r),z=[M,L];if(A!=null){const D=jb(A,k);z.push(D)}return z},_={x:h,filter:d,bias:v,preluActivationWeights:x},w={strides:t,pad:r,dataFormat:i,dilations:s,dimRoundingMode:a,activation:c,leakyreluAlpha:u};return o==null?sl((S,T,C)=>{let y=X.runKernel(Dh,_,w);return C([T,S,y]),p&&(y=j(y,[y.shape[1],y.shape[2],y.shape[3]])),{value:y,gradFunc:b}})(h,d):sl((S,T,C,y)=>{let A=X.runKernel(Dh,_,w);return y([T,S,A,C]),p&&(A=j(A,[A.shape[1],A.shape[2],A.shape[3]])),{value:A,gradFunc:b}})(h,d,v)}const jB=Y({fusedConv2d_:KB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YB(n,e,t,r,i,s=[1,1],a){let o=n;n.rank===3&&(o=j(n,[1,n.shape[0],n.shape[1],n.shape[2]]));let c=e;c.rank===3&&(c=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={x:o,dy:c},u={strides:r,pad:i,dimRoundingMode:a,dilations:s,filterShape:t};return X.runKernel(H0,l,u)}const ZB=Y({depthwiseConv2dNativeBackpropFilter_:YB});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QB(n,e,t,r,i,s=[1,1],a){let o=e,c=!1;e.rank===3&&(c=!0,o=j(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const l={dy:o,filter:t},u={strides:r,pad:i,dimRoundingMode:a,dilations:s,inputShape:n},f=X.runKernel(W0,l,u);return c?j(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const JB=Y({depthwiseConv2dNativeBackpropInput_:QB});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eV({a:n,b:e,transposeA:t=!1,transposeB:r=!1,bias:i,activation:s="linear",preluActivationWeights:a,leakyreluAlpha:o=.2}){if(Zb(X.state.gradientDepth,s)===!1){let A=Ot(n,e,t,r);return i!=null&&(A=ye(A,i)),Yb(A,s,a,o)}let c=U(n,"a","fused matMul"),l=U(e,"b","fused matMul");[c,l]=_n(c,l);const u=t?c.shape[c.rank-2]:c.shape[c.rank-1],f=r?l.shape[l.rank-1]:l.shape[l.rank-2],d=t?c.shape[c.rank-1]:c.shape[c.rank-2],h=r?l.shape[l.rank-2]:l.shape[l.rank-1],p=c.shape.slice(0,-2),g=l.shape.slice(0,-2),m=ue(p),v=ue(g);R(u===f,()=>`Error in fused matMul: inner shapes (${u}) and (${f}) of Tensors with shapes ${c.shape} and ${l.shape} and transposeA=${t} and transposeB=${r} must match.`);const b=pt(c.shape.slice(0,-2),l.shape.slice(0,-2)).concat([d,h]),_=t?j(c,[m,u,d]):j(c,[m,d,u]),w=r?j(l,[v,h,f]):j(l,[v,f,h]);let E;i!=null&&(E=U(i,"bias","fused matMul"),[E]=_n(E,c),pt(b,E.shape));let S;a!=null&&(S=U(a,"prelu weights","fused matMul"));const T=(A,k)=>{const[M,L,z,D]=k,F=Kb(j(A,z.shape),z,s);let O,V;if(!t&&!r?(O=Ot(F,L,!1,!0),V=Ot(M,F,!0,!1)):!t&&r?(O=Ot(F,L,!1,!1),V=Ot(F,M,!0,!1)):t&&!r?(O=Ot(L,F,!1,!0),V=Ot(M,F,!1,!1)):(O=Ot(L,F,!0,!0),V=Ot(F,M,!0,!0)),i!=null){const J=jb(D,F);return[O,V,J]}else return[O,V]},C={a:_,b:w,bias:E,preluActivationWeights:S},y={transposeA:t,transposeB:r,activation:s,leakyreluAlpha:o};return i==null?sl((k,M,L)=>{const z=X.runKernel(kh,C,y);return L([k,M,z]),{value:j(z,b),gradFunc:T}})(_,w):sl((k,M,L,z)=>{const D=X.runKernel(kh,C,y);return z([k,M,D,L]),{value:j(D,b),gradFunc:T}})(_,w,E)}const T2=Y({fusedMatMul_:eV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tV(n,e,t,r,i="bilinear",s=0){const a=U(n,"image","cropAndResize"),o=U(e,"boxes","cropAndResize","float32"),c=U(t,"boxInd","cropAndResize","int32"),l=o.shape[0];R(a.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${a.rank}.`),R(o.rank===2&&o.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${l},4] but had shape ${o.shape}.`),R(c.rank===1&&c.shape[0]===l,()=>`Error in cropAndResize: boxInd must be have size [${l}] but had shape ${o.shape}.`),R(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),R(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),R(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const u={image:a,boxes:o,boxInd:c},f={method:i,extrapolationValue:s,cropSize:r};return X.runKernel(B0,u,f)}const nV=Y({cropAndResize_:tV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rV(n){const e=U(n,"image","flipLeftRight","float32");R(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const t={image:e};return X.runKernel(Y0,t,{})}const iV=Y({flipLeftRight_:rV});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sV(n){const e=U(n,"image","grayscaleToRGB"),t=e.rank-1,r=e.shape[t];R(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),R(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const i=new Array(e.rank);return i.fill(1,0,t),i[t]=3,Vi(e,i)}const aV=Y({grayscaleToRGB_:sV});/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oV(n){const e=U(n,"image","RGBToGrayscale"),t=e.rank-1,r=e.shape[t];R(e.rank>=2,()=>`Error in RGBToGrayscale: images must be at least rank 2, but got rank ${e.rank}.`),R(r===3,()=>`Error in RGBToGrayscale: last dimension of an RGB image should be size 3, but got size ${r}.`);const i=e.dtype,s=Ie(e,"float32"),a=Vr([.2989,.587,.114]);let o;switch(e.rank){case 2:o=ru("ij,j->i",s,a);break;case 3:o=ru("ijk,k->ij",s,a);break;case 4:o=ru("ijkl,l->ijk",s,a);break;case 5:o=ru("ijklm,m->ijkl",s,a);break;case 6:o=ru("ijklmn,n->ijklm",s,a);break;default:throw new Error("Not a valid tensor rank.")}return o=Sr(o,-1),Ie(o,i)}const cV=Y({rgbToGrayscale_:oV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lV(n,e,t=0,r=.5){const i=U(n,"image","rotateWithOffset","float32");R(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const s={image:i},a={radians:e,fillValue:t,center:r};return X.runKernel(mb,s,a)}const uV=Y({rotateWithOffset_:lV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cl(n,e,t,r,i,s){r==null&&(r=.5),i==null&&(i=Number.NEGATIVE_INFINITY),s==null&&(s=0);const a=n.shape[0];return t=Math.min(t,a),R(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),R(n.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${n.rank}'`),R(n.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${n.shape[1]}`),R(e.rank===1,()=>"scores must be a 1D tensor"),R(e.shape[0]===a,()=>`scores has incompatible shape with boxes. Expected ${a}, but was ${e.shape[0]}`),R(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:t,iouThreshold:r,scoreThreshold:i,softNmsSigma:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fV(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY){const s=U(n,"boxes","nonMaxSuppression","float32"),a=U(e,"scores","nonMaxSuppression","float32"),o=Cl(s,a,t,r,i);t=o.maxOutputSize,r=o.iouThreshold,i=o.scoreThreshold;const c={maxOutputSize:t,iouThreshold:r,scoreThreshold:i};return X.runKernel(nb,{boxes:s,scores:a},c)}const dV=Y({nonMaxSuppression_:fV});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hV(n,e,t){const r=pV(n,e,t),i=r<0?-(r+1):r;n.splice(i,0,e)}function pV(n,e,t){return vV(n,e,t||mV)}function mV(n,e){return n>e?1:n<e?-1:0}function vV(n,e,t){let r=0,i=n.length,s=0,a=!1;for(;r<i;){s=r+(i-r>>>1);const o=t(e,n[s]);o>0?r=s+1:(i=s,a=!o)}return a?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qb(n,e,t,r,i){return t_(n,e,t,r,i,0)}function Jb(n,e,t,r,i,s){return t_(n,e,t,r,i,0,!1,s,!0)}function e_(n,e,t,r,i,s){return t_(n,e,t,r,i,s,!0)}function t_(n,e,t,r,i,s,a=!1,o=!1,c=!1){const l=[];for(let m=0;m<e.length;m++)e[m]>i&&l.push({score:e[m],boxIndex:m,suppressBeginIndex:0});l.sort(A2);const u=s>0?-.5/s:0,f=[],d=[];for(;f.length<t&&l.length>0;){const m=l.pop(),{score:v,boxIndex:x,suppressBeginIndex:b}=m;if(v<i)break;let _=!1;for(let w=f.length-1;w>=b;--w){const E=gV(n,x,f[w]);if(E>=r){_=!0;break}if(m.score=m.score*xV(r,u,E),m.score<=i)break}m.suppressBeginIndex=f.length,_||(m.score===v?(f.push(x),d.push(m.score)):m.score>i&&hV(l,m,A2))}const h=f.length,p=t-h;o&&p>0&&(f.push(...new Array(p).fill(0)),d.push(...new Array(p).fill(0)));const g={selectedIndices:f};return a&&(g.selectedScores=d),c&&(g.validOutputs=h),g}function gV(n,e,t){const r=n.subarray(e*4,e*4+4),i=n.subarray(t*4,t*4+4),s=Math.min(r[0],r[2]),a=Math.min(r[1],r[3]),o=Math.max(r[0],r[2]),c=Math.max(r[1],r[3]),l=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),f=Math.max(i[0],i[2]),d=Math.max(i[1],i[3]),h=(o-s)*(c-a),p=(f-l)*(d-u);if(h<=0||p<=0)return 0;const g=Math.max(s,l),m=Math.max(a,u),v=Math.min(o,f),x=Math.min(c,d),b=Math.max(v-g,0)*Math.max(x-m,0);return b/(h+p-b)}function xV(n,e,t){const r=Math.exp(e*t*t);return t<=n?r:0}function A2(n,e){return n.score-e.score||n.score===e.score&&e.boxIndex-n.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function bV(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY){const s=U(n,"boxes","nonMaxSuppressionAsync"),a=U(e,"scores","nonMaxSuppressionAsync"),o=Cl(s,a,t,r,i);t=o.maxOutputSize,r=o.iouThreshold,i=o.scoreThreshold;const c=await Promise.all([s.data(),a.data()]),l=c[0],u=c[1],{selectedIndices:f}=Qb(l,u,t,r,i);return s!==n&&s.dispose(),a!==e&&a.dispose(),Vr(f,"int32")}const _V=bV;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yV(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=U(n,"boxes","nonMaxSuppression"),o=U(e,"scores","nonMaxSuppression"),c=Cl(a,o,t,r,i,s);t=c.maxOutputSize,r=c.iouThreshold,i=c.scoreThreshold,s=c.softNmsSigma;const l={boxes:a,scores:o},u={maxOutputSize:t,iouThreshold:r,scoreThreshold:i,softNmsSigma:s},f=X.runKernel(ib,l,u);return{selectedIndices:f[0],selectedScores:f[1]}}const wV=Y({nonMaxSuppressionWithScore_:yV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function EV(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const a=U(n,"boxes","nonMaxSuppressionAsync"),o=U(e,"scores","nonMaxSuppressionAsync"),c=Cl(a,o,t,r,i,s);t=c.maxOutputSize,r=c.iouThreshold,i=c.scoreThreshold,s=c.softNmsSigma;const l=await Promise.all([a.data(),o.data()]),u=l[0],f=l[1],{selectedIndices:d,selectedScores:h}=e_(u,f,t,r,i,s);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Vr(d,"int32"),selectedScores:Vr(h)}}const SV=EV;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TV(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=U(n,"boxes","nonMaxSuppression"),o=U(e,"scores","nonMaxSuppression"),c=Cl(a,o,t,r,i,null),l=c.maxOutputSize,u=c.iouThreshold,f=c.scoreThreshold,d={boxes:a,scores:o},h={maxOutputSize:l,iouThreshold:u,scoreThreshold:f,padToMaxOutputSize:s},p=X.runKernel(rb,d,h);return{selectedIndices:p[0],validOutputs:p[1]}}const AV=Y({nonMaxSuppressionPadded_:TV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function CV(n,e,t,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const a=U(n,"boxes","nonMaxSuppressionAsync"),o=U(e,"scores","nonMaxSuppressionAsync"),c=Cl(a,o,t,r,i,null),l=c.maxOutputSize,u=c.iouThreshold,f=c.scoreThreshold,[d,h]=await Promise.all([a.data(),o.data()]),{selectedIndices:p,validOutputs:g}=Jb(d,h,l,u,f,s);return a!==n&&a.dispose(),o!==e&&o.dispose(),{selectedIndices:Vr(p,"int32"),validOutputs:zt(g,"int32")}}const IV=CV;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MV(n,e,t=!1,r=!1){const i=U(n,"images","resizeBilinear");R(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),R(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),R(r===!1||t===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=i,a=!1;i.rank===3&&(a=!0,s=j(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:s},c={alignCorners:t,halfPixelCenters:r,size:e},l=X.runKernel(om,o,c);return a?j(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const bS=Y({resizeBilinear_:MV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RV(n,e,t=!1,r=!1){const i=U(n,"images","resizeNearestNeighbor");R(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),R(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),R(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),R(r===!1||t===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=i,a=!1;i.rank===3&&(a=!0,s=j(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const o={images:s},c={alignCorners:t,halfPixelCenters:r,size:e},l=X.runKernel(am,o,c);return a?j(l,[l.shape[1],l.shape[2],l.shape[3]]):l}const _S=Y({resizeNearestNeighbor_:RV});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NV(n,e="binary",t=!1,r=.5){const i=U(n,"image","threshold"),s=.2989,a=.587,o=.114,c=i.shape[0]*i.shape[1];let l=W(Vr([r]),255),u,f,d,h;if(R(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),R(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),R(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),R(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[u,f,d]=ti(i,[1,1,1],-1);const m=W(u,s),v=W(f,a),x=W(d,o);h=ye(ye(m,v),x)}else h=n;if(e==="otsu"){const m=k$(Ie(oS(h),"int32"),xb([]),256);l=kV(m,c)}const p=t?Al(h,l):ri(h,l);return Ie(W(p,255),"int32")}function kV(n,e){let t=Vr([-1]),r=Vr([0]),i=Vr([0]),s,a,o,c,l,u;for(let f=0;f<n.size-1;f++){s=Jt(n,0,f+1),a=Jt(n,f+1),l=nt(et(s),e),u=nt(et(a),e);const d=et(W(s,Iu(0,s.size)));o=nt(d,et(s));const h=ym(a.shape,s.size),p=ye(Iu(0,a.size),h),g=W(a,p);c=nt(et(g),et(a));const m=st(o,c),v=st(o,c),x=W(l,u);i=W(W(x,m),v);const b=ri(i,r);r=xn(b,i,r),t=xn(b,Vr([f]),t)}return t}const DV=Y({threshold_:NV});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LV(n,e,t="nearest",r="constant",i=0,s){const a=U(n,"image","transform","float32"),o=U(e,"transforms","transform","float32");R(a.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${a.rank}.`),R(o.rank===2&&(o.shape[0]===a.shape[0]||o.shape[0]===1)&&o.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),R(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const c={image:a,transforms:o},l={interpolation:t,fillMode:r,fillValue:i,outputShape:s};return X.runKernel(hb,c,l)}const OV=Y({transform_:LV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zV(n,e,t){const r=U(n,"a","bandPart");R(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const i=r.shape,[s,a]=r.shape.slice(-2);let o,c;typeof e=="number"?(R(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),R(e<=s,()=>`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`),o=U(e<0?s:e,"numLower","bandPart")):(R(e.dtype==="int32",()=>"bandPart(): numLower's dtype must be an int32."),o=xn(Fh(e,0),s,Cu(e,s))),typeof t=="number"?(R(t%1===0,()=>`bandPart(): numUpper must be an integer, got ${t}.`),R(t<=a,()=>`bandPart(): numUpper (${t}) must not be greater than the number of columns (${a}).`),c=U(t<0?a:t,"numUpper","bandPart")):(R(t.dtype==="int32",()=>"bandPart(): numUpper's dtype must be an int32."),c=xn(Fh(t,0),a,Cu(t,a)));const l=j(Iu(0,s,1,"int32"),[-1,1]),u=Iu(0,a,1,"int32"),f=st(l,u),d=Xs(Al(f,o),Ho(f,bn(c))),h=Un([s,a],r.dtype);return j(Ks(Lo(j(r,[-1,s,a])).map(p=>xn(d,p,h))),i)}const PV=Y({bandPart_:zV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FV(n){let e;if(Array.isArray(n)){e=!1,R(n!=null&&n.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=n[0].shape[0];for(let s=1;s<n.length;++s)R(n[s].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${n[s].shape[0]} vs. ${i})`)}else e=!0,n=ti(n,n.shape[0],0).map(i=>qf(i,[0]));R(n.length<=n[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${n.length}) exceeds number of dimensions (${n[0].shape[0]}).`);const t=[],r=n;for(let i=0;i<n.length;++i)t.push(X.tidy(()=>{let s=r[i];if(i>0)for(let a=0;a<i;++a){const o=W(et(W(t[a],s)),t[a]);s=st(s,o)}return nt(s,Em(s,"euclidean"))}));return e?Ks(t,0):t}const $V=Y({gramSchmidt_:FV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UV(n,e=!1){if(R(n.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${n.rank}`),n.rank===2)return C2(n,e);{const t=n.shape.slice(0,n.shape.length-2).reduce((c,l)=>c*l),r=Lo(j(n,[t,n.shape[n.shape.length-2],n.shape[n.shape.length-1]]),0),i=[],s=[];r.forEach(c=>{const[l,u]=C2(c,e);i.push(l),s.push(u)});const a=j(Ks(i,0),n.shape),o=j(Ks(s,0),n.shape);return[a,o]}}function C2(n,e=!1){return X.tidy(()=>{R(n.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${n.shape.length}D Tensor.`);const t=n.shape[0],r=n.shape[1];let i=Q3(t),s=bo(n);const a=Uv([[1]],[1,1]);let o=bo(a);const c=t>=r?r:t;for(let l=0;l<c;++l){const u=s,f=o,d=i;[o,s,i]=X.tidy(()=>{const h=Jt(s,[l,l],[t-l,1]),p=Em(h),g=Jt(s,[l,l],[1,1]),m=xn(ri(g,0),Uv([[-1]]),Uv([[1]])),v=st(g,W(m,p)),x=nt(h,v);x.shape[0]===1?o=bo(a):o=nr([a,Jt(x,[1,0],[x.shape[0]-1,x.shape[1]])],0);const b=bn(nt(Ot(m,v),p)),_=Jt(s,[l,0],[t-l,r]),w=W(b,o),E=Mt(o);if(l===0)s=st(_,Ot(w,Ot(E,_)));else{const C=st(_,Ot(w,Ot(E,_)));s=nr([Jt(s,[0,0],[l,r]),C],0)}const S=Mt(w),T=Jt(i,[0,l],[t,i.shape[1]-l]);if(l===0)i=st(T,Ot(Ot(T,o),S));else{const C=st(T,Ot(Ot(T,o),S));i=nr([Jt(i,[0,0],[t,l]),C],1)}return[o,s,i]}),He([u,f,d])}return!e&&t>r&&(i=Jt(i,[0,0],[t,r]),s=Jt(s,[0,0],[r,r])),[i,s]})}const BV=Y({qr_:UV});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vs={flipLeftRight:iV,grayscaleToRGB:aV,resizeNearestNeighbor:_S,resizeBilinear:bS,rgbToGrayscale:cV,rotateWithOffset:uV,cropAndResize:nV,nonMaxSuppression:dV,nonMaxSuppressionAsync:_V,nonMaxSuppressionWithScore:wV,nonMaxSuppressionWithScoreAsync:SV,nonMaxSuppressionPadded:AV,nonMaxSuppressionPaddedAsync:IV,threshold:DV,transform:OV},VV={bandPart:PV,gramSchmidt:$V,qr:BV};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GV=new Map,HV=new Map;class Il{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class hi{constructor(){this.classNameMap={}}static getMap(){return hi.instance==null&&(hi.instance=new hi),hi.instance}static register(e){hi.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function ge(n,e,t){R(n.className!=null,()=>"Class being registered does not have the static className property defined."),R(typeof n.className=="string",()=>"className is required to be a string, but got type "+typeof n.className),R(n.className.length>0,()=>"Class being registered has an empty-string as its className, which is disallowed."),typeof e>"u"&&(e="Custom"),typeof t>"u"&&(t=n.className);const r=t,i=e+">"+r;return hi.register(n),GV.set(i,n),HV.set(n,i),n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Wa extends Il{minimize(e,t=!1,r){const{value:i,grads:s}=this.computeGradients(e,r);if(r!=null){const a=r.map(o=>({name:o.name,tensor:s[o.name]}));this.applyGradients(a)}else this.applyGradients(s);return He(s),t?i:(i.dispose(),null)}get iterations(){return this.iterations_==null&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return QU(e,t)}dispose(){this.iterations_!=null&&He(this.iterations_)}async saveIterations(){return this.iterations_==null&&(this.iterations_=0),{name:"iter",tensor:zt(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error(`setWeights() is not implemented for this optimizer class ${this.getClassName()}`)}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Wa,Symbol.hasInstance,{value:n=>n.minimize!=null&&n.computeGradients!=null&&n.applyGradients!=null});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yS extends Wa{static get className(){return"Adadelta"}constructor(e,t,r=null){super(),this.learningRate=e,this.rho=t,this.epsilon=r,this.accumulatedGrads=[],this.accumulatedUpdates=[],r==null&&(this.epsilon=X.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=X.registeredVariables[r],a=!1;this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${r}/accum_grad`,variable:te(()=>Rt(s).variable(a))}),this.accumulatedUpdates[i]==null&&(this.accumulatedUpdates[i]={originalName:`${r}/accum_var`,variable:te(()=>Rt(s).variable(a))});const o=Array.isArray(e)?e[i].tensor:e[r];if(o==null)return;const c=this.accumulatedGrads[i].variable,l=this.accumulatedUpdates[i].variable;te(()=>{const u=ye(W(c,this.rho),W(nn(o),1-this.rho)),f=W(nt(ar(ye(l,this.epsilon)),ar(ye(c,this.epsilon))),o),d=ye(W(l,this.rho),W(nn(f),1-this.rho));c.assign(u),l.assign(d);const h=ye(W(f,-this.learningRate),s);s.assign(h)})}),this.incrementIterations()}dispose(){this.accumulatedUpdates!=null&&(He(this.accumulatedGrads.map(e=>e.variable)),He(this.accumulatedUpdates.map(e=>e.variable)))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=e.length/2,r=!1;this.accumulatedGrads=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),this.accumulatedUpdates=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wS extends Wa{static get className(){return"Adagrad"}constructor(e,t=.1){super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=X.registeredVariables[r];this.accumulatedGrads[i]==null&&(this.accumulatedGrads[i]={originalName:`${r}/accumulator`,variable:te(()=>ym(s.shape,this.initialAccumulatorValue).variable(!1))});const a=Array.isArray(e)?e[i].tensor:e[r];if(a==null)return;const o=this.accumulatedGrads[i].variable;te(()=>{const c=ye(o,nn(a));o.assign(c);const l=ye(W(nt(a,ar(ye(c,X.backend.epsilon()))),-this.learningRate),s);s.assign(l)})}),this.incrementIterations()}dispose(){this.accumulatedGrads!=null&&He(this.accumulatedGrads.map(e=>e.variable))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulatedGrads=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ES extends Wa{static get className(){return"Adam"}constructor(e,t,r,i=null){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=i,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],te(()=>{this.accBeta1=zt(t).variable(),this.accBeta2=zt(r).variable()}),i==null&&(this.epsilon=X.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);te(()=>{const r=st(1,this.accBeta1),i=st(1,this.accBeta2);t.forEach((s,a)=>{const o=X.registeredVariables[s],c=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:te(()=>Rt(o).variable(c))}),this.accumulatedSecondMoment[a]==null&&(this.accumulatedSecondMoment[a]={originalName:`${s}/v`,variable:te(()=>Rt(o).variable(c))});const l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;const u=this.accumulatedFirstMoment[a].variable,f=this.accumulatedSecondMoment[a].variable,d=ye(W(u,this.beta1),W(l,1-this.beta1)),h=ye(W(f,this.beta2),W(nn(l),1-this.beta2)),p=nt(d,r),g=nt(h,i);u.assign(d),f.assign(h);const m=ye(W(nt(p,ye(ar(g),this.epsilon)),-this.learningRate),o);o.assign(m)}),this.accBeta1.assign(W(this.accBeta1,this.beta1)),this.accBeta2.assign(W(this.accBeta2,this.beta2))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),this.accumulatedFirstMoment!=null&&He(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedSecondMoment!=null&&He(this.accumulatedSecondMoment.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e),te(()=>{this.accBeta1.assign(ko(this.beta1,this.iterations_+1)),this.accBeta2.assign(ko(this.beta2,this.iterations_+1))});const t=e.length/2,r=!1;this.accumulatedFirstMoment=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),this.accumulatedSecondMoment=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(r)}))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SS extends Wa{static get className(){return"Adamax"}constructor(e,t,r,i=null,s=0){super(),this.learningRate=e,this.beta1=t,this.beta2=r,this.epsilon=i,this.decay=s,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],te(()=>{this.iteration=zt(0).variable(),this.accBeta1=zt(t).variable()}),i==null&&(this.epsilon=X.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map(r=>r.name):Object.keys(e);te(()=>{const r=st(1,this.accBeta1),i=nt(-this.learningRate,ye(W(this.iteration,this.decay),1));t.forEach((s,a)=>{const o=X.registeredVariables[s],c=!1;this.accumulatedFirstMoment[a]==null&&(this.accumulatedFirstMoment[a]={originalName:`${s}/m`,variable:Rt(o).variable(c)}),this.accumulatedWeightedInfNorm[a]==null&&(this.accumulatedWeightedInfNorm[a]={originalName:`${s}/v`,variable:Rt(o).variable(c)});const l=Array.isArray(e)?e[a].tensor:e[s];if(l==null)return;const u=this.accumulatedFirstMoment[a].variable,f=this.accumulatedWeightedInfNorm[a].variable,d=ye(W(u,this.beta1),W(l,1-this.beta1)),h=W(f,this.beta2),p=pr(l),g=Ga(h,p);u.assign(d),f.assign(g);const m=ye(W(nt(i,r),nt(d,ye(g,this.epsilon))),o);o.assign(m)}),this.iteration.assign(ye(this.iteration,1)),this.accBeta1.assign(W(this.accBeta1,this.beta1))}),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),this.accumulatedFirstMoment!=null&&He(this.accumulatedFirstMoment.map(e=>e.variable)),this.accumulatedWeightedInfNorm!=null&&He(this.accumulatedWeightedInfNorm.map(e=>e.variable))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class n_ extends Wa{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=Array.isArray(e)?e[i].tensor:e[r];if(s==null)return;const a=X.registeredVariables[r];te(()=>{const o=ye(W(this.c,s),a);a.assign(o)})}),this.incrementIterations()}setLearningRate(e){this.learningRate=e,this.c!=null&&this.c.dispose(),this.c=fs(zt(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(e=await this.extractIterations(e),e.length!==0)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class TS extends n_{static get className(){return"Momentum"}constructor(e,t,r=!1){super(e),this.learningRate=e,this.momentum=t,this.useNesterov=r,this.accumulations=[],this.m=zt(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=X.registeredVariables[r];this.accumulations[i]==null&&(this.accumulations[i]={originalName:`${r}/momentum`,variable:te(()=>Rt(s).variable(!1))});const a=this.accumulations[i].variable,o=Array.isArray(e)?e[i].tensor:e[r];o!=null&&te(()=>{let c;const l=ye(W(this.m,a),o);this.useNesterov?c=ye(W(this.c,ye(o,W(l,this.m))),s):c=ye(W(this.c,l),s),a.assign(l),s.assign(c)})}),this.incrementIterations()}dispose(){this.m.dispose(),this.accumulations!=null&&He(this.accumulations.map(e=>e.variable))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map(e=>({name:e.originalName,tensor:e.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=!1;this.accumulations=e.map(r=>({originalName:r.name,variable:r.tensor.variable(t)}))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class AS extends Wa{static get className(){return"RMSProp"}constructor(e,t=.9,r=0,i=null,s=!1){if(super(),this.learningRate=e,this.decay=t,this.momentum=r,this.epsilon=i,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=s,i==null&&(this.epsilon=X.backend.epsilon()),e==null)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map(r=>r.name):Object.keys(e)).forEach((r,i)=>{const s=X.registeredVariables[r],a=!1;this.accumulatedMeanSquares[i]==null&&(this.accumulatedMeanSquares[i]={originalName:`${r}/rms`,variable:te(()=>Rt(s).variable(a))}),this.accumulatedMoments[i]==null&&(this.accumulatedMoments[i]={originalName:`${r}/momentum`,variable:te(()=>Rt(s).variable(a))}),this.accumulatedMeanGrads[i]==null&&this.centered&&(this.accumulatedMeanGrads[i]={originalName:`${r}/mg`,variable:te(()=>Rt(s).variable(a))});const o=Array.isArray(e)?e[i].tensor:e[r];if(o==null)return;const c=this.accumulatedMeanSquares[i].variable,l=this.accumulatedMoments[i].variable;te(()=>{const u=ye(W(c,this.decay),W(nn(o),1-this.decay));if(this.centered){const f=this.accumulatedMeanGrads[i].variable,d=ye(W(f,this.decay),W(o,1-this.decay)),h=nt(W(o,this.learningRate),ar(st(u,ye(nn(d),this.epsilon)))),p=ye(W(l,this.momentum),h);c.assign(u),f.assign(d),l.assign(p);const g=st(s,p);s.assign(g)}else{const f=ye(W(c,this.decay),W(nn(o),1-this.decay)),d=ye(W(l,this.momentum),nt(W(o,this.learningRate),ar(ye(f,this.epsilon))));c.assign(f),l.assign(d);const h=st(s,d);s.assign(h)}})}),this.incrementIterations()}dispose(){this.accumulatedMeanSquares!=null&&He(this.accumulatedMeanSquares.map(e=>e.variable)),this.accumulatedMeanGrads!=null&&this.centered&&He(this.accumulatedMeanGrads.map(e=>e.variable)),this.accumulatedMoments!=null&&He(this.accumulatedMoments.map(e=>e.variable))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map(t=>({name:t.originalName,tensor:t.variable})))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,r=!1;this.accumulatedMeanSquares=e.slice(0,t).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),this.accumulatedMoments=e.slice(t,t*2).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})),this.centered&&(this.accumulatedMeanGrads=e.slice(t*2,t*3).map(i=>({originalName:i.name,variable:i.tensor.variable(r)})))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WV=[yS,wS,ES,SS,TS,AS,n_];function qV(){for(const n of WV)ge(n)}function r_(n,e){const t=n.shape.length,r=e.shape.length;if(t<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${t}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>t)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${t}`);if(ue(n.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${n.shape}.`);const i=e.shape,s=i[i.length-1];let a=1;for(let f=0;f<i.length-1;++f)a*=i[f];const o=n.shape,c=i.slice();c.pop();let l=1;for(let f=s;f<t;++f)l*=o[f],c.push(o[f]);const u=[...Qe(n.shape).map(f=>f/l),1].slice(0,s);return[c,a,l,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bx=-2,XV=-1;function i_(n,e,t){const r=n.shape.length;R(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),R(r===t.length,()=>`Error in slice${r}D: Length of size ${t} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)R(e[i]+t[i]<=n.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${e[i]+t[i]}) would overflow input.shape[${i}] (${n.shape[i]})`)}function KV(n){const e=[];let t=0;for(;n>0;)n&1&&e.push(t),n/=2,t++;return e}function s_(n,e,t){const r=[];for(let i=0;i<n.length;i++)r[i]=Math.ceil((e[i]-n[i])/t[i]);return r}function CS(n,e,t,r){const i=[...n];for(let s=i.length;s<r.length;s++)i.push(1);for(let s=0;s<t;s++)s===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function IS(n,e,t){return t<=n?t:t-(e-1)}function MS(n,e){const t=[];for(let r=0;r<n;r++)t.push(e+r);return t}function jV(n,e,t,r,i,s,a,o,c){const l=n.length;let u=new Array(l),f=new Array(l),d=new Array(l);if(e.length&&t>0){const h=e[0],p=t+1;u=RS(a,h,p,r,n),f=NS(o,h,p,i,n),d=CS(s,h,p,n)}else for(let h=0;h<l;h++)u[h]=DS(a,r,s,n,h,c),f[h]=LS(o,i,s,n,h,c),d[h]=kS(s,h,c);return{begin:u,end:f,strides:d}}function RS(n,e,t,r,i){const s=[...i],a=MS(t,e);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=0;else{const c=IS(e,t,o);let l=r[c];n&1<<c&&(l=0),s[o]=l}return s}function NS(n,e,t,r,i){const s=[...i],a=MS(t,e);for(let o=0;o<s.length;o++)if(a.indexOf(o)>-1)s[o]=Number.MAX_SAFE_INTEGER;else{const c=IS(e,t,o);let l=r[c];n&1<<c&&(l=Number.MAX_SAFE_INTEGER),s[o]=l}for(let o=0;o<s.length;o++){const c=i[o];s[o]<0&&(s[o]+=c),s[o]=To(0,s[o],i[o])}return s}function kS(n,e,t){let r=n[e];return(t&1<<e||r==null)&&(r=1),r}function DS(n,e,t,r,i,s){let a=e[i];const o=t[i]||1;(n&1<<i||s&1<<i||a==null)&&(o>0?a=Number.MIN_SAFE_INTEGER:a=Number.MAX_SAFE_INTEGER);const c=r[i];return a<0&&(a+=c),a=To(0,a,c-1),a}function LS(n,e,t,r,i,s){let a=e[i];const o=t[i]||1;(n&1<<i||s&1<<i||a==null)&&(o>0?a=Number.MAX_SAFE_INTEGER:a=Number.MIN_SAFE_INTEGER);const c=r[i];return a<0&&(a+=c),o>0?a=To(0,a,c):a=To(-1,a,c-1),a}function a_(n,e,t){let r=t.length;for(let i=0;i<t.length;i++)if(t[i]>1){r=i;break}for(let i=r+1;i<t.length;i++)if(e[i]>0||t[i]!==n[i])return!1;return!0}function o_(n,e){let t=n.length>0?n[n.length-1]:1;for(let r=0;r<n.length-1;r++)t+=n[r]*e[r];return t}function Tm(n,e,t){let r;const i=n.shape.length;typeof e=="number"?r=[e,...new Array(i-1).fill(0)]:e.length<i?r=e.concat(new Array(i-e.length).fill(0)):r=e.slice(),r.forEach(a=>{R(a!==-1,()=>"slice() does not support negative begin indexing.")});let s;return t==null?s=new Array(i).fill(-1):typeof t=="number"?s=[t,...new Array(i-1).fill(-1)]:t.length<i?s=t.concat(new Array(i-t.length).fill(-1)):s=t,s=s.map((a,o)=>a>=0?a:(R(a===-1,()=>`Negative size values should be exactly -1 but got ${a} for the slice() size at index ${o}.`),n.shape[o]-r[o])),[r,s]}function c_(n,e,t,r,i,s,a,o,c){let l;if(r==null?(l=new Array(e.length),l.fill(1)):l=r,a!=null&&a&a-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const f={dims:l.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:t.slice(),strides:l.slice(),beginMask:i,endMask:s,ellipsisMask:a,newAxisMask:o,shrinkAxisMask:c};for(let b=0;b<f.dims;b++)u&&1<<b&o&&f.numAddAxisAfterEllipsis++,1<<b&a&&(u=!0);u||(f.ellipsisMask|=1<<f.dims,f.dims++);const d={dims:n.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};YV(f,d);let h=!0,p=!0,g=!0;const m=[],v=[];for(let b=0;b<n.length;++b){if(d.strides[b]===0)throw Error(`strides[${b}] must be non-zero`);const _=!!(d.shrinkAxisMask&1<<b),w=n[b];if(w===-1){m.push(_?1:-1);continue}const E=[d.beginMask&1<<b,d.endMask&1<<b],S=[d.strides[b]>0?0:-1,d.strides[b]>0?w:w-1];if(_&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");g=g&&d.strides[b]===1;const T=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(_){const k=d.begin[b]<0?w+d.begin[b]:d.begin[b];if(d.begin[b]=k,d.end[b]=d.begin[b]+1,k<0||k>=w)throw Error(`slice index ${d.begin[b]} of dimension ${b} out of bounds.`)}else d.begin[b]=I2(d.begin[b],0,d.strides[b],w,E,S),d.end[b]=I2(d.end[b],1,d.strides[b],w,E,S);const A=d.strides[b]===1&&d.begin[b]===0&&d.end[b]===w;h=h&&A,p=p&&(b===0&&d.strides[b]===1||A)}else h=h&&d.strides[b]===1&&T,p=p&&(b===0&&d.strides[b]===1||T);let C,y=!1;if(d.beginValid&&d.endValid?(C=d.end[b]-d.begin[b],y=!0):_?(C=1,y=!0):T&&w>=0&&(d.strides[b]<0?C=-w:C=w,y=!0),y){let A;C===0||C<0!=d.strides[b]<0?A=0:A=Math.trunc(C/d.strides[b])+(C%d.strides[b]!==0?1:0),m.push(A)}else m.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const _=d.finalShapeGatherIndices[b];_>=0?v.push(m[_]):_===bx&&v.push(1)}return{finalShapeSparse:v.filter((b,_)=>d.finalShapeGatherIndices[_]!==bx),finalShape:v,isIdentity:h,sliceDim0:p,isSimpleSlice:g,begin:d.begin,end:d.end,strides:d.strides}}function YV(n,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let t=0;e.beginValid=n.begin!=null,e.endValid=n.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<n.dims;r++)if(1<<r&n.ellipsisMask){const i=Math.min(e.dims-(n.dims-r)+1+n.numAddAxisAfterEllipsis,e.dims);for(;t<i;t++)e.begin[t]=0,e.end[t]=0,e.strides[t]=1,e.beginMask|=1<<t,e.endMask|=1<<t,e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[t]=r}else if(1<<r&n.newAxisMask)e.finalShapeGatherIndices.push(bx),e.finalShapeGatherIndicesSparse.push(-1);else{if(t===e.begin.length)throw Error(`Index out of range using input dim ${t}; input has only ${e.dims} dims, ${e.begin.length}.`);n.begin!=null&&(e.begin[t]=n.begin[r]),n.end!=null&&(e.end[t]=n.end[r]),e.strides[t]=n.strides[r],n.beginMask&1<<r&&(e.beginMask|=1<<t),n.endMask&1<<r&&(e.endMask|=1<<t),n.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(XV),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<t):(e.finalShapeGatherIndices.push(t),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[t]=r,t++}}function I2(n,e,t,r,i,s){if(i[e])return t>0?s[e]:s[e+1&1];{const a=n<0?r+n:n;return a<s[0]?s[0]:a>s[1]?s[1]:a}}const ZV=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:i_,computeFlatOffset:o_,computeOutShape:s_,getNormalizedAxes:jV,isSliceContinous:a_,maskToAxes:KV,parseSliceParams:Tm,sliceInfo:c_,startForAxis:DS,startIndicesWithElidedDims:RS,stopForAxis:LS,stopIndicesWithElidedDims:NS,stridesForAxis:kS,stridesWithElidedDims:CS},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QV{static sgd(e){return new n_(e)}static momentum(e,t,r=!1){return new TS(e,t,r)}static rmsprop(e,t=.9,r=0,i=null,s=!1){return new AS(e,t,r,i,s)}static adam(e=.001,t=.9,r=.999,i=null){return new ES(e,t,r,i)}static adadelta(e=.001,t=.95,r=null){return new yS(e,t,r)}static adamax(e=.002,t=.9,r=.999,i=null,s=0){return new SS(e,t,r,i,s)}static adagrad(e,t=.1){return new wS(e,t)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bc=QV;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JV=(()=>typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:n=>n())();function OS(){return new Promise(n=>JV(()=>n()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l_(n,e){const t=n[0].length;n.forEach((i,s)=>{R(i.length===t,()=>`Error in concat${t}D: rank of tensors[${s}] must be the same as the rank of the rest (${t})`)}),R(e>=0&&e<t,()=>`Error in concat${t}D: axis must be between 0 and ${t-1}.`);const r=n[0];n.forEach((i,s)=>{for(let a=0;a<t;a++)R(a===e||i[a]===r[a],()=>`Error in concat${t}D: Shape of tensors[${s}] (${i}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function ds(n,e){const t=n[0].slice();for(let r=1;r<n.length;r++)t[e]+=n[r][e];return t}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Fi;(function(n){n[n.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",n[n.VALUE_ROWIDS=1]="VALUE_ROWIDS",n[n.ROW_LENGTHS=2]="ROW_LENGTHS",n[n.ROW_SPLITS=3]="ROW_SPLITS",n[n.ROW_LIMITS=4]="ROW_LIMITS",n[n.ROW_STARTS=5]="ROW_STARTS"})(Fi||(Fi={}));function zS(n,e,t){let r=new Array;if(t==null&&e==null)return r;if(e==null)for(;r.length<n+t.length;)r.push(-1);else r=e.slice();if(t==null)return r;if(n+t.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${n+t.length}, but shape.rank = ${r.length}`);for(let i=1;i<t.length;++i){const s=t[i],a=r[r.length-t.length+i],o=r[a];if(s>=0)if(o>=0){if(o!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+n}] = ${s} but shape[${i+n}] = ${o}`)}else r[a]=s}return r}function PS(n){const e={FIRST_DIM_SIZE:Fi.FIRST_DIM_SIZE,VALUE_ROWIDS:Fi.VALUE_ROWIDS,ROW_LENGTHS:Fi.ROW_LENGTHS,ROW_SPLITS:Fi.ROW_SPLITS,ROW_LIMITS:Fi.ROW_LIMITS,ROW_STARTS:Fi.ROW_STARTS},t=[];for(const r of n)if(r in e)t.push(e[r]);else break;return t}function FS(n){return n.length===0?0:n[0]===Fi.FIRST_DIM_SIZE?n.length-1:n.length}function $S(n,e){if(n==null||e==null)return;const t=n.length,r=e.length;if(t>=r)throw new Error(`defaultValue.shape=${n} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${t} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(t,r-1);++i){const s=n[i],a=e[i+1];if(s>=0&&a>=0&&s!==1&&s!==a)throw new Error(`defaultValue.shape=${n}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-n.length}] = ${s} but ragged tensor input.flatValues.shape[${i-n.length}] = ${a}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u_=30;function Am(n){return n<=u_?n:tx(n,Math.floor(Math.sqrt(n)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f_(n,e,t){const r=t*(typeof n=="number"?n:n[0]),i=e*(typeof n=="number"?n:n[1]);return[r,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kf(n,e,t,r=!0){let i=[];if(r)i=i.concat(e.slice(0)),i.push(n[0]/t),i=i.concat(n.slice(1));else{i=i.concat(n[0]);const s=e.length;for(let a=0;a<s;++a)i=i.concat([n[a+1]/e[a],e[a]]);i=i.concat(n.slice(s+1))}return i}function jf(n,e,t=!0){const r=[];if(t){r.push(e);for(let i=e+1;i<n;++i)i<=2*e?(r.push(i),r.push(i-(e+1))):r.push(i)}else{const i=[],s=[];for(let a=1;a<n;++a)a>=e*2+1||a%2===1?s.push(a):i.push(a);r.push(...i),r.push(0),r.push(...s)}return r}function Yf(n,e,t,r=!0){const i=[];r?i.push(n[0]/t):i.push(n[0]*t);for(let s=1;s<n.length;++s)s<=e.length?r?i.push(e[s-1]*n[s]):i.push(n[s]/e[s-1]):i.push(n[s]);return i}function d_(n,e){const t=[0];for(let r=0;r<e;++r)t.push(n[r][0]);return t}function h_(n,e,t){const r=n.slice(0,1);for(let i=0;i<t;++i)r.push(n[i+1]-e[i][0]-e[i][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cm=1.7580993408473768,Im=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p_=.3275911,m_=.254829592,v_=-.284496736,g_=1.421413741,x_=-1.453152027,b_=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function js(n,e){if(n.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${n.length}, imag: ${e.length}.`);const t=new Float32Array(n.length*2);for(let r=0;r<t.length;r+=2)t[r]=n[r/2],t[r+1]=e[r/2];return t}function US(n){const e=new Float32Array(n.length/2),t=new Float32Array(n.length/2);for(let r=0;r<n.length;r+=2)e[r/2]=n[r],t[r/2]=n[r+1];return{real:e,imag:t}}function BS(n){const e=Math.ceil(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let i=0;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],r[Math.floor(i/4)]=n[i+1];return{real:t,imag:r}}function VS(n){const e=Math.floor(n.length/4),t=new Float32Array(e),r=new Float32Array(e);for(let i=2;i<n.length;i+=4)t[Math.floor(i/4)]=n[i],r[Math.floor(i/4)]=n[i+1];return{real:t,imag:r}}function __(n,e){const t=n[e*2],r=n[e*2+1];return{real:t,imag:r}}function GS(n,e,t,r){n[r*2]=e,n[r*2+1]=t}function HS(n,e){const t=new Float32Array(n/2),r=new Float32Array(n/2);for(let i=0;i<Math.ceil(n/2);i++){const s=(e?2:-2)*Math.PI*(i/n);t[i]=Math.cos(s),r[i]=Math.sin(s)}return{real:t,imag:r}}function WS(n,e,t){const r=(t?2:-2)*Math.PI*(n/e),i=Math.cos(r),s=Math.sin(r);return{real:i,imag:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vv="->",eG=/->/g,M2=",",R2="...";function y_(n,e){n=n.replace(/\s/g,"");const t=(n.length-n.replace(eG,"").length)/Vv.length;if(t<1)throw new Error("Equations without an arrow are not supported.");if(t>1)throw new Error(`Equation must contain exactly one arrow ("${Vv}").`);const[r,i]=n.split(Vv);R(r.indexOf(R2)===-1,()=>`The ellipsis notation ("${R2}") is not supported yet.`);const s=r.split(M2),a=s.length;if(e!==a)throw new Error(`Expected ${a} input tensors, received ${e}`);if(a>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const o=[];for(let d=0;d<i.length;++d){const h=i[d];if(!s.some(p=>p.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);o.indexOf(h)===-1&&o.push(h)}for(let d=0;d<r.length;++d){const h=r[d];o.indexOf(h)===-1&&h!==M2&&o.push(h)}const c=new Array(s.length);for(let d=0;d<a;++d){if(new Set(s[d].split("")).size!==s[d].length)throw new Error(`Found duplicate axes in input component ${s[d]}. Support for duplicate axes in input is not implemented yet.`);c[d]=[];for(let h=0;h<s[d].length;++h)c[d].push(o.indexOf(s[d][h]))}const l=o.length,u=i.length,f=[];for(let d=u;d<l;++d)f.push(d);return{allDims:o,summedDims:f,idDims:c}}function w_(n,e){let t=new Array(n);t.fill(-1);for(let i=0;i<e.length;++i)t[e[i]]=i;const r=[];for(let i=0;i<n;++i)t[i]===-1&&r.push(i);return t=t.filter(i=>i!==-1),{permutationIndices:t,expandDims:r}}function E_(n,e,t){const r=new Array(n);for(let i=0;i<t.length;++i){const s=t[i].shape;for(let a=0;a<e[i].length;++a)r[e[i][a]]===void 0?r[e[i][a]]=s[a]:R(r[e[i][a]]===s[a],()=>`Expected dimension ${r[e[i][a]]} at axis ${a} of input shaped ${JSON.stringify(s)}, but got dimension ${s[a]}`)}}function S_(n,e){const t=n,r=[];let i=0;n.length===0&&t.push(-1),i=n.length+1;for(let a=0;a<i;++a)r.push([]);const s=[];for(let a=0;a<t.length;++a){const o=t[a],c=tG(e,o);for(const l of c)s.indexOf(l)===-1&&(r[a].push(l),s.push(l))}return{path:t,steps:r}}function T_(n){return n.every((e,t)=>e===t)}function tG(n,e){const t=[];for(let r=0;r<n.length;++r)(n[r].length===0||n[r].indexOf(e)!==-1||e===-1)&&t.push(r);return t}function A_(n,e,t=0){let r=[];if(typeof e=="number")R(n.shape[t]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(n.shape[t]/e);else{const i=e.reduce((a,o)=>(o===-1&&(a+=1),a),0);R(i<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(s!==-1){const a=e.reduce((o,c)=>c>0?o+c:o);e[s]=n.shape[t]-a}R(n.shape[t]===e.reduce((a,o)=>a+o),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qS(n){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${n}`}function XS(n,e){return`indices(${n}, 0) is invalid: ${e} < 0`}function KS(n,e,t){return`indices(${n}, 0) is invalid: ${e} >= ${t}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jS(n,e){return`only one output dimension may be -1, not both ${n} and ${e}`}function YS(n,e){return`size ${n} must be non-negative, not ${e}`}function ZS(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function QS(n,e){const t=ue(n),r=ue(e);return`Input to reshape is a SparseTensor with ${t}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${n} outputShape= ${e}`}function JS(n,e){const t=ue(n),r=ue(e);return`Input to reshape is a tensor with ${t} dense values, but the requested shape has ${r}. inputShape=${n} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _x(){return"segment ids must be >= 0"}function eT(){return"segment ids are not increasing"}function tT(n,e){return`Segment id ${n} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function nT(n,e,t){return`Bad: indices[${n}] == ${e} out of range [0, ${t})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rT(n,e){let t=!1,r;for(n<=u_?(r=n,t=!0):r=tx(n,Math.floor(Math.sqrt(n)));!t;)r>e||r===n?t=!0:r=tx(n,r+1);return r}function iT(n,e,t){const r=[],i=n.length;for(let s=0;s<i;s++)s!==e?r.push(n[s]):r.push(t);return r}function C_(n,e,t,r){const i=e.shape.length,s=n.shape.length;if(r!==0&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(t<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${t}).`);for(let f=0;f<r;++f)if(n.shape[f]!==e.shape[f])throw new Error(`x.shape[${f}]: ${n.shape[f]} should be equal to indices.shape[${f}]: ${e.shape[f]}.`);const a=n.shape[t],o=[];let c=1,l=1,u=1;for(let f=0;f<r;++f)o.push(n.shape[f]),c*=n.shape[f];for(let f=r;f<t;f++)o.push(n.shape[f]),l*=n.shape[f];for(let f=r;f<i;f++)o.push(e.shape[f]);for(let f=t+1;f<s;f++)o.push(n.shape[f]),u*=n.shape[f];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:a,outputShape:o}}const nG=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:C_,computeOutShape:iT,segOpComputeOptimalWindowSize:rT},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ys(n){try{return n.map(e=>Na(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function sT(n){return n.map(e=>Ca(e))}const rG=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:m_,ERF_A2:v_,ERF_A3:g_,ERF_A4:x_,ERF_A5:b_,ERF_P:p_,PARALLELIZE_THRESHOLD:u_,get RowPartitionType(){return Fi},SELU_SCALE:Im,SELU_SCALEALPHA:Cm,applyActivation:Yb,assertAndGetBroadcastShape:pt,assertAxesAreInnerMostDims:Zn,assertParamsConsistent:l_,assignToTypedArray:GS,axesAreInnerMostDims:Ab,calculateShapes:Xo,checkEinsumDimSizes:E_,checkPadOnDimRoundingMode:kr,combineLocations:Y3,combineRaggedTensorToTensorShapes:zS,complexWithEvenIndex:BS,complexWithOddIndex:VS,computeConv2DInfo:Yn,computeConv3DInfo:Ba,computeDefaultPad:_b,computeDilation2DInfo:Gf,computeOptimalWindowSize:Am,computeOutAndReduceShapes:Wn,computeOutShape:ds,computePool2DInfo:Ii,computePool3DInfo:ta,convertConv2DDataFormat:na,decodeEinsumEquation:y_,eitherStridesOrDilationsAreOne:or,expandShapeToKeepDim:Cn,exponent:WS,exponents:HS,fromStringArrayToUint8:sT,fromUint8ToStringArray:Ys,getAxesPermutation:pn,getBroadcastDims:il,getComplexWithIndex:__,getEinsumComputePath:S_,getEinsumPermutation:w_,getFusedBiasGradient:jb,getFusedDyActivation:Kb,getImageCenter:f_,getInnerMostAxes:yn,getPermuted:jf,getRaggedRank:FS,getReductionAxes:zn,getReshaped:Kf,getReshapedPermuted:Yf,getRowPartitionTypesHelper:PS,getSliceBeginCoords:d_,getSliceSize:h_,getSparseFillEmptyRowsIndicesDenseShapeMismatch:qS,getSparseFillEmptyRowsNegativeIndexErrorMessage:XS,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:KS,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:ZS,getSparseReshapeInputOutputMismatchErrorMessage:JS,getSparseReshapeInputOutputMultipleErrorMessage:QS,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:jS,getSparseReshapeNegativeOutputDimErrorMessage:YS,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:nT,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:_x,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:eT,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:tT,getUndoAxesPermutation:Va,isIdentityPermutation:T_,log:UP,mergeRealAndImagArrays:js,prepareAndValidate:r_,prepareSplitSize:A_,segment_util:nG,shouldFuse:Zb,slice_util:ZV,splitRealAndImagArrays:US,stridesOrDilationsArePositive:Ro,tupleValuesAreOne:Mo,upcastType:Hr,validateDefaultValueShape:$S,validateInput:LB,validateUpdateShape:mS,warn:Qr},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */qV();/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aT={kernelName:xp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(n,Xf(Ie(t,"float32"),-1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iG={kernelName:Hu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=nn(Ie(t,"float32")),i=ar(st(zt(1),r));return bn(nt(n,i))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sG={kernelName:Wu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=ar(st(nn(Ie(t,"float32")),1));return nt(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aG={kernelName:El,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=pt(t.shape,r.shape);return{a:()=>{let o=n;const c=zn(t.shape,i);return c.length>0&&(o=et(o,c)),j(o,t.shape)},b:()=>{let o=n;const c=zn(r.shape,i);return c.length>0&&(o=et(o,c)),j(o,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oG={kernelName:M0,saveAllInputs:!0,gradFunc:(n,e)=>{const t={};return e.forEach((r,i)=>{t[i]=()=>n.clone()}),t}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cG={kernelName:bp,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(t)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lG={kernelName:_p,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>Rt(t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uG={kernelName:qu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,ar(st(zt(1),nn(Ie(t,"float32")))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fG={kernelName:Xu,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=ar(ye(zt(1),nn(Ie(t,"float32"))));return nt(n,r)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dG={kernelName:Yu,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=pt(t.shape,r.shape);return{a:()=>{const o=ye(nn(t),nn(r));let c=W(n,nt(r,o));const l=zn(t.shape,i);return l.length>0&&(c=et(c,l)),j(c,t.shape)},b:()=>{const o=ye(nn(t),nn(r));let c=bn(W(n,nt(t,o)));const l=zn(r.shape,i);return l.length>0&&(c=et(c,l)),j(c,r.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hG={kernelName:Ku,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,ye(nn(Ie(t,"float32")),1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pG={kernelName:ju,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,st(zt(1),nn(Ie(t,"float32"))))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mG(n,e,t,r,i,s){const a=U(n,"dy","avgPool3dGrad"),o=U(e,"input","avgPool3dGrad");let c=a,l=o,u=!1;o.rank===4&&(u=!0,c=j(a,[1,a.shape[0],a.shape[1],a.shape[2],a.shape[3]]),l=j(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),R(c.rank===5,()=>`Error in avgPool3dGrad: dy must be rank 5 but got rank ${c.rank}.`),R(l.rank===5,()=>`Error in avgPool3dGrad: input must be rank 5 but got rank ${l.rank}.`),kr("avgPool3dGrad",i,s);const f={dy:c,input:l},d={filterSize:t,strides:r,pad:i,dimRoundingMode:s},h=X.runKernel(D0,f,d);return u?j(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}const vG=Y({avgPool3dGrad_:mG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gG={kernelName:wp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:i,strides:s,pad:a,dimRoundingMode:o}=t;return{x:()=>vG(n,r,i,s,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xG(n,e,t,r,i){const s=U(n,"dy","avgPoolGrad"),a=U(e,"input","avgPoolGrad");R(a.rank===s.rank,()=>`Rank of input (${a.rank}) does not match rank of dy (${s.rank})`);let o=a,c=s,l=!1;a.rank===3&&(l=!0,o=j(a,[1,a.shape[0],a.shape[1],a.shape[2]]),c=j(s,[1,s.shape[0],s.shape[1],s.shape[2]])),R(c.rank===4,()=>`Error in avgPoolGrad: dy must be rank 4 but got rank ${c.rank}.`),R(o.rank===4,()=>`Error in avgPoolGrad: input must be rank 4 but got rank ${o.rank}.`);const u={dy:c,input:o},f={filterSize:t,strides:r,pad:i},d=X.runKernel(k0,u,f);return l?j(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const bG=Y({avgPoolGrad_:xG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _G={kernelName:yp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{filterSize:i,strides:s,pad:a}=t;return{x:()=>bG(n,r,i,s,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yG={kernelName:Ep,inputsToSave:["a","b"],gradFunc:(n,e,t)=>{const[r,i]=e,{transposeA:s,transposeB:a}=t;return!s&&!a?{a:()=>Ot(n,i,!1,!0),b:()=>Ot(r,n,!0,!1)}:!s&&a?{a:()=>Ot(n,i,!1,!1),b:()=>Ot(n,r,!0,!1)}:s&&!a?{a:()=>Ot(i,n,!1,!0),b:()=>Ot(r,n,!1,!1)}:{a:()=>Ot(i,n,!0,!0),b:()=>Ot(n,r,!0,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wG={kernelName:Sp,gradFunc:(n,e,t)=>{const{blockShape:r,crops:i}=t;return{x:()=>Ob(n,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EG={kernelName:zP,gradFunc:(n,e,t)=>{const r=t,i=r.inputShape,s=r.shape,a=Array.from(s);for(let c=i.length-1;c>=0;c--)if(i[c]===s[c])a[c]=1;else if(i[c]!==1)throw new Error(`broadcastTo(): [${i}] cannot be broadcast to [${s}].`);const o=[];for(let c=0;c<a.length;c++)a[c]>1&&o.push(c);return{x:()=>et(n,o,!0)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SG={kernelName:Zu,gradFunc:n=>({x:()=>n.clone()})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TG={kernelName:Qu,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const AG={kernelName:Ju,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{clipValueMin:i,clipValueMax:s}=t;return{x:()=>xn(Xs(Ho(r,i),Al(r,s)),n,Rt(n))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CG={kernelName:Tp,inputsToSave:["x"],gradFunc:aT.gradFunc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IG={kernelName:Ap,saveAllInputs:!0,gradFunc:(n,e,t)=>{const r=e.map(c=>c.shape),{axis:i}=t,s=St(i,e[0].shape)[0],a=r.map(c=>c[s]);return ti(n,a,s).map(c=>()=>c)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MG={kernelName:Cp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,i]=e,{dilations:s,strides:a,pad:o,dataFormat:c}=t;return R(Mo(s),()=>`Error in gradient of conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`),{x:()=>Eb(r.shape,n,i,a,o,c),filter:()=>Xb(r,n,i.shape,a,o,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RG={kernelName:Ip,inputsToSave:["dy","filter"],gradFunc:(n,e,t)=>{const[r,i]=e,{strides:s,pad:a,dataFormat:o,dimRoundingMode:c}=t;return{dy:()=>No(n,i,s,a,o,1,c),filter:()=>Xb(n,r,i.shape,s,a,o,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NG(n,e,t,r,i){let s=n;n.rank===4&&(s=j(n,[1,n.shape[0],n.shape[1],n.shape[2],n.shape[3]]));let a=e;a.rank===4&&(a=j(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]])),R(s.rank===5,()=>`Error in conv3dDerFilter: input must be rank 5, but got shape ${s.shape}.`),R(a.rank===5,()=>`Error in conv3dDerFilter: dy must be rank 5, but got shape ${a.shape}.`),R(t.length===5,()=>`Error in conv3dDerFilter: filterShape must be length 5, but got ${t}.`),R(s.shape[4]===t[3],()=>`Error in conv3dDerFilter: depth of input ${s.shape[4]}) must match input depth in filter (${t[3]}.`),R(a.shape[4]===t[4],()=>`Error in conv3dDerFilter: depth of dy (${a.shape[4]}) must match output depth for filter (${t[4]}).`);const o={x:s,dy:a},c={strides:r,pad:i,filterShape:t};return X.runKernel(F0,o,c)}const kG=Y({conv3DBackpropFilter_:NG});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DG={kernelName:Mp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:i,pad:s}=t;R(Mo(r),()=>`Error in gradient of conv3D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${r}'`);const[a,o]=e;return{x:()=>q3(a.shape,n,o,i,s),filter:()=>kG(a,n,o.shape,i,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LG={kernelName:ef,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(bn(fS(Ie(t,"float32"))),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OG={kernelName:tf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(dS(Ie(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zG={kernelName:Rp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:i,exclusive:s,reverse:a}=t;return{x:()=>{const o=pn([i],r.rank);let c=K3(n,i,s,!a);return o!=null&&(c=Mt(c,o)),c}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PG={kernelName:Np,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const{dilations:r,strides:i,pad:s,dimRoundingMode:a}=t,o=r??[1,1];R(Mo(o),()=>`Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations '${o}'`);const[c,l]=e;return R(c.rank===4,()=>`Error in gradient of depthwiseConv2dNative: input must be rank 4, but got rank ${c.rank}.`),R(l.rank===4,()=>`Error in gradient of depthwiseConv2dNative: filter must be rank 4, but got rank ${l.rank}.`),R(c.shape[3]===l.shape[2],()=>`Error in gradient of depthwiseConv2d: number of input channels (${c.shape[3]}) must match the inChannels dimension in filter ${l.shape[2]}.`),R(or(i,o),()=>`Error in gradient of depthwiseConv2d: Either strides or dilations must be  1. Got strides ${i} and dilations '${o}'.`),kr("depthwiseConv2d",s,a),{x:()=>JB(c.shape,n,l,i,s,o,a),filter:()=>ZB(c,n,l.shape,i,s,o,a)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FG={kernelName:kp,inputsToSave:["x","filter"],gradFunc:(n,e,t)=>{const[r,i]=e,s={x:r,filter:i,dy:n},a={x:r,filter:i,dy:n};return{x:()=>X.runKernel(nx,s,t),filter:()=>X.runKernel(rx,a,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $G={kernelName:rf,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e,r={dy:n,y:t};return{x:()=>X.runKernel(X0,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UG={kernelName:sf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=W(gs(bn(nn(t))),2/Math.sqrt(Math.PI));return{x:()=>W(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BG={kernelName:af,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(n,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VG={kernelName:Lp,inputsToSave:["input"],gradFunc:(n,e)=>{const[t]=e;return{input:()=>j(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const GG={kernelName:of,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(n,gs(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HG={kernelName:cf,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WG={kernelName:lf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=pt(t.shape,r.shape);return{a:()=>{const o=nt(n,Ie(r,"float32")),c=zn(t.shape,i);return c.length>0?j(et(o,c),t.shape):o},b:()=>{let o=W(n,Ie(t,"float32"));const c=zn(r.shape,i);c.length>0&&(o=j(et(o,c),r.shape));const l=nn(r);return bn(nt(o,Ie(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qG={kernelName:Op,inputsToSave:["x","mean","variance","scale"],gradFunc:(n,e,t)=>{const{varianceEpsilon:r}=t,[i,s,a,o]=e,c=o??zt(1),l=zn(s.shape,i.shape),u=[];if(s.rank===1){for(let _=0;_<i.shape.length-1;++_)u.push(i.shape[_]);u.push(1)}const f=st(i,s),d=W(n,c),h=cS(ye(a,zt(r))),p=W(W(W(h,h),h),zt(-.5));return{x:()=>s.rank===1?j(W(W(n,Vi(j(h,[1,1,1,s.shape[0]]),u)),c),i.shape):j(W(W(n,h),c),i.shape),mean:()=>{let _=W(W(h,zt(-1)),d);return s.rank===1&&(_=et(_,l)),j(_,s.shape)},variance:()=>{let _=W(W(p,f),d);return s.rank===1&&(_=et(_,l)),j(_,s.shape)},scale:()=>{const _=W(f,h);let w=W(n,_);return s.rank===1&&(w=et(w,l)),j(w,s.shape)},offset:()=>{let _=n;return s.rank===1&&(_=et(_,l)),j(_,s.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XG={kernelName:zp,inputsToSave:["x","indices"],gradFunc:(n,e,t)=>{const[r,i]=e,{axis:s,batchDims:a}=t,o=St(s,r.shape)[0],c=(l,u,f)=>()=>{const d=l.shape,h=u.size,p=d.slice(0,o),g=p.length,m=d.slice(s,d.length).slice(1),v=m.length,x=N2(0,g),b=N2(g+1,g+1+v),_=k2([p,[h],m]),w=j(f,_),E=j(u,[h]),S=k2([[g],x,b]),T=Mt(w,S);let C=gS(T,E,l.shape[o]);const y=Va(S);return C=Mt(C,y),C};if(a===1){const l=r.shape[0],u=r.split(l,0);return{x:()=>Ks(u.map((h,p)=>c(h,i.slice(p,1),n.slice(p,1))())).reshape(r.shape),indices:()=>i}}else return{x:c(r,i,n),indices:()=>i}}};function N2(n,e){const t=[];for(let r=n;r<e;++r)t.push(r);return t}function k2(n){const e=[];for(let t=0;t<n.length;++t)for(let r=0;r<n[t].length;++r)e.push(n[t][r]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KG={kernelName:uf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>Rt(t),b:()=>Rt(r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jG={kernelName:ff,gradFunc:n=>({x:()=>Ie(n,"float32")})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YG={kernelName:df,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZG={kernelName:hf,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QG={kernelName:pf,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JG={kernelName:Fp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{alpha:i}=t,s=ri(r,0);return{x:()=>xn(s,n,W(n,i))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e6={kernelName:vf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,ye(t,1))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t6={kernelName:mf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,Ie(t,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n6={kernelName:FP,inputsToSave:[],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{axis:i}=t;return{logits:()=>{const a=gs(r);return st(n,W(et(n,i,!0),a))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r6(n,e,t,r=5,i=1,s=1,a=.5){const o={x:n,y:e,dy:t},c={depthRadius:r,bias:i,alpha:s,beta:a};return X.runKernel(J0,o,c)}const i6=Y({localResponseNormalizationBackprop_:r6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const s6={kernelName:Hp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,i]=e,{depthRadius:s,bias:a,alpha:o,beta:c}=t;return{x:()=>i6(r,i,n,s,a,o,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oT(n,e,t,r){return e.rank<t.rank&&(e=j(e,Cn(e.shape,r))),n.rank<t.rank&&(n=j(n,Cn(n.shape,r))),{x:()=>W(n,Ie(vs(t,e),n.dtype))}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D2={kernelName:Wp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{reductionIndices:i}=r,s=e[0],a=e[1],o=St(i,s.shape),c=oT(n,a,s,o);return{x:()=>c.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a6={kernelName:gf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>W(n,Ie(Ho(t,r),"float32")),b:()=>W(n,Ie(Fh(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o6(n,e,t,r,i,s,a){const o=U(n,"dy","maxPool3dGrad"),c=U(e,"input","maxPool3dGrad"),l=U(t,"output","maxPool3dGrad");let u=o,f=c,d=l,h=!1;c.rank===4&&(h=!0,u=j(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),f=j(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),d=j(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),R(u.rank===5,()=>`Error in maxPool3dGrad: dy must be rank 5 but got rank ${u.rank}.`),R(f.rank===5,()=>`Error in maxPool3dGrad: input must be rank 5 but got rank ${f.rank}.`),R(d.rank===5,()=>`Error in maxPool3dGrad: output must be rank 5 but got rank ${d.rank}.`),kr("maxPool3dGrad",s,a);const p={dy:u,input:f,output:d},g={filterSize:r,strides:i,pad:s,dimRoundingMode:a},m=X.runKernel(tb,p,g);return h?j(m,[m.shape[1],m.shape[2],m.shape[3],m.shape[4]]):m}const c6=Y({maxPool3dGrad_:o6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l6={kernelName:Xp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,i]=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:c}=t;return{x:()=>c6(n,r,i,s,a,o,c)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u6(n,e,t,r,i,s,a){const o=U(n,"dy","maxPoolGrad"),c=U(e,"input","maxPoolGrad"),l=U(t,"output","maxPoolGrad");R(c.rank===o.rank,()=>`Rank of input (${c.rank}) does not match rank of dy (${o.rank})`),R(o.rank===4,()=>`Error in maxPoolGrad: dy must be rank 4 but got rank ${o.rank}.`),R(c.rank===4,()=>`Error in maxPoolGrad: input must be rank 4 but got rank ${c.rank}.`),kr("maxPoolGrad",s,a);const u={dy:o,input:c,output:l},f={filterSize:r,strides:i,pad:s,dimRoundingMode:a};return X.runKernel(eb,u,f)}const f6=Y({maxPoolGrad_:u6});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d6={kernelName:qp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r,i]=e,{filterSize:s,strides:a,pad:o}=t;return{x:()=>f6(n,r,i,s,a,o)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const h6={kernelName:Kp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:i}=t,s=St(i,r.shape),o=Wn(r.shape,s)[1],c=ue(o);return{x:()=>{const u=r.shape.slice();s.forEach(h=>{u[h]=1});const f=j(n,u);return nt(W(f,Ha(r.shape,"float32")),c)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p6={kernelName:jp,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(n,e,t)=>{const r=t,{axis:i}=r,[s,a]=e,o=St(i,s.shape),c=oT(n,a,s,o);return{x:()=>c.x()}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m6={kernelName:xf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e;return{a:()=>W(n,Ie(Al(t,r),"float32")),b:()=>W(n,Ie(ri(t,r),"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const v6={kernelName:Yp,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:i}=t,s=i.map(a=>a[0]);return{x:()=>Jt(n,s,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g6={kernelName:bf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=pt(t.shape,r.shape);return{a:()=>{const o=zn(t.shape,i);return o.length>0?j(et(n,o),t.shape):n},b:()=>{const o=W(n,bn(Sm(nt(t,r)))),c=zn(r.shape,i);return c.length>0?j(et(o,c),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const x6={kernelName:_f,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=pt(t.shape,r.shape);return{a:()=>{const o=W(n,Ie(r,"float32")),c=zn(t.shape,i);return c.length>0?j(et(o,c),t.shape):o},b:()=>{const o=W(n,Ie(t,"float32")),c=zn(r.shape,i);return c.length>0?j(et(o,c),r.shape):o}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b6={kernelName:Zp,gradFunc:n=>({x:()=>bn(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _6={kernelName:em,inputsToSave:["indices"],gradFunc:(n,e)=>{const t=e[0];return{indices:()=>Un(t.shape,"float32")}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y6={kernelName:Jp,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w6={kernelName:tm,saveAllInputs:!0,gradFunc:(n,e,t)=>{const{axis:r}=t;return Lo(n,r).map(s=>()=>s)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L2={kernelName:nm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const r=e[0],{paddings:i}=t,s=i.map(a=>a[0]);return{x:()=>Jt(n,s,r.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E6={kernelName:yf,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(n,e)=>{const[t,r,i]=e,s=t,a=r,o=pt(s.shape,a.shape);return{a:()=>{const u=Ie(a,"float32");let f=W(n,W(u,ko(s,st(u,zt(1)))));const d=zn(s.shape,o);return d.length>0&&(f=et(f,d)),j(f,s.shape)},b:()=>{const u=ri(s,0),f=xn(u,xs(s),Rt(s));let d=W(n,W(i,f));const h=zn(a.shape,o);return h.length>0&&(d=et(d,h)),j(d,a.shape)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const S6={kernelName:rm,inputsToSave:["x","alpha"],gradFunc:(n,e)=>{const[t,r]=e,i=ri(t,0);return{x:()=>xn(i,n,W(n,r)),alpha:()=>{let s=xn(i,Rt(n),W(n,t));const a=zn(r.shape,n.shape);return a.length>0&&(s=et(s,a)),j(s,r.shape)}}}};/**
 * @license
 * Copyright 2022 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T6(n,e,t){const r=n.shape.slice();r[t]=1;const i=j(e,r),s=gx(n,t,!0,!1),a=gx(n,t,!0,!0),o=W(s,a);return W(i,o)}function A6(n,e,t){const r=n.shape.length,i=r-t.length,s=pn(t,r);let a=n;s!=null&&(a=Mt(n,s));const o=a.shape.slice(),l=o.splice(r-t.length,t.length).reduce((d,h)=>d*h,1);o.push(l);const u=a.reshape(o);let f=T6(u,e,i);if(f=f.reshape(a.shape),s!=null){const d=Va(s);f=Mt(f,d)}return f}const C6={kernelName:im,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{axis:i}=t;let s=[];return i==null?s=r.shape.map((a,o)=>o):typeof i=="number"?s=[i]:s=i,{x:()=>A6(r,n,s)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I6={kernelName:nf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=pt(t.shape,r.shape);return{a:()=>{const o=nt(n,Ie(r,"float32")),c=zn(t.shape,i);return c.length>0?j(et(o,c),t.shape):o},b:()=>{let o=W(n,Ie(t,"float32"));const c=zn(r.shape,i);c.length>0&&(o=j(et(o,c),r.shape));const l=nn(r);return bn(nt(o,Ie(l,"float32")))}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const M6={kernelName:wf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,bn(nn(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R6={kernelName:Sf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e,r=W(Al(t,6),Xf(t));return{x:()=>W(n,Ie(r,"float32"))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N6={kernelName:Ef,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(n,Ie(Xf(t),"float32"))}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k6={kernelName:sm,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>j(n,t.shape)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D6={kernelName:om,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,i={dy:n,images:r};return{images:()=>X.runKernel(cb,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const L6={kernelName:am,inputsToSave:["images"],gradFunc:(n,e,t)=>{const[r]=e,i={dy:n,images:r};return{images:()=>X.runKernel(ob,i,t)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O6={kernelName:cm,gradFunc:(n,e,t)=>{const{dims:r}=t,i=St(r,n.shape);return{x:()=>Ki(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z6={kernelName:Tf,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const P6={kernelName:Af,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>bn(nt(n,W(ko(t,1.5),2)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F6={kernelName:lm,inputsToSave:["condition"],gradFunc:(n,e)=>{const[t]=e;return{condition:()=>Ie(Rt(t),"float32"),t:()=>W(n,Ie(t,n.dtype)),e:()=>W(n,Ie(Rb(t),n.dtype))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $6={kernelName:Cf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>{const r=ri(t,zt(0)),i=zt(Cm),s=zt(Im),a=W(n,s),o=W(W(n,i),gs(Ie(t,"float32")));return xn(r,a,o)}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U6={kernelName:Nf,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(n,W(t,st(zt(1),t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const B6={kernelName:Rf,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V6={kernelName:If,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(Sb(Ie(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G6={kernelName:Mf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(X3(Ie(t,"float32")),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H6={kernelName:um,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{begin:i,size:s}=t,a=r.shape,[o,c]=Tm(r,i,s),l=[];for(let u=0;u<n.rank;u++)l.push([o[u],a[u]-o[u]-c[u]]);return{x:()=>Lb(n,l)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const W6={kernelName:pm,outputsToSave:[!0],gradFunc:(n,e,t)=>{const[r]=e,{dim:i}=t,s=!0,a=W(n,r);return{logits:()=>st(a,W(et(a,[i],s),r))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q6={kernelName:kf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(n,Tl(t))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const O2={kernelName:dm,gradFunc:(n,e,t)=>{const{blockShape:r,paddings:i}=t;return{x:()=>wb(n,r,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z2={kernelName:hm,gradFunc:(n,e,t)=>{const{axis:r}=t;return{x:()=>nr(n,r)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X6={kernelName:Df,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,W(ar(Ie(t,"float32")),2))}}};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const K6={kernelName:lb,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(n,W(Ie(t,"float32"),2))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j6={kernelName:Lf,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=zt(2);return{a:()=>W(n,W(i,st(t,r))),b:()=>W(n,W(i,st(r,t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Y6={kernelName:$f,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z6={kernelName:Of,inputsToSave:["a","b"],gradFunc:(n,e)=>{const[t,r]=e,i=pt(t.shape,r.shape);return{a:()=>{let o=n;const c=zn(t.shape,i);return c.length>0&&(o=et(o,c)),j(o,t.shape)},b:()=>{let o=n;const c=zn(r.shape,i);return c.length>0&&(o=et(o,c)),j(bn(o),r.shape)}}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q6={kernelName:fm,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,i=r.shape.slice(),{axis:s}=t;St(s,r.shape).forEach(l=>{i[l]=1});const o=j(n,i),c=W(o,Ha(r.shape,"float32"));return{x:()=>c}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J6={kernelName:zf,inputsToSave:["x"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>nt(n,nn(Sb(t)))}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eH={kernelName:Pf,outputsToSave:[!0],gradFunc:(n,e)=>{const[t]=e;return{x:()=>W(st(zt(1),nn(t)),n)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tH={kernelName:Ff,inputsToSave:["x"],gradFunc:(n,e,t)=>{const[r]=e,{reps:i}=t;return{x:()=>{let a=Rt(r);if(r.rank===1)for(let o=0;o<i[0];++o)a=ye(a,Jt(n,[o*r.shape[0]],[r.shape[0]]));else if(r.rank===2)for(let o=0;o<i[0];++o)for(let c=0;c<i[1];++c)a=ye(a,Jt(n,[o*r.shape[0],c*r.shape[1]],[r.shape[0],r.shape[1]]));else if(r.rank===3)for(let o=0;o<i[0];++o)for(let c=0;c<i[1];++c)for(let l=0;l<i[2];++l)a=ye(a,Jt(n,[o*r.shape[0],c*r.shape[1],l*r.shape[2]],[r.shape[0],r.shape[1],r.shape[2]]));else if(r.rank===4)for(let o=0;o<i[0];++o)for(let c=0;c<i[1];++c)for(let l=0;l<i[2];++l)for(let u=0;u<i[3];++u)a=ye(a,Jt(n,[o*r.shape[0],c*r.shape[1],l*r.shape[2],u*r.shape[3]],[r.shape[0],r.shape[1],r.shape[2],r.shape[3]]));else throw new Error(`Gradient for tile operation is not implemented for rank-${r.rank} tensors yet.`);return a}}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nH={kernelName:Fc,gradFunc:(n,e,t)=>{const r=t,{perm:i}=r,s=Va(i);return{x:()=>Mt(n,s)}}};/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rH={kernelName:mm,gradFunc:(n,e,t)=>{const r=t,{axis:i}=r;return{value:()=>Ks(n,i)}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iH={kernelName:vm,inputsToSave:["segmentIds"],gradFunc:(n,e)=>{const[t]=e;return{x:()=>sH(n,t)}}};function sH(n,e){const t=Ga(e,Rt(e)),r=Cb(n,t);let i=Ho(e,zt(0,"int32"));const s=r.rank-i.rank;for(let o=0;o<s;++o)i=Sr(i,o+1);i=Xs(i,Ha(r.shape,"bool"));const a=Rt(r);return xn(i,r,a)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aH={kernelName:gm,gradFunc:n=>({x:()=>Rt(n)})};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oH=[aT,iG,sG,aG,oG,cG,lG,uG,fG,dG,hG,pG,gG,_G,yG,wG,EG,SG,TG,AG,CG,IG,RG,MG,DG,LG,OG,zG,PG,FG,I6,$G,UG,BG,VG,GG,WG,HG,qG,XG,KG,jG,YG,ZG,QG,JG,e6,t6,n6,s6,D2,D2,a6,l6,d6,h6,p6,m6,v6,g6,x6,b6,_6,y6,w6,L2,L2,E6,S6,C6,M6,R6,N6,k6,D6,L6,O6,z6,P6,F6,$6,U6,B6,V6,G6,H6,W6,q6,O2,O2,z2,z2,X6,j6,K6,Y6,Z6,Q6,J6,eH,tH,nH,rH,iH,aH];for(const n of oH)BP(n);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.abs=function(){return this.throwIfDisposed(),pr(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.acos=function(){return this.throwIfDisposed(),WF(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.acosh=function(){return this.throwIfDisposed(),XF(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.add=function(n){return this.throwIfDisposed(),ye(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.all=function(n,e){return this.throwIfDisposed(),V3(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.any=function(n,e){return this.throwIfDisposed(),mx(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.argMax=function(n){return this.throwIfDisposed(),Su(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.argMin=function(n){return this.throwIfDisposed(),QF(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.asScalar=function(){return this.throwIfDisposed(),R(this.size===1,()=>"The array must have only 1 element."),j(this,[])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.asType=function(n){return this.throwIfDisposed(),Ie(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.as1D=function(){return this.throwIfDisposed(),j(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.as2D=function(n,e){return this.throwIfDisposed(),j(this,[n,e])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.as3D=function(n,e,t){return this.throwIfDisposed(),j(this,[n,e,t])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.as4D=function(n,e,t,r){return this.throwIfDisposed(),j(this,[n,e,t,r])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.as5D=function(n,e,t,r,i){return this.throwIfDisposed(),j(this,[n,e,t,r,i])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.asin=function(){return this.throwIfDisposed(),e$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.asinh=function(){return this.throwIfDisposed(),n$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.atan=function(){return this.throwIfDisposed(),i$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.atan2=function(n){return this.throwIfDisposed(),a$(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.atanh=function(){return this.throwIfDisposed(),c$(this)};ce().prototype.avgPool=function(n,e,t,r){return this.throwIfDisposed(),yb(this,n,e,t,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.batchToSpaceND=function(n,e){return this.throwIfDisposed(),wb(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.batchNorm=function(n,e,t,r,i){return this.throwIfDisposed(),_m(this,n,e,t,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.broadcastTo=function(n){return this.throwIfDisposed(),xu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.cast=function(n){return this.throwIfDisposed(),Ie(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.ceil=function(){return this.throwIfDisposed(),O$(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.clipByValue=function(n,e){return this.throwIfDisposed(),ni(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.concat=function(n,e){return this.throwIfDisposed(),n instanceof Nn&&(n=[n]),nr([this,...n],e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.conv1d=function(n,e,t,r,i,s){return this.throwIfDisposed(),G3(this,n,e,t,r,i,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.conv2dTranspose=function(n,e,t,r,i){return this.throwIfDisposed(),H3(this,n,e,t,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.conv2d=function(n,e,t,r,i,s){return this.throwIfDisposed(),No(this,n,e,t,r,i,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.cos=function(){return this.throwIfDisposed(),Sb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.cosh=function(){return this.throwIfDisposed(),X3(this)};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.cumprod=function(n,e,t){return this.throwIfDisposed(),gx(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.cumsum=function(n,e,t){return this.throwIfDisposed(),K3(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.depthToSpace=function(n,e){return this.throwIfDisposed(),sU(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.depthwiseConv2d=function(n,e,t,r,i,s){return this.throwIfDisposed(),Tb(this,n,e,t,r,i,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.dilation2d=function(n,e,t,r,i){return this.throwIfDisposed(),cU(this,n,e,t,r,i)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.divNoNan=function(n){return this.throwIfDisposed(),hU(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.div=function(n){return this.throwIfDisposed(),nt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.dot=function(n){return this.throwIfDisposed(),mU(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.elu=function(){return this.throwIfDisposed(),wm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.equal=function(n){return this.throwIfDisposed(),vs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.erf=function(){return this.throwIfDisposed(),j3(this)};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.euclideanNorm=function(n,e){return this.throwIfDisposed(),CU(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.exp=function(){return this.throwIfDisposed(),gs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.expandDims=function(n){return this.throwIfDisposed(),Sr(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.expm1=function(){return this.throwIfDisposed(),NU(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.fft=function(){return this.throwIfDisposed(),pS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.flatten=function(){return this.throwIfDisposed(),j(this,[this.size])};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.floor=function(){return this.throwIfDisposed(),Sm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.floorDiv=function(n){return this.throwIfDisposed(),B3(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.gather=function(n,e,t){return this.throwIfDisposed(),Cb(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.greaterEqual=function(n){return this.throwIfDisposed(),Ho(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.greater=function(n){return this.throwIfDisposed(),ri(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.ifft=function(){return this.throwIfDisposed(),xx(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.irfft=function(){return this.throwIfDisposed(),yB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.isFinite=function(){return this.throwIfDisposed(),UU(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.isInf=function(){return this.throwIfDisposed(),VU(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.isNaN=function(){return this.throwIfDisposed(),HU(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.leakyRelu=function(n){return this.throwIfDisposed(),Mb(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.lessEqual=function(n){return this.throwIfDisposed(),Al(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.less=function(n){return this.throwIfDisposed(),Fh(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.localResponseNormalization=function(n,e,t,r){return this.throwIfDisposed(),jU(this,n,e,t,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.logSigmoid=function(){return this.throwIfDisposed(),n5(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.logSoftmax=function(n){return this.throwIfDisposed(),eS(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.logSumExp=function(n,e){return this.throwIfDisposed(),tS(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.log=function(){return this.throwIfDisposed(),xs(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.log1p=function(){return this.throwIfDisposed(),J3(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.logicalAnd=function(n){return this.throwIfDisposed(),Xs(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.logicalNot=function(){return this.throwIfDisposed(),Rb(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.logicalOr=function(n){return this.throwIfDisposed(),nS(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.logicalXor=function(n){return this.throwIfDisposed(),u5(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.matMul=function(n,e,t){return this.throwIfDisposed(),Ot(this,n,e,t)};ce().prototype.maxPool=function(n,e,t,r){return this.throwIfDisposed(),Nb(this,n,e,t,r)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.max=function(n,e){return this.throwIfDisposed(),Wi(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.maximum=function(n){return this.throwIfDisposed(),Ga(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.mean=function(n,e){return this.throwIfDisposed(),An(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.min=function(n,e){return this.throwIfDisposed(),Ph(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.minimum=function(n){return this.throwIfDisposed(),Cu(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.mirrorPad=function(n,e){return this.throwIfDisposed(),g5(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.mod=function(n){return this.throwIfDisposed(),b5(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.mul=function(n){return this.throwIfDisposed(),W(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.neg=function(){return this.throwIfDisposed(),bn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.norm=function(n,e,t){return this.throwIfDisposed(),Em(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.notEqual=function(n){return this.throwIfDisposed(),Do(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.oneHot=function(n,e=1,t=0){return this.throwIfDisposed(),rS(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.onesLike=function(){return this.throwIfDisposed(),Ai(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.pad=function(n,e){return this.throwIfDisposed(),Lb(this,n,e)};ce().prototype.pool=function(n,e,t,r,i,s){return this.throwIfDisposed(),M5(this,n,e,t,r,i,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.pow=function(n){return this.throwIfDisposed(),ko(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.prelu=function(n){return this.throwIfDisposed(),zb(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.prod=function(n,e){return this.throwIfDisposed(),k5(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.reciprocal=function(){return this.throwIfDisposed(),tB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.relu=function(){return this.throwIfDisposed(),qo(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.relu6=function(){return this.throwIfDisposed(),aS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.reshapeAs=function(n){return this.throwIfDisposed(),j(this,n.shape)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.reshape=function(n){return this.throwIfDisposed(),j(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.resizeBilinear=function(n,e,t){return this.throwIfDisposed(),bS(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.resizeNearestNeighbor=function(n,e,t){return this.throwIfDisposed(),_S(this,n,e,t)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.reverse=function(n){return this.throwIfDisposed(),Ki(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.rfft=function(){return this.throwIfDisposed(),SB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.round=function(){return this.throwIfDisposed(),oS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.rsqrt=function(){return this.throwIfDisposed(),cS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.selu=function(){return this.throwIfDisposed(),lS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.separableConv2d=function(n,e,t,r,i,s){return this.throwIfDisposed(),uS(this,n,e,t,r,i,s)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.sigmoid=function(){return this.throwIfDisposed(),Tl(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.sign=function(){return this.throwIfDisposed(),uB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.sin=function(){return this.throwIfDisposed(),fS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.sinh=function(){return this.throwIfDisposed(),dS(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.slice=function(n,e){return this.throwIfDisposed(),Jt(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.softmax=function(n){return this.throwIfDisposed(),qb(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.softplus=function(){return this.throwIfDisposed(),Hf(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.spaceToBatchND=function(n,e){return this.throwIfDisposed(),Ob(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.split=function(n,e){return this.throwIfDisposed(),ti(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.sqrt=function(){return this.throwIfDisposed(),ar(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.square=function(){return this.throwIfDisposed(),nn(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.squaredDifference=function(n){return this.throwIfDisposed(),AB(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.squeeze=function(n){return this.throwIfDisposed(),qf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.stack=function(n,e){this.throwIfDisposed();const t=n instanceof Nn?[this,n]:[this,...n];return Ks(t,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.step=function(n){return this.throwIfDisposed(),Xf(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.stridedSlice=function(n,e,t,r,i,s,a,o){return this.throwIfDisposed(),NB(this,n,e,t,r,i,s,a,o)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.sub=function(n){return this.throwIfDisposed(),st(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.sum=function(n,e){return this.throwIfDisposed(),et(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.tan=function(){return this.throwIfDisposed(),DB(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.tanh=function(){return this.throwIfDisposed(),bm(this)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.tile=function(n){return this.throwIfDisposed(),Vi(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.toBool=function(){return this.throwIfDisposed(),Ie(this,"bool")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.toFloat=function(){return this.throwIfDisposed(),Ie(this,"float32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.toInt=function(){return this.throwIfDisposed(),Ie(this,"int32")};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.topk=function(n,e){return this.throwIfDisposed(),zB(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.transpose=function(n){return this.throwIfDisposed(),Mt(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.unique=function(n){return this.throwIfDisposed(),$B(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.unsortedSegmentSum=function(n,e){return this.throwIfDisposed(),gS(this,n,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.unstack=function(n){return this.throwIfDisposed(),Lo(this,n)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.where=function(n,e){return this.throwIfDisposed(),xn(n,this,e)};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */ce().prototype.zerosLike=function(){return this.throwIfDisposed(),Rt(this)};/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class is extends Error{constructor(e){super(e),Object.setPrototypeOf(this,is.prototype)}}class xi extends Error{constructor(e){super(e),Object.setPrototypeOf(this,xi.prototype)}}class G extends Error{constructor(e){super(e),Object.setPrototypeOf(this,G.prototype)}}class vt extends Error{constructor(e){super(e),Object.setPrototypeOf(this,vt.prototype)}}class I_ extends Error{constructor(e){super(e),Object.setPrototypeOf(this,I_.prototype)}}/**
 * @license
 * Copyright 2022 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cT{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const r=this.cache.keys().next().value;this.cache.delete(r)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${e}.`);if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const r=this.cache.keys().next().value;this.cache.delete(r)}this.maxEntries=e}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Oo(n,e){if(Array.isArray(n)){let t=[];for(let r=0;r<e;r++)t=t.concat(n);return t}else{const t=new Array(e);return t.fill(n),t}}function ss(n,e){if(!n)throw new I_(e)}function P2(n,e){let t=0;for(const r of n)r===e&&t++;return t}function Tr(n){return n.length===1?n[0]:n}function Ht(n){return Array.isArray(n)?n:[n]}function Os(n){const t=n.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return t[0]!=="_"?t:"private"+t}function fo(n){return n.length<=1||n.indexOf("_")===-1?n:n.replace(/[_]+(\w|$)/g,(e,t)=>t.toUpperCase())}let oi={};function M_(n){if(n==null)return null;const e={};return e.className=n.getClassName(),e.config=n.getConfig(),e}function yx(n){if(!(n==null||typeof n!="object"))if(Array.isArray(n))n.forEach(e=>yx(e));else{const e=Object.keys(n);for(const t of e){const r=n[t];r!=null&&typeof r=="object"&&(!Array.isArray(r)&&r.type==="ndarray"&&typeof r.value=="number"?n[t]=r.value:yx(r))}}}function Zf(n,e={},t={},r="object",i=!1){if(typeof n=="string"){const s=n;let a;if(s in t)a=t[s];else if(s in oi)a=oi[s];else if(a=e[s],a==null)throw new G(`Unknown ${r}: ${n}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);return a}else{const s=n;if(s.className==null||s.config==null)throw new G(`${r}: Improper config format: ${JSON.stringify(s)}.
'className' and 'config' must set.`);const a=s.className;let o,c;if(a in t?[o,c]=t[a]:a in oi?[o,c]=oi.className:a in e&&([o,c]=e[a]),o==null)throw new G(`Unknown ${r}: ${a}. This may be due to one of the following reasons:
1. The ${r} is defined in Python, in which case it needs to be ported to TensorFlow.js or your JavaScript code.
2. The custom ${r} is defined in JavaScript, but is not registered properly with tf.serialization.registerClass().`);if(c!=null){const l={};for(const h of Object.keys(oi))l[h]=oi[h];for(const h of Object.keys(t))l[h]=t[h];const u=s.config;u.customObjects=l;const f=Object.assign({},oi);for(const h of Object.keys(t))oi[h]=t[h];yx(s.config);const d=c(o,s.config,t,i);return oi=Object.assign({},f),d}else{const l=Object.assign({},oi);for(const f of Object.keys(t))oi[f]=t[f];const u=new o(s.config);return oi=Object.assign({},l),u}}}function cH(n,e){return n<e?-1:n>e?1:0}function Zd(n,e){return-1*cH(n,e)}function Ia(n){if(n==null)return n;const e=[];for(const t of n)e.indexOf(t)===-1&&e.push(t);return e}function lH(n){if(n==null)throw new G(`Invalid value in obj: ${JSON.stringify(n)}`);for(const e in n)if(n.hasOwnProperty(e))return!1;return!0}function Ko(n,e,t){if(t!=null&&n.indexOf(t)<0)throw new G(`${t} is not a valid ${e}.  Valid values are ${n} or null/undefined.`)}function R_(n,e,t=0,r=1/0){return ss(t>=0),ss(r>=t),Array.isArray(n)&&n.length>=t&&n.length<=r&&n.every(i=>typeof i===e)}function Bn(n,e){Array.isArray(n)?(R(n.length>0,()=>`${e} is unexpectedly an empty array.`),n.forEach((t,r)=>Bn(t,`element ${r+1} of ${e}`))):R(Number.isInteger(n)&&n>0,()=>`Expected ${e} to be a positive integer, but got ${lT(n)}.`)}function lT(n){return n===null?"null":Array.isArray(n)?"["+n.map(e=>lT(e)).join(",")+"]":typeof n=="string"?`"${n}"`:`${n}`}function uH(n,e,t){let r=t!=null?t():wr(),i;return(...a)=>{const o=t!=null?t():wr();return o-r<e||(r=o,i=n(...a)),i}}function uT(n){return n==="relu"?"relu":n==="linear"?"linear":n==="elu"?"elu":null}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let fH=0;function fT(){return fH++}const Qd={};function Mm(n=""){return n in Qd||(Qd[n]=0),Qd[n]+=1,n+Qd[n].toString()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const dH=["channelsFirst","channelsLast"],hH=["nearest","bilinear"],pH=["valid","same","causal"],mH=["max","avg"],vH=["sum","mul","concat","ave"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const _c=new Map;function wn(n){Ko(dH,"DataFormat",n)}function gH(n){Ko(hH,"InterpolationFormat",n)}function ii(n){Ko(pH,"PaddingMode",n)}function dT(n){Ko(mH,"PoolMode",n)}const bu=[],F2="/";function _o(n,e){bu.push(n);try{const t=e();return bu.pop(),t}catch(t){throw bu.pop(),t}}function xH(){return bu.length===0?"":bu.join(F2)+F2}function hT(n){if(!mT(n))throw new Error("Not a valid tensor name: '"+n+"'");return xH()+n}function pT(n){if(!mT(n))throw new Error("Not a valid tensor name: '"+n+"'");_c.has(n)||_c.set(n,0);const e=_c.get(n);if(_c.set(n,_c.get(n)+1),e>0){const t=`${n}_${e}`;return _c.set(t,1),t}else return n}const bH=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function mT(n){return!!n.match(bH)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _H(n){return n===parseInt(n.toString(),10)}function Ma(n,e,t){e==null&&(e=0),t==null&&(t=n.length);let r=1;for(let i=e;i<t;++i)r*=n[i];return r}function al(n){if(n.length===0)return Number.NaN;let e=Number.POSITIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r<e&&(e=r)}return e}function ka(n){if(n.length===0)return Number.NaN;let e=Number.NEGATIVE_INFINITY;for(let t=0;t<n.length;t++){const r=n[t];r>e&&(e=r)}return e}function ji(n,e){if(e<n)throw new G(`end (${e}) < begin (${n}) is forbidden.`);const t=[];for(let r=n;r<e;++r)t.push(r);return t}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let Gv;function kn(){return Gv==null&&(Gv=Vf().epsilon()),Gv}function Yi(){return"channelsLast"}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function hs(n,e){return Ie(n,e)}function Qf(n,e=-1){const t=n.shape.slice();return e<0&&(e=t.length+e+1),t.splice(e,0,1),j(n,t)}function yH(n,e){return te(()=>{if(n.shape.length!==2)throw new G(`repeat() expects a rank-2 tensor, but received a rank-${n.shape.length} tensor.`);const t=Qf(n,1);return wx(t,[1,e,1])})}function wH(n){const e=[Ma(n.shape)];return j(n,e)}function EH(n){if(n.rank<=1)throw new G(`batchFlatten requires a minimum rank of 2. Got rank: ${n.rank}.`);const e=[n.shape[0],Ma(n.shape,1)];return j(n,e)}function yo(n,e,t){return te(()=>{switch(n.rank){case 1:return Hb(n,e,t);case 2:return hS(n,[e,0],[t,n.shape[1]]);case 3:return Wb(n,[e,0,0],[t,n.shape[1],n.shape[2]]);case 4:return Uh(n,[e,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3]]);case 5:return Jt(n,[e,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4]]);case 6:return Jt(n,[e,0,0,0,0,0],[t,n.shape[1],n.shape[2],n.shape[3],n.shape[4],n.shape[5]]);default:throw new G(`sliceAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Hv(n,e,t){return te(()=>{switch(n.rank){case 1:return Hb(n,e,t);case 2:return hS(n,[0,e],[n.shape[0],t]);case 3:return Wb(n,[0,0,e],[n.shape[0],n.shape[1],t]);case 4:return Uh(n,[0,0,0,e],[n.shape[0],n.shape[1],n.shape[2],t]);default:throw new G(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function Jd(n,e,t,r){return te(()=>{switch(n.rank){case 1:return Hb(n,e,t);case 2:switch(r){case 1:return yo(n,e,t);case 2:return Hv(n,e,t);default:throw new G(`The axis is not within the rank of the tensor ${r}`)}case 3:switch(r){case 1:return yo(n,e,t);case 2:return Wb(n,[0,e,0],[n.shape[0],t,n.shape[2]]);case 3:return Hv(n,e,t);default:throw new G(`The axis is not within the rank of the tensor ${r}`)}case 4:switch(r){case 1:return yo(n,e,t);case 2:return Uh(n,[0,e,0,0],[n.shape[0],t,n.shape[2],n.shape[3]]);case 3:return Uh(n,[0,0,e,0],[n.shape[0],n.shape[1],t,n.shape[3]]);case 4:return Hv(n,e,t);default:throw new G(`The axis is not within the rank of the tensor ${r}`)}default:throw new G(`sliceAlongLastAxis() received an unsupported tensor rank: ${n.rank}`)}})}function N_(n,e=-1){let t;return e<0&&(t=n[0].rank,t!==0?e=t:e=0),e===n[0].rank&&(e=-1),nr(n,e)}function $2(n,e){switch(n.rank){case 1:return F$([n,e]);case 2:return U$([n,e],0);case 3:return V$([n,e],0);case 4:return H$([n,e],0);default:throw new G(`concatAlongFirstAxis() received an unsupported tensor rank: ${n.rank}`)}}function wx(n,e){if(Array.isArray(e)||(e=[e]),n.rank!==e.length)throw new G(`The length of input n (${e.length}) does not match the number of dimensions in input x (${n.rank})`);return Vi(n,e)}function Rm(n,e=0,t=1,r,i){return Z5(n,e,t,r,i)}function ps(n,e,t,r){if(n.rank<2||e.rank<2)throw new vt(`dot requires both inputs to be rank >= 2 but got x shape = ${n.shape} and y shape = ${e.shape}`);if(e.rank>=3){const i=n.shape.slice(-1)[0],s=e.shape.slice(-2)[0];if(i!==s)throw new vt(`If rank y >= 3, then the second last dim of y must equal the last dim of x but got x shape = ${n.shape} and  y shape = ${e.shape}`)}if(n.rank===2&&e.rank===2)return T2({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?Ex(n.rank,r,Yi()):null,activation:t});{const i=n.shape.slice(),s=i.pop();n=j(n,[-1,s]);const a=e.shape.slice(),o=a.pop(),c=a.pop(),l=[...a,o],u=Array.from({length:e.rank},(p,g)=>g===0?e.rank-2:g<=e.rank-2?g-1:g);e=j(Mt(e,u),[c,-1]);const f=[...i,...l];return j(T2({a:n,b:e,transposeA:!1,transposeB:!1,bias:r?Ex(n.rank,r,Yi()):null,activation:t}),f)}}function vT(n,e,t){return te(()=>(Array.isArray(e)?e=Vr(e,"int32"):e=Ie(e,"int32"),Cb(n,e,t)))}function Jf(n){return W(n,n)}function Ex(n,e,t){const r=e.shape;if(e.rank!==1&&e.rank!==n)throw new G(`Unexpected bias dimensions: ${e.rank}; expected it to be 1 or ${n}`);if(n===5){if(t==="channelsFirst")return r.length===1?j(e,[1,r[0],1,1,1]):j(e,[1,r[3],r[0],r[1],r[2]]);if(t==="channelsLast")return r.length===1?j(e,[1,1,1,1,r[0]]):j(e,[1].concat(r))}else if(n===4){if(t==="channelsFirst")return r.length===1?j(e,[1,r[0],1,1]):j(e,[1,r[2],r[0],r[1]]);if(t==="channelsLast")return r.length===1?j(e,[1,1,1,r[0]]):j(e,[1].concat(r))}else if(n===3){if(t==="channelsFirst")return r.length===1?j(e,[1,r[0],1]):j(e,[1,r[1],r[0]]);if(t==="channelsLast")return r.length===1?j(e,[1,1,r[0]]):j(e,[1].concat(r))}else if(n<3)return e;throw new G(`Unsupported input rank by biasAdd: ${e.rank}`)}function Ji(n,e,t){return te(()=>(t==null&&(t=Yi()),wn(t),ye(n,Ex(n.rank,e,t))))}function SH(n,e=1){if(e!==1)throw new vt(`Support for alpha values other than 1 (${e}) is not implemented yet.`);return wm(n)}function TH(n){return te(()=>nt(n,ye(pr(n),1)))}function gT(n,e,t,r){return te(()=>qB(n,e,t,r))}function AH(n){return te(()=>{const e=ye(.5,W(.2,n));return ni(e,0,1)})}function ed(n,e,t=!1){return t?n():e()}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const CH=["fanIn","fanOut","fanAvg"],IH=["normal","uniform","truncatedNormal"];/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function MH(n){Ko(CH,"FanMode",n)}function RH(n){Ko(IH,"Distribution",n)}class Mi extends Il{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class xT extends Mi{apply(e,t){return Un(e,t)}}xT.className="Zeros";ge(xT);class k_ extends Mi{apply(e,t){return Ha(e,t)}}k_.className="Ones";ge(k_);class bT extends Mi{constructor(e){if(super(),typeof e!="object")throw new G(`Expected argument of type ConstantConfig but got ${e}`);if(e.value===void 0)throw new G(`config must have value set but got ${e}`);this.value=e.value}apply(e,t){return te(()=>W(zt(this.value),Ha(e,t)))}getConfig(){return{value:this.value}}}bT.className="Constant";ge(bT);class _T extends Mi{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return Wf(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}_T.className="RandomUniform";ge(_T);class yT extends Mi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new vt(`randomNormal does not support dType ${t}.`);return Rm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}yT.className="RandomNormal";ge(yT);class wT extends Mi{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if(t=t||"float32",t!=="float32"&&t!=="int32")throw new vt(`truncatedNormal does not support dType ${t}.`);return vS(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}wT.className="TruncatedNormal";ge(wT);class ET extends Mi{constructor(e){super(),this.gain=e.gain!=null?e.gain:1}apply(e,t){return te(()=>{if(e.length!==2||e[0]!==e[1])throw new G("Identity matrix initializer can only be used for 2D square matrices.");return W(this.gain,Q3(e[0]))})}getConfig(){return{gain:this.gain}}}ET.className="Identity";ge(ET);function NH(n,e="channelsLast"){let t,r;if(wn(e),n.length===2)t=n[0],r=n[1];else if([3,4,5].indexOf(n.length)!==-1){if(e==="channelsFirst"){const i=Ma(n,2);t=n[1]*i,r=n[0]*i}else if(e==="channelsLast"){const i=Ma(n,0,n.length-2);t=n[n.length-2]*i,r=n[n.length-1]*i}}else{const i=Ma(n);t=Math.sqrt(i),r=Math.sqrt(i)}return[t,r]}class Wr extends Mi{constructor(e){if(super(),e.scale<0)throw new G(`scale must be a positive float. Got: ${e.scale}`);this.scale=e.scale==null?1:e.scale,this.mode=e.mode==null?"fanIn":e.mode,MH(this.mode),this.distribution=e.distribution==null?"normal":e.distribution,RH(this.distribution),this.seed=e.seed}apply(e,t){const r=NH(e),i=r[0],s=r[1];let a=this.scale;if(this.mode==="fanIn"?a/=Math.max(1,i):this.mode==="fanOut"?a/=Math.max(1,s):a/=Math.max(1,(i+s)/2),this.distribution==="normal"){const o=Math.sqrt(a);if(t=t||"float32",t!=="float32"&&t!=="int32")throw new vt(`${this.getClassName()} does not support dType ${t}.`);return vS(e,0,o,t,this.seed)}else{const o=Math.sqrt(3*a);return Wf(e,-o,o,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}Wr.className="VarianceScaling";ge(Wr);class D_ extends Wr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}D_.className="GlorotUniform";ge(D_);class L_ extends Wr{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}L_.className="GlorotNormal";ge(L_);class O_ extends Wr{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}O_.className="HeNormal";ge(O_);class z_ extends Wr{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}z_.className="HeUniform";ge(z_);class P_ extends Wr{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}P_.className="LeCunNormal";ge(P_);class F_ extends Wr{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:e==null?null:e.seed})}getClassName(){return Wr.className}}F_.className="LeCunUniform";ge(F_);class ST extends Mi{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=e.gain==null?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return te(()=>{if(e.length<2)throw new vt("Shape must be at least 2D.");if(t!=="int32"&&t!=="float32"&&t!==void 0)throw new TypeError(`Unsupported data type ${t}.`);t=t;const r=ue(e.slice(0,-1)),i=e[e.length-1],s=r*i;s>this.ELEMENTS_WARN_SLOW&&console.warn(`Orthogonal initializer is being called on a matrix with more than ${this.ELEMENTS_WARN_SLOW} (${s}) elements: Slowness may result.`);const a=[Math.max(i,r),Math.min(i,r)],o=Rm(a,0,1,t,this.seed),c=VV.qr(o,!1);let l=c[0];const f=c[1].flatten().stridedSlice([0],[Math.min(i,r)*Math.min(i,r)],[Math.min(i,r)+1]);return l=W(l,f.sign()),r<i&&(l=l.transpose()),W(zt(this.gain),l.reshape(e))})}getConfig(){return{gain:this.gain,seed:this.seed}}}ST.className="Orthogonal";ge(ST);const U2={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function B2(n,e={}){return Zf(n,hi.getMap().classNameMap,e,"initializer")}function hn(n){return M_(n)}function un(n){if(typeof n=="string"){const e=n in U2?U2[n]:n;if(e==="GlorotNormal")return new L_;if(e==="GlorotUniform")return new D_;if(e==="HeNormal")return new O_;if(e==="HeUniform")return new z_;if(e==="LeCunNormal")return new P_;if(e==="LeCunUniform")return new F_;{const t={};return t.className=e,t.config={},B2(t)}}else return n instanceof Mi?n:B2(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Sx(n){return Array.isArray(n)&&Array.isArray(n[0])}function Bh(n){return n.length===0?[]:Array.isArray(n[0])?n:[n]}function ot(n){let e;if(Array.isArray(n)){if(n.length!==1)throw new G(`Expected Tensor length to be 1; got ${n.length}`);e=n[0]}else e=n;return e}function kt(n){if(Array.isArray(n)&&Array.isArray(n[0])){if(n.length===1)return n=n,n[0];throw new G(`Expected exactly 1 Shape; got ${n.length}`)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Vh(n){let e=0;for(const t of n)t.shape.length===0?e+=1:e+=t.shape.reduce((r,i)=>r*i);return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const V2="Variable";class kH{constructor(e,t="float32",r=V2,i=!0,s=null){this.dtype=t??"float32",this.shape=e.shape,this.id=fT(),r=r??V2,this.originalName=hT(r),this.name=pT(this.originalName),this.trainable_=i,this.constraint=s,this.val=VB(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),DH(this.val,e),this.val.id!==e.id&&(this.val.assign(e),this.constraint!=null&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error(`LayersVariable ${this.name} is already disposed.`)}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function DH(n,e){if(n.shape.toString()!==e.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(n.shape)+" vs. "+JSON.stringify(e.shape))}function Tx(n){return n.map(e=>e.read())}function $_(n){n.forEach(e=>{e[0].write(e[1])})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Dn{constructor(e){this.dtype=e.dtype,this.shape=e.shape,e.shape!=null?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class bs{constructor(e,t,r,i,s,a,o){this.dtype=e,this.shape=t,this.sourceLayer=r,this.inputs=i,this.callArgs=s,this.outputTensorIndex=o,this.id=fT(),a!=null&&(this.originalName=hT(a),this.name=pT(this.originalName)),this.rank=t.length}}let LH=0;class Nm{constructor(e,t){this.callArgs=t,this.id=LH++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const r of e.inboundLayers)r!=null&&r.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)t!=null?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let OH=0;class Tt extends Il{constructor(e={}){super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=OH++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const r=this.getClassName();t=Os(r)+"_"+Mm(r)}if(this.name=t,this.trainable_=e.trainable==null?!0:e.trainable,e.inputShape!=null||e.batchInputShape!=null){let r;if(e.batchInputShape!=null)r=e.batchInputShape;else if(e.inputShape!=null){let s=null;e.batchSize!=null&&(s=e.batchSize),r=[s].concat(e.inputShape)}this.batchInputShape=r;let i=e.dtype;i==null&&(i=e.inputDType),i==null&&(i="float32"),this.dtype=i}e.weights!=null?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(this.inboundNodes.length===0)throw new xi(`The layer has never been called and thus has no defined ${t}.`);if(this.inboundNodes.length<=e)throw new G(`Asked to get ${t} at node ${e}, but the layer has only ${this.inboundNodes.length} inbound nodes.`);return this.inboundNodes[e]}getInputAt(e){return Tr(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Tr(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new is(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use \`getInputAt(nodeIndex)\` instead.`);if(this.inboundNodes.length===0)throw new is(`Layer ${this.name} is not connected, no input to return.`);return Tr(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(this.inboundNodes.length===0)throw new is(`Layer ${this.name} has no inbound nodes.`);if(this.inboundNodes.length>1)throw new is(`Layer ${this.name} has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use \`getOutputAt(nodeIndex)\` instead.`);return Tr(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map(e=>e())}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach(t=>t.trainable=e),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter(e=>e.trainable):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter(e=>!e.trainable).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Ht(e);if(this.inputSpec==null||this.inputSpec.length===0)return;const r=Ht(this.inputSpec);if(t.length!==r.length)throw new G(`Layer ${this.name} expects ${r.length} inputs, but it received ${t.length} input tensors. Input received: ${e}`);for(let i=0;i<t.length;i++){const s=t[i],a=r[i];if(a==null)continue;const o=s.rank;if(a.ndim!=null&&o!==a.ndim)throw new G(`Input ${i} is incompatible with layer ${this.name}: expected ndim=${a.ndim}, found ndim=${o}`);if(a.maxNDim!=null&&o>a.maxNDim)throw new G(`Input ${i} is incompatible with layer ${this.name}: expected max_ndim=${a.maxNDim}, found ndim=${o}`);if(a.minNDim!=null&&o<a.minNDim)throw new G(`Input ${i} is incompatible with layer ${this.name}: expected min_ndim=${a.minNDim}, found ndim=${o}.`);if(a.dtype!=null&&s.dtype!==a.dtype)throw new G(`Input ${i} is incompatible with layer ${this.name} : expected dtype=${a.dtype}, found dtype=${s.dtype}.`);if(a.axes){const c=s.shape;for(const l in a.axes){const u=Number(l),f=a.axes[l],d=u>=0?c[u]:c[c.length+u];if(f!=null&&[f,null].indexOf(d)===-1)throw new G(`Input ${i} is incompatible with layer ${this.name}: expected axis ${u} of input shape to have value ${f} but got shape ${c}.`)}}if(a.shape!=null)for(let c=0;c<a.shape.length;++c){const l=a.shape[c],u=s.shape[c];if(l!=null&&u!=null&&l!==u)throw new G(`Input ${i} is incompatible with layer ${this.name}: expected shape=${a.shape}, found shape=${s.shape}.`)}}}call(e,t){return e}invokeCallHook(e,t){this._callHook!=null&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const r=Ht(e),i=FH(e),s=$H(e);if(i===s)throw new G("Arguments to apply() must be all SymbolicTensors or all Tensors");return _o(this.name,()=>{if(!this.built){this.assertInputCompatibility(e);const a=[];for(const o of Ht(e))a.push(o.shape);this.build(Tr(a)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),this._refCount===null&&s&&(this._refCount=1)}if(this.assertInputCompatibility(e),s){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const o=Ht(a),c=[];for(let l of o)r.indexOf(l)!==-1&&(l=l.clone()),c.push(l);if(a=Tr(c),this.activityRegularizer!=null)throw new vt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}else{const a=zH(e),o=this.computeOutputShape(a);let c;const l=PH(e);if(this.warnOnIncompatibleInputShape(Array.isArray(e)?a[0]:a),o!=null&&o.length>0&&Array.isArray(o[0])?c=o.map((u,f)=>new bs(l,u,this,Ht(e),t,this.name,f)):c=new bs(l,o,this,Ht(e),t,this.name),this.addInboundNode(e,c,null,null,a,o,t),this._refCount++,this.activityRegularizer!=null)throw new vt("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return c}})}warnOnIncompatibleInputShape(e){if(this.batchInputShape!=null)if(e.length!==this.batchInputShape.length)console.warn(`The rank of the input tensor provided (shape: ${JSON.stringify(e)}) does not match that of the batchInputShape (${JSON.stringify(this.batchInputShape)}) of the layer ${this.name}`);else{let t=!1;this.batchInputShape.forEach((r,i)=>{r!=null&&e[i]!=null&&e[i]!==r&&(t=!0)}),t&&console.warn(`The shape of the input tensor (${JSON.stringify(e)}) does not match the expectation of layer ${this.name}: ${JSON.stringify(this.batchInputShape)}`)}}get outputShape(){if(this.inboundNodes==null||this.inboundNodes.length===0)throw new is(`The layer ${this.name} has never been called and thus has no defined output shape.`);const e=[];for(const t of this.inboundNodes){const r=JSON.stringify(t.outputShapes);e.indexOf(r)===-1&&e.push(r)}if(e.length===1){const t=this.inboundNodes[0].outputShapes;return Array.isArray(t)&&Array.isArray(t[0])&&t.length===1?t[0]:t}else throw new is(`The layer ${this.name} has multiple inbound nodes with different output shapes. Hence the notion of "output shape" is ill-defined for the layer.`)}countParams(){if(!this.built)throw new xi(`You tried to call countParams() on ${this.name}, but the layer is not built yet. Build it first by calling build(batchInputShape).`);return Vh(this.weights)}build(e){this.built=!0}getWeights(e=!1){return Tx(e?this.trainableWeights:this.weights)}setWeights(e){te(()=>{const t=this.weights;if(t.length!==e.length)throw new G(`You called setWeights(weights) on layer "${this.name}" with a weight list of length ${e.length}, but the layer was expecting ${t.length} weights. Provided weights: ${e}...`);if(t.length===0)return;const r=[],i=Tx(t);for(let s=0;s<i.length;++s){const a=i[s],o=t[s],c=e[s];if(!Pt(a.shape,c.shape))throw new G(`Layer weight shape ${a.shape} not compatible with provided weight shape ${c.shape}`);r.push([o,c])}$_(r)})}addWeight(e,t,r,i,s,a,o,c){if(this._addedWeightNames.indexOf(e)!==-1)throw new G(`Duplicate weight name ${e} for layer ${this.name}`);this._addedWeightNames.push(e),r==null&&(r="float32"),this.fastWeightInitDuringBuild&&(i=c!=null?c():un("zeros"));const l=i.apply(t,r),u=new kH(l,r,e,a,o);return l.dispose(),s!=null&&this.addLoss(()=>s.apply(u.read())),a==null&&(a=!0),a?this._trainableWeights.push(u):this._nonTrainableWeights.push(u),u}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){e==null||Array.isArray(e)&&e.length===0||(e=Ht(e),this._losses!==void 0&&this._losses!==null&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(t!=null)if(Array.isArray(t))t.forEach(r=>{if(r!=null)throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`)});else throw new TypeError(`Layer ${this.name} does not support masking, but was passed an inputMask.`);return null}return t}setMaskMetadata(e,t,r){if(!this.supportsMasking)return;const i=this.computeMask(e,r),s=Ht(t),a=Ht(i);if(s.length!==a.length)throw new Error(`${this.name} outputs ${s.length} tensors but ${s.length} masks for those tensors`);for(let o=0;o<s.length;o++)s[o].kerasMask=a[o]}addInboundNode(e,t,r,i,s,a,o=null){const c=Ht(e);t=Ht(t),r=Ht(r),i=Ht(i),s=Bh(s),a=Bh(a);const l=[],u=[],f=[];for(const d of c)l.push(d.sourceLayer),u.push(d.nodeIndex),f.push(d.tensorIndex);new Nm({outboundLayer:this,inboundLayers:l,nodeIndices:u,tensorIndices:f,inputTensors:c,outputTensors:t,inputMasks:r,outputMasks:i,inputShapes:s,outputShapes:a},o);for(let d=0;d<t.length;d++)t[d].sourceLayer=this,t[d].nodeIndex=this.inboundNodes.length-1,t[d].tensorIndex=d}getConfig(){const e={name:this.name,trainable:this.trainable};return this.batchInputShape!=null&&(e.batchInputShape=this.batchInputShape),this.dtype!=null&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach(e=>e.dispose()),this.weights.length}assertNotDisposed(){if(this._refCount===0)throw new Error(`Layer '${this.name}' is already disposed.`)}dispose(){if(!this.built)throw new Error(`Cannot dispose Layer ${this.name} because it has not been built yet.`);if(this._refCount===null)throw new Error(`Cannot dispose Layer ${this.name} because it has not been used yet.`);this.assertNotDisposed();let e=0;return--this._refCount===0&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function zH(n){n=Ht(n);const e=[];for(const t of n)e.push(t.shape);return Tr(e)}function PH(n){return"float32"}function TT(n,e,t){if((e==null||t!=null&&t>0)&&(e=n.sourceLayer,t=n.nodeIndex),e.inboundNodes.length===0)return[n];{const r=e.inboundNodes[t];if(r.inboundLayers.length===0)return r.inputTensors;{const i=[];for(let s=0;s<r.inboundLayers.length;s++){const a=r.inputTensors[s],o=r.inboundLayers[s],c=r.nodeIndices[s],l=TT(a,o,c);for(const u of l)i.indexOf(u)===-1&&i.push(u)}return i}}}function FH(n){let e=!0;for(const t of Ht(n))if(!(t instanceof bs)){e=!1;break}return e}function $H(n){let e=!0;for(const t of Ht(n))if(t instanceof bs){e=!1;break}return e}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class td extends Tt{constructor(e){if(super({dtype:e.dtype,name:e.name!=null?e.name:Mm("input").toString()}),e.batchSize==null&&(e.batchSize=null),e.sparse==null&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,e.inputShape!=null&&e.batchInputShape!=null)throw new G("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(t==null){if(e.inputShape==null)throw new G("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(e.batchSize!=null)throw new G("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const r=e.dtype||"float32";this.batchInputShape=t,this.dtype=r,this.inputSpec=[{shape:t}];const i=new bs(this.dtype,this.batchInputShape,this,[],{},this.name);i.nodeIndex=0,i.tensorIndex=0,new Nm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[i],outputTensors:[i],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new G(`Cannot pass any input to an InputLayer's apply() method. InputLayer name: ${this.name}`)}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}td.className="InputLayer";ge(td);function UH(n){if(n.batchShape==null&&n.shape==null)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(n.batchShape!=null&&n.shape!=null)throw new G("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let e=n.batchShape;n.shape!=null&&e==null&&(e=[null].concat(n.shape));let t=n.dtype;return t==null&&(t="float32"),new td({batchInputShape:e,name:n.name,dtype:t,sparse:n.sparse}).inboundNodes[0].outputTensors[0]}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function BH(n,e){if(n.dtype==null||n.dtype===e.dtype)return e;try{return Ie(e,n.dtype)}catch{throw new G(`The dtype of the feed (${e.dtype}) can not be cast to the dtype of the key '${n.name}' (${n.dtype}).`)}}class ya{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof ya)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(e==null)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,r){if(this.id2Value[e.id]==null)this.id2Value[e.id]=BH(e,t),this.name2Id[e.name]=e.id,r!=null&&(this.id2Mask[e.id]=r);else throw new G(`Duplicate key: name=${e.name}, id=${e.id}`);return this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return this.id2Value[e.id]!=null}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof bs){if(this.id2Value[e.id]==null)throw new G(`Nonexistent key: ${e.name}`);return this.id2Value[e.id]}else{const t=this.name2Id[e];if(t==null)throw new G(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Value[t]}}getMask(e){if(e instanceof bs){if(this.id2Value[e.id]==null)throw new G(`Nonexistent key: ${e.name}`);return this.id2Mask[e.id]}else{const t=this.name2Id[e];if(t==null)throw new G(`Feed dict has no SymbolicTensor name: ${e}`);return this.id2Mask[t]}}disposeMasks(){this.id2Mask!=null&&He(this.id2Mask)}}const Gh=new cT,Hh=new cT;function VH(n){Gh!=null&&Gh.setMaxEntries(n),Hh!=null&&Hh.setMaxEntries(n)}function fu(n,e,t,r){const i=t==null?!1:t.training,s=Array.isArray(n),a=s?n:[n],o=a.map(p=>p.name),c=[],l=e.names();for(const p of o)l.indexOf(p)!==-1?c.push(e.getValue(p)):c.push(null);r!=null&&(r.maxNumTensors=-1/0,r.minNumTensors=1/0);const u=o.join(",")+"|"+e.names().sort().join(",");let f=Gh.get(u),d;if(f==null){const p=GH(a,e);f=p.sorted,d=p.recipientCounts,Gh.put(u,f),Hh.put(u,d)}d={},i||Object.assign(d,Hh.get(u));const h=new ya(e);for(let p=0;p<f.length;++p){if(r!=null){const C=fx().numTensors;C>r.maxNumTensors&&(r.maxNumTensors=C),C<r.minNumTensors&&(r.minNumTensors=C)}const g=f[p],m=g.sourceLayer;if(m instanceof td)continue;const v=[],x=[],b=[];let _=!1;for(const C of g.inputs){const y=h.getValue(C),A=h.getMask(C);v.push(y),x.push(A),A!=null&&(_=!0),i||(d[C.name]--,d[C.name]===0&&!e.hasKey(C)&&o.indexOf(C.name)===-1&&!y.isDisposed&&C.sourceLayer.stateful!==!0&&b.push(y))}_&&(t=t||{},t.mask=x[0]);const w=Ht(m.apply(v,t));let E=null;m.supportsMasking&&(E=m.computeMask(v,x));const S=WH(g),T=Array.isArray(S)?S:[S];for(let C=0;C<T.length;++C){h.hasKey(T[C])||h.add(T[C],w[C],Array.isArray(E)?E[0]:E);const y=o.indexOf(T[C].name);y!==-1&&(c[y]=w[C])}i||He(b)}return h.disposeMasks(),s?c:c[0]}function GH(n,e){R(n!=null&&n.length>0,()=>"Expected at least one fetch, got none");let t=[],r={};if(n.length===1){const i=G2(n[0],e);t=i.sorted,r=i.recipientMap}else{const i=new Set;for(const s of n){const{sorted:a,recipientMap:o}=G2(s,e);for(const c of a)i.has(c.name)||(t.push(c),i.add(c.name));for(const c in o)r[c]==null&&(r[c]=new Set),o[c].forEach(l=>r[c].add(l))}}return{sorted:t,recipientCounts:HH(r)}}function HH(n){const e={};for(const t in n)e[t]=n[t].size;return e}function G2(n,e){const t=new Set,r=[],i={};for(const o of e.names())t.add(o);const s=[],a=[];for(s.push(n);s.length>0;){const o=s[s.length-1];if(t.has(o.name)){s.pop();continue}const c=a[a.length-1]===s.length-1;if(o.inputs.length===0||c)s.pop(),r.push(o),t.add(o.name),c&&a.pop();else{a.push(s.length-1);for(const l of o.inputs)i[l.name]==null&&(i[l.name]=new Set),i[l.name].add(o.name),!t.has(l.name)&&s.push(l)}}return{sorted:r,recipientMap:i}}function WH(n){let e;if(n.sourceLayer.inboundNodes.length===1)e=n.sourceLayer.output;else{let t=null;for(let r=0;r<n.sourceLayer.inboundNodes.length;++r)for(const i of n.sourceLayer.inboundNodes[r].outputTensors)if(i.id===n.id){t=r;break}e=n.sourceLayer.getOutputAt(t)}return e}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qH=ie();qH.registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",()=>100,VH);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function U_(n,e){return te(()=>ar(et(W(n,n),e,!0)))}class nd extends Il{getConfig(){return{}}}class AT extends nd{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return te(()=>{const t=U_(e,this.axis),r=ni(t,0,this.maxValue);return W(e,nt(r,ye(kn(),t)))})}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}AT.className="MaxNorm";ge(AT);class CT extends nd{constructor(e){super(),this.defaultAxis=0,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return te(()=>nt(e,ye(kn(),U_(e,this.axis))))}getConfig(){return{axis:this.axis}}}CT.className="UnitNorm";ge(CT);class IT extends nd{apply(e){return qo(e)}}IT.className="NonNeg";ge(IT);class MT extends nd{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=e.minValue!=null?e.minValue:this.defaultMinValue,this.maxValue=e.maxValue!=null?e.maxValue:this.defaultMaxValue,this.rate=e.rate!=null?e.rate:this.defaultRate,this.axis=e.axis!=null?e.axis:this.defaultAxis}apply(e){return te(()=>{const t=U_(e,this.axis),r=ye(W(this.rate,ni(t,this.minValue,this.maxValue)),W(1-this.rate,t));return W(e,nt(r,ye(kn(),t)))})}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}MT.className="MinMaxNorm";ge(MT);const H2={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Ln(n){return M_(n)}function W2(n,e={}){return Zf(n,hi.getMap().classNameMap,e,"constraint")}function On(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in H2?H2[n]:n,config:{}};return W2(t)}else return n instanceof nd?n:W2(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */async function ro(n){if(n==null)return;const e=[],t=[],r=[];for(const i in n){const s=n[i];if(typeof s!="number"){const a=s;e.push(a.data()),t.push(i),r.push(a)}}if(e.length>0){const i=await Promise.all(e);for(let s=0;s<i.length;++s)n[t[s]]=i[s][0];He(r)}}function RT(n){if(n!=null)for(const e in n){const t=n[e];typeof t!="number"&&t.dispose()}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var q2;(function(n){n[n.SILENT=0]="SILENT",n[n.VERBOSE=1]="VERBOSE"})(q2||(q2={}));const XH=125;class Mu{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class KH{constructor(e,t=10){e==null&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochBegin(e,t)}async onEpochEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onEpochEnd(e,t)}async onBatchBegin(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchBegin(e,t)}async onBatchEnd(e,t){t==null&&(t={});for(const r of this.callbacks)await r.onBatchEnd(e,t)}async onTrainBegin(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){e==null&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class jH extends Mu{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){t==null&&(t={});const r=t.size==null?0:t.size;this.seen+=r;for(const i in t){const s=t[i];if(typeof s=="number")this.totals.hasOwnProperty(i)||(this.totals[i]=0),this.totals[i]=this.totals[i]+s*r;else{let a;i in this.totals?a=this.totals[i]:this.totals[i]=0;const o=te(()=>ye(this.totals[i],W(s,r)));this.totals[i]=o,a!=null&&a.dispose()}}}async onEpochEnd(e,t){if(t!=null)for(const r of this.params.metrics)this.totals[r]!=null&&(typeof this.totals[r]=="number"?t[r]=this.totals[r]/this.seen:te(()=>{const i=W(nt(1,this.seen),this.totals[r]);t[r]=i,this.totals[r].dispose(),fs(t[r])}))}}class YH extends Mu{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){t==null&&(t={}),this.epoch.push(e);for(const r in t)this.history[r]==null&&(this.history[r]=[]),this.history[r].push(t[r])}async syncData(){const e=[],t=[],r=[];for(const s in this.history){const a=this.history[s];for(let o=0;o<a.length;++o)if(typeof a[o]!="number"){const c=a[o];e.push(c.data()),t.push(s),r.push(o)}}const i=await Promise.all(e);for(let s=0;s<i.length;++s)this.history[t[s]][r[s]].dispose(),this.history[t[s]][r[s]]=i[s][0]}}class ZH extends Mu{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||OS,this.yieldEvery=t||"auto",this.yieldEvery==="auto"&&(this.yieldEvery=XH),this.yieldEvery==="never"&&e.onYield!=null)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");Jg(this.yieldEvery)&&(this.maybeWait=uH(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,r){const i=[];this.yield!=null&&(await ro(r),i.push(this.yield(e,t,r))),i.push(this.nextFrameFunc()),await Promise.all(i)}async onEpochBegin(e,t){this.currentEpoch=e,this.epochBegin!=null&&(await ro(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const r=[];this.epochEnd!=null&&(await ro(t),r.push(this.epochEnd(e,t))),this.yieldEvery==="epoch"&&r.push(this.nextFrameFunc()),await Promise.all(r)}async onBatchBegin(e,t){this.batchBegin!=null&&(await ro(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const r=[];this.batchEnd!=null&&(await ro(t),r.push(this.batchEnd(e,t))),this.yieldEvery==="batch"?r.push(this.nextFrameFunc()):Jg(this.yieldEvery)&&r.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(r)}async onTrainBegin(e){this.trainBegin!=null&&(await ro(e),await this.trainBegin(e))}async onTrainEnd(e){this.trainEnd!=null&&(await ro(e),await this.trainEnd(e))}}function NT(n,e){return n==null&&(n={}),n instanceof Mu?[n]:Array.isArray(n)&&n[0]instanceof Mu?n:Ht(n).map(r=>new ZH(r,e))}class fi{constructor(){}static registerCallbackConstructor(e,t){R(e>=0&&Number.isInteger(e),()=>`Verbosity level is expected to be an integer >= 0, but got ${e}`),fi.checkForDuplicate(t),fi.constructors[e]==null&&(fi.constructors[e]=[]),fi.constructors[e].push(t)}static checkForDuplicate(e){for(const t in fi.constructors)fi.constructors[+t].forEach(i=>{if(i===e)throw new G("Duplicate callback constructor.")})}static clear(){fi.constructors={}}static createCallbacks(e){const t=[];for(const r in fi.constructors){const i=+r;e>=i&&t.push(...fi.constructors[i])}return t.map(r=>new r)}}fi.constructors={};function kT(n,e,t,r,i,s,a,o,c){const l=new YH,u=[new jH,...fi.createCallbacks(e)];n!=null&&u.push(...n),u.push(l);const f=new KH(u);return f.setParams({epochs:t,initialEpoch:r,samples:i,steps:s,batchSize:a,verbose:e,doValidation:o,metrics:c}),{callbackList:f,history:l}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Hs(n,e={},t=!1){return Zf(n,hi.getMap().classNameMap,e,"layer",t)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Wh(n,e){return te(()=>{n.dtype!=="float32"&&(n=Ie(n,"float32"));const t=et(Jf(n),e,!0),r=ym(t.shape,kn()),i=ar(Ga(t,r));return nt(n,i)})}function km(n,e){return te(()=>An(Jf(st(e,n)),-1))}function B_(n,e){return te(()=>An(pr(st(e,n)),-1))}function V_(n,e){return te(()=>{const t=st(n,e),r=ni(pr(n),kn(),Number.MAX_VALUE),i=pr(nt(t,r));return W(100,An(i,-1))})}function QH(n,e){return te(()=>{const t=ni(e,kn(),Number.MAX_VALUE),r=xs(ye(1,t)),i=ni(n,kn(),Number.MAX_VALUE),s=xs(ye(1,i));return An(Jf(st(r,s)),-1)})}function JH(n,e){return te(()=>{const t=Ga(0,st(1,W(n,e)));return An(Jf(t),-1)})}function eW(n,e){return te(()=>{const t=Ga(0,st(1,W(n,e)));return An(t,-1)})}function tW(n,e){return te(()=>{const t=et(W(n,e),-1),r=Wi(W(st(1,n),e),-1);return Ga(0,ye(1,st(r,t)))})}function nW(n,e){return te(()=>{const t=Math.log(2),r=st(e,n),i=st(ye(r,Hf(W(-2,r))),t);return An(i,-1)})}function Ru(n,e,t=!1){return te(()=>{if(t)e=qb(e);else{const r=et(e,e.shape.length-1,!0);e=nt(e,r)}return e=ni(e,kn(),1-kn()),bn(et(W(Ie(n,"float32"),xs(e)),e.shape.length-1))})}function qh(n,e,t=!1){return te(()=>{const r=Ie(Sm(wH(n)),"int32");e=ni(e,kn(),1-kn());const i=e.shape,s=j(rS(r,i[i.length-1]),i);return Ru(s,e,t)})}function rW(n,e){if(!Pt(n.shape,e.shape))throw new G(`logits and labels must have the same shape, but got shapes ${JSON.stringify(n.shape)} and ${JSON.stringify(e.shape)}`);return te(()=>{const t=qo(e),r=bn(pr(e));return ye(st(t,W(e,n)),J3(gs(r)))})}function Dm(n,e){return te(()=>{let t;return t=ni(e,kn(),1-kn()),t=xs(nt(t,st(1,t))),An(rW(n,t),-1)})}function iW(n,e){return te(()=>{const t=ni(n,kn(),1),r=ni(e,kn(),1);return et(W(n,xs(nt(t,r))),-1)})}function sW(n,e){return te(()=>{const t=xs(ye(kn(),e));return An(st(e,W(n,t)),-1)})}function DT(n,e){return te(()=>{const t=Wh(n,-1),r=Wh(e,-1),i=W(t,r);return bn(et(i,-1))})}const Xh={meanSquaredError:km,meanAbsoluteError:B_,meanAbsolutePercentageError:V_,meanSquaredLogarithmicError:QH,squaredHinge:JH,hinge:eW,categoricalHinge:tW,logcosh:nW,categoricalCrossentropy:Ru,sparseCategoricalCrossentropy:qh,binaryCrossentropy:Dm,kullbackLeiblerDivergence:iW,poisson:sW,cosineProximity:DT};function Wv(n){if(typeof n=="string"){if(n in Xh)return Xh[n];let e=`Unknown loss ${n}`;throw n.toLowerCase().includes("softmaxcrossentropy")&&(e=`Unknown loss ${n}. Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy`),new G(e)}else return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function LT(n,e){return te(()=>{const t=W(.5,Ai(e)),r=hs(ri(e,t),n.dtype);return An(vs(n,r),-1)})}function OT(n,e){return te(()=>hs(vs(Su(n,-1),Su(e,-1)),"float32"))}function aW(n,e){return te(()=>Ie(et(Xs(vs(n,1),vs(e,1))),"float32"))}function oW(n,e){return te(()=>Ie(et(Xs(vs(n,0),vs(e,1))),"float32"))}function cW(n,e){return te(()=>{const t=aW(n,e),r=oW(n,e),i=ye(t,r);return Ie(xn(ri(i,0),nt(t,i),0),"float32")})}function lW(n,e){return Dm(n,e)}function uW(n,e){return n.rank===e.rank&&(n=qf(n,[n.rank-1])),e=Su(e,-1),e.dtype!==n.dtype&&(e=Ie(e,n.dtype)),Ie(vs(n,e),"float32")}const fW=km,dW=km,hW=B_,pW=B_,mW=V_,vW=V_,zT=Ru,gW=DT,PT=qh,Kh={binaryAccuracy:LT,categoricalAccuracy:OT,precision:cW,categoricalCrossentropy:zT,sparseCategoricalCrossentropy:PT,mse:fW,MSE:dW,mae:hW,MAE:pW,mape:mW,MAPE:vW,cosine:gW};function xW(n){if(typeof n=="string"&&n in Kh)return Kh[n];if(typeof n!="string"&&n!=null)return n;throw new G(`Unknown metric ${n}`)}function eh(n){if(ss(n!==null,`Unknown LossOrMetricFn ${n}`),typeof n=="string")return n;{let e;for(const t of Object.keys(Xh))if(Xh[t]===n){e=t;break}if(e!==void 0)return e;for(const t of Object.keys(Kh))if(Kh[t]===n){e=t;break}return e!==void 0?e:n.name}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function bW(n){const e={Adagrad:()=>bc.adagrad(.01),Adadelta:()=>bc.adadelta(1,.95,kn()),Adam:()=>bc.adam(.001,.9,.999,kn()),Adamax:()=>bc.adamax(.002,.9,.999,kn(),0),RMSProp:()=>bc.rmsprop(.001,.9,0,kn()),SGD:()=>bc.sgd(.01)};if(e.adagrad=e.Adagrad,e.adadelta=e.Adadelta,e.adam=e.Adam,e.adamax=e.Adamax,e.rmsprop=e.RMSProp,e.sgd=e.SGD,n in e)return e[n]();throw new G(`Unknown Optimizer ${n}`)}/**
 * @license
 * Copyright 2019 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const X2=1*1024*1024;function K2(n,e,t=!1){if(n==null||typeof n!="object"||Object.getPrototypeOf(n)!==Object.prototype||!Ax(n))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(t){const r=JSON.stringify(n);r.length>X2&&console.warn(`User-defined metadata of model "${e}" is too large in size (length=${r.length} when serialized). It is not recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= ${X2}.`)}}function Ax(n){if(n===null)return!0;if(typeof n=="object")if(Object.getPrototypeOf(n)===Object.prototype){const e=Object.keys(n);for(const t of e)if(typeof t!="string"||!Ax(n[t]))return!1;return!0}else if(Array.isArray(n)){for(const e of n)if(!Ax(e))return!1;return!0}else return!1;else{const e=typeof n;return e==="string"||e==="number"||e==="boolean"}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function _W(n,e,t,r=console.log){const i=wW(n),s=["Layer (type)","Input Shape","Output shape","Param #"];i?(e=e||90,t=t||[.32,.61,.89,1]):(e=e||115,t=t||[.24,.48,.7,.8,1]),t[t.length-1]<=1&&(t=t.map(u=>Math.floor(e*u)));let a;if(!i){s.push("Receives inputs"),a=[];for(const u in n.nodesByDepth)a.push(...n.nodesByDepth[u])}r("_".repeat(e)),jh(s,t,r),r("=".repeat(e));const o=n.layers;for(let u=0;u<o.length;++u)i?EW(o[u],t,r):SW(o[u],t,a,r),r((u===o.length-1?"=":"_").repeat(e));n.checkTrainableWeightsConsistency();const c=yW(n),l=Vh(n.nonTrainableWeights);r(`Total params: ${c+l}`),r(`Trainable params: ${c}`),r(`Non-trainable params: ${l}`),r("_".repeat(e))}function yW(n){let e;return n.collectedTrainableWeights!=null?e=Vh(n.collectedTrainableWeights):e=Vh(n.trainableWeights),e}function wW(n){let e=!0;const t=[],r=[];for(const i in n.nodesByDepth)t.push(n.nodesByDepth[i]);for(const i of t){if(i.length>1||i.length===1&&i[0].inboundLayers.length>1){e=!1;break}r.push(...i)}if(e)for(const i of n.layers){let s=!1;for(const a of i.inboundNodes)if(r.indexOf(a)!==-1)if(s){e=!1;break}else s=!0;if(!e)break}return e}function jh(n,e,t=console.log){let r="";for(let i=0;i<n.length;++i)i>0&&(r=r.slice(0,r.length-1)+" "),r+=n[i],r=r.slice(0,e[i]),r+=" ".repeat(e[i]-r.length);t(r)}function EW(n,e,t){let r,i;try{i=n.inboundNodes.map(c=>JSON.stringify(c.inputShapes)).join(",")}catch{i="multiple"}try{r=JSON.stringify(n.outputShape)}catch{r="multiple"}const s=n.name,a=n.getClassName(),o=[`${s} (${a})`,i,r,n.countParams().toString()];jh(o,e,t)}function SW(n,e,t,r){let i,s;try{s=n.inboundNodes.map(f=>JSON.stringify(f.inputShapes)).join(",")}catch{s="multiple"}try{i=JSON.stringify(n.outputShape)}catch{i="multiple"}const a=[];for(const f of n.inboundNodes)if(!(t!=null&&t.length>0&&t.indexOf(f)===-1))for(let d=0;d<f.inboundLayers.length;++d){const h=f.inboundLayers[d].name,p=f.nodeIndices[d],g=f.tensorIndices[d];a.push(`${h}[${p}][${g}]`)}const o=n.name,c=n.getClassName(),l=a.length===0?"":a[0],u=[`${o} (${c})`,s,i,n.countParams().toString(),l];jh(u,e,r);for(let f=1;f<a.length;++f)jh(["","","","",a[f]],e,r)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function FT(n,e,t){return(n==="inboundNodes"||n==="outputLayers"||n==="inputLayers")&&e===0&&typeof t=="string"}function Cx(n,e){if(n===null)return null;if(typeof n=="string")return fo(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let i=0;i<r;++i){const s=n[i];FT(e,i,s)?t.push(s):t.push(Cx(s,e))}return t}else{const t={};for(const r of Object.keys(n)){const i=n[r];if(r==="name"&&typeof i=="string")t[r]=i;else{const s=fo(r);t[s]=Cx(i,s)}}return t}}function Ix(n,e){if(n==null)return null;if(typeof n=="string")return Os(n);if(typeof n=="number"||typeof n=="boolean")return n;if(n instanceof Array){const t=[],r=n.length;for(let i=0;i<r;++i){const s=n[i];FT(e,i,s)?t.push(s):t.push(Ix(s,e))}return t}else{const t={};for(const r of Object.keys(n)){const i=n[r],s=Os(r);(r==="name"||r==="className")&&typeof i=="string"?t[s]=i:t[s]=Ix(i,r)}return t}}/** @license See the LICENSE file. */const $T="4.21.0";/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const TW=n=>{const e=Object.keys(n);if(e.length===0)return!1;const t=e[0].split("/");return!isNaN(parseInt(t[t.length-1],10))};class zi extends Tt{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,this.name==null){const x=this.getClassName().toLowerCase();this.name=Mm(x)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Ia(this.inputs).length!==this.inputs.length)throw new G(`The list of inputs passed to the model is redundant. All inputs should only appear once. Found: ${this.inputs.map(x=>x.name)}`);Ia(this.outputs).length!==this.outputs.length&&console.warn(`The list of outputs passed to the model is redundant. All outputs should only appear once. Found: ${this.outputs.map(x=>x.name)}`),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const x of this.outputs){const b=x.sourceLayer,_=x.nodeIndex,w=x.tensorIndex;this.outputLayers.push(b),this.outputLayersNodeIndices.push(_),this.outputLayersTensorIndices.push(w)}for(const x of this.inputs){const b=x.sourceLayer,_=x.nodeIndex,w=x.tensorIndex;ss(_===0,"input layer has >1 nodes"),ss(w===0,"input layer has >1 tensors"),this.inputLayers.push(b),this.inputLayersNodeIndices.push(_),this.inputLayersTensorIndices.push(w)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let x=0;x<this.inputLayers.length;x++){const b=this.inputLayers[x];if(!(b instanceof td))throw new TypeError(`Input layers to a LayersModel must be InputLayer objects. Received inputs: ${e.inputs}. Input ${x} (0-based) originates from layer type ${b.getClassName()}.`);this.inputNames.push(b.name),this.feedInputShapes.push(b.batchInputShape),this.feedInputNames.push(b.name)}for(const x of this.outputLayers)this.outputNames.push(x.name);this.internalInputShapes=this.inputs.map(x=>x.shape),this.internalOutputShapes=this.outputs.map(x=>x.shape);const t={},r={},i={},s={},a={},o=[],c=(x,b,_,w,E,S)=>{(w==null||E==null||S==null)&&(w=x.sourceLayer,E=x.nodeIndex,S=x.tensorIndex);const T=w.inboundNodes[E];if(_.indexOf(T)!==-1)throw new xi(`The tensor ${x.name} at layer "${w.name}" is part of a cycle.`);if(b.indexOf(T)!==-1)return;this.containerNodes.add(zi.nodeKey(w,E)),w.id in a||(a[w.id]=Object.keys(a).length),_.indexOf(T)===-1&&_.push(T);const C=T.inboundLayers.length;for(let y=0;y<C;y++){const A=T.inputTensors[y],k=T.inboundLayers[y],M=T.nodeIndices[y],L=T.tensorIndices[y];c(A,b,_,k,M,L)}for(b.push(T);_.indexOf(T)>=0;)_.splice(_.indexOf(T),1);o.push(T)},l=[],u=[];for(const x of this.outputs)c(x,l,u);const f=o.slice().reverse();for(const x of f){r[x.id]=x,x.id in t||(t[x.id]=0);let b=t[x.id];const _=i[x.outboundLayer.id]==null?0:i[x.outboundLayer.id];b=Math.max(b,_),i[x.outboundLayer.id]=b,s[x.outboundLayer.id]=x.outboundLayer,t[x.id]=b;for(let w=0;w<x.inboundLayers.length;w++){const E=x.inboundLayers[w],S=x.nodeIndices[w],T=E.inboundNodes[S],C=t[T.id]==null?0:t[T.id];t[T.id]=Math.max(b+1,C),r[T.id]=T}}const d={};for(const x in t){const b=t[x];b in d||(d[b]=[]),d[b].push(r[x])}const h={};for(const x in i){const b=i[x];b in h||(h[b]=[]),h[b].push(s[x])}let p=Object.keys(h).map(x=>parseInt(x,10)).sort(Zd);this.layers=[];for(const x of p){const b=h[x];b.sort((_,w)=>{const E=a[_.id],S=a[w.id];return E<S?-1:E>S?1:0});for(const _ of b)_ instanceof zi&&this.internalContainerRefs.push(_),this.layers.push(_)}this.layersByDepth=h,p=Object.keys(d).map(x=>parseInt(x,10)).sort(Zd);const g=this.inputs.slice(),m=[];for(const x of p)for(const b of d[x]){const _=b.outboundLayer;if(_!=null){for(const w of b.inputTensors)if(g.indexOf(w)===-1)throw new xi(`Graph disconnected: cannot obtain value for tensor ${w} at layer "${_.name}". The following previous layers were accessed without issue: ${m}`);for(const w of b.outputTensors)g.push(w);m.push(_.name)}}this.nodesByDepth=d;const v=this.layers.map(x=>x.name);for(const x of v){const b=v.filter(_=>_===x).length;if(b!==1)throw new xi(`The name "${x}" is used ${b} times in the model. All layer names should be unique. Layer names: `+JSON.stringify(v))}this.outboundNodes=[],this.inboundNodes=[],new Nm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map(x=>null),outputMasks:this.outputs.map(x=>null),inputShapes:this.inputs.map(x=>x.shape),outputShapes:this.outputs.map(x=>x.shape)}),this.built=!0,this._refCount=1}assertNotDisposed(){if(this._refCount===0)throw new Error(`Container '${this.name}' is already disposed.`)}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(--this._refCount===0){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach(t=>{t._trainableWeights.forEach(r=>r.trainable=e)}),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new G("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.layers)t.push(...r.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e,t=!0){const r={};let i=0;const s=TW(e);s&&this.parseWeights(e);for(const o of this.layers)for(const[c,l]of o.weights.entries()){const u=s?`${l.name.split("/").slice(0,-1).join("/")+"/"}${c}`:l.originalName;if(r[u]!=null)throw new G(`Duplicate weight name: ${u}`);r[u]=l,i++}const a=[];for(const o in e){let c=o;if(r[o]==null){const l=o.split("/");c=l.slice(0,-2).concat([l[l.length-1]]).join("/")}if(r[c]!=null)a.push([r[c],e[o]]);else if(t)throw new G(`Provided weight data has no target variable: ${o}`);delete r[c]}if(t){const o=[];for(const c in r)o.push(c);if(o.length>0)throw new G(`${o.length} of ${i} weights are not set: ${o}`)}$_(a)}parseWeights(e){for(const t in Object.keys(e)){const r=t.split("/"),i=["vars","layer_checkpoint_dependencies"],s=r.map(a=>a.startsWith("_")?a.slice(1):a).filter(a=>!i.includes(a)).join("/");s!==t&&(e[s]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion=`tfjs-layers ${$T}`,t.backend="TensorFlow.js",t}toJSON(e,t=!0){const r=Ix(this.updatedConfig());return t?JSON.stringify(r):r}call(e,t){return te(()=>{e=Ht(e);const r=new ya;for(let i=0;i<this.inputs.length;++i)r.add(this.inputs[i],e[i]);return fu(this.outputs,r,t)})}computeMask(e,t){return te(()=>{e=Ht(e);let r;return t==null?r=Oo(null,e.length):r=Ht(t),this.runInternalGraph(e,r)[1]})}computeOutputShape(e){const t=Bh(e);if(t.length!==this.inputLayers.length)throw new G(`Invalid inputShape argument ${e}: model has ${this.inputLayers.length} tensor inputs.`);const r={};for(let o=0;o<t.length;o++){const c=this.inputLayers[o],l=t[o],u=c.name+"_0_0";r[u]=l}const i=Object.keys(this.nodesByDepth).map(o=>parseInt(o,10)).sort(Zd);if(i.length>1)for(const o of i){const c=this.nodesByDepth[o];for(const l of c){const u=l.outboundLayer;if(this.inputLayers.map(g=>g.id).indexOf(u.id)!==-1)continue;const f=[];for(let g=0;g<l.inboundLayers.length;g++){const m=l.inboundLayers[g],v=l.nodeIndices[g],x=l.tensorIndices[g],b=`${m.name}_${v}_${x}`,_=r[b];f.push(_)}const d=u.computeOutputShape(Tr(f)),h=Bh(d),p=u.inboundNodes.indexOf(l);for(let g=0;g<h.length;g++){const m=`${u.name}_${p}_${g}`;r[m]=h[g]}}}const s=[],a=[];for(let o=0;o<this.outputLayers.length;o++){const c=this.outputLayers[o],l=this.outputLayersNodeIndices[o],u=this.outputLayersTensorIndices[o],f=`${c.name}_${l}_${u}`;a.push(f)}for(let o=0;o<a.length;o++){const c=a[o];ss(c in r),s.push(r[c])}return Tr(s)}runInternalGraph(e,t){t==null&&(t=Oo(null,e.length));const r={};for(let c=0;c<this.inputs.length;++c){const l=this.inputs[c],u=e[c],f=t[c];r[l.id]=[u,f]}const i=Object.keys(this.nodesByDepth).map(c=>parseInt(c,10)).sort(Zd);for(const c of i){const l=this.nodesByDepth[c];for(const u of l){const f=u.outboundLayer,d=u.inputTensors,h=u.outputTensors,p=new Array;for(const g of d)g.id in r&&p.push(r[g.id]);if(p.length===d.length){let g={},m,v,x,b;if(u.callArgs!=null&&(g=u.callArgs),p.length===1){const[_,w]=p[0];g.mask==null&&(g.mask=w),x=Ht(f.call(_,g)),b=Ht(f.computeMask(_,w)),m=[_],v=[w]}else m=p.map(_=>_[0]),v=p.map(_=>_[1]),g.mask==null&&(g.mask=v),x=Ht(f.call(m,g)),b=Ht(f.computeMask(m,v));if(f.activityRegularizer)throw new vt("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let _=0;_<h.length;++_){const w=h[_],E=x[_],S=b[_];r[w.id]=[E,S]}}}}const s=[],a=[],o=[];for(const c of this.outputs){ss(c.id in r,`Could not compute output ${c.name} : ${c.id}`);const[l,u]=r[c.id];o.push(l.shape),s.push(l),a.push(u)}return[s,a,o]}buildNodeConversionMap(e){const t={};let r;for(const i of this.layers){r=i instanceof zi?1:0;for(let s=0;s<i.inboundNodes.length;s++){const a=zi.nodeKey(i,s);this.containerNodes.has(a)&&(t[a]=r,r+=1)}}return t}getLayer(e,t){if(t!=null)return this.findLayer(t);if(e==null)throw new G("Provide either a layer name or layer index");if(typeof e=="number")return this.findLayer(e);for(const r of this.layers)if(r.name===e)return r;throw new G(`No such layer: ${e}`)}findLayer(e){if(this.layers.length<=e)throw new G(`Was asked to retrieve layer at index ${e}, but model only has ${this.layers.length} layer(s).`);return this.layers[e]}calculateLosses(){return te(()=>{const e=[];for(const t of this.layers)for(let r=0;r<t.inboundNodes.length;++r){const i=zi.nodeKey(t,r);this.containerNodes.has(i)&&e.push(...t.calculateLosses())}return e})}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),r=[];for(const a of this.layers){const o=a.getClassName(),c=a.getConfig(),l=[];for(let f=0;f<a.inboundNodes.length;f++){const d=a.inboundNodes[f],h=zi.nodeKey(a,f);let p={};if(this.containerNodes.has(h)){if(d.callArgs)try{JSON.stringify(d.callArgs),p=d.callArgs}catch{console.warn(`Layer ${a.name} was passed non-serializable keyword arguments: ${d.callArgs}. They will not be included in the serialized model (and thus will be missing at deserialization time).`),p={}}if(d.inboundLayers.length>0){const g=[];for(let m=0;m<d.inboundLayers.length;m++){const v=d.inboundLayers[m],x=d.nodeIndices[m],b=d.tensorIndices[m],_=zi.nodeKey(v,x);let w=t[_];w==null&&(w=0),g.push([v.name,w,b,p])}l.push(g)}}}const u={};u.name=a.name,u.className=o,u.config=c,u.inboundNodes=l,r.push(u)}e.layers=r;const i=[];for(let a=0;a<this.inputLayers.length;a++){const o=this.inputLayers[a],c=this.inputLayersNodeIndices[a],l=zi.nodeKey(o,c);if(!this.containerNodes.has(l))continue;let u=t[l];u==null&&(u=0);const f=this.inputLayersTensorIndices[a];i.push([o.name,u,f])}e.inputLayers=i;const s=[];for(let a=0;a<this.outputLayers.length;a++){const o=this.outputLayers[a],c=this.outputLayersNodeIndices[a],l=zi.nodeKey(o,c);if(!this.containerNodes.has(l))continue;let u=t[l];u==null&&(u=0);const f=this.outputLayersTensorIndices[a];s.push([o.name,u,f])}return e.outputLayers=s,e}static fromConfig(e,t,r={},i=!1){const s={},a={};function o(m,v){m.name in a?a[m.name].push(v):a[m.name]=[v]}function c(m,v){const x=[];let b;for(const _ of v){const w=_[0],E=_[1],S=_[2];if(b=_[3]==null?{}:_[3],!(w in s)){o(m,v);return}const T=s[w];if(T.inboundNodes.length<=E){o(m,v);return}const C=T.inboundNodes[E];x.push(C.outputTensors[S])}x.length>0&&m.apply(Tr(x),b)}function l(m){const v=m.name,x=Hs(m,t.customObjects!=null?t.customObjects:{});x.setFastWeightInitDuringBuild(i),s[v]=x,m.inboundNodes.forEach(_=>{if(!(_ instanceof Array))throw new G(`Corrupted configuration, expected array for nodeData: ${_}`);o(x,_)})}const u=t.name,f=t.layers;for(const m of f)l(m);for(;!lH(a);)for(const m of f){const v=s[m.name];if(v.name in a){const x=a[v.name];delete a[v.name];for(const b of x)c(v,b)}}const d=[],h=[],p=t.inputLayers;for(const m of p){const v=m[0],x=m[1],b=m[2];ss(v in s);const w=s[v].inboundNodes[x].outputTensors;d.push(w[b])}const g=t.outputLayers;for(const m of g){const v=m[0],x=m[1],b=m[2];ss(v in s);const w=s[v].inboundNodes[x].outputTensors;h.push(w[b])}return new e({inputs:d,outputs:h,name:u})}get stateful(){if(this._stateful)throw new G("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){te(()=>{this.layers.forEach(e=>{e.stateful&&e.resetStates()})})}}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function AW(n,e,t){const r=e.length;if(n==null||Array.isArray(n)&&n.length===0)return e.map(i=>null);if(r===1)return Array.isArray(n)&&n.length===1?n:typeof n=="object"&&e[0]in n?[n[e[0]]]:[n];if(Array.isArray(n)){if(n.length!==r)throw new Error(`Provided ${t} is an array of ${n.length} element(s), but the model has ${r} outputs. Make sure a set of weights is provided for each model output.`);return n}else if(typeof n=="object"&&Object.keys(n).length>0&&typeof n[Object.keys(n)[0]]=="object"){const i=[];return e.forEach(s=>{s in n?i.push(n[s]):i.push(null)}),i}else throw new Error(`The model has multiple (${r}) outputs, so ${t} must be either an array with ${r} elements or an object with ${e} keys. Provided ${t} not understood: ${JSON.stringify(n)}`)}function UT(n,e){return AW(n,e,"classWeight")}async function BT(n,e,t,r){if(e!=null||r!=null)throw new Error("Support sampleWeight is not implemented yet");if(t!=null){const i=te(()=>{if(n.shape.length===1)return bo(n);if(n.shape.length===2){if(n.shape[1]>1)return Su(n,1);if(n.shape[1]===1)return j(n,[n.shape[0]]);throw new Error(`Encountered unexpected last-dimension size (${n.shape[1]}) during handling of class weights. The size is expected to be >= 1.`)}else throw new Error(`Unexpected rank of target (y) tensor (${n.rank}) during handling of class weights. The rank is expected to be 1 or 2.`)}),s=Array.from(await i.data());He(i);const a=[];return s.forEach(o=>{if(t[o]==null)throw new Error(`classWeight must contain all classes in the training data. The class ${o} exists in the data but not in classWeight`);a.push(t[o])}),Vr(a,"float32")}else return null}function CW(n,e){return W(n,e)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const IW=32;function VT(n,e){let t,r;const i=e;t=i.xs,r=i.ys,R(t!=null&&r!=null,()=>`A Dataset iterator for fitDataset() is expected to generate objects of the form \`{xs: xVal, ys: yVal}\`, where the two values may be \`tf.Tensor\`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates ${e}`);const s=j2("input",n.inputNames,t),a=j2("output",n.outputNames,r),o=s[0].shape[0];R(s.length===n.inputs.length,()=>`LayersModel has ${n.inputs.length} inputs, but the dataset provides ${s.length} inputs.  (Expected input keys: ${JSON.stringify(n.inputNames)})`),R(a.length===n.outputs.length,()=>`LayersModel has ${n.outputs.length} outputs, but the dataset provides ${a.length} outputs.  (Expected output keys: ${JSON.stringify(n.outputNames)})`);for(let c=0;c<s.length;c++)R(s[c].shape[0]===o,()=>`Batch size mismatch: input ${n.inputNames[c]} has ${s[c].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);for(let c=0;c<a.length;c++)R(a[c].shape[0]===o,()=>`Batch size mismatch: output ${n.outputNames[c]} has ${a[c].shape[0]}; expected  ${o} based on input ${n.inputNames[0]}.`);return{xs:s,ys:a}}function j2(n,e,t){if(t instanceof Nn)return[t];if(Array.isArray(t))return R(t.length===e.length,()=>`Received an array of ${t.length} Tensors, but expected ${e.length} to match the ${n} keys ${e}.`),t;{const r=[];for(const i of e){if(t[i]==null)throw new G(`The feature data generated by the dataset lacks the required ${n} key '${i}'.`);r.push(t[i])}return r}}function MW(n){if(n.length===3)throw new vt("Validation with sample weights is not implemented yet.");return{xs:n[0],ys:n[1]}}async function RW(n,e,t){const r=t.batchesPerEpoch!=null;if(R(n.optimizer!=null,()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig)."),R(t!=null,()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call."),R(t.epochs!=null&&t.epochs>0&&Number.isInteger(t.epochs),()=>`For fitDataset(), config.epochs is expected to be a positive integer, but got ${t.epochs}`),R(!r||t.batchesPerEpoch>0&&Number.isInteger(t.batchesPerEpoch),()=>`For fitDataset(), config.batchesPerEpoch is expected to be a positive integer if specified, but got ${t.batchesPerEpoch}`),R(t.validationSplit==null,()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead."),n.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");n.isTraining=!0;try{const i=t.validationData!=null;let s,a;if(i)if(Y2(t.validationData))R(t.validationBatches==null||t.validationBatches>0&&Number.isInteger(t.validationBatches),()=>`For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, but got ${t.validationBatches}`);else{const m=MW(t.validationData);s=m.xs,a=m.ys}const o=n.makeTrainFunction(),c=n.getDedupedMetricsNames();let l;i?l=c.slice().concat(c.map(m=>"val_"+m)):l=c.slice();const u=NT(t.callbacks,t.yieldEvery),f=t.verbose==null?1:t.verbose,{callbackList:d,history:h}=kT(u,f,t.epochs,null,null,NW(e,t),null,i,l);d.setModel(n),n.history=h,await d.onTrainBegin(),n.stopTraining_=!1;let p=t.initialEpoch==null?0:t.initialEpoch,g=await e.iterator();for(;p<t.epochs;){const m={};await d.onEpochBegin(p);let v=0,x=0;for(r||(g=await e.iterator());!r||v<t.batchesPerEpoch;){const b=await g.next();if(r&&b.done){console.warn(`You provided \`batchesPerEpoch\` as ${t.batchesPerEpoch}, but your dataset iterator ran out of data after ${v} batches; interrupting training. Make sure that your dataset can generate at least \`batchesPerEpoch * epochs\` batches (in this case, ${t.batchesPerEpoch*t.epochs} batches). You may need to use the repeat() function when building your dataset.`);break}if(b.value!=null){const{xs:_,ys:w}=VT(n,b.value),E={};E.batch=x,E.size=_[0].shape[0],await d.onBatchBegin(x,E);const S=[];if(t.classWeight!=null){const y=UT(t.classWeight,n.outputNames);for(let A=0;A<y.length;++A)S.push(await BT(w[A],null,y[A]))}const T=_.concat(w).concat(S),C=o(T);He(T);for(let y=0;y<c.length;++y){const A=c[y],k=C[y];E[A]=k,fs(k)}await d.onBatchEnd(x,E),RT(E),x++,v++}if(r?v>=t.batchesPerEpoch:b.done){if(i){let _;Y2(t.validationData)?_=Ht(await n.evaluateDataset(t.validationData,{batches:t.validationBatches})):_=Ht(n.evaluate(s,a,{batchSize:t.validationBatchSize==null?IW:t.validationBatchSize,verbose:0}));for(let w=0;w<n.metricsNames.length;++w)m[`val_${n.metricsNames[w]}`]=_[w]}break}if(n.stopTraining_)break}if(await d.onEpochEnd(p,m),p++,n.stopTraining_)break}return await d.onTrainEnd(),await n.history.syncData(),n.history}finally{n.isTraining=!1}}function NW(n,e){let t=null;return e.batchesPerEpoch!=null?t=e.batchesPerEpoch:Number.isFinite(n.size)&&(t=n.size),t}function Y2(n){return typeof n.iterator=="function"}function kW(n){return typeof n.next=="function"}async function DW(n,e,t){t=t||{};const r=t.batches!=null,i=n.testFunction;let s=[];if(t.verbose>0)throw new vt("Verbose mode is not implemented yet.");R(!r||t.batches>0&&Number.isInteger(t.batches),()=>`Test loop expects \`batches\` to be a positive integer, but received ${JSON.stringify(t.batches)}`);const a=kW(e)?e:await e.iterator();let o=0,c=0;for(;!r||c<t.batches;){const l=await a.next();if(s=te(()=>{if(l.value){const{xs:u,ys:f}=VT(n,l.value),d=u.concat(f),h=te(()=>i(d));if(He(d),c===0)for(let g=0;g<h.length;++g)s.push(zt(0));const p=d[0].shape[0];for(let g=0;g<h.length;++g){const m=h[g],v=s[g];s[g]=te(()=>ye(s[g],W(p,m))),c>0&&He(v)}He(h),o+=p,++c}return s}),l.done){r&&console.warn(`Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least \`batches\` batches (in this case, ${t.batches} batches). You may need to use the repeat() function when building your dataset.`);break}}for(let l=0;l<s.length;++l){const u=s[l];s[l]=nt(s[l],o),He(u)}return Tr(s)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function qv(n){R(n>0&&Number.isInteger(n),()=>`batchSize is required to be a positive integer, but got ${n}`)}function iu(n,e,t){return n==null?[null]:Array.isArray(n)?n.map(r=>yo(r,e,t-e)):yo(n,e,t-e)}function Mx(n,e){return te(()=>n==null?null:Array.isArray(n)?n.map(t=>Mx(t,e)):vT(n,e.dtype==="int32"?e:Ie(e,"int32")))}function Xv(n,e){const t=[];let r=0,i=null;for(;r<n;)i=r+e,i>=n&&(i=n),t.push([r,i]),r=i;return t}function GT(n){const e=[];n instanceof Nn&&(n=[n]);for(let t=0;t<n.length;++t){const r=n[t];if(r.rank===1)e.push(Qf(r,1));else{if(r.rank===0)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");e.push(r)}}return e}function Oi(n,e){if(n==null)return;const t=[];if(e instanceof Nn)t.push(e.id);else if(Array.isArray(e))e.forEach(i=>t.push(i.id));else if(e!=null)for(const i in e){const s=e[i];t.push(s.id)}const r=[];if(n instanceof Nn)t.indexOf(n.id)===-1&&r.push(n);else if(Array.isArray(n))n.forEach(i=>{t.indexOf(i.id)===-1&&r.push(i)});else if(n!=null)for(const i in n){const s=n[i];t.indexOf(s.id)===-1&&r.push(s)}r.forEach(i=>{i.isDisposed||i.dispose()})}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function LW(n){return n instanceof Nn}function Rx(n){return Array.isArray(n)}function Z2(n){return!LW(n)&&!Rx(n)}function Q2(n,e,t,r=!0,i=""){if(e==null||e.length===0){if(n!=null){let a=!1;if(Rx(n)&&n.length>0)a=!0;else if(Z2(n)){for(const o in n)if(n.hasOwnProperty(o)){a=!0;break}}else a=!0;if(a)throw new G(`Error when checking model ${i} expected no data, but got ${n}`)}return[]}if(n==null)return e.map(a=>null);let s;if(Z2(n)){n=n,s=[];for(const a of e){if(n[a]==null)throw new G(`No data provided for "${a}". Need data for each key in: ${e}`);s.push(n[a])}}else if(Rx(n)){if(n=n,n.length!==e.length)throw new G(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the model expected. Expected to see ${e.length} Tensor(s), but instead got the following list of Tensor(s): ${n}`);s=n}else{if(n=n,e.length>1)throw new G(`The model ${i} expects ${e.length} Tensor(s), but only received one Tensor. Found: Tensor with shape ${n.shape}`);s=[n]}if(s=GT(s),t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=s[a];if(o.shape.length!==t[a].length)throw new G(`Error when checking ${i}: expected ${e[a]} to have ${t[a].length} dimension(s). but got array with shape ${o.shape}`);for(let c=0;c<t[a].length;++c){if(c===0&&!r)continue;const l=o.shape[c],u=t[a][c];if(u!=null&&u>=0&&l!==u)throw new G(`${i} expected a batch of elements where each example has shape [${t[a].slice(1,t[a].length)}] (i.e.,tensor shape [*,${t[a].slice(1,t[a].length)}]) but the ${i} received an input with ${o.shape[0]} examples, each with shape [${o.shape.slice(1,o.shape.length)}] (tensor shape [${o.shape}])`)}}return s}function OW(n,e,t){const r=Ia(n.map(s=>s.shape[0]));r.sort();const i=Ia(e.map(s=>s.shape[0]));if(i.sort(),r.length>1)throw new G(`All input Tensors (x) should have the same number of samples. Got array shapes: ${JSON.stringify(n.map(s=>s.shape))}`);if(i.length>1)throw new G(`All target Tensors (y) should have the same number of samples. Got array shapes: ${JSON.stringify(e.map(s=>s.shape))}`);if(r.length>0&&i.length>0&&!Pt(r,i))throw new G(`Input Tensors should have the same number of samples as target Tensors. Found ${r[0]} input sample(s) and ${i[0]} target sample(s).`)}function zW(n,e,t){const r=[km,Dm,Ru];for(let i=0;i<n.length;++i){const s=n[i],a=e[i],o=t[i];if(a!=null){if(a===Ru&&s.shape[s.shape.length-1]===1)throw new G(`You are passing a target array of shape ${s.shape} while using a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].`);if(r.indexOf(a)!==-1){const c=s.shape.slice(1),l=o.slice(1);for(let u=0;u<c.length;++u){const f=c[u],d=l[u];if(d!=null&&f!==d)throw new G(`A target Tensor with shape ${s.shape} was passed for an output of shape ${o}, while using a loss function that expects targets to have the same shape as the output.`)}}}}}function J2(n,e,t,r=!0,i=""){let s;if(Array.isArray(n)){if(n.length!==e.length)throw new G(`Error when checking model ${i}: the Array of Tensors that you are passing to your model is not the size the the model expected. Expected to see ${e.length} Tensor(s), but instead got ${n.length} Tensors(s).`);s=n}else{if(e.length>1)throw new G(`The model expects ${e.length} ${i} Tensors, but only received one Tensor. Found: array with shape ${JSON.stringify(n.shape)}.`);s=[n]}if(t!=null)for(let a=0;a<e.length;++a){if(t[a]==null)continue;const o=s[a];if(o.shape.length!==t[a].length)throw new G(`Error when checking ${i}: expected ${e[a]} to have ${t[a].length} dimension(s), but got array with shape ${JSON.stringify(o.shape)}`);for(let c=0;c<t[a].length;++c){if(c===0&&!r)continue;const l=o.shape[c],u=t[a][c];if(u!=null&&u!==l)throw new G(`Error when checking ${i}: expected ${e[a]} to have shape ${JSON.stringify(t[a])} but got array with shape ${JSON.stringify(o.shape)}.`)}}}function PW(n,e){if(n==null||Array.isArray(n)&&n.length===0)return e.map(r=>[]);let t;if(typeof n=="string"||typeof n=="function")t=[n];else if(Array.isArray(n)||typeof n=="object")t=n;else throw new TypeError(`Type of metrics argument not understood. Expected an string,function, Array, or Object, found: ${n}`);if(Array.isArray(t))return e.map(r=>t);{const r=[];for(const i of e){let s=t.hasOwnProperty(i)?t[i]:[];Array.isArray(s)||(s=[s]),r.push(s)}return r}}const FW="layers-model";class Uc extends zi{constructor(e){super(e),this.isTraining=!1}summary(e,t,r=console.log){if(!this.built)throw new G("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");_W(this,e,t,r)}compile(e){if(e.loss==null&&(e.loss=[]),this.loss=e.loss,typeof e.optimizer=="string")this.optimizer_=bW(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Wa))throw new G("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(!Array.isArray(e.loss)&&typeof e.loss!="string"&&typeof e.loss!="function"){e.loss=e.loss;for(const a in e.loss)if(this.outputNames.indexOf(a)===-1)throw new G(`Unknown entry in loss dictionary: "${a}". Only expected the following keys: ${this.outputNames}`);for(const a of this.outputNames)e.loss[a]==null&&console.warn(`Output "${a}" is missing from loss dictionary. We assume this was done on purpose, and we will not be expecting data to be passed to ${a} during training`),t.push(Wv(e.loss[a]))}else if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new G(`When passing an Array as loss, it should have one entry per model output. The model has ${this.outputs.length} output(s), but you passed loss=${e.loss}.`);t=e.loss.map(o=>Wv(o))}else{const a=Wv(e.loss);this.outputs.forEach(o=>{t.push(a)})}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let a=0;a<this.outputs.length;++a){const o=this.internalOutputShapes[a],c=this.outputNames[a];this.feedOutputNames.push(c),this.feedOutputShapes.push(o),this.feedLossFns.push(this.lossFunctions[a])}const r=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],_o("loss",()=>{for(let a=0;a<this.outputs.length;++a){if(r.indexOf(a)!==-1)continue;const o=this.lossFunctions[a];this.outputs.length>1&&(this.metricsTensors.push([o,a]),this.metricsNames.push(this.outputNames[a]+"_loss"))}});const i=PW(e.metrics,this.outputNames),s=(a,o,c)=>{this.outputNames.length>1&&(o=this.outputNames[a]+"_"+o),this.metricsNames.push(o),this.metricsTensors.push([c,a])};_o("metric",()=>{for(let a=0;a<this.outputs.length;++a){if(r.indexOf(a)!==-1)continue;const o=i[a];(l=>{const u="";let f,d,h;for(const p of l){if(typeof p=="string"&&["accuracy","acc","crossentropy","ce"].indexOf(p)!==-1){const m=this.internalOutputShapes[a];m[m.length-1]===1||this.lossFunctions[a]===Dm?["accuracy","acc"].indexOf(p)!==-1?d=LT:["crossentropy","ce"].indexOf(p)!==-1&&(d=lW):this.lossFunctions[a]===qh?["accuracy","acc"].indexOf(p)!==-1?d=uW:["crossentropy","ce"].indexOf(p)!==-1&&(d=PT):["accuracy","acc"].indexOf(p)!==-1?d=OT:["crossentropy","ce"].indexOf(p)!==-1&&(d=zT);let v;["accuracy","acc"].indexOf(p)!==-1?v="acc":["crossentropy","ce"].indexOf(p)!==-1&&(v="ce"),h=d,f=u+v}else h=xW(p),f=u+eh(p);let g;_o(f,()=>{g=h}),s(a,f,g)}})(o)}}),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){this.collectedTrainableWeights!=null&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t,r={}){const i=r.batchSize==null?32:r.batchSize;qv(i);const s=!0,a=this.standardizeUserDataXY(e,t,s,i);try{const o=a[0].concat(a[1]);this.makeTestFunction();const c=this.testFunction,l=this.testLoop(c,o,i,r.verbose,r.steps);return Tr(l)}finally{Oi(a[0],e),Oi(a[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),DW(this,e,t)}checkNumSamples(e,t,r,i="steps"){let s;if(r!=null){if(s=null,t!=null)throw new G(`If ${i} is set, batchSize must be null or undefined.Got batchSize = ${t}`)}else if(e!=null)Array.isArray(e)?s=e[0].shape[0]:s=e.shape[0];else throw new G(`Either the input data should have a defined shape, or ${i} shoud be specified.`);return s}execute(e,t){if(Array.isArray(t)&&t.length===0)throw new G("`outputs` is an empty Array, which is not allowed.");const r=Array.isArray(t),i=r?t:[t],s=this.retrieveSymbolicTensors(i),a=new ya;if(e instanceof Nn&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new G(`The number of inputs provided (${e.length}) does not match the number of inputs of this model (${this.inputs.length}).`);for(let c=0;c<this.inputs.length;++c)a.add(this.inputs[c],e[c])}else for(const c of this.inputs){const l=e[c.name];if(l==null)throw new G(`No value is provided for the model's input ${c.name}`);a.add(c,l)}const o=fu(s,a);return r?o:o[0]}retrieveSymbolicTensors(e){const t=Oo(null,e.length);let r=e.length;for(const i of this.layers){const s=Array.isArray(i.output)?i.output:[i.output],a=s.map(o=>o.name);for(let o=0;o<e.length;++o){const c=a.indexOf(e[o]);if(c!==-1&&(t[o]=s[c],r--),r===0)break}if(r===0)break}if(r>0){const i=[];throw t.forEach((s,a)=>{s==null&&i.push(e[a])}),new G(`Cannot find SymbolicTensors for output name(s): ${JSON.stringify(i)}`)}return t}predictLoop(e,t=32,r=!1){return te(()=>{const i=this.checkNumSamples(e);if(r)throw new vt("Verbose predictLoop() is not implemented yet.");const s=Xv(i,t),a=this.outputs.map(o=>[]);for(let o=0;o<s.length;++o)te(()=>{const l=s[o][0],u=s[o][1],f=iu(e,l,u),d=[];if(Array.isArray(f))for(let p=0;p<f.length;++p)d.push({key:this.inputs[p],value:f[p]});else d.push({key:this.inputs[0],value:f});const h=new ya(d);return fu(this.outputs,h)}).forEach((l,u)=>a[u].push(l));return Tr(a.map(o=>nr(o,0)))})}predict(e,t={}){const r=GT(e);J2(r,this.inputNames,this.feedInputShapes,!1);try{const i=t.batchSize==null?32:t.batchSize;return qv(i),this.predictLoop(r,i)}finally{Oi(r,e)}}predictOnBatch(e){J2(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t,r=!0,i){if(this.optimizer_==null)throw new xi("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const s=[];for(let a=0;a<this.feedOutputShapes.length;++a){const o=this.feedOutputShapes[a];this.feedLossFns[a]===qh?s.push(o.slice(0,o.length-1).concat([1])):s.push(o)}if(e=Q2(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=Q2(t,this.feedOutputNames,s,!1,"target"),OW(e,t),zW(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&i!=null&&i>0&&e[0].shape[0]%i!==0)throw new G(`In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size ${i}. Found: ${e[0].shape[0]} sample(s).`);return[e,t]}async standardizeUserData(e,t,r,i,s=!0,a){const[o,c]=this.standardizeUserDataXY(e,t,s,a);if(r!=null)throw new Error("sample weight is not supported yet.");let l=null;if(i!=null){const u=UT(i,this.outputNames);l=[];for(let f=0;f<u.length;++f)l.push(await BT(c[f],null,u[f]))}return[o,c,l]}testLoop(e,t,r,i=0,s){return te(()=>{const a=this.checkNumSamples(t,r,s,"steps"),o=[];if(i>0)throw new vt("Verbose mode is not implemented yet.");if(s!=null)throw new vt("steps mode in testLoop() is not implemented yet");{const c=Xv(a,r),l=Vr(ji(0,a));for(let u=0;u<c.length;++u){const f=c[u][0],d=c[u][1],h=yo(l,f,d-f),p=Mx(t,h),g=e(p);if(u===0)for(let m=0;m<g.length;++m)o.push(zt(0));for(let m=0;m<g.length;++m){const v=g[m];o[m]=ye(o[m],W(d-f,v))}}for(let u=0;u<o.length;++u)o[u]=nt(o[u],a)}return o})}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let r=0;r<e.length;++r){const i=e[r];let s=i;if(P2(e,i)>1){const a=P2(e.slice(0,r),i);s+=`_${a}`}t.push(s)}return t}makeTrainFunction(){return e=>{const t=[],r=e.slice(0,this.inputs.length),i=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+this.outputs.length*2),a=[],o=()=>{const f=[];for(let g=0;g<this.inputs.length;++g)f.push({key:this.inputs[g],value:r[g]});const d=new ya(f),h=fu(this.outputs,d,{training:!0});let p;for(let g=0;g<this.lossFunctions.length;++g){const m=this.lossFunctions[g];let v=m(i[g],h[g]);s[g]!=null&&(v=CW(v,s[g]));const x=An(v);t.push(x),g===0?p=v:p=ye(p,v)}for(let g=0;g<this.metricsTensors.length;++g){let m;if(this.outputs.length>1&&g<this.outputs.length)m=t[g];else{const v=this.metricsTensors[g][0],x=this.metricsTensors[g][1];m=An(v(i[x],h[x]))}fs(m),a.push(m)}return p=An(p),this.calculateLosses().forEach(g=>{p=ye(p,g)}),p},c=this.collectedTrainableWeights.map(f=>f.read()),l=!0;return[this.optimizer_.minimize(o,l,c)].concat(a)}}makeTestFunction(){this.testFunction=e=>te(()=>{const t=[];let r;const i=e.slice(0,this.inputs.length),s=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),a=[];for(let l=0;l<this.inputs.length;++l)a.push({key:this.inputs[l],value:i[l]});const o=new ya(a),c=fu(this.outputs,o);for(let l=0;l<this.lossFunctions.length;++l){const u=this.lossFunctions[l],f=An(u(s[l],c[l]));l===0?r=f:r=ye(r,f),t.push(r)}for(let l=0;l<this.metricsTensors.length;++l){const u=this.metricsTensors[l][0],f=this.metricsTensors[l][1],d=An(u(s[f],c[f]));t.push(d)}return t})}async fit(e,t,r={}){if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;let i,s,a,o,c,l,u,f,d;try{const h=r.batchSize==null?32:r.batchSize;qv(h);const p=!1,g=await this.standardizeUserData(e,t,r.sampleWeight,r.classWeight,p,h);i=g[0],s=g[1],d=g[2];let m=!1,v;if(r.validationData!=null&&r.validationData.length>0){if(m=!0,r.validationData.length===2)c=r.validationData[0],l=r.validationData[1];else throw r.validationData.length===3?new vt("validationData including sample weights is not supported yet."):new G(`When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; ${r.validationData} is invalid.`);const C=!0,y=await this.standardizeUserData(c,l,null,null,C,h);u=y[0],f=y[1],v=u.concat(f)}else if(r.validationSplit!=null&&r.validationSplit>0&&r.validationSplit<1){m=!0;const C=Math.floor(i[0].shape[0]*(1-r.validationSplit)),y=i[0].shape[0];u=iu(i,C,y),a=i,i=iu(i,0,C),f=iu(s,C,y),o=s,s=iu(s,0,C),v=u.concat(f)}else r.validationSteps!=null&&(m=!0);const x=i.concat(s).concat(d);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),_=this.getDedupedMetricsNames();let w,E;m?(this.makeTestFunction(),w=this.testFunction,E=_.slice().concat(_.map(C=>"val_"+C))):(w=null,v=[],E=_.slice());const S=NT(r.callbacks,r.yieldEvery);return await this.fitLoop(b,x,_,h,r.epochs,r.verbose,S,w,v,r.shuffle,E,r.initialEpoch,null,null)}finally{this.isTraining=!1,Oi(i,e),Oi(s,t),Oi(a,e),Oi(o,t),Oi(u,c),Oi(f,l),d!=null&&He(d)}}async fitLoop(e,t,r,i,s,a,o,c,l,u,f,d,h,p){i==null&&(i=32),s==null&&(s=1),u==null&&(u=!0),d==null&&(d=0);let g=!1;if(c!=null&&l!=null&&(g=!0),p!=null&&(g=!0,h==null))throw new G("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,i,h,"steps_per_epoch");let v;m!=null&&(v=ji(0,m)),a==null&&(a=1);const{callbackList:x,history:b}=kT(o,a,s,d,m,h,i,g,f);x.setModel(this),this.history=b,await x.onTrainBegin(),this.stopTraining_=!1;for(let _=d;_<s;++_){await x.onEpochBegin(_);const w={};if(h!=null)throw new vt("stepsPerEpoch mode is not implemented yet.");{if(u==="batch")throw new vt("batch shuffling is not implemneted yet");u&&EP(v);const E=Vr(v),S=Xv(m,i);for(let T=0;T<S.length;++T){const C={};if(await x.onBatchBegin(T,C),te(()=>{const y=S[T][0],A=S[T][1],k=yo(E,y,A-y);C.batch=T,C.size=A-y;const M=Mx(t,k),L=e(M);for(let z=0;z<r.length;++z){const D=r[z],F=L[z];C[D]=F,fs(F)}if(T===S.length-1&&g){const z=this.testLoop(c,l,i);for(let D=0;D<r.length;++D){const F=r[D],O=z[D];fs(O),w["val_"+F]=O}}}),await x.onBatchEnd(T,C),RT(C),this.stopTraining_)break}E.dispose()}if(await x.onEpochEnd(_,w),this.stopTraining_)break}return await x.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return RW(this,e,t)}async trainOnBatch(e,t){const r=await this.standardizeUserData(e,t),i=r[0],s=r[1],o=this.makeTrainFunction()(i.concat(s)),c=[];for(const l of o){const u=await l.data();c.push(u[0])}return He(o),Oi(r[0],e),Oi(r[1],t),Tr(c)}getNamedWeights(e){const t=[],r=e!=null&&e.trainableOnly,i=r?this.trainableWeights:this.weights,s=this.getWeights(r);for(let a=0;a<i.length;++a)r&&!i[a].trainable||t.push({name:i[a].originalName,tensor:s[a]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(e.refCountAfterDispose===0&&this.optimizer!=null&&this.isOptimizerOwned){const t=fx().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-fx().numTensors}return e}getLossIdentifiers(){let e;if(typeof this.loss=="string")e=Os(this.loss);else if(Array.isArray(this.loss)){for(const t of this.loss)if(typeof t!="string")throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map(t=>Os(t))}else{const t=Object.keys(this.loss);e={};const r=this.loss;for(const i of t)if(typeof r[i]=="string")e[i]=Os(r[i]);else throw new Error("Serialization of non-string loss is not supported.")}return e}getMetricIdentifiers(){if(typeof this.metrics=="string"||typeof this.metrics=="function")return[Os(eh(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map(e=>Os(eh(e)));{const e={};for(const t in this.metrics)e[t]=Os(eh(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(e.weighted_metrics!=null)throw new Error("Loading weight_metrics is not supported yet.");if(e.loss_weights!=null)throw new Error("Loading loss_weights is not supported yet.");if(e.sample_weight_mode!=null)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Cx(e.optimizer_config),r=Hs(t);let i;if(typeof e.loss=="string")i=fo(e.loss);else if(Array.isArray(e.loss))i=e.loss.map(a=>fo(a));else if(e.loss!=null){i={};for(const a in e.loss)i[a]=fo(e.loss[a])}let s;if(Array.isArray(e.metrics))s=e.metrics.map(a=>fo(a));else if(e.metrics!=null){s={};for(const a in e.metrics)s[a]=fo(e.metrics[a])}this.compile({loss:i,metrics:s,optimizer:r})}async save(e,t){if(typeof e=="string"){const l=_F(e);if(l.length===0)throw new G(`Cannot find any save handlers for URL '${e}'`);if(l.length>1)throw new G(`Found more than one (${l.length}) save handlers for URL '${e}'`);e=l[0]}if(e.save==null)throw new G("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const r=await y2(this.getNamedWeights(t)),i=!1,s=null,o={modelTopology:this.toJSON(s,i),format:FW,generatedBy:`TensorFlow.js tfjs-layers v${$T}`,convertedBy:null};if((t==null?!1:t.includeOptimizer)&&this.optimizer!=null){o.trainingConfig=this.getTrainingConfig();const l="optimizer",{data:u,specs:f}=await y2(await this.optimizer.getWeights(),l);r.specs.push(...f),r.data=bF([r.data,u])}return this.userDefinedMetadata!=null&&(K2(this.userDefinedMetadata,this.name,!0),o.userDefinedMetadata=this.userDefinedMetadata),o.weightData=r.data,o.weightSpecs=r.specs,e.save(o)}setUserDefinedMetadata(e){K2(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Uc.className="Model";ge(Uc);class HT extends Uc{}HT.className="Functional";ge(HT);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class Nu extends Uc{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=e.name!=null?e.name:Mm("sequential_"),e.layers!=null)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some(r=>r<0))throw new G(`Negative dimension size caused by adding layer ${e.name} with input shape [${e.inboundNodes[0].inputTensors[0].shape}]`)}add(e){const t=e instanceof Nu||e instanceof Uc;let r;if(t){if(r=e,r.outputs.length!==1)throw new G("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(r.inputs.length!==1)throw new G("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(this.outputs.length===0){if(e.inboundNodes.length===0){if(e.batchInputShape==null)throw new G("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const i=UH({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(i)}if(t)this.outputs=r.outputs,this.inputs=r.inputs;else{if(e.inboundNodes.length!==1)throw new G(`A layer added to a Sequential model must not already be connected somewhere else. LayersModel received layer ${e.name} which has ${e.inboundNodes.length} pre-existing inbound connections.`);if(e.inboundNodes[0].outputTensors.length!==1)throw new G("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=TT(this.outputs[0])}this.inboundNodes=[],new Nm({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Oo(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map(i=>i.shape),outputShapes:this.outputs[0].shape})}else{const i=e.apply(this.outputs[0]);if(Array.isArray(i))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[i],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(this.layers.length===0)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),this.layers.length===0)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return this.model==null&&this.build(),this.model.call(e,t)}build(e){if(kt(e),this.inputs.length===0||this.outputs.length===0)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Uc({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t,r=console.log){this.built||this.build(),super.summary(e,t,r)}setWeights(e){this.model==null&&this.build(),this.model.setWeights(e)}evaluate(e,t,r={}){if(!this.built)throw new xi("The model needs to be compiled before being used.");return this.model.evaluate(e,t,r)}async evaluateDataset(e,t){if(!this.built)throw new xi("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e,t={}){return this.model==null&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return this.model==null&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return this.model==null?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t,r={}){if(!this.built)throw new xi("The model needs to be compiled before being used.");return this.model.fit(e,t,r)}async fitDataset(e,t){if(!this.built)throw new xi("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t,r={},i=!1){let s,a={};if(t instanceof Array){if(t[0].className==null||t[0].className==="Merge")throw new G("Legacy serialization format not supported yet.");s=t}else R(t.layers!=null,()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field."),s=t.layers,delete t.layers,a=t;const o=new e(a);if(!(o instanceof Nu))throw new vt(`Sequential.fromConfig called on non-Sequential input: ${o}`);for(const c of s){const u=Hs(c,void 0,i);i&&u.setFastWeightInitDuringBuild(!0),o.add(u)}return o}set stopTraining(e){if(this.model==null)throw new G("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(this.model==null)throw new G("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const r={};r.className=t.getClassName(),r.config=t.getConfig(),e.push(r)}return{name:this.name,layers:e}}}Nu.className="Sequential";ge(Nu);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */let cr=class extends Il{getConfig(){return{}}};class WT extends cr{apply(e,t=1){return SH(e,t)}}WT.className="elu";ge(WT);class qT extends cr{apply(e){return lS(e)}}qT.className="selu";ge(qT);class XT extends cr{apply(e){return qo(e)}}XT.className="relu";ge(XT);class KT extends cr{apply(e){return te(()=>Cu(6,qo(e)))}}KT.className="relu6";ge(KT);class jT extends cr{apply(e){return e}}jT.className="linear";ge(jT);class YT extends cr{apply(e){return Tl(e)}}YT.className="sigmoid";ge(YT);class ZT extends cr{apply(e){return AH(e)}}ZT.className="hardSigmoid";ge(ZT);class QT extends cr{apply(e){return Hf(e)}}QT.className="softplus";ge(QT);class JT extends cr{apply(e){return TH(e)}}JT.className="softsign";ge(JT);class eA extends cr{apply(e){return bm(e)}}eA.className="tanh";ge(eA);let G_=class extends cr{apply(e,t=-1){return qb(e,t)}};G_.className="softmax";ge(G_);class tA extends cr{apply(e,t=-1){return eS(e,t)}}tA.className="logSoftmax";ge(tA);class nA extends cr{apply(e){return te(()=>te(()=>{const t=Math.sqrt(2),r=W(.5,ye(1,j3(nt(e,t))));return W(e,r)}))}}nA.className="gelu";ge(nA);class rA extends cr{apply(e){return te(()=>W(.5,W(e,ye(1,bm(W(ar(nt(2,Math.PI)),ye(e,W(.044715,ko(e,3)))))))))}}rA.className="gelu_new";ge(rA);class iA extends cr{apply(e){return te(()=>W(e,bm(Hf(e))))}}iA.className="mish";ge(iA);class sA extends cr{apply(e,t=1){return te(()=>W(Tl(W(e,t)),e))}}sA.className="swish";ge(sA);function Da(n){return n.getClassName()}function Kv(n,e={}){return Zf(n,hi.getMap().classNameMap,e,"activation")}function La(n){if(n==null){const e={};return e.className="linear",e.config={},Kv(e)}if(typeof n=="string"){const e={};return e.className=n,e.config={},Kv(e)}else return n instanceof cr?n:Kv(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function $W(n){if(n!=null&&typeof n!="object")throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an object, but received: ${n}`)}class aA extends Il{}class oA extends aA{constructor(e){super(),$W(e),this.l1=e==null||e.l1==null?.01:e.l1,this.l2=e==null||e.l2==null?.01:e.l2,this.hasL1=this.l1!==0,this.hasL2=this.l2!==0}apply(e){return te(()=>{let t=Un([1]);return this.hasL1&&(t=ye(t,et(W(this.l1,pr(e))))),this.hasL2&&(t=ye(t,et(W(this.l2,Jf(e))))),j(t,[])})}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}oA.className="L1L2";ge(oA);const ew={l1l2:"L1L2"};function Zt(n){return M_(n)}function tw(n,e={}){return Zf(n,hi.getMap().classNameMap,e,"regularizer")}function fn(n){if(n==null)return null;if(typeof n=="string"){const t={className:n in ew?ew[n]:n,config:{}};return tw(t)}else return n instanceof aA?n:tw(n)}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class cA extends Tt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null&&(this.maxValue=e.maxValue)}call(e,t){e=ot(e);let r=qo(e);return this.maxValue!=null&&(r=ni(r,0,this.maxValue)),r}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}cA.className="ReLU";ge(cA);class lA extends Tt{constructor(e){super(e??{}),this.DEFAULT_ALPHA=.3,e==null&&(e={}),this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=ot(e);return Mb(r,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}lA.className="LeakyReLU";ge(lA);class uA extends Tt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA_INITIALIZER="zeros",e==null&&(e={}),this.supportsMasking=!0,this.alphaInitializer=un(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=fn(e.alphaRegularizer),this.alphaConstraint=On(e.alphaConstraint),e.sharedAxes==null)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else if(typeof e.sharedAxes=="number")this.sharedAxes=[e.sharedAxes];else throw new G(`Expected sharedAxes to be a number or an array of numbers, but got ${e.sharedAxes}`)}build(e){e=kt(e);const t=e.slice(1);if(this.sharedAxes!=null)for(const i of this.sharedAxes)t[i-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const r={};if(this.sharedAxes!=null)for(let i=1;i<e.length;++i)r[i]=e[i];this.inputSpec=[new Dn({ndim:e.length,axes:r})],this.built=!0}call(e,t){return e=ot(e),zb(e,this.alpha.read())}getConfig(){const e={alphaInitializer:hn(this.alphaInitializer),alphaRegularizer:Zt(this.alphaRegularizer),alphaConstraint:Ln(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}uA.className="PReLU";ge(uA);let fA=class extends Tt{constructor(e){if(super(e??{}),this.DEFAULT_ALPHA=1,e==null&&(e={}),e.alpha!=null&&e.alpha!==this.DEFAULT_ALPHA)throw new vt(`Non-default alpha value (${e.alpha}) is not supported by the ELU layer yet.`);this.alpha=e.alpha==null?this.DEFAULT_ALPHA:e.alpha}call(e,t){const r=ot(e);return wm(r)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}};fA.className="ELU";ge(fA);class dA extends Tt{constructor(e){super(e??{}),this.DEFAULT_THETA=1,e==null&&(e={}),this.theta=e.theta==null?this.DEFAULT_THETA:e.theta}call(e,t){const r=ot(e);return W(r,Ie(ri(r,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}dA.className="ThresholdedReLU";ge(dA);class hA extends Tt{constructor(e){super(e??{}),this.DEFAULT_AXIS=1,e==null&&(e={}),this.softmax=new G_().apply,this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis}call(e,t){return te(()=>{let r=ot(e);const i=t.mask;if(i!=null){const s=W(st(Ha(r.shape),Ie(i,r.dtype)),zt(-1e9));r=ye(r,s)}return this.axis instanceof Array?this.axis.length>1?gs(st(r,tS(r,this.axis,!0))):this.softmax(r,this.axis[0]):this.softmax(r,this.axis)})}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}hA.className="Softmax";ge(hA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Bc(n,e,t){if(typeof n=="number")return Oo(n,e);if(n.length!==e)throw new G(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${n.length} elements.`);for(let r=0;r<e;++r){const i=n[r];if(!_H(i))throw new G(`The ${t} argument must be an integer or tuple of ${e} integers. Received: ${JSON.stringify(n)} including a non-integer number ${i}`)}return n}function qi(n,e,t,r,i=1){if(n==null)return n;const s=e+(e-1)*(i-1);let a;return t==="same"?a=n:a=n-s+1,Math.floor((a+r-1)/r)}function as(n,e,t,r){if(n==null)return null;if(r==="valid")n=n*e+ka([t-e,0]);else if(r==="same")n=n*e;else throw new G(`Unsupport padding mode: ${r}.`);return n}/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function H_(n,e){return te(()=>(wn(e),e==="channelsFirst"?Mt(n,[0,2,3,1]):n))}function pA(n,e){return te(()=>(wn(e),e==="channelsFirst"?Mt(n,[0,2,3,4,1]):n))}function UW(n,e,t,r=1,i="valid",s,a=1){return te(()=>{if(s==null&&(s=Yi()),wn(s),n.shape.length!==3)throw new G(`The input of a conv1dWithBias operation should be 3, but is ${n.shape.length} instead.`);if(e.shape.length!==3)throw new G(`The kernel for a conv1dWithBias operation should be 3, but is ${e.shape.length} instead`);if(t!=null&&t.shape.length!==1)throw new G(`The bias for a conv1dWithBias operation should be 1, but is ${t.shape.length} instead`);if(s==="channelsFirst"&&(n=Mt(n,[0,2,1])),i==="causal")throw new vt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let o=G3(n,e,r,i==="same"?"same":"valid","NWC",a);return t!=null&&(o=Ji(o,t)),o})}function nw(n,e,t,r=[1,1],i="valid",s,a,o=null){return te(()=>{if(s==null&&(s=Yi()),wn(s),n.rank!==3&&n.rank!==4)throw new G(`conv2dWithBiasActivation expects input to be of rank 3 or 4, but received ${n.rank}.`);if(e.rank!==3&&e.rank!==4)throw new G(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, but received ${n.rank}.`);let c=H_(n,s);if(i==="causal")throw new vt("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=jB({x:c,filter:e,strides:r,pad:i==="same"?"same":"valid",dilations:a,dataFormat:"NHWC",bias:t,activation:o}),s==="channelsFirst"&&(c=Mt(c,[0,3,1,2])),c})}function BW(n,e,t,r=[1,1,1],i="valid",s,a){return te(()=>{if(s==null&&(s=Yi()),wn(s),n.rank!==4&&n.rank!==5)throw new G(`conv3dWithBias expects input to be of rank 4 or 5, but received ${n.rank}.`);if(e.rank!==4&&e.rank!==5)throw new G(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ${n.rank}.`);let o=pA(n,s);if(i==="causal")throw new vt("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return o=W3(o,e,r,i==="same"?"same":"valid","NDHWC",a),t!=null&&(o=Ji(o,t)),s==="channelsFirst"&&(o=Mt(o,[0,4,1,2,3])),o})}class Lm extends Tt{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Lm.verifyArgs(t),this.rank=e,Bn(this.rank,"rank"),this.rank!==1&&this.rank!==2&&this.rank!==3)throw new vt(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is not implemented yet.`);if(this.kernelSize=Bc(t.kernelSize,e,"kernelSize"),this.strides=Bc(t.strides==null?1:t.strides,e,"strides"),this.padding=t.padding==null?"valid":t.padding,ii(this.padding),this.dataFormat=t.dataFormat==null?"channelsLast":t.dataFormat,wn(this.dataFormat),this.activation=La(t.activation),this.useBias=t.useBias==null?!0:t.useBias,this.biasInitializer=un(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=On(t.biasConstraint),this.biasRegularizer=fn(t.biasRegularizer),this.activityRegularizer=fn(t.activityRegularizer),this.dilationRate=Bc(t.dilationRate==null?1:t.dilationRate,e,"dilationRate"),this.rank===1&&Array.isArray(this.dilationRate)&&this.dilationRate.length!==1)throw new G(`dilationRate must be a number or an array of a single number for 1D convolution, but received ${JSON.stringify(this.dilationRate)}`);if(this.rank===2){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==2)throw new G(`dilationRate must be a number or array of two numbers for 2D convolution, but received ${JSON.stringify(this.dilationRate)}`)}else if(this.rank===3){if(typeof this.dilationRate=="number")this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(this.dilationRate.length!==3)throw new G(`dilationRate must be a number or array of three numbers for 3D convolution, but received ${JSON.stringify(this.dilationRate)}`)}}static verifyArgs(e){if(ss("kernelSize"in e,"required key 'kernelSize' not in config"),typeof e.kernelSize!="number"&&!R_(e.kernelSize,"number",1,3))throw new G(`BaseConv expects config.kernelSize to be number or number[] with length 1, 2, or 3, but received ${JSON.stringify(e.kernelSize)}.`)}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:Da(this.activation),useBias:this.useBias,biasInitializer:hn(this.biasInitializer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),biasConstraint:Ln(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Ml extends Lm{constructor(e,t){super(e,t),this.kernel=null,Ml.verifyArgs(t),this.filters=t.filters,Bn(this.filters,"filters"),this.kernelInitializer=un(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=On(t.kernelConstraint),this.kernelRegularizer=fn(t.kernelRegularizer)}build(e){e=kt(e);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new G(`The channel dimension of the input should be defined. Found ${e[t]}`);const r=e[t],i=this.kernelSize.concat([r,this.filters]);this.kernel=this.addWeight("kernel",i,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:r}}],this.built=!0}call(e,t){return te(()=>{e=ot(e);let r;const i=this.bias==null?null:this.bias.read(),s=uT(this.activation.getClassName());if(s!=null&&this.rank===2)r=nw(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate,s);else{if(this.rank===1)r=UW(e,this.kernel.read(),i,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(this.rank===2)r=nw(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else if(this.rank===3)r=BW(e,this.kernel.read(),i,this.strides,this.padding,this.dataFormat,this.dilationRate);else throw new vt("convolutions greater than 3D are not implemented yet.");this.activation!=null&&(r=this.activation.apply(r))}return r})}computeOutputShape(e){e=kt(e);const t=[],r=this.dataFormat==="channelsLast"?e.slice(1,e.length-1):e.slice(2);for(let s=0;s<r.length;++s){const a=qi(r[s],this.kernelSize[s],this.padding,this.strides[s],typeof this.dilationRate=="number"?this.dilationRate:this.dilationRate[s]);t.push(a)}let i=[e[0]];return this.dataFormat==="channelsLast"?(i=i.concat(t),i.push(this.filters)):(i.push(this.filters),i=i.concat(t)),i}getConfig(){const e={filters:this.filters,kernelInitializer:hn(this.kernelInitializer),kernelRegularizer:Zt(this.kernelRegularizer),kernelConstraint:Ln(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||typeof e.filters!="number"||e.filters<1)throw new G(`Convolution layer expected config.filters to be a 'number' > 0 but got ${JSON.stringify(e.filters)}`)}}class rd extends Ml{constructor(e){super(2,e),rd.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!R_(e.kernelSize,"number",1,2))throw new G(`Conv2D expects config.kernelSize to be number or number[] with length 1 or 2, but received ${JSON.stringify(e.kernelSize)}.`)}}rd.className="Conv2D";ge(rd);class id extends Ml{constructor(e){super(3,e),id.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!(Array.isArray(e.kernelSize)&&(e.kernelSize.length===1||e.kernelSize.length===3)))throw new G(`Conv3D expects config.kernelSize to be number or [number, number, number], but received ${JSON.stringify(e.kernelSize)}.`)}}id.className="Conv3D";ge(id);class mA extends rd{constructor(e){if(super(e),this.inputSpec=[new Dn({ndim:4})],this.padding!=="same"&&this.padding!=="valid")throw new G(`Conv2DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=kt(e),e.length!==4)throw new G("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new G("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Dn({ndim:4,axes:{[t]:r}})],this.built=!0}call(e,t){return te(()=>{let r=ot(e);if(r.shape.length!==4)throw new G(`Conv2DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const i=r.shape,s=i[0];let a,o;this.dataFormat==="channelsFirst"?(a=2,o=3):(a=1,o=2);const c=i[a],l=i[o],u=this.kernelSize[0],f=this.kernelSize[1],d=this.strides[0],h=this.strides[1],p=as(c,d,u,this.padding),g=as(l,h,f,this.padding),m=[s,p,g,this.filters];this.dataFormat!=="channelsLast"&&(r=Mt(r,[0,2,3,1]));let v=H3(r,this.kernel.read(),m,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(v=Mt(v,[0,3,1,2])),this.bias!=null&&(v=Ji(v,this.bias.read(),this.dataFormat)),this.activation!=null&&(v=this.activation.apply(v)),v})}computeOutputShape(e){e=kt(e);const t=e.slice();let r,i,s;this.dataFormat==="channelsFirst"?(r=1,i=2,s=3):(r=3,i=1,s=2);const a=this.kernelSize[0],o=this.kernelSize[1],c=this.strides[0],l=this.strides[1];return t[r]=this.filters,t[i]=as(t[i],c,a,this.padding),t[s]=as(t[s],l,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}mA.className="Conv2DTranspose";ge(mA);class vA extends id{constructor(e){if(super(e),this.inputSpec=[new Dn({ndim:5})],this.padding!=="same"&&this.padding!=="valid")throw new G(`Conv3DTranspose currently supports only padding modes 'same' and 'valid', but received padding mode ${this.padding}`)}build(e){if(e=kt(e),e.length!==5)throw new G("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null)throw new G("The channel dimension of the inputs should be defined. Found `None`.");const r=e[t],i=this.kernelSize.concat([this.filters,r]);this.kernel=this.addWeight("kernel",i,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new Dn({ndim:5,axes:{[t]:r}})],this.built=!0}call(e,t){return te(()=>{let r=ot(e);if(r.shape.length!==5)throw new G(`Conv3DTranspose.call() expects input tensor to be rank-4, but received a tensor of rank-${r.shape.length}`);const i=r.shape,s=i[0];let a,o,c;this.dataFormat==="channelsFirst"?(c=2,a=3,o=4):(c=1,a=2,o=3);const l=i[c],u=i[a],f=i[o],d=this.kernelSize[0],h=this.kernelSize[1],p=this.kernelSize[2],g=this.strides[0],m=this.strides[1],v=this.strides[2],x=as(l,g,d,this.padding),b=as(u,m,h,this.padding),_=as(f,v,p,this.padding),w=[s,x,b,_,this.filters];this.dataFormat!=="channelsLast"&&(r=Mt(r,[0,2,3,4,1]));let E=Q$(r,this.kernel.read(),w,this.strides,this.padding);return this.dataFormat!=="channelsLast"&&(E=Mt(E,[0,4,1,2,3])),this.bias!==null&&(E=Ji(E,this.bias.read(),this.dataFormat)),this.activation!==null&&(E=this.activation.apply(E)),E})}computeOutputShape(e){e=kt(e);const t=e.slice();let r,i,s,a;this.dataFormat==="channelsFirst"?(r=1,i=2,s=3,a=4):(r=4,i=1,s=2,a=3);const o=this.kernelSize[0],c=this.kernelSize[1],l=this.kernelSize[2],u=this.strides[0],f=this.strides[1],d=this.strides[2];return t[r]=this.filters,t[i]=as(t[i],u,o,this.padding),t[s]=as(t[s],f,c,this.padding),t[a]=as(t[a],d,l,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}vA.className="Conv3DTranspose";ge(vA);class gA extends Ml{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,t.filters==null)throw new G("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(t.kernelInitializer!=null||t.kernelRegularizer!=null||t.kernelConstraint!=null)throw new G("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(t.padding!=null&&t.padding!=="same"&&t.padding!=="valid")throw new G(`SeparableConv${this.rank}D supports only padding modes: 'same' and 'valid', but received ${JSON.stringify(t.padding)}`);this.depthMultiplier=t.depthMultiplier==null?1:t.depthMultiplier,this.depthwiseInitializer=un(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=fn(t.depthwiseRegularizer),this.depthwiseConstraint=On(t.depthwiseConstraint),this.pointwiseInitializer=un(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=fn(t.pointwiseRegularizer),this.pointwiseConstraint=On(t.pointwiseConstraint)}build(e){if(e=kt(e),e.length<this.rank+2)throw new G(`Inputs to SeparableConv${this.rank}D should have rank ${this.rank+2}, but received input shape: ${JSON.stringify(e)}`);const t=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[t]==null||e[t]<0)throw new G(`The channel dimension of the inputs should be defined, but found ${JSON.stringify(e[t])}`);const r=e[t],i=this.kernelSize.concat([r,this.depthMultiplier]),s=[];for(let o=0;o<this.rank;++o)s.push(1);s.push(r*this.depthMultiplier,this.filters);const a=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",i,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,a,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",s,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,a,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,a,this.biasConstraint):this.bias=null,this.inputSpec=[new Dn({ndim:this.rank+2,axes:{[t]:r}})],this.built=!0}call(e,t){return te(()=>{e=ot(e);let r;if(this.rank===1)throw new vt("1D separable convolution is not implemented yet.");return this.rank===2&&(this.dataFormat==="channelsFirst"&&(e=Mt(e,[0,2,3,1])),r=uS(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(r=Ji(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),this.dataFormat==="channelsFirst"&&(r=Mt(r,[0,3,1,2])),r})}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=hn(this.depthwiseInitializer),e.pointwiseInitializer=hn(this.pointwiseInitializer),e.depthwiseRegularizer=Zt(this.depthwiseRegularizer),e.pointwiseRegularizer=Zt(this.pointwiseRegularizer),e.depthwiseConstraint=Ln(this.depthwiseConstraint),e.pointwiseConstraint=Ln(this.pointwiseConstraint),e}}gA.className="SeparableConv";class xA extends gA{constructor(e){super(2,e)}}xA.className="SeparableConv2D";ge(xA);class Om extends Ml{constructor(e){super(1,e),Om.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if(typeof e.kernelSize!="number"&&!R_(e.kernelSize,"number",1,1))throw new G(`Conv1D expects config.kernelSize to be number or number[] with length 1, but received ${JSON.stringify(e.kernelSize)}.`)}}Om.className="Conv1D";ge(Om);class bA extends Tt{constructor(e){super(e),typeof e.cropping=="number"?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:typeof e.cropping[0]=="number"?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=e.dataFormat===void 0?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return this.dataFormat==="channelsFirst"?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return te(()=>{if(e=ot(e),this.dataFormat==="channelsLast"){const r=Jd(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Jd(r,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}else{const r=Jd(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Jd(r,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}})}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}bA.className="Cropping2D";ge(bA);class _A extends Tt{constructor(e){super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=e.size==null?this.DEFAULT_SIZE:e.size,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,wn(this.dataFormat),this.interpolation=e.interpolation==null?"nearest":e.interpolation,gH(this.interpolation)}computeOutputShape(e){if(this.dataFormat==="channelsFirst"){const t=e[2]==null?null:this.size[0]*e[2],r=e[3]==null?null:this.size[1]*e[3];return[e[0],e[1],t,r]}else{const t=e[1]==null?null:this.size[0]*e[1],r=e[2]==null?null:this.size[1]*e[2];return[e[0],t,r,e[3]]}}call(e,t){return te(()=>{let r=ot(e);const i=r.shape;if(this.dataFormat==="channelsFirst"){r=Mt(r,[0,2,3,1]);const s=this.size[0]*i[2],a=this.size[1]*i[3],o=this.interpolation==="nearest"?Vs.resizeNearestNeighbor(r,[s,a]):Vs.resizeBilinear(r,[s,a]);return Mt(o,[0,3,1,2])}else{const s=this.size[0]*i[1],a=this.size[1]*i[2];return this.interpolation==="nearest"?Vs.resizeNearestNeighbor(r,[s,a]):Vs.resizeBilinear(r,[s,a])}})}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}_A.className="UpSampling2D";ge(_A);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function VW(n,e,t=[1,1],r="valid",i,s){return te(()=>{i==null&&(i=Yi()),wn(i);let a=H_(n,i);if(n.rank!==4)throw new G(`Input for depthwiseConv2d is required to be 4-D, but is instead ${n.rank}-D`);if(e.rank!==4)throw new G(`depthwiseKernel is required to be 4-D, but is instead ${e.rank}-D`);return a=Tb(a,e,t,r==="same"?"same":"valid","NHWC",s),i==="channelsFirst"&&(a=Mt(a,[0,3,1,2])),a})}class yA extends Lm{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=e.depthMultiplier==null?1:e.depthMultiplier,this.depthwiseInitializer=un(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=On(e.depthwiseConstraint),this.depthwiseRegularizer=fn(e.depthwiseRegularizer)}build(e){if(e=kt(e),e.length<4)throw new G(`Inputs to DepthwiseConv2D should have rank 4. Received input shape: ${JSON.stringify(e)}.`);const t=this.dataFormat==="channelsFirst"?1:3;if(e[t]==null||e[t]<0)throw new G(`The channel dimension of the inputs to DepthwiseConv2D should be defined, but is not (${e[t]}).`);const r=e[t],i=[this.kernelSize[0],this.kernelSize[1],r,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",i,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[r*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return te(()=>{e=ot(e);let r=VW(e,this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(r=Ji(r,this.bias.read(),this.dataFormat)),this.activation!=null&&(r=this.activation.apply(r)),r})}computeOutputShape(e){e=kt(e);const t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,s=qi(t,this.kernelSize[0],this.padding,this.strides[0]),a=qi(r,this.kernelSize[1],this.padding,this.strides[1]);return this.dataFormat==="channelsFirst"?[e[0],i,s,a]:[e[0],s,a,i]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=hn(this.depthwiseInitializer),e.depthwiseRegularizer=Zt(this.depthwiseRegularizer),e.depthwiseConstraint=Ln(this.depthwiseRegularizer),e}}yA.className="DepthwiseConv2D";ge(yA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function wA(n,e,t,r){if(Array.isArray(n)){if(e!=null||t!=null)throw new G("When inputs is an array, neither initialState or constants should be provided");r!=null&&(t=n.slice(n.length-r,n.length),n=n.slice(0,n.length-r)),n.length>1&&(e=n.slice(1,n.length)),n=n[0]}function i(s){return s==null||Array.isArray(s)?s:[s]}return e=i(e),t=i(t),{inputs:n,initialState:e,constants:t}}function EA(n,e,t,r=!1,i,s,a=!1,o=!1){return te(()=>{const c=e.shape.length;if(c<3)throw new G(`Input should be at least 3D, but is ${c}D.`);const l=[1,0].concat(ji(2,c));if(e=Mt(e,l),s!=null)throw new vt("The rnn() functoin of the deeplearn.js backend does not support constants yet.");a&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),i!=null&&(i=Ie(Ie(i,"bool"),"float32"),i.rank===c-1&&(i=Sr(i,-1)),i=Mt(i,l)),r&&(e=Ki(e,0),i!=null&&(i=Ki(i,0)));const u=[];let f,d=t;const h=e.shape[0],p=Lo(e);let g;i!=null&&(g=Lo(i));for(let v=0;v<h;++v){const x=p[v],b=te(()=>n(x,d));if(i==null)f=b[0],d=b[1];else{const _=te(()=>{const w=g[v],E=st(Ai(w),w),S=ye(W(b[0],w),W(d[0],E)),T=d.map((C,y)=>ye(W(b[1][y],w),W(C,E)));return{output:S,newStates:T}});f=_.output,d=_.newStates}o&&u.push(f)}let m;return o&&(m=Ks(u,1)),[f,m,d]})}class qa extends Tt{constructor(e){super(e);let t;if(e.cell==null)throw new G("cell property is missing for the constructor of RNN.");if(Array.isArray(e.cell)?t=new X_({cells:e.cell}):t=e.cell,t.stateSize==null)throw new G("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=e.returnSequences==null?!1:e.returnSequences,this.returnState=e.returnState==null?!1:e.returnState,this.goBackwards=e.goBackwards==null?!1:e.goBackwards,this._stateful=e.stateful==null?!1:e.stateful,this.unroll=e.unroll==null?!1:e.unroll,this.supportsMasking=!0,this.inputSpec=[new Dn({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;return ji(0,e).map(t=>null)}else return this.states_}setStates(e){this.states_=e}computeOutputShape(e){Sx(e)&&(e=e[0]),e=e;let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const r=t[0];let i;if(this.returnSequences?i=[e[0],e[1],r]:i=[e[0],r],this.returnState){const s=[];for(const a of t)s.push([e[0],a]);return[i].concat(s)}else return i}computeMask(e,t){return te(()=>{Array.isArray(t)&&(t=t[0]);const r=this.returnSequences?t:null;if(this.returnState){const i=this.states.map(s=>null);return[r].concat(i)}else return r})}get states(){if(this.states_==null){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let r=0;r<e;++r)t.push(null);return t}else return this.states_}set states(e){this.states_=e}build(e){if(this.numConstants!=null)throw new vt("Constants support is not implemented in RNN yet.");Sx(e)&&(e=e[0]),e=e;const t=this.stateful?e[0]:null,r=e.slice(2);this.inputSpec[0]=new Dn({shape:[t,null,...r]});const i=[e[0]].concat(e.slice(2));this.cell.build(i);let s;if(Array.isArray(this.cell.stateSize)?s=this.cell.stateSize:s=[this.cell.stateSize],this.stateSpec!=null){if(!Pt(this.stateSpec.map(a=>a.shape[a.shape.length-1]),s))throw new G(`An initialState was passed that is not compatible with cell.stateSize. Received stateSpec=${this.stateSpec}; However cell.stateSize is ${this.cell.stateSize}`)}else this.stateSpec=s.map(a=>new Dn({shape:[null,a]}));this.stateful&&this.resetStates()}resetStates(e,t=!1){te(()=>{if(!this.stateful)throw new is("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape[0];if(r==null)throw new G("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.states_==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Un([r,i])):this.states_=[Un([r,this.cell.stateSize])];else if(e==null)He(this.states_),this.keptStates!=null&&(He(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(i=>Un([r,i])):this.states_[0]=Un([r,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new G(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t===!0?this.keptStates.push(this.states_.slice()):He(this.states_);for(let i=0;i<this.states_.length;++i){const s=e[i],a=Array.isArray(this.cell.stateSize)?this.cell.stateSize[i]:this.cell.stateSize,o=[r,a];if(!Pt(s.shape,o))throw new G(`State ${i} is incompatible with layer ${this.name}: expected shape=${o}, received shape=${s.shape}`);this.states_[i]=s}}this.states_=this.states_.map(i=>fs(i.clone()))})}apply(e,t){let r=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const s=wA(e,r,i,this.numConstants);e=s.inputs,r=s.initialState,i=s.constants;let a=[],o=[];if(r!=null){t.initialState=r,a=a.concat(r),this.stateSpec=[];for(const l of r)this.stateSpec.push(new Dn({shape:l.shape}));o=o.concat(this.stateSpec)}if(i!=null&&(t.constants=i,a=a.concat(i),this.numConstants=i.length),a[0]instanceof bs){const l=[e].concat(a),u=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=u;const d=super.apply(l,t);return this.inputSpec=f,d}else return super.apply(e,t)}call(e,t){return te(()=>{const r=t==null?null:t.mask,i=t==null?null:t.training;let s=t==null?null:t.initialState;e=ot(e),s==null&&(this.stateful?s=this.states_:s=this.getInitialState(e));const a=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(s.length!==a)throw new G(`RNN Layer has ${a} state(s) but was passed ${s.length} initial state(s).`);this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:i},l=EA((p,g)=>{const m=this.cell.call([p].concat(g),o);return[m[0],m.slice(1)]},e,s,this.goBackwards,r,null,this.unroll,this.returnSequences),u=l[0],f=l[1],d=l[2];this.stateful&&this.resetStates(d,i);const h=this.returnSequences?f:u;return this.returnState?[h].concat(d):h})}getInitialState(e){return te(()=>{let t=Un(e.shape);return t=et(t,[1,2]),t=Qf(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map(r=>r>1?wx(t,[1,r]):t):this.cell.stateSize>1?[wx(t,[1,this.cell.stateSize])]:[t]})}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.cell!=null&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};this.numConstants!=null&&(t.numConstants=this.numConstants);const r=this.cell.getConfig();return this.getClassName()===qa.className&&(t.cell={className:this.cell.getClassName(),config:r}),Object.assign(Object.assign(Object.assign({},r),e),t)}static fromConfig(e,t,r={}){const i=t.cell,s=Hs(i,r);return new e(Object.assign(t,{cell:s}))}}qa.className="RNN";ge(qa);class zm extends Tt{}class W_ extends zm{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Bn(this.units,"units"),this.activation=La(e.activation==null?this.DEFAULT_ACTIVATION:e.activation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=un(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=un(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=un(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fn(e.kernelRegularizer),this.recurrentRegularizer=fn(e.recurrentRegularizer),this.biasRegularizer=fn(e.biasRegularizer),this.kernelConstraint=On(e.kernelConstraint),this.recurrentConstraint=On(e.recurrentConstraint),this.biasConstraint=On(e.biasConstraint),this.dropout=al([1,ka([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=al([1,ka([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=kt(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return te(()=>{if(e=e,e.length!==2)throw new G(`SimpleRNNCell expects 2 input Tensors, got ${e.length}.`);let r=e[1];e=e[0];const i=t.training==null?!1:t.training;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Oa({ones:()=>Ai(e),rate:this.dropout,training:i,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Oa({ones:()=>Ai(r),rate:this.recurrentDropout,training:i,dropoutFunc:this.dropoutFunc}));let s;const a=this.dropoutMask,o=this.recurrentDropoutMask;a!=null?s=ps(W(e,a),this.kernel.read()):s=ps(e,this.kernel.read()),this.bias!=null&&(s=Ji(s,this.bias.read())),o!=null&&(r=W(r,o));let c=ye(s,ps(r,this.recurrentKernel.read()));return this.activation!=null&&(c=this.activation.apply(c)),[c,c]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Da(this.activation),useBias:this.useBias,kernelInitializer:hn(this.kernelInitializer),recurrentInitializer:hn(this.recurrentInitializer),biasInitializer:hn(this.biasInitializer),kernelRegularizer:Zt(this.kernelRegularizer),recurrentRegularizer:Zt(this.recurrentRegularizer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),kernelConstraint:Ln(this.kernelConstraint),recurrentConstraint:Ln(this.recurrentConstraint),biasConstraint:Ln(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}W_.className="SimpleRNNCell";ge(W_);class SA extends qa{constructor(e){e.cell=new W_(e),super(e)}call(e,t){return te(()=>{this.cell.dropoutMask!=null&&(He(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(He(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,i=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:r,training:i,initialState:s})})}static fromConfig(e,t){return new e(t)}}SA.className="SimpleRNN";ge(SA);class q_ extends zm{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new G("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Bn(this.units,"units"),this.activation=La(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=La(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=un(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=un(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=un(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=fn(e.kernelRegularizer),this.recurrentRegularizer=fn(e.recurrentRegularizer),this.biasRegularizer=fn(e.biasRegularizer),this.kernelConstraint=On(e.kernelConstraint),this.recurrentConstraint=On(e.recurrentConstraint),this.biasConstraint=On(e.biasConstraint),this.dropout=al([1,ka([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=al([1,ka([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=kt(e);const t=e[e.length-1];this.kernel=this.addWeight("kernel",[t,this.units*3],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*3],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units*3],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return te(()=>{if(e=e,e.length!==2)throw new G(`GRUCell expects 2 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training==null?!1:t.training;let i=e[1];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Oa({ones:()=>Ai(e),rate:this.dropout,training:r,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Oa({ones:()=>Ai(i),rate:this.recurrentDropout,training:r,count:3,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,a=this.recurrentDropoutMask;let o,c,l;0<this.dropout&&this.dropout<1&&(e=W(e,s[0]));let u=ps(e,this.kernel.read());this.useBias&&(u=Ji(u,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(i=W(i,a[0]));const f=this.recurrentKernel.read(),[d,h]=ti(f,[2*this.units,this.units],f.rank-1),p=ps(i,d),[g,m,v]=ti(u,3,u.rank-1),[x,b]=ti(p,2,p.rank-1);o=this.recurrentActivation.apply(ye(g,x)),c=this.recurrentActivation.apply(ye(m,b));const _=ps(W(c,i),h);l=this.activation.apply(ye(v,_));const w=ye(W(o,i),W(ye(1,bn(o)),l));return[w,w]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Da(this.activation),recurrentActivation:Da(this.recurrentActivation),useBias:this.useBias,kernelInitializer:hn(this.kernelInitializer),recurrentInitializer:hn(this.recurrentInitializer),biasInitializer:hn(this.biasInitializer),kernelRegularizer:Zt(this.kernelRegularizer),recurrentRegularizer:Zt(this.recurrentRegularizer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),kernelConstraint:Ln(this.kernelConstraint),recurrentConstraint:Ln(this.recurrentConstraint),biasConstraint:Ln(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}q_.className="GRUCell";ge(q_);class TA extends qa{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new q_(e),super(e)}call(e,t){return te(()=>{this.cell.dropoutMask!=null&&(He(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(He(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,i=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:r,training:i,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}TA.className="GRU";ge(TA);class Pm extends zm{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Bn(this.units,"units"),this.activation=La(e.activation===void 0?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=La(e.recurrentActivation===void 0?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=e.useBias==null?!0:e.useBias,this.kernelInitializer=un(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=un(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=un(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=fn(e.kernelRegularizer),this.recurrentRegularizer=fn(e.recurrentRegularizer),this.biasRegularizer=fn(e.biasRegularizer),this.kernelConstraint=On(e.kernelConstraint),this.recurrentConstraint=On(e.recurrentConstraint),this.biasConstraint=On(e.biasConstraint),this.dropout=al([1,ka([0,e.dropout==null?0:e.dropout])]),this.recurrentDropout=al([1,ka([0,e.recurrentDropout==null?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;e=kt(e);const r=e[e.length-1];this.kernel=this.addWeight("kernel",[r,this.units*4],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units*4],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint);let i;if(this.useBias){if(this.unitForgetBias){const s=this.biasInitializer,a=this.units;i=new(t=class extends Mi{apply(c,l){const u=s.apply([a]),f=new k_().apply([a]),d=s.apply([a*2]);return $2($2(u,f),d)}},t.className="CustomInit",t)}else i=this.biasInitializer;this.bias=this.addWeight("bias",[this.units*4],null,i,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return te(()=>{const r=t.training==null?!1:t.training;if(e=e,e.length!==3)throw new G(`LSTMCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);let i=e[1];const s=e[2];e=e[0],0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Oa({ones:()=>Ai(e),rate:this.dropout,training:r,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Oa({ones:()=>Ai(i),rate:this.recurrentDropout,training:r,count:4,dropoutFunc:this.dropoutFunc}));const a=this.dropoutMask,o=this.recurrentDropoutMask;let c,l,u,f;0<this.dropout&&this.dropout<1&&(e=W(e,a[0]));let d=ps(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(i=W(i,o[0])),d=ye(d,ps(i,this.recurrentKernel.read())),this.useBias&&(d=Ji(d,this.bias.read()));const[h,p,g,m]=ti(d,4,d.rank-1);c=this.recurrentActivation.apply(h),l=this.recurrentActivation.apply(p),u=ye(W(l,s),W(c,this.activation.apply(g))),f=this.recurrentActivation.apply(m);const v=W(f,this.activation.apply(u));return[v,v,u]})}getConfig(){const e=super.getConfig(),t={units:this.units,activation:Da(this.activation),recurrentActivation:Da(this.recurrentActivation),useBias:this.useBias,kernelInitializer:hn(this.kernelInitializer),recurrentInitializer:hn(this.recurrentInitializer),biasInitializer:hn(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:Zt(this.kernelRegularizer),recurrentRegularizer:Zt(this.recurrentRegularizer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),kernelConstraint:Ln(this.kernelConstraint),recurrentConstraint:Ln(this.recurrentConstraint),biasConstraint:Ln(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}Pm.className="LSTMCell";ge(Pm);class AA extends qa{constructor(e){e.implementation===0&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new Pm(e),super(e)}call(e,t){return te(()=>{this.cell.dropoutMask!=null&&(He(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(He(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const r=t==null?null:t.mask,i=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:r,training:i,initialState:s})})}static fromConfig(e,t){return t.implmentation===0&&(t.implementation=1),new e(t)}}AA.className="LSTM";ge(AA);class X_ extends zm{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return te(()=>{e=e;let r=e.slice(1);const i=[];for(const o of this.cells.slice().reverse())Array.isArray(o.stateSize)?i.push(r.splice(0,o.stateSize.length)):i.push(r.splice(0,1));i.reverse();const s=[];let a;for(let o=0;o<this.cells.length;++o){const c=this.cells[o];r=i[o],o===0?a=[e[0]].concat(r):a=[a[0]].concat(r),a=c.call(a,t),s.push(a.slice(1))}r=[];for(const o of s.slice().reverse())r.push(...o);return[a[0]].concat(r)})}build(e){Sx(e)&&(e=e[0]),e=e;let t;this.cells.forEach((r,i)=>{_o(`RNNCell_${i}`,()=>{r.build(e),Array.isArray(r.stateSize)?t=r.stateSize[0]:t=r.stateSize,e=[e[0],t]})}),this.built=!0}getConfig(){const e=super.getConfig(),t=s=>({className:s.getClassName(),config:s.getConfig()}),i={cells:this.cells.map(t)};return Object.assign(Object.assign({},e),i)}static fromConfig(e,t,r={}){const i=[];for(const s of t.cells)i.push(Hs(s,r));return new e({cells:i})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const r of this.cells)t.push(...r.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return Tx(e)}setWeights(e){const t=[];for(const r of this.cells){const i=r.weights.length,s=e.splice(i);for(let a=0;a<r.weights.length;++a)t.push([r.weights[a],s[a]])}$_(t)}}X_.className="StackedRNNCells";ge(X_);function Oa(n){const{ones:e,rate:t,training:r=!1,count:i=1,dropoutFunc:s}=n,a=()=>s!=null?s(e(),t):gT(e(),t),o=()=>ed(a,e,r);return!i||i<=1?fs(o().clone()):Array(i).fill(void 0).map(o).map(l=>fs(l.clone()))}/**
 * @license
 * Copyright 2020 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */var GW=globalThis&&globalThis.__rest||function(n,e){var t={};for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&e.indexOf(r)<0&&(t[r]=n[r]);if(n!=null&&typeof Object.getOwnPropertySymbols=="function")for(var i=0,r=Object.getOwnPropertySymbols(n);i<r.length;i++)e.indexOf(r[i])<0&&Object.prototype.propertyIsEnumerable.call(n,r[i])&&(t[r[i]]=n[r[i]]);return t};class CA extends qa{constructor(e){if(e.unroll)throw new vt("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new vt("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new Dn({ndim:5})]}call(e,t){return te(()=>{if(this.cell.dropoutMask!=null&&(He(this.cell.dropoutMask),this.cell.dropoutMask=null),this.cell.recurrentDropoutMask!=null&&(He(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new G("ConvRNN2D cell does not support constants");const r=t==null?null:t.mask,i=t==null?null:t.training,s=t==null?null:t.initialState;return super.call(e,{mask:r,training:i,initialState:s})})}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return te(()=>{const{stateSize:t}=this.cell,r=e.shape,i=this.computeSingleOutputShape(r),s=[i[0],...i.slice(2)],a=Un(s);return Array.isArray(t)?Array(t.length).fill(a):[a]})}resetStates(e,t=!1){te(()=>{if(!this.stateful)throw new is("Cannot call resetStates() on an RNN Layer that is not stateful.");const r=this.inputSpec[0].shape,i=this.computeSingleOutputShape(r),s=[i[0],...i.slice(2)];if(r[0]==null)throw new G("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(this.getStates()==null)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Un(s)):this.states_=[Un(s)];else if(e==null)He(this.states_),this.keptStates!=null&&(He(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map(()=>Un(s)):this.states_[0]=Un(s);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new G(`Layer ${this.name} expects ${this.states_.length} state(s), but it received ${e.length} state value(s). Input received: ${e}`);t?this.keptStates.push(this.states_.slice()):He(this.states_);for(let o=0;o<this.states_.length;++o){const c=e[o],l=s;if(!Pt(c.shape,l))throw new G(`State ${o} is incompatible with layer ${this.name}: expected shape=${l}, received shape=${c.shape}`);this.states_[o]=c}}this.states_=this.states_.map(o=>fs(o.clone()))})}computeSingleOutputShape(e){const{dataFormat:t,filters:r,kernelSize:i,padding:s,strides:a,dilationRate:o}=this.cell,c=t==="channelsFirst",l=e[c?3:2],u=e[c?4:3],f=qi(l,i[0],s,a[0],o[0]),d=qi(u,i[1],s,a[1],o[1]);return[...e.slice(0,2),...c?[r,f,d]:[f,d,r]]}}CA.className="ConvRNN2D";class K_ extends Pm{constructor(e){const{filters:t,kernelSize:r,strides:i,padding:s,dataFormat:a,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Bn(this.filters,"filters"),this.kernelSize=Bc(r,2,"kernelSize"),this.kernelSize.forEach(c=>Bn(c,"kernelSize")),this.strides=Bc(i||1,2,"strides"),this.strides.forEach(c=>Bn(c,"strides")),this.padding=s||"valid",ii(this.padding),this.dataFormat=a||"channelsLast",wn(this.dataFormat),this.dilationRate=Bc(o||1,2,"dilationRate"),this.dilationRate.forEach(c=>Bn(c,"dilationRate"))}build(e){var t;e=kt(e);const r=this.dataFormat==="channelsFirst"?1:e.length-1;if(e[r]==null)throw new G(`The channel dimension of the input should be defined. Found ${e[r]}`);const i=e[r],s=4,a=this.kernelSize.concat([i,this.filters*s]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const o=this.kernelSize.concat([this.filters,this.filters*s]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",o,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let c;if(this.unitForgetBias){const l=this.biasInitializer,u=this.filters;c=new(t=class extends Mi{apply(d,h){const p=l.apply([u]),g=Ha([u]),m=l.apply([u*2]);return N_([p,g,m])}},t.className="CustomInit",t)}else c=this.biasInitializer;this.bias=this.addWeight("bias",[this.filters*s],null,c,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return te(()=>{if(e.length!==3)throw new G(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ${e.length}.`);const r=t.training||!1,i=e[0],s=e[1],a=e[2],o=4;0<this.dropout&&this.dropout<1&&this.dropoutMask==null&&(this.dropoutMask=Oa({ones:()=>Ai(i),rate:this.dropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const c=this.dropoutMask,l=(J,Q,de)=>!Q||!Q[de]?J:W(Q[de],J);let u=l(i,c,0),f=l(i,c,1),d=l(i,c,2),h=l(i,c,3);0<this.recurrentDropout&&this.recurrentDropout<1&&this.recurrentDropoutMask==null&&(this.recurrentDropoutMask=Oa({ones:()=>Ai(s),rate:this.recurrentDropout,training:r,count:o,dropoutFunc:this.dropoutFunc}));const p=this.recurrentDropoutMask;let g=l(s,p,0),m=l(s,p,1),v=l(s,p,2),x=l(s,p,3);const b=3,[_,w,E,S]=ti(this.kernel.read(),o,b),[T,C,y,A]=this.useBias?ti(this.bias.read(),o):[null,null,null,null];u=this.inputConv(u,_,T,this.padding),f=this.inputConv(f,w,C,this.padding),d=this.inputConv(d,E,y,this.padding),h=this.inputConv(h,S,A,this.padding);const[k,M,L,z]=ti(this.recurrentKernel.read(),o,b);g=this.recurrentConv(g,k),m=this.recurrentConv(m,M),v=this.recurrentConv(v,L),x=this.recurrentConv(x,z);const D=this.recurrentActivation.apply(ye(u,g)),F=this.recurrentActivation.apply(ye(f,m)),O=ye(W(F,a),W(D,this.activation.apply(ye(d,v)))),V=W(this.recurrentActivation.apply(ye(h,x)),this.activation.apply(O));return[V,V,O]})}getConfig(){const e=super.getConfig(),t=GW(e,["units"]),r={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},t),r)}inputConv(e,t,r,i){const s=No(e,t,this.strides,i||"valid",this.dataFormat==="channelsFirst"?"NCHW":"NHWC",this.dilationRate);return r?Ji(s,r,this.dataFormat):s}recurrentConv(e,t){return No(e,t,1,"same",this.dataFormat==="channelsFirst"?"NCHW":"NHWC")}}K_.className="ConvLSTM2DCell";ge(K_);class IA extends CA{constructor(e){const t=new K_(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}IA.className="ConvLSTM2D";ge(IA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class j_ extends Tt{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(this.noiseShape==null)return this.noiseShape;const t=e.shape,r=[];for(let i=0;i<this.noiseShape.length;++i)r.push(this.noiseShape[i]==null?t[i]:this.noiseShape[i]);return r}call(e,t){return te(()=>{this.invokeCallHook(e,t);const r=ot(e);if(0<this.rate&&this.rate<1){const i=t.training==null?!1:t.training,s=this.getNoiseShape(r);return ed(()=>gT(r,this.rate,s,this.seed),()=>r,i)}return e})}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}j_.className="Dropout";ge(j_);class MA extends j_{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}MA.className="SpatialDropout1D";ge(MA);class RA extends Tt{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.batchInputShape==null&&e.inputShape==null&&e.inputDim!=null){let t=null;e.batchSize!=null&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Bn(this.units,"units"),this.activation=La(e.activation),e.useBias!=null&&(this.useBias=e.useBias),this.kernelInitializer=un(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=un(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=On(e.kernelConstraint),this.biasConstraint=On(e.biasConstraint),this.kernelRegularizer=fn(e.kernelRegularizer),this.biasRegularizer=fn(e.biasRegularizer),this.activityRegularizer=fn(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){e=kt(e);const t=e[e.length-1];this.kernel==null&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){e=kt(e);const t=e.slice();return t[t.length-1]=this.units,t}call(e,t){return te(()=>{this.invokeCallHook(e,t);const r=ot(e),i=uT(this.activation.getClassName());let s;return i!=null?s=ps(r,this.kernel.read(),i,this.bias?this.bias.read():null):(s=ps(r,this.kernel.read()),this.bias!=null&&(s=Ji(s,this.bias.read())),this.activation!=null&&(s=this.activation.apply(s))),s})}getConfig(){const e={units:this.units,activation:Da(this.activation),useBias:this.useBias,kernelInitializer:hn(this.kernelInitializer),biasInitializer:hn(this.biasInitializer),kernelRegularizer:Zt(this.kernelRegularizer),biasRegularizer:Zt(this.biasRegularizer),activityRegularizer:Zt(this.activityRegularizer),kernelConstraint:Ln(this.kernelConstraint),biasConstraint:Ln(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}RA.className="Dense";ge(RA);class NA extends Tt{constructor(e){e=e||{},super(e),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=kt(e);for(const t of e.slice(1))if(t==null)throw new G(`The shape of the input to "Flatten" is not fully defined (got ${e.slice(1)}). Make sure to pass a complete "input_shape" or "batch_input_shape" argument to the first layer in your model.`);return[e[0],Ma(e,1)]}call(e,t){return te(()=>{this.invokeCallHook(e,t);let r=ot(e);if(this.dataFormat==="channelsFirst"&&r.rank>1){const i=[0];for(let s=2;s<r.rank;++s)i.push(s);i.push(1),r=Mt(r,i)}return EH(r)})}getConfig(){const e={};this.dataFormat!=null&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}NA.className="Flatten";ge(NA);class kA extends Tt{constructor(e){super(e),this.supportsMasking=!0,this.activation=La(e.activation)}call(e,t){return te(()=>{this.invokeCallHook(e,t);const r=ot(e);return this.activation.apply(r)})}getConfig(){const e={activation:Da(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}kA.className="Activation";ge(kA);class DA extends Tt{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return te(()=>(e=ot(e),yH(e,this.n)))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}DA.className="RepeatVector";ge(DA);class LA extends Tt{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||e==null}fixUnknownDimension(e,t){const r="Total size of new array must be unchanged.",i=t.slice();let s=1,a=null;for(let c=0;c<i.length;++c){const l=i[c];if(this.isUnknown(l))if(a===null)a=c;else throw new G("Can only specifiy one unknown dimension.");else s*=l}const o=Ma(e);if(a!==null){if(s===0||o%s!==0)throw new G(r);i[a]=o/s}else if(o!==s)throw new G(r);return i}computeOutputShape(e){let t=!1;for(let r=0;r<e.length;++r)if(this.isUnknown(e[r])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return te(()=>{this.invokeCallHook(e,t);const r=ot(e),i=r.shape,s=i.slice(0,1).concat(this.fixUnknownDimension(i.slice(1),this.targetShape));return j(r,s)})}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}LA.className="Reshape";ge(LA);class OA extends Tt{constructor(e){if(super(e),e.dims==null)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error(`Permute constructor requires \`dims\` to be an Array, but received ${e.dims} instead.`);const t=ji(1,e.dims.length+1);if(!Pt(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new Dn({ndim:this.dims.length+1})]}computeOutputShape(e){e=kt(e);const t=e.slice();return this.dims.forEach((r,i)=>{t[i+1]=e[r]}),t}call(e,t){return Mt(ot(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}OA.className="Permute";ge(OA);class zA extends Tt{constructor(e){super(e??{}),this.supportsMasking=!0,e!=null?this.maskValue=e.maskValue==null?0:e.maskValue:this.maskValue=0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const r=ot(e),i=-1;return mx(Do(r,this.maskValue),i)}call(e,t){return te(()=>{this.invokeCallHook(e,t);const r=ot(e),i=-1,s=!0,a=mx(Do(r,this.maskValue),i,s);return W(r,Ie(a,r.dtype))})}}zA.className="Masking";ge(zA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class PA extends Tt{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",e.batchInputShape==null&&e.inputShape==null){let t=null;e.batchSize!=null&&(t=e.batchSize),e.inputLength==null?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Ht(e.inputLength))}this.inputDim=e.inputDim,Bn(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Bn(this.outputDim,"outputDim"),this.embeddingsInitializer=un(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=fn(e.embeddingsRegularizer),this.activityRegularizer=fn(e.activityRegularizer),this.embeddingsConstraint=On(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return te(()=>this.maskZero?(e=ot(e),Do(e,Rt(e))):null)}computeOutputShape(e){if(e=kt(e),this.inputLength==null)return[...e,this.outputDim];const t=Ht(this.inputLength);if(t.length!==e.length-1)throw new G(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);{let r=0;for(let i=0;i<t.length;++i){const s=t[i],a=e[i+1];if(s!=null&&a!=null&&s!==a)throw new G(`"inputLength" is ${this.inputLength}, but received input shape has shape ${e}`);s==null&&(t[r]=a),r++}}return[e[0],...t,this.outputDim]}call(e,t){return te(()=>{this.invokeCallHook(e,t);let r=ot(e);r.dtype!=="int32"&&(r=hs(r,"int32"));const i=vT(this.embeddings.read(),j(r,[r.size]));return j(i,kt(this.computeOutputShape(r.shape)))})}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:hn(this.embeddingsInitializer),embeddingsRegularizer:Zt(this.embeddingsRegularizer),activityRegularizer:Zt(this.activityRegularizer),embeddingsConstraint:Ln(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}PA.className="Embedding";ge(PA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class jo extends Tt{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new vt}computeElementwiseOpOutputShape(e,t){if(e==null||t==null)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(t.length===0)return e;const r=e.slice(0,e.length-t.length);for(let i=0;i<t.length;++i){const s=e[e.length-t.length+i],a=t[i];if(s==null||a==null||s<0||a<0)r.push(null);else if(s===1)r.push(a);else if(a===1)r.push(s);else{if(s!==a)throw new G("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));r.push(s)}}return r}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[kt(e)]),e=e,e.length<2)throw new G(`A merge layer should be called on an Array of at least 2 inputs. Got ${e.length} input(s).`);let t=[];for(const s of e)s!=null&&s[0]!==null&&t.push(s[0]);if(t=Ia(t),t.length>1)throw new G(`Can not merge tensors with different batch sizes. Got tensors with shapes: ${JSON.stringify(e)}.`);let r=e[0]==null?null:e[0].slice(1);for(let s=1;s<e.length;++s){const a=e[s]==null?null:e[s].slice(1);r=this.computeElementwiseOpOutputShape(r,a)}const i=e.map(s=>s.length);e.indexOf(null)===-1&&Ia(i).length===1?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return te(()=>{if(e=e,this.reshapeRequired){const r=[],i=e.map(s=>s.rank);if(i.indexOf(null)===-1){const s=ka(i);for(let a of e){const o=a.rank;for(let c=0;c<s-o;++c)a=Qf(a,1);r.push(a)}return this.mergeFunction(r)}else{let s=!1;for(const c of e){const l=c.rank;if(l==null){const u=c.shape,f=u[0],d=u.slice(1).concat([f]);let h=j(c,[f].concat(Ma(u.slice(1))));h=Mt(h,[1,0]),h=j(h,d),r.push(h),s=!0}else if(l>1){const u=ji(1,l).concat([0]);r.push(Mt(c,u)),s=!0}else r.push(c)}let a=this.mergeFunction(r);const o=a.rank;if(s){if(o==null){const c=a.shape,l=c.length,u=c[l-1],f=[u].concat(c.slice(0,c.length-1));a=j(Mt(j(a,[-1,u]),[1,0]),f)}else if(o>1){const c=[o-1].concat(ji(0,o-1));a=Mt(a,c)}}return a}}else return this.mergeFunction(e)})}computeOutputShape(e){e=e;let t;e[0]==null?t=null:t=e[0].slice(1);for(let i=1;i<e.length;++i){const s=e[i]==null?null:e[i].slice(1);t=this.computeElementwiseOpOutputShape(t,s)}let r=[];for(const i of e)i!=null&&i[0]!==null&&r.push(i[0]);return r=Ia(r),r.length===1?t=r.concat(t):t=[null].concat(t),t}computeMask(e,t){return te(()=>{if(t==null)return null;if(!Array.isArray(t))throw new G("`mask` should be an Array");if(!Array.isArray(e))throw new G("`inputs` should be an Array");if(t.length!==e.length)throw new G(`The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths (${e.length} vs ${t.length})`);if(t.every(i=>i==null))return null;t=t.map(i=>i==null?i:Sr(i,0));let r=t[0];for(let i=1;i<t.length-1;++i)r=Xs(r,t[i]);return r})}}class FA extends jo{constructor(e){super(e)}mergeFunction(e){return te(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=ye(t,e[r]);return t})}}FA.className="Add";ge(FA);class $A extends jo{constructor(e){super(e)}mergeFunction(e){return te(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=W(t,e[r]);return t})}}$A.className="Multiply";ge($A);class UA extends jo{constructor(e){super(e)}mergeFunction(e){return te(()=>{let t=e[0].clone();for(let r=1;r<e.length;++r)t=ye(t,e[r]);return W(1/e.length,t)})}}UA.className="Average";ge(UA);class BA extends jo{constructor(e){super(e)}mergeFunction(e){return te(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=Ga(t,e[r]);return t})}}BA.className="Maximum";ge(BA);class VA extends jo{constructor(e){super(e)}mergeFunction(e){return te(()=>{let t=e[0];for(let r=1;r<e.length;++r)t=Cu(t,e[r]);return t})}}VA.className="Minimum";ge(VA);class GA extends jo{constructor(e){super(e),this.DEFAULT_AXIS=-1,e==null&&(e={}),this.axis=e.axis==null?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!(Array.isArray(e)&&Array.isArray(e[0]))||e.length===1)throw new G("A `Concatenate` layer should be called on a list of at least 2 inputs");e=e;let t=!0;for(const i of e)if(i!=null){t=!1;break}if(t)return;const r=[];for(let i=0;i<e.length;++i){const s=e[i].slice();s.splice(this.axis,1);let a=!1;for(const o of r)if(Pt(o,s)){a=!0;break}a||r.push(s)}if(r.length>1)throw new G("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return te(()=>N_(e,this.axis))}computeOutputShape(e){if(!(Array.isArray(e)&&Array.isArray(e[0])))throw new G("A `Concatenate` layer should be called on a list of inputs.");const t=e,r=t[0].slice(),i=this.axis<0?r.length+this.axis:this.axis;for(const s of t.slice(1)){if(r[i]==null||s[i]==null){r[i]=null;break}r[i]+=s[i]}return r}computeMask(e,t){if(t==null)return null;if(!Array.isArray(t))throw new G("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new G("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new G(`Mismatch in the length of mask (${t.length}) and the legnth of inputs (${e.length})`);return te(()=>{let r=!0;if(t.forEach(a=>{if(a!=null){r=!1;return}}),r)return null;const i=[];for(let a=0;a<e.length;++a)t[a]==null?i.push(Ie(Ai(e[a]),"bool")):t[a].rank<e[a].rank?i.push(Sr(t[a],-1)):i.push(t[a]);const s=nr(i,this.axis);return V3(s,-1,!1)})}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}GA.className="Concatenate";ge(GA);function su(n,e){for(;n<0;)n+=e;return n}function HW(n,e,t){if(n.shape.length>3||e.shape.length>3)throw new vt("batchDot is not implemented for tensors of 4D or higher rank yet");if(R(n.shape.length>=2,()=>`batchDot requires the rank of x to be >= 2, but got ${n.shape.length}`),R(n.shape.length>=2,()=>`batchDot requires the rank of y to be >= 2, but got ${e.shape.length}`),typeof t=="number"&&(t=[t,t]),n.dtype==="complex64"||e.dtype==="complex64")throw new vt("batchDot is not implemented for complex64-type Tensors yet.");const r=n.shape.length,i=e.shape.length;t==null&&(t=[r-1,i-2]);const s=t;return te(()=>{let a;if(r>i){a=r-i;const c=[];for(let l=0;l<a;++l)c.push(1);e=j(e,e.shape.concat(c))}else if(i>r){a=i-r;const c=[];for(let l=0;l<a;++l)c.push(1);n=j(n,n.shape.concat(c))}else a=0;let o;if(n.shape.length===2&&e.shape.length===2)s[0]===s[1]?o=et(W(n,e),s[0]):o=et(W(Mt(n,[1,0]),e),s[1]);else{const c=s[0]!==n.shape.length-1,l=s[1]===e.shape.length-1;o=Ot(n,e,c,l)}if(a>0){let c;r>i?c=r+i-3:c=r-1;const l=[];for(let u=c;u<c+a;++u)l.push(u);o=qf(o,l)}return o.shape.length===1&&(o=Sr(o,1)),o})}class HA extends jo{constructor(e){super(e),this.axes=e.axes,this.normalize=e.normalize==null?!1:e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){R(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0],r=e[1];if(t.length>3||r.length>3)throw new vt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,r);if(t[i[0]]!==r[i[1]])throw new G(`Dimension incompatibility: ${t[i[0]]} !== ${r[i[1]]}`)}mergeFunction(e){if(e.length!==2)throw new G(`A \`Dot\` layer must be called on exactly 2 inputs, but received ${e.length} input(s).`);let t=e[0],r=e[1],i;return Array.isArray(this.axes)?i=this.axes.map((s,a)=>su(s,e[a].shape.length)):i=[su(this.axes,t.shape.length),su(this.axes,r.shape.length)],this.normalize&&(t=Wh(t,i[0]),r=Wh(r,i[1])),HW(t,r,i)}interpretAxes(e,t){let r;return Array.isArray(this.axes)?r=this.axes:r=[su(this.axes,e.length),su(this.axes,t.length)],r}computeOutputShape(e){R(Array.isArray(e)&&e.length===2&&Array.isArray(e[0])&&Array.isArray(e[1]),()=>"A `Dot` layer should be called on a list of exactly 2 inputs.");const t=e[0].slice(),r=e[1].slice();if(t.length>3||r.length>3)throw new vt("Dot layer does not support tensors of 4D or higher rank yet.");const i=this.interpretAxes(t,r);t.splice(i[0],1),r.splice(i[1],1),r.splice(0,1);const s=t.concat(r);return s.length===1&&s.push(1),s}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}HA.className="Dot";ge(HA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class WA extends Tt{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return te(()=>{this.invokeCallHook(e,t);const r=ot(e);return ed(()=>ye(Rm(r.shape,0,this.stddev),r),()=>r,t.training||!1)})}}WA.className="GaussianNoise";ge(WA);class qA extends Tt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return te(()=>{this.invokeCallHook(e,t);const r=ot(e);return this.rate>0&&this.rate<1?ed(()=>{const s=Math.sqrt(this.rate/(1-this.rate));return W(r,Rm(r.shape,1,s))},()=>r,t.training||!1):r})}}qA.className="GaussianDropout";ge(qA);class XA extends Tt{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ot(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return te(()=>{if(this.rate<1&&this.rate>0){const r=this._getNoiseShape(e);return ed(()=>{const s=ot(e),a=1.6732632423543772,o=1.0507009873554805,c=-a*o;let l=Ho(Wf(r),this.rate);l=hs(l,"float32");const u=((1-this.rate)*(1+this.rate*c**2))**-.5,f=-u*c*this.rate,d=ye(W(s,l),W(ye(l,-1),c));return ye(W(d,u),f)},()=>ot(e),t.training||!1)}return e})}}XA.className="AlphaDropout";ge(XA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function ku(n,e,t,r,i,s=.001){let a;if(n.rank===2)a=A$(n,e,t,r,i,s);else if(n.rank===3)a=I$(n,e,t,r,i,s);else if(n.rank===4)a=R$(n,e,t,r,i,s);else throw new vt(`batchNormalization is not implemented for array of rank ${n.rank} yet`);return a}function WW(n,e,t,r,i=.001){return te(()=>{const s=Db(n,r),a=s.mean,o=s.variance;return[ku(n,a,o,t,e,i),a,o]})}function qW(n,e,t,r,i=.001){return te(()=>{const s=Db(n,r),a=s.mean,o=s.variance,c=[];for(const p of ji(0,n.rank))r.indexOf(p)!==-1?c.push(1):c.push(n.shape[p]);const l=j(a,c),u=j(o,c),f=e==null?null:j(e,c),d=t==null?null:j(t,c);return[ku(n,l,u,d,f,i),a,o]})}function XW(n,e,t,r,i=.001){return Pt(r.slice().sort(),ji(0,n.rank-1))?WW(n,e,t,r,i):qW(n,e,t,r,i)}class KA extends Tt{constructor(e){e==null&&(e={}),super(e),this.supportsMasking=!0,this.axis=e.axis==null?-1:e.axis,this.momentum=e.momentum==null?.99:e.momentum,this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=un(e.betaInitializer||"zeros"),this.gammaInitializer=un(e.gammaInitializer||"ones"),this.movingMeanInitializer=un(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=un(e.movingVarianceInitializer||"ones"),this.betaConstraint=On(e.betaConstraint),this.gammaConstraint=On(e.gammaConstraint),this.betaRegularizer=fn(e.betaRegularizer),this.gammaRegularizer=fn(e.gammaRegularizer)}build(e){e=kt(e);const t=this.axis>=0?this.axis:this.axis+e.length,r=e[t];if(r==null)throw new G(`Axis ${t} of input tensor should have a defined dimension but the layer received an input with shape ${JSON.stringify(e)}.`);this.inputSpec=[new Dn({ndim:e.length,axes:{[t]:r}})];const i=[r];this.scale&&(this.gamma=this.addWeight("gamma",i,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",i,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",i,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",i,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return te(()=>{const r=t.training==null?!1:t.training,i=ot(e),s=i.shape,a=s.length,o=ji(0,a),c=this.axis>=0?this.axis:this.axis+a;o.splice(c,1);const l=Oo(1,a);l[c]=s[c];const u=o.slice();u.sort();const f=!Pt(u,ji(0,a).slice(0,a-1)),d=()=>{if(f){const x=j(this.movingMean.read(),l),b=j(this.movingVariance.read(),l),_=this.center?j(this.beta.read(),l):null,w=this.scale?j(this.gamma.read(),l):null;return ku(i,x,b,_,w,this.epsilon)}else return ku(i,this.movingMean.read(),this.movingVariance.read(),this.beta==null?null:this.beta.read(),this.gamma==null?null:this.gamma.read(),this.epsilon)};if(!r)return d();const[h,p,g]=XW(i,this.gamma.read(),this.beta.read(),o,this.epsilon),m=(x,b,_)=>{te(()=>{const w=1-_,E=x.read(),S=W(st(E,b),w);x.write(st(E,S))})};return(()=>{m(this.movingMean,p,this.momentum),m(this.movingVariance,g,this.momentum)})(),h})}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:hn(this.betaInitializer),gammaInitializer:hn(this.gammaInitializer),movingMeanInitializer:hn(this.movingMeanInitializer),movingVarianceInitializer:hn(this.movingVarianceInitializer),betaRegularizer:Zt(this.betaRegularizer),gammaRegularizer:Zt(this.gammaRegularizer),betaConstraint:Ln(this.betaConstraint),gammaConstraint:Ln(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}KA.className="BatchNormalization";ge(KA);class jA extends Tt{constructor(e){if(e==null&&(e={}),super(e),this.axis=e.axis==null?-1:e.axis,typeof this.axis=="number"){if(!Number.isInteger(this.axis))throw new Error(`Expected axis to be an integer, but received ${this.axis}`)}else if(Array.isArray(this.axis)){for(const t of this.axis)if(!Number.isInteger(t))throw new Error(`Expected axis to be an array of integers, but received ${JSON.stringify(this.axis)}`)}else throw new Error(`Expected axis to be an integer or an array of integers, but received ${JSON.stringify(this.axis)}`);this.epsilon=e.epsilon==null?.001:e.epsilon,this.center=e.center==null?!0:e.center,this.scale=e.scale==null?!0:e.scale,this.betaInitializer=un(e.betaInitializer||"zeros"),this.gammaInitializer=un(e.gammaInitializer||"ones"),this.betaRegularizer=fn(e.betaRegularizer),this.gammaRegularizer=fn(e.gammaRegularizer),this.supportsMasking=!0}build(e){e=kt(e);const t=e.length;typeof this.axis=="number"&&(this.axis=[this.axis]);for(let s=0;s<this.axis.length;++s)this.axis[s]<0&&(this.axis[s]+=t);for(const s of this.axis)if(s<0||s>=t)throw new Error(`Invalid axis: ${s}`);if(this.axis.length!==Ia(this.axis).length)throw new Error(`Found duplicate axes in: ${this.axis}`);const r=this.axis.map(s=>e[s]),i=!0;this.scale?this.gamma=this.addWeight("gamma",r,"float32",this.gammaInitializer,this.gammaRegularizer,i):this.gamma=null,this.center?this.beta=this.addWeight("beta",r,"float32",this.betaInitializer,this.betaRegularizer,i):this.beta=null,this.built=!0}call(e,t){const r=ot(e),i=r.shape,s=i.length;return te(()=>{let{mean:o,variance:c}=Db(r,this.axis,!0);const l=Oo(1,s);for(const g of this.axis)l[g]=i[g];const u=g=>g!=null&&g.shape.length!==s?j(g,l):g;let f=this.scale?u(this.gamma.read()):null,d=this.center?u(this.beta.read()):null;const h=[],p=[];for(let g=0;g<s;++g)this.axis.indexOf(g)!==-1?(h.push(i[g]),p.push(1)):(h.push(1),p.push(i[g]));return o=Vi(o,h),c=Vi(c,h),f!=null&&(f=Vi(f,p)),d!=null&&(d=Vi(d,p)),ku(r,o,c,d,f,this.epsilon)})}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:hn(this.betaInitializer),gammaInitializer:hn(this.gammaInitializer),betaRegularizer:Zt(this.betaRegularizer),gammaRegularizer:Zt(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}jA.className="LayerNormalization";ge(jA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function KW(n,e,t){return te(()=>{if(n.rank!==4)throw new G(`temporalPadding expects input tensor to be 4-D, but received a ${n.rank}-D tensor.`);if(e==null&&(e=[[1,1],[1,1]]),e.length!==2||e[0].length!==2||e[1].length!==2)throw new G("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(t==null&&(t=Yi()),t!=="channelsLast"&&t!=="channelsFirst")throw new G(`Unknown data format: ${t}. Supported data formats are 'channelsLast' and 'channelsFirst.`);let r;return t==="channelsFirst"?r=[[0,0],[0,0],e[0],e[1]]:r=[[0,0],e[0],e[1],[0,0]],Lb(n,r)})}class YA extends Tt{constructor(e){if(e==null&&(e={}),super(e),this.dataFormat=e.dataFormat==null?Yi():e.dataFormat,e.padding==null)this.padding=[[1,1],[1,1]];else if(typeof e.padding=="number")this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,e.padding.length!==2)throw new G(`ZeroPadding2D expects padding to be a length-2 array, but received a length-${e.padding.length} array.`);let t,r;if(typeof e.padding[0]=="number")t=[e.padding[0],e.padding[0]],r=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,e.padding[0].length!==2)throw new G(`ZeroPadding2D expects height padding to be a length-2 array, but received a length-${e.padding[0].length} array.`);if(t=e.padding[0],e.padding[1].length!==2)throw new G(`ZeroPadding2D expects width padding to be a length-2 array, but received a length-${e.padding[1].length} array.`);r=e.padding[1]}this.padding=[t,r]}this.inputSpec=[new Dn({ndim:4})]}computeOutputShape(e){e=kt(e);let t,r;return this.dataFormat==="channelsFirst"?(e[2]!=null&&e[2]>=0?t=e[2]+this.padding[0][0]+this.padding[0][1]:t=null,e[3]!=null&&e[3]>=0?r=e[3]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],e[1],t,r]):(e[1]!=null&&e[1]>=0?t=e[1]+this.padding[0][0]+this.padding[0][1]:t=null,e[2]!=null&&e[2]>=0?r=e[2]+this.padding[1][0]+this.padding[1][1]:r=null,[e[0],t,r,e[3]])}call(e,t){return te(()=>KW(ot(e),this.padding,this.dataFormat))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}YA.className="ZeroPadding2D";ge(YA);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function Fm(n,e,t,r,i,s){return te(()=>{wn(i),dT(s),ii(r),t==null&&(t=[1,1]),r==null&&(r="valid"),i==null&&(i=Yi()),s==null&&(s="max"),n=H_(n,i);let a;const o=r==="same"?"same":"valid";return s==="max"?a=Nb(n,e,t,o):a=yb(n,e,t,o),i==="channelsFirst"&&(a=Mt(a,[0,3,1,2])),a})}function ZA(n,e,t,r,i,s){return te(()=>{wn(i),dT(s),ii(r),t==null&&(t=[1,1,1]),r==null&&(r="valid"),i==null&&(i=Yi()),s==null&&(s="max"),n=pA(n,i);let a;const o=r==="same"?"same":"valid";return s==="max"?a=kb(n,e,t,o):a=v$(n,e,t,o),i==="channelsFirst"&&(a=Mt(a,[0,4,1,2,3])),a})}class QA extends Tt{constructor(e){if(e.poolSize==null&&(e.poolSize=2),super(e),typeof e.poolSize=="number")this.poolSize=[e.poolSize];else if(Array.isArray(e.poolSize)&&e.poolSize.length===1&&typeof e.poolSize[0]=="number")this.poolSize=e.poolSize;else throw new G(`poolSize for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.poolSize)}`);if(Bn(this.poolSize,"poolSize"),e.strides==null)this.strides=this.poolSize;else if(typeof e.strides=="number")this.strides=[e.strides];else if(Array.isArray(e.strides)&&e.strides.length===1&&typeof e.strides[0]=="number")this.strides=e.strides;else throw new G(`strides for 1D convolutional layer must be a number or an Array of a single number, but received ${JSON.stringify(e.strides)}`);Bn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,ii(this.padding),this.inputSpec=[new Dn({ndim:3})]}computeOutputShape(e){e=kt(e);const t=qi(e[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return te(()=>{this.invokeCallHook(e,t),e=Qf(ot(e),2);const r=this.poolingFunction(ot(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return qf(r,[2])})}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class JA extends QA{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return wn(s),ii(i),Fm(e,t,r,i,s,"max")}}JA.className="MaxPooling1D";ge(JA);class eC extends QA{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return wn(s),ii(i),Fm(e,t,r,i,s,"avg")}}eC.className="AveragePooling1D";ge(eC);class tC extends Tt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==2)throw new G(`If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides];Bn(this.poolSize,"poolSize"),Bn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,wn(this.dataFormat),ii(this.padding),this.inputSpec=[new Dn({ndim:4})]}computeOutputShape(e){e=kt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2];return t=qi(t,this.poolSize[0],this.padding,this.strides[0]),r=qi(r,this.poolSize[1],this.padding,this.strides[1]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r]:[e[0],t,r,e[3]]}call(e,t){return te(()=>(this.invokeCallHook(e,t),this.poolingFunction(ot(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class nC extends tC{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return wn(s),ii(i),Fm(e,t,r,i,s,"max")}}nC.className="MaxPooling2D";ge(nC);class rC extends tC{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return wn(s),ii(i),Fm(e,t,r,i,s,"avg")}}rC.className="AveragePooling2D";ge(rC);class iC extends Tt{constructor(e){if(e.poolSize==null&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],e.strides==null)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(e.strides.length!==3)throw new G(`If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length ${e.strides.length}.`);this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Bn(this.poolSize,"poolSize"),Bn(this.strides,"strides"),this.padding=e.padding==null?"valid":e.padding,this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,wn(this.dataFormat),ii(this.padding),this.inputSpec=[new Dn({ndim:5})]}computeOutputShape(e){e=kt(e);let t=this.dataFormat==="channelsFirst"?e[2]:e[1],r=this.dataFormat==="channelsFirst"?e[3]:e[2],i=this.dataFormat==="channelsFirst"?e[4]:e[3];return t=qi(t,this.poolSize[0],this.padding,this.strides[0]),r=qi(r,this.poolSize[1],this.padding,this.strides[1]),i=qi(i,this.poolSize[2],this.padding,this.strides[2]),this.dataFormat==="channelsFirst"?[e[0],e[1],t,r,i]:[e[0],t,r,i,e[4]]}call(e,t){return te(()=>(this.invokeCallHook(e,t),this.poolingFunction(ot(e),this.poolSize,this.strides,this.padding,this.dataFormat)))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class sC extends iC{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return wn(s),ii(i),ZA(e,t,r,i,s,"max")}}sC.className="MaxPooling3D";ge(sC);class aC extends iC{constructor(e){super(e)}poolingFunction(e,t,r,i,s){return wn(s),ii(i),ZA(e,t,r,i,s,"avg")}}aC.className="AveragePooling3D";ge(aC);class oC extends Tt{constructor(e){super(e),this.inputSpec=[new Dn({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new vt}}class cC extends oC{constructor(e){super(e||{})}call(e,t){return te(()=>{const r=ot(e);return An(r,1)})}}cC.className="GlobalAveragePooling1D";ge(cC);class lC extends oC{constructor(e){super(e||{})}call(e,t){return te(()=>{const r=ot(e);return Wi(r,1)})}}lC.className="GlobalMaxPooling1D";ge(lC);class uC extends Tt{constructor(e){super(e),this.dataFormat=e.dataFormat==null?"channelsLast":e.dataFormat,wn(this.dataFormat),this.inputSpec=[new Dn({ndim:4})]}computeOutputShape(e){return e=e,this.dataFormat==="channelsLast"?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new vt}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class fC extends uC{call(e,t){return te(()=>{const r=ot(e);return this.dataFormat==="channelsLast"?An(r,[1,2]):An(r,[2,3])})}}fC.className="GlobalAveragePooling2D";ge(fC);class dC extends uC{call(e,t){return te(()=>{const r=ot(e);return this.dataFormat==="channelsLast"?Wi(r,[1,2]):Wi(r,[2,3])})}}dC.className="GlobalMaxPooling2D";ge(dC);/**
 * @license
 * Copyright 2018 Google LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class hC extends Tt{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return this.layer!=null?this.layer.trainable:!1}set trainable(e){this.layer!=null&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.layer!=null&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t,r={}){const i=t.layer,s=Hs(i,r);delete t.layer;const a={layer:s};return Object.assign(a,t),new e(a)}}class pC extends hC{constructor(e){super(e),this.supportsMasking=!0}build(e){if(e=kt(e),e.length<3)throw new G(`TimeDistributed layer expects an input shape >= 3D, but received input shape ${JSON.stringify(e)}`);this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){e=kt(e);const t=[e[0]].concat(e.slice(2)),r=this.layer.computeOutputShape(t),i=e[1];return[r[0],i].concat(r.slice(1))}call(e,t){return te(()=>(e=ot(e),EA((a,o)=>[ot(this.layer.call(a,t)),[]],e,[],!1,null,null,!1,!0)[1]))}}pC.className="TimeDistributed";ge(pC);function jW(n){Ko(vH,"BidirectionalMergeMode",n)}const YW="concat";class mC extends hC{constructor(e){super(e);const t=e.layer.getConfig(),r={};r.className=e.layer.getClassName(),r.config=t,this.forwardLayer=Hs(r),t.goBackwards=t.goBackwards!==!0;const i={};if(i.className=e.layer.getClassName(),i.config=t,this.backwardLayer=Hs(i),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=e.mergeMode===void 0?YW:e.mergeMode,jW(this.mergeMode),e.weights)throw new vt("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,this.forwardLayer!=null&&(this.forwardLayer.trainable=e),this.backwardLayer!=null&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,r=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,r)),this.backwardLayer.setWeights(e.slice(r))}computeOutputShape(e){let t=this.forwardLayer.computeOutputShape(e);Array.isArray(t)&&Array.isArray(t[0])||(t=[t]),t=t;let r,i,s;return this.returnState&&(s=t.slice(1)),r=t[0],r=r,this.mergeMode==="concat"?(r[r.length-1]*=2,i=[r]):this.mergeMode==null?i=[r,r.slice()]:i=[r],this.returnState?this.mergeMode==null?i.concat(s).concat(s.slice()):[r].concat(s).concat(s.slice()):Tr(i)}apply(e,t){let r=t==null?null:t.initialState,i=t==null?null:t.constants;t==null&&(t={});const s=wA(e,r,i,this.numConstants);if(e=s.inputs,r=s.initialState,i=s.constants,Array.isArray(e)&&(r=e.slice(1),e=e[0]),(r==null||r.length===0)&&i==null)return super.apply(e,t);const a=[],o=[];if(r!=null){const l=r.length;if(l%2>0)throw new G("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=r,a.push(...r);const u=r.map(f=>new Dn({shape:f.shape}));this.forwardLayer.stateSpec=u.slice(0,l/2),this.backwardLayer.stateSpec=u.slice(l/2),o.push(...u)}if(i!=null)throw new vt("Support for constants in Bidirectional layers is not implemented yet.");const c=a[0]instanceof bs;for(const l of a)if(l instanceof bs!==c)throw new G("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(c){const l=[e].concat(a),u=this.inputSpec.concat(o),f=this.inputSpec;this.inputSpec=u;const d=super.apply(l,t);return this.inputSpec=f,d}else return super.apply(e,t)}call(e,t){return te(()=>{const r=t.initialState;let i,s;if(r==null)i=this.forwardLayer.call(e,t),s=this.backwardLayer.call(e,t);else{const c=r.slice(0,r.length/2),l=r.slice(r.length/2);i=this.forwardLayer.call(e,Object.assign(t,{initialState:c})),s=this.backwardLayer.call(e,Object.assign(t,{initialState:l}))}let a;this.returnState&&(Array.isArray(i)&&(a=i.slice(1).concat(s.slice(1))),i=i[0],s=s[0]),this.returnSequences&&(s=Ki(s,1));let o;return this.mergeMode==="concat"?o=N_([i,s]):this.mergeMode==="sum"?o=ye(i,s):this.mergeMode==="ave"?o=W(.5,ye(i,s)):this.mergeMode==="mul"?o=W(i,s):this.mergeMode==null&&(o=[i,s]),this.returnState?this.mergeMode==null?o.concat(a):[o].concat(a):o})}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){_o(this.forwardLayer.name,()=>{this.forwardLayer.build(e)}),_o(this.backwardLayer.name,()=>{this.backwardLayer.build(e)}),this.built=!0}computeMask(e,t){Array.isArray(t)&&(t=t[0]);let r;if(this.returnSequences?this.mergeMode==null?r=[t,t]:r=t:this.mergeMode==null?r=[null,null]:r=null,this.returnState){const s=this.forwardLayer.states.map(a=>null);return Array.isArray(r)?r.concat(s).concat(s):[r].concat(s).concat(s)}else return r}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),this.forwardLayer!=null&&this.forwardLayer.setFastWeightInitDuringBuild(e),this.backwardLayer!=null&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const r=Hs(t.layer);if(delete t.layer,t.numConstants!=null)throw new vt("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const i=t;return i.layer=r,new e(i)}}mC.className="Bidirectional";ge(mC);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class vC extends Tt{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return te(()=>(e=ot(e),e.dtype!=="float32"&&(e=hs(e,"float32")),ye(W(e,this.scale),this.offset)))}}vC.className="Rescaling";ge(vC);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const{resizeBilinear:ZW,cropAndResize:QW}=Vs;class gC extends Tt{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,r,i,s,a,o,c){return te(()=>{let l,u=!1;const f=t/a,d=r/o,h=(i+t)/a,p=(s+r)/o,g=[f,d,h,p],m=[];e.rank===3?(u=!0,l=Ks([e])):l=e;for(let w=0;w<l.shape[0];w++)m.push(g);const v=xb(m,[m.length,4]),x=Iu(0,m.length,1,"int32"),_=QW(l,v,x,[i,s],"nearest");return hs(u?ot(Lo(_)):_,c)})}upsize(e,t,r,i){return te(()=>{const s=ZW(e,[t,r]);return hs(s,i)})}call(e,t){return te(()=>{const r=ot(e),i=r.dtype,s=r.shape,a=s[s.length-3],o=s[s.length-2];let c=0;a!==this.height&&(c=Math.floor((a-this.height)/2));let l=0;return o!==this.width&&(l=Math.floor((o-this.width)/2),l===0&&(l=1)),c>=0&&l>=0?this.centerCrop(r,c,l,this.height,this.width,a,o,i):this.upsize(e,this.height,this.width,i)})}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=kt(e);const t=e.length-3,r=e.length-2;return e[t]=this.height,e[r]=this.width,e}}gC.className="CenterCrop";ge(gC);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */function JW(n,e,t,r){let i=ot(n);if(i.dtype!=="int32"&&(i=hs(i,"int32")),e==="int")return i;const s=i.shape;if(i.rank===0&&(i=Sr(i,-1)),e==="oneHot"&&i.shape[i.shape.length-1]!==1&&(i=Sr(i,-1)),i.rank>2)throw new G(`When outputMode is not int, maximum output rank is 2 Received outputMode ${e} and input shape ${s} which would result in output rank ${i.rank}.`);const a=["multiHot","oneHot"].includes(e),o=i;let c;if(typeof r<"u"&&e==="count"?c=S2(o,r,t,a):c=S2(o,[],t,a),e!=="tfIdf")return c;if(r)return W(c,r);throw new G("When outputMode is 'tfIdf', weights must be provided.")}/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class xC extends Tt{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return e=kt(e),e==null?[this.numTokens]:this.outputMode==="oneHot"&&e[e.length-1]!==1?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return te(()=>{e=ot(e),e.dtype!=="int32"&&(e=hs(e,"int32"));let r;if(typeof t.countWeights<"u"){if(this.outputMode!=="count")throw new G(`countWeights is not used when outputMode !== count.
              Received countWeights=${t.countWeights}`);r=ot(t.countWeights)}const i=Wi(e),s=Ph(e),a=ri(this.numTokens,i).bufferSync().get(0),o=Ho(s,0).bufferSync().get(0);if(!(a&&o))throw new G(`Input values must be between 0 < values <= numTokens with numTokens=${this.numTokens}`);return JW(e,this.outputMode,this.numTokens,r)})}}xC.className="CategoryEncoding";ge(xC);/**
 * @license
 * Copyright 2022 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const e8=["bilinear","nearest"],rw=new Set(e8);class bC extends Tt{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation)if(rw.has(e.interpolation))this.interpolation=e.interpolation;else throw new G(`Invalid interpolation parameter: ${e.interpolation} is not implemented`);else this.interpolation="bilinear";this.cropToAspectRatio=!!e.cropToAspectRatio}computeOutputShape(e){e=kt(e);const t=e[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return te(()=>{const r=[this.height,this.width];if(this.interpolation==="bilinear")return Vs.resizeBilinear(e,r,!this.cropToAspectRatio);if(this.interpolation==="nearest")return Vs.resizeNearestNeighbor(e,r,!this.cropToAspectRatio);throw new Error(`Interpolation is ${this.interpolation} but only ${[...rw]} are supported`)})}}bC.className="Resizing";ge(bC);/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class _C{constructor(e){this.seed=e}next(){if(this.seed!==void 0)return this.seed++}}_C.className="RandomSeed";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */class yC extends Tt{constructor(e){super(e),this.randomGenerator=new _C(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}yC.className="BaseRandomLayer";/**
 * @license
 * Copyright 2023 CodeSmith LLC
 *
 * Use of this source code is governed by an MIT-style
 * license that can be found in the LICENSE file or at
 * https://opensource.org/licenses/MIT.
 * =============================================================================
 */const t8=["bilinear","nearest"],iw=new Set(t8);class wC extends yC{constructor(e){super(e);const{factor:t,interpolation:r="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&this.factor.length===2)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else if(!Array.isArray(this.factor)&&this.factor>0)this.widthLower=-this.factor,this.widthUpper=this.factor;else throw new G(`Invalid factor: ${this.factor}. Must be positive number or tuple of 2 numbers`);if(this.widthLower<-1||this.widthUpper<-1)throw new G(`factor must have values larger than -1. Got: ${this.factor}`);if(this.widthUpper<this.widthLower)throw new G(`factor cannot have upper bound less than lower bound.
        Got upper bound: ${this.widthUpper}.
        Got lower bound: ${this.widthLower}
      `);if(r)if(iw.has(r))this.interpolation=r;else throw new G(`Invalid interpolation parameter: ${r} is not implemented`)}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){e=kt(e);const t=e[2];return[this.imgHeight,-1,t]}call(e,t){return te(()=>{const r=ot(e);this.imgHeight=r.shape[r.shape.length-3];const i=r.shape[r.shape.length-2];this.widthFactor=Wf([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let s=this.widthFactor.dataSync()[0]*i;s=Math.round(s);const a=[this.imgHeight,s];switch(this.interpolation){case"bilinear":return Vs.resizeBilinear(e,a);case"nearest":return Vs.resizeNearestNeighbor(e,a);default:throw new Error(`Interpolation is ${this.interpolation}
          but only ${[...iw]} are supported`)}})}}wC.className="RandomWidth";ge(wC);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n8=ie();n8.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,n=>{n&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var sw;(function(n){n[n.DT_INVALID=0]="DT_INVALID",n[n.DT_FLOAT=1]="DT_FLOAT",n[n.DT_DOUBLE=2]="DT_DOUBLE",n[n.DT_INT32=3]="DT_INT32",n[n.DT_UINT8=4]="DT_UINT8",n[n.DT_INT16=5]="DT_INT16",n[n.DT_INT8=6]="DT_INT8",n[n.DT_STRING=7]="DT_STRING",n[n.DT_COMPLEX64=8]="DT_COMPLEX64",n[n.DT_INT64=9]="DT_INT64",n[n.DT_BOOL=10]="DT_BOOL",n[n.DT_QINT8=11]="DT_QINT8",n[n.DT_QUINT8=12]="DT_QUINT8",n[n.DT_QINT32=13]="DT_QINT32",n[n.DT_BFLOAT16=14]="DT_BFLOAT16",n[n.DT_QINT16=15]="DT_QINT16",n[n.DT_QUINT16=16]="DT_QUINT16",n[n.DT_UINT16=17]="DT_UINT16",n[n.DT_COMPLEX128=18]="DT_COMPLEX128",n[n.DT_HALF=19]="DT_HALF",n[n.DT_RESOURCE=20]="DT_RESOURCE",n[n.DT_VARIANT=21]="DT_VARIANT",n[n.DT_UINT32=22]="DT_UINT32",n[n.DT_UINT64=23]="DT_UINT64",n[n.DT_FLOAT_REF=101]="DT_FLOAT_REF",n[n.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",n[n.DT_INT32_REF=103]="DT_INT32_REF",n[n.DT_UINT8_REF=104]="DT_UINT8_REF",n[n.DT_INT16_REF=105]="DT_INT16_REF",n[n.DT_INT8_REF=106]="DT_INT8_REF",n[n.DT_STRING_REF=107]="DT_STRING_REF",n[n.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",n[n.DT_INT64_REF=109]="DT_INT64_REF",n[n.DT_BOOL_REF=110]="DT_BOOL_REF",n[n.DT_QINT8_REF=111]="DT_QINT8_REF",n[n.DT_QUINT8_REF=112]="DT_QUINT8_REF",n[n.DT_QINT32_REF=113]="DT_QINT32_REF",n[n.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",n[n.DT_QINT16_REF=115]="DT_QINT16_REF",n[n.DT_QUINT16_REF=116]="DT_QUINT16_REF",n[n.DT_UINT16_REF=117]="DT_UINT16_REF",n[n.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",n[n.DT_HALF_REF=119]="DT_HALF_REF",n[n.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",n[n.DT_VARIANT_REF=121]="DT_VARIANT_REF",n[n.DT_UINT32_REF=122]="DT_UINT32_REF",n[n.DT_UINT64_REF=123]="DT_UINT64_REF"})(sw||(sw={}));var aw;(function(n){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(n.CheckpointFormatVersion||(n.CheckpointFormatVersion={}))})(aw||(aw={}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var ow;(function(n){n[n.FAIL=0]="FAIL",n[n.SHORTEST=1]="SHORTEST",n[n.LONGEST=2]="LONGEST"})(ow||(ow={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ge(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&R(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the CPU backend.`)})}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r8=xS;class $m extends w0{nextDataId(){return $m.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new FE(this,Fr())}write(e,t,r){this.firstUse&&(this.firstUse=!1,ie().get("IS_NODE")&&Qr(`
============================
Hi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. 
============================`));const i={id:this.nextDataId()};return this.data.set(i,{values:e,dtype:r,refCount:1}),i}makeTensorInfo(e,t,r){let i;if(t==="string"&&r!=null&&r.length>0&&Gu(r[0])){const s=r.map(a=>Ca(a));i=this.write(s,e,t)}else i=this.write(r,e,t);return{dataId:i,shape:e,dtype:t}}refCount(e){return this.data.has(e)?this.data.get(e).refCount:0}incRef(e){const t=this.data.get(e);t.refCount++}decRef(e){if(this.data.has(e)){const t=this.data.get(e);t.refCount--}}move(e,t,r,i,s){this.data.set(e,{values:t,dtype:i,refCount:s})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:r}=this.data.get(e);if(t==="complex64"){const i=this.readSync(r.real.dataId),s=this.readSync(r.imag.dataId);return js(i,s)}return MP(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(i=>Na(i));return Et(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Et(e.shape,e.dtype,t)}makeOutput(e,t,r){return Fr().makeTensorFromTensorInfo(this.makeTensorInfo(t,r,e),this)}disposeData(e,t=!1){if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:r}=this.data.get(e);r!=null&&(this.disposeData(r.real.dataId,!0),this.disposeData(r.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=wr();return e(),{kernelMs:wr()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Ge([e],"where");const t=this.readSync(e.dataId);return r8(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}$m.nextDataId=0;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EC(n){const e=new Float32Array(n.length);for(let t=0;t<n.length;++t)e[t]=Math.abs(n[t]);return e}const i8=n=>{const{x:e}=n.inputs,t=n.backend;Ge(e,"abs");let r=new Float32Array(ue(e.shape));const i=t.data.get(e.dataId).values;return r=EC(i),t.makeOutput(r,e.shape,e.dtype)},s8={kernelName:xp,backendName:"cpu",kernelFunc:i8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function En(n){return(e,t,r,i,s)=>{const a=pt(e,t),o=a.length,c=Qe(a),l=ue(a),u=ir(s,l),f=e.length,d=t.length,h=Qe(e),p=Qe(t),g=il(e,a),m=il(t,a);if(g.length+m.length===0)for(let v=0;v<u.length;++v)u[v]=n(r[v%r.length],i[v%i.length]);else for(let v=0;v<u.length;++v){const x=wl(v,o,c),b=x.slice(-f);g.forEach(S=>b[S]=0);const _=us(b,f,h),w=x.slice(-d);m.forEach(S=>w[S]=0);const E=us(w,d,p);u[v]=n(r[_],i[E])}return[u,a]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ur(n){const{inputs:e,backend:t}=n,{real:r,imag:i}=e,s=t.data.get(r.dataId).values,a=t.data.get(i.dataId).values,o=t.makeTensorInfo(r.shape,"complex64"),c=t.data.get(o.dataId);return c.complexTensorInfos={real:t.makeTensorInfo(r.shape,"float32",s),imag:t.makeTensorInfo(i.shape,"float32",a)},o}const a8={kernelName:z0,backendName:"cpu",kernelFunc:Ur};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yh(n,e,t="float32"){if(t==="complex64"){const i=Yh(n,e,"float32"),s=Yh(n,e,"float32");return Ur({inputs:{real:i,imag:s},backend:n})}const r=sr(ue(e),t);return n.makeTensorInfo(e,t,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _s(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const o8={kernelName:ff,backendName:"cpu",kernelFunc:_s};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zo(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.data.get(r.dataId).complexTensorInfos.real,s=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,s)}const c8={kernelName:ab,backendName:"cpu",kernelFunc:zo};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function SC(n,e,t,r){if(r==="int32"){const i=Int32Array.from(n);return[e,"int32",i]}if(r==="bool"){const i=Go([0],t),[s,a]=En((o,c)=>o!==c?1:0)(e,[],n,i,"bool");return[a,"bool",s]}throw new Error(`Error in Cast: failed to cast ${t} to ${r}`)}function za(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dtype:s}=r;if(s==="complex64"){if(i.dtype==="complex64")return _s({inputs:{x:i},backend:t});const u=Yh(t,i.shape,i.dtype),f=za({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),d=Ur({inputs:{real:f,imag:u},backend:t});return t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(f),d}if(i.dtype==="complex64"){const u=zo({inputs:{input:i},backend:t}),f=za({inputs:{x:u},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(u),f}if(!UE(i.dtype,s)){const u=_s({inputs:{x:i},backend:t});return{dataId:u.dataId,shape:u.shape,dtype:s}}const a=t.data.get(i.dataId).values,[o,c,l]=SC(a,i.shape,i.dtype,s);return t.makeTensorInfo(o,c,l)}const l8={kernelName:Zu,backendName:"cpu",kernelFunc:za};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Pn(n,e,t,r){return t==null?({inputs:i,backend:s})=>{const{a,b:o}=i,c=s;Ge([a,o],n);const l=c.data.get(a.dataId).values,u=c.data.get(o.dataId).values,f=a.dtype==="string"?Ys(l):l,d=a.dtype==="string"?Ys(u):u,h=r||a.dtype,[p,g]=e(a.shape,o.shape,f,d,h);return c.makeTensorInfo(g,h,p)}:({inputs:i,backend:s})=>{const{a,b:o}=i,c=s;if(a.dtype==="complex64"||o.dtype==="complex64"){const l=za({inputs:{x:a},backend:c,attrs:{dtype:"complex64"}}),u=c.data.get(l.dataId),f=u.complexTensorInfos.real,d=u.complexTensorInfos.imag,h=c.data.get(f.dataId).values,p=c.data.get(d.dataId).values,g=za({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),m=c.data.get(g.dataId),v=m.complexTensorInfos.real,x=m.complexTensorInfos.imag,b=c.data.get(v.dataId).values,_=c.data.get(x.dataId).values,[w,E,S]=t(a.shape,o.shape,h,p,b,_),T=c.makeTensorInfo(S,"float32",w),C=c.makeTensorInfo(S,"float32",E),y=Ur({inputs:{real:T,imag:C},backend:c});return c.disposeIntermediateTensorInfo(l),c.disposeIntermediateTensorInfo(g),c.disposeIntermediateTensorInfo(T),c.disposeIntermediateTensorInfo(C),y}else{const l=c.data.get(a.dataId).values,u=c.data.get(o.dataId).values,f=r||a.dtype,[d,h]=e(a.shape,o.shape,l,u,f);return c.makeTensorInfo(h,f,d)}}}function Y_(n){return(e,t,r,i,s,a)=>{const o=pt(e,t),c=ue(o),l=o.length,u=Qe(o),f=ir("float32",c),d=ir("float32",c),h=il(e,o),p=il(t,o),g=js(r,i),m=js(s,a),v=e.length,x=Qe(e),b=t.length,_=Qe(t);if(h.length+p.length===0)for(let w=0;w<f.length;w++){const E=w%g.length,S=w%m.length,T=n(g[E*2],g[E*2+1],m[S*2],m[S*2+1]);f[w]=T.real,d[w]=T.imag}else for(let w=0;w<f.length;w++){const E=wl(w,l,u),S=E.slice(-v);h.forEach(k=>S[k]=0);const T=us(S,v,x),C=E.slice(-b);p.forEach(k=>C[k]=0);const y=us(C,b,_),A=n(g[T*2],g[T*2+1],m[y*2],m[y*2+1]);f[w]=A.real,d[w]=A.imag}return[f,d,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TC=En((n,e)=>n+e),u8=Y_((n,e,t,r)=>({real:n+t,imag:e+r})),ol=Pn(El,TC,u8),f8={kernelName:El,backendName:"cpu",kernelFunc:ol};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z_(n,e,t,r,i){const s=ue(r),a=sr(i,t);for(let o=0;o<n.length;o++){const c=n[o];if(c<0)throw new Error("Input x must be non-negative!");c>=i||(s>0?a[c]+=e[o]:a[c]+=1)}return a}function AC(n,e,t,r=!1){const i=n.shape[0],s=n.shape[1],a=Et([i,t],e.dtype);for(let o=0;o<i;o++)for(let c=0;c<s;c++){const l=n.get(o,c);if(l<0)throw new Error("Input x must be non-negative!");l>=t||(r?a.set(1,o,l):e.size>0?a.set(a.get(o,l)+e.get(o,c),o,l):a.set(a.get(o,l)+1,o,l))}return a}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CC=En((n,e)=>n&e),d8=Pn(O0,CC),h8={kernelName:O0,backendName:"cpu",kernelFunc:d8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ts(n){return(e,t,r)=>{const i=gn(t,e.length);for(let s=0;s<e.length;++s)i[s]=n(e[s],r);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wt(n,e,t){const r=Ts(e);return Xa(n,r,t)}function Xa(n,e,t){return({inputs:r,attrs:i,backend:s})=>{const{x:a}=r;Ge(a,n);const o=s,c=o.data.get(a.dataId).values;let l;if(a.dtype==="string"){if(!Array.isArray(c))throw new Error("String tensor's value was not an instance of Array");l=Ys(c)}else l=c;const u=t||a.dtype,f=e(l,u,i);return o.makeTensorInfo(a.shape,u,f)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const IC=Ts(n=>Math.ceil(n)),p8=Xa(Qu,IC),m8={kernelName:Qu,backendName:"cpu",kernelFunc:p8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MC(n,e,t,r){const i=gn(t,ue(e));if(r&&t!=="string"){let s=0;n.forEach(a=>{const o=ue(a.shape);i.set(a.vals,s),s+=o})}else{let s=0;n.forEach(a=>{const o=t==="string"?Ys(a.vals):a.vals;let c=0;for(let l=0;l<a.shape[0];++l){const u=l*e[1]+s;for(let f=0;f<a.shape[1];++f)i[u+f]=o[c++]}s+=a.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RC=En((n,e)=>n===e?1:0),NC=Pn(Dp,RC,null,"bool"),v8={kernelName:Dp,backendName:"cpu",kernelFunc:NC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kC=Ts(n=>Math.exp(n)),DC=Xa(af,kC,"float32"),g8={kernelName:af,backendName:"cpu",kernelFunc:DC};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LC=Ts(n=>Math.expm1(n)),x8=Xa(of,LC),b8={kernelName:of,backendName:"cpu",kernelFunc:x8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OC=Ts(n=>Math.floor(n)),_8=Xa(cf,OC),y8={kernelName:cf,backendName:"cpu",kernelFunc:_8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zC=En((n,e)=>Math.floor(n/e)),w8=Pn(lf,zC,null,"int32"),E8={kernelName:lf,backendName:"cpu",kernelFunc:w8};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PC(n,e,t,r,i,s,a,o,c){const l=Et([r,s],t);for(let u=0;u<r;u++){const f=[];let d=0;for(let h=0;h<i;h++){const p=n[u*i+h];d+=p*a[h],f.push(p)}if(d<0||d>=c/s)throw new Error(`Invalid indices: ${f} does not index into ${o}`);for(let h=0;h<s;h++)l.values[u*s+h]=e.get(...e.indexToLoc(d*s+h))}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FC(n,e,t){const r=Et(t,n.dtype);for(let i=0;i<r.size;++i){const a=r.indexToLoc(i).slice(),o=a[0],c=a[2],l=e.locToIndex([o,c]);a[2]=e.values[l];const u=n.locToIndex(a);0<=u&&u<n.values.length&&(r.values[i]=n.values[u])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $C=En((n,e)=>n>e?1:0),S8=Pn(Pp,$C,null,"bool"),T8={kernelName:Pp,backendName:"cpu",kernelFunc:S8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UC=En((n,e)=>n>=e?1:0),A8=Pn(uf,UC,null,"bool"),C8={kernelName:uf,backendName:"cpu",kernelFunc:A8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BC=En((n,e)=>n<e?1:0),I8=Pn($p,BC,null,"bool"),M8={kernelName:$p,backendName:"cpu",kernelFunc:I8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VC=En((n,e)=>n<=e?1:0),R8=Pn(Up,VC,null,"bool"),N8={kernelName:Up,backendName:"cpu",kernelFunc:R8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GC(n,e,t){const r=(e-n)/(t-1),i=sr(t,"float32");i[0]=n;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HC=Ts(n=>Math.log(n)),k8=Xa(mf,HC),D8={kernelName:mf,backendName:"cpu",kernelFunc:k8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WC(n,e,t,r){const i=ir(r,ue(t));for(let s=0;s<i.length;++s){const a=s*e;let o=n[a];for(let c=0;c<e;++c){const l=n[a+c];(Number.isNaN(l)||l>o)&&(o=l)}i[s]=o}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qC=En((n,e)=>Math.max(n,e)),L8=Pn(gf,qC),O8={kernelName:gf,backendName:"cpu",kernelFunc:L8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XC=En((n,e)=>Math.min(n,e)),z8=Pn(xf,XC),P8={kernelName:xf,backendName:"cpu",kernelFunc:z8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Q_=En((n,e)=>n*e),F8=Y_((n,e,t,r)=>({real:n*t-e*r,imag:n*r+e*t})),Um=Pn(_f,Q_,F8),$8={kernelName:_f,backendName:"cpu",kernelFunc:Um};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KC(n,e,t){const r=Ua(-1,t);return Q_([],e,r,n,t)}function U8(n){const{inputs:e,backend:t}=n,{x:r}=e;Ge(r,"neg");const i=t.data.get(r.dataId).values,[s,a]=KC(i,r.shape,r.dtype);return t.makeTensorInfo(a,r.dtype,s)}const B8={kernelName:Zp,backendName:"cpu",kernelFunc:U8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jC=En((n,e)=>n!==e?1:0),V8=Pn(Qp,jC,null,"bool"),G8={kernelName:Qp,backendName:"cpu",kernelFunc:V8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_(n,e,t,r,i){const s=e.length,a=ue(e),o=Qe(e),c=Qe(i),l=ir(t,ue(i));for(let u=0;u<a;++u){const f=wl(u,s,o),d=new Array(f.length);for(let p=0;p<d.length;p++)d[p]=f[r[p]];const h=us(d,s,c);l[h]=n[u]}return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nr(n){const{inputs:e,attrs:t,backend:r}=n,{x:i}=e,{perm:s}=t;Ge(i,"transpose");const a=i.shape.length,o=new Array(a);for(let f=0;f<o.length;f++)o[f]=i.shape[s[f]];const c=r.data.get(i.dataId).values,l=J_(c,i.shape,i.dtype,s,o);return{dataId:r.write(l,o,i.dtype),shape:o,dtype:i.dtype}}const H8={kernelName:Fc,backendName:"cpu",kernelFunc:Nr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YC(n,e,t,r){const[i,s]=Wn(n,r),a=Hr(e,"int32"),o=sr(ue(i),a),c=ue(s);for(let l=0;l<o.length;++l){const u=l*c;let f=1;for(let d=0;d<c;++d)f*=t[u+d];o[l]=f}return{outVals:o,outShape:i,outDtype:a}}function W8(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r;Ge(i,"prod");const o=i.shape.length,c=St(s,i.shape),l=pn(c,o);let u=c,f=i;const d=[];l!=null&&(f=Nr({inputs:{x:i},backend:t,attrs:{perm:l}}),d.push(f),u=yn(u.length,o));const h=t.data.get(f.dataId).values,{outVals:p,outShape:g,outDtype:m}=YC(f.shape,f.dtype,h,u);let v=g;return a&&(v=Cn(g,c)),d.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.makeTensorInfo(v,m,p)}const q8={kernelName:im,backendName:"cpu",kernelFunc:W8};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X8(n,e,t){n.forEach((r,i)=>{if(r<0||r>=t){const s=wl(i,e.length,Qe(e)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${t})`)}})}function K8(n,e){for(let t=0;t<n.length;++t){const r=n[t],i=t===n.length-1?e:n[t+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function j8(n,e,t,r){const i=[];let s=0;const a=e.length-1+t.length,o=new Array(a).fill(null).map(()=>[0]);K8(t,r);let c=1;for(let l=0;l<e.length-1;++l){c*=e[l];const u=e[l+1];for(let f=1;f<c+1;++f)o[l].push(f*u)}for(let l=0;l<n.length;++l){let u=n[l],f=n[l]+1;for(let d=0;d<t.length;++d){const h=t[d],p=d+e.length-1;if(p>=0){const g=o[p],m=g[g.length-1]-h[u];for(let v=u;v<f;++v)o[p].push(h[v+1]+m)}u=h[u],f=h[f]}f!==u&&(i.push([u,f]),s+=f-u)}return{outSplits:o,valueSlices:i,numValues:s}}function Y8(n){const e=[];for(let t=0;t<n.length;++t){const r=n[t].length,i=gn("int32",r);e.push(i),n[t].forEach((s,a)=>i[a]=s)}return e}function cw(n,e){const t=n.slice(0,e);for(;t.length<e;)t.push(1);for(let r=e;r<n.length;r++)t[e-1]*=n[r];return t}function Z8(n,e,t,r,i,s){const a=cw(e,2)[1],o=cw(s,2)[1];let c=0;for(const l of t)for(let u=l[0];u<l[1];++u){for(let f=0;f<r;++f)i[c*o+f]=n[u*a+f];++c}}function Q8(n,e,t,r,i){const s=e.slice();s[0]=i;const a=gn(t,ue(s)),o=n.length,c=o===0?0:o/e[0];return Z8(n,e,r,c,a,s),[a,s]}function ZC(n,e,t,r,i,s,a,o){if(n.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const c=e[0][0]-1;if(X8(s,a,c),r.length===0)throw new Error("params.rank must be nonzero");const l=r[0],{outSplits:u,valueSlices:f,numValues:d}=j8(s,a,n,l),h=Y8(u),p=Q8(t,r,i,f,d);return[h,p[0],p[1]]}/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lw=2147483647;function QC(n,e,t,r,i,s,a){if(e.length>1)throw new Error("starts must be a scalar or vector");if(i.length>1)throw new Error("limits must be a scalar or vector");if(a.length>1)throw new Error("deltas must be a scalar or vector");const o=e.length===0,c=i.length===0,l=a.length===0,u=[];o||u.push(e[0]),c||u.push(i[0]),l||u.push(a[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const f=u.length===0?1:u[0],d=gn("int32",f+1);d[0]=0;for(let m=0;m<f;++m){const v=o?n[0]:n[m],x=c?r[0]:r[m],b=l?s[0]:s[m];if(b===0)throw new Error("Requires delta != 0");let _;if(b>0&&x<v||b<0&&x>v)_=0;else if(_=Math.ceil(Math.abs((x-v)/b)),_>lw)throw new Error(`Requires ((limit - start) / delta) <= ${lw}`);d[m+1]=d[m]+_}const h=d[f],p=gn(t,h);let g=0;for(let m=0;m<f;++m){const v=d[m+1]-d[m];let x=o?n[0]:n[m];const b=l?s[0]:s[m];for(let _=0;_<v;++_)p[g++]=x,x+=b}return[d,p]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ci=Fi;class Zh{constructor(e,t,r,i,s,a,o,c,l,u){this.shape=e,this.shapeShape=t,this.values=r,this.valuesShape=i,this.valuesDType=s,this.defaultValue=a,this.defaultValueShape=o,this.rowPartitionValues=c,this.rowPartitionValuesShapes=l,this.rowPartitionTypes=PS(u),this.raggedRank=FS(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===ci.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===ci.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case ci.VALUE_ROWIDS:return Zh.getMaxWidthValueRowID(t);case ci.ROW_SPLITS:return Zh.getMaxWidthRowSplit(t);default:throw new Error(`Cannot handle partition type ${ci[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const t=e.length;if(t===0||t===1)return 0;let r=0;for(let i=0;i<t-1;++i){const s=e[i+1]-e[i];s>r&&(r=s)}return r}static getMaxWidthValueRowID(e){const t=e.length;if(t===0)return 0;let r=0,i=e[0],s=0;for(let a=1;a<t;++a){const o=e[a];o!==i&&(i=o,s=Math.max(a-r,s),r=a)}return Math.max(t-r,s)}tensorShapeFromTensor(e,t,r=!0){if(t.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return fw(e,r)}calculateOutputSize(e){const t=this.valuesShape,r=this.defaultValueShape;$S(r,t);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=zS(this.raggedRank,i,t);a[0]<0&&(a[0]=e);for(let o=1;o<=this.raggedRank;++o)a[o]<0&&(a[o]=this.getMaxWidth(o));return a}calculateFirstParentOutputIndex(e,t,r){const i=Math.min(e,r),s=[];let a=0;for(let o=0;o<i;++o,a+=t)s.push(a);for(let o=i;o<e;++o)s.push(-1);return R(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,t,r,i){const s=e.length,a=[];for(let o=0;o<s-1;++o){const c=e[o+1]-e[o];let l=Math.min(i,c),u=t[o];u===-1&&(l=0);for(let f=0;f<l;++f)a.push(u),u+=r;for(let f=0;f<c-l;++f)a.push(-1)}if(s>0&&a.length!==e[s-1])throw new Error("Invalid row split size.");return a}calculateOutputIndexValueRowID(e,t,r,i){const s=e.length,a=[];if(s===0)return[];let o=0,c=e[0];if(c>=t.length)throw new Error(`Got currentValueRowId=${c}, which is not less than ${t.length}`);let l=t[c];a.push(l);for(let u=1;u<s;++u){const f=e[u];if(f===c)l>=0&&(++o,o<i?l+=r:l=-1);else{if(o=0,c=f,f>=t.length)throw new Error(`Got nextValueRowId=${f} which is not less than ${t.length}`);l=t[f]}a.push(l)}if(a.length!==e.length)throw new Error("Invalid row ids.");return a}calculateOutputIndex(e,t,r,i){const s=this.getRowPartitionTensor(e),a=this.getRowPartitionTypeByDimension(e);switch(a){case ci.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,t,r,i);case ci.ROW_SPLITS:if(s.length-1>t.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${t.length}`);return this.calculateOutputIndexRowSplit(s,t,r,i);default:throw new Error(`Unsupported partition type: ${ci[a]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case ci.FIRST_DIM_SIZE:return e[0];case ci.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case ci.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${ci[t]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const t=this.getFirstDimensionSize(),r=this.calculateOutputSize(t),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let c=i.length-2;c>=0;--c)i[c]=i[c+1]*r[c+1];const s=fw(r,!1),a=gn(this.valuesDType,ue(s));if(i[0]*r[0]>0){let c=this.calculateFirstParentOutputIndex(t,i[0],r[0]);for(let l=1;l<=this.raggedRank;++l)c=this.calculateOutputIndex(l-1,c,i[l],r[l]);this.setOutput(this.raggedRank,c,a,s)}return[s,a]}setOutput(e,t,r,i){if(r.length===0)return;const s=this.values,a=r;let o=i.slice();o=o.slice(e+1);const c=ue(o),l=t.length;let u=this.defaultValue;if(u.length!==c&&u.length!==1){const p=this.defaultValueShape;te(()=>{const g=j(u,p);u=xu(g,o).dataSync()})}let f=0,d=0,h=0;for(let p=0;p<=l;++p){let g=p<l?t[p]:-1;if(g===h){++h;continue}if(d<h){const m=s.subarray(f*c),v=a.subarray(d*c),x=(h-d)*c;uw(v,m,x)}if(p>=l){const m=r.length;g=Math.floor(m/c)}if(g>h)if(this.defaultValue.length===1)a.subarray(h*c,g*c).fill(this.defaultValue[0]),h=g;else for(;g>h;){const m=a.slice(h*c);uw(m,u,c),++h}g<0?(f=p+1,d=h):(f=p,d=h,h=d+1)}}}function uw(n,e,t){for(let r=0;r<t;r++)n[r]=e[r]}function fw(n,e){const t=[];for(let r of n){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}t.push(r)}return t}function JC(n,e,t,r,i,s,a,o,c,l){return new Zh(n,e,t,r,i,s,a,o,c,l).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eI(n,e,t,r){const i=n===e,s=n<e&&t<0,a=e<n&&t>1;if(i||s||a)return sr(0,r);const o=Math.abs(Math.ceil((e-n)/t)),c=sr(o,r);e<n&&t===1&&(t=-1),c[0]=n;for(let l=1;l<c.length;l++)c[l]=c[l-1]+t;return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tI=Ts(n=>1/Math.sqrt(n)),J8=Xa(Af,tI),eq={kernelName:Af,backendName:"cpu",kernelFunc:J8};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xo(n,e,t,r,i,s,a,o,c,l){const u=[r/i,i],f=n.values,d=e.values;if(r===0)return Et(t,e.dtype);const h=c instanceof jn?c:Et(u,e.dtype);typeof c=="string"||typeof c=="number"?h.values.fill(c):typeof c=="boolean"&&h.values.fill(+c);for(let p=0;p<s;p++){const g=[];let m=0;for(let v=0;v<a;v++){const x=f[p*a+v];g.push(x),m+=x*o[v]}if(m<0||m>=r/i)throw new Error(`Invalid indices: ${g} does not index into ${t}`);for(let v=0;v<i;v++)l?h.values[m*i+v]+=d[p*i+v]:h.values[m*i+v]=e.rank===0?d[0]:d[p*i+v]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tq=Ts(n=>1/(1+Math.exp(-n))),nI=Wt(Nf,n=>1/(1+Math.exp(-n))),nq={kernelName:Nf,backendName:"cpu",kernelFunc:nI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rI(n,e,t,r,i){const s=a_(r,e,t),a=ue(t),o=Qe(r);if(s){const f=o_(e,o);return i==="string"?n.slice(f,f+a):n.subarray(f,f+a)}const c=i==="string"?Ys(n):n,l=Et(r,i,c),u=Et(t,i);for(let f=0;f<u.size;++f){const d=u.indexToLoc(f),h=d.map((p,g)=>p+e[g]);u.set(l.get(...h),...d)}return i==="string"?sT(u.values):u.values}function Po(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,size:a}=r;Ge(i,"slice");const[o,c]=Tm(i,s,a);i_(i,o,c);const l=t.data.get(i.dataId).values,u=rI(l,o,c,i.shape,i.dtype);return t.makeTensorInfo(c,i.dtype,u)}const rq={kernelName:um,backendName:"cpu",kernelFunc:Po};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iI(n,e,t,r,i,s,a){const o=e[0],c=s[0],l=new Array(c),u=new Array(o),f=e[1];if(c===0){if(o!==0)throw new Error(qS(o));const m=gn(t,0),v=gn(i,0);return[m,[0,f],v,l,u]}let d=!0,h=0;const p=new Array(c).fill(0);for(let m=0;m<o;++m){const v=n[m*f];if(v<0)throw new Error(XS(m,v));if(v>=c)throw new Error(KS(m,v,c));++p[v],d=d&&v>=h,h=v}let g=!0;for(let m=0;m<c;++m){const v=p[m]===0;l[m]=v,g=g&&!v,p[m]=Math.max(p[m],1),m>0&&(p[m]+=p[m-1])}if(g&&d){const m=n,v=r;for(let x=0;x<o;++x)u[x]=x;return[m,[o,f],v,l,u]}else{const m=p[c-1],v=gn(t,m*f),x=gn(i,m),b=new Array(c).fill(0);for(let _=0;_<o;++_){const w=n[_*f],E=b[w],S=(w===0?0:p[w-1])+E;b[w]++;for(let T=0;T<f;++T)v[S*f+T]=n[_*f+T];x[S]=r[_],u[_]=S}for(let _=0;_<c;++_)if(b[_]===0){const E=_===0?0:p[_-1];v[E*f+0]=_;for(let S=1;S<f;++S)v[E*f+S]=0;x[E]=a}return[v,[m,f],x,l,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sI(n,e,t,r,i){const s=ue(r),a=e[0],o=i.length,c=[];let l=1,u=-1;for(let m=0;m<o;++m){const v=i[m];if(v===-1){if(u!==-1)throw new Error(jS(u,m));u=m,c.push(1)}else{if(v<0)throw new Error(YS(m,v));l*=v,c.push(v)}}if(u!==-1){if(l<=0)throw new Error(ZS());const m=Math.trunc(s/l);if(l*m!==s)throw new Error(QS(r,c));c[u]=m}if(ue(c)!==s)throw new Error(JS(r,c));const d=r.length,h=[];if(d>0){h[d-1]=1;for(let m=d-2;m>=0;--m)h[m]=h[m+1]*r[m+1]}const p=[];if(o>0){p[o-1]=1;for(let m=o-2;m>=0;--m)p[m]=p[m+1]*c[m+1]}const g=gn(t,a*o);for(let m=0;m<a;++m){let v=0;for(let x=0;x<d;++x)v+=n[m*d+x]*h[x];for(let x=0;x<o;++x)g[m*o+x]=Math.trunc(v/p[x]),v%=p[x]}return[g,[a,o],c]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ey(n,e,t,r,i,s=!1,a=0){const o=r.length,c=[e[0],n.length/e[0]],l=c[1],f=o>0?i[o-1]+1:0;if(f<0)throw new Error(_x());const d=e.slice();d[0]=f;const h=d.reduce((b,_)=>b*_,1),p=gn(t,h);if(o===0)return f>0&&p.fill(a),[p,d];if(f<=0)throw new Error(_x());let g=0,m=1,v=0,x=i[g];for(;;){let b=0;if(m<o){if(b=i[m],x===b){++m;continue}if(x>=b)throw new Error(eT())}if(x<0||x>=f)throw new Error(tT(x,f));x>v&&p.fill(a,v*l,x*l);for(let _=g;_<m;++_){const w=r[_];if(w<0||w>=c[0])throw new Error(nT(_,r[_],c[0]));for(let E=0;E<l;E++)p[x*l+E]+=n[w*l+E]}if(s)for(let _=0;_<l;_++)p[x*l+_]/=m-g;if(g=m,++m,v=x+1,x=b,m>o)break}return v<f&&p.fill(a,v*l,f*l),[p,d]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iq=Ts(n=>Math.sqrt(n)),sq=Wt(Df,n=>Math.sqrt(n)),aq={kernelName:Df,backendName:"cpu",kernelFunc:sq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aI=En((n,e)=>{const t=n-e;return t*t}),oq=Pn(Lf,aI),cq={kernelName:Lf,backendName:"cpu",kernelFunc:oq};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oI=Ts((n,e)=>{const{pattern:t,replaceGlobal:r,rewrite:i}=e;return n.replace(new RegExp(t,r?"g":""),i)}),lq=Xa(ub,oI),uq={kernelName:ub,backendName:"cpu",kernelFunc:lq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cI(n,e,t,r){const i=Et(n,e.dtype);for(let s=0;s<i.size;s++){const a=i.indexToLoc(s),o=new Array(a.length);for(let c=0;c<o.length;c++)o[c]=a[c]*t[c]+r[c];i.set(e.get(...o),...a)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fq{constructor(e,t,r,i,s,a){this.separator=Ca(e),this.nGramWidths=t,this.leftPad=Ca(r),this.rightPad=Ca(i),this.padWidth=s,this.preserveShort=a}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const r=this.getPadWidth(t);return Math.max(0,e+2*r-t+1)}createNGrams(e,t,r,i,s,a){for(let o=0;o<s;++o){const c=this.getPadWidth(a),l=Math.max(0,c-o),u=Math.max(0,c-(s-(o+1))),f=a-(l+u),d=t+(l>0?0:o-c);let h=0;h+=l*this.leftPad.length;for(let x=0;x<f;++x)h+=e[d+x].length;h+=u*this.rightPad.length;const p=l+u+f-1;h+=p*this.separator.length,r[i+o]=new Uint8Array(h);const g=r[i+o];let m=0;const v=x=>x.forEach(b=>g[m++]=b);for(let x=0;x<l;++x)v(this.leftPad),v(this.separator);for(let x=0;x<f-1;++x)v(e[d+x]),v(this.separator);if(f>0){v(e[d+f-1]);for(let x=0;x<u;++x)v(this.separator),v(this.rightPad)}else{for(let x=0;x<u-1;++x)v(this.rightPad),v(this.separator);v(this.rightPad)}}}compute(e,t){const r=e.length,i=t.length;if(i>0){let c=t[0];if(c!==0)throw new Error(`First split value must be 0, got ${c}`);for(let l=1;l<i;++l){let u=t[l]>=c;if(u=u&&t[l]<=r,!u)throw new Error(`Invalid split value ${t[l]}, must be in [${c}, ${r}]`);c=t[l]}if(c!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${c}`)}const s=i-1,a=gn("int32",i);if(r===0||i===0){const c=new Array(r);for(let l=0;l<=s;++l)a[l]=0;return[c,a]}a[0]=0;for(let c=1;c<=s;++c){const l=t[c]-t[c-1];let u=0;this.nGramWidths.forEach(f=>{u+=this.getNumNGrams(l,f)}),this.preserveShort&&l>0&&u===0&&(u=1),a[c]=a[c-1]+u}const o=new Array(a[s]);for(let c=0;c<s;++c){const l=t[c];let u=a[c];if(this.nGramWidths.forEach(f=>{const d=t[c+1]-t[c],h=this.getNumNGrams(d,f);this.createNGrams(e,l,o,u,h,f),u+=h}),this.preserveShort&&u===a[c]){const f=t[c+1]-t[c];if(f===0)continue;const d=f+2*this.padWidth,h=1;this.createNGrams(e,l,o,u,h,d)}}return[o,a]}}function lI(n,e,t,r,i,s,a,o){return new fq(t,r,i,s,a,o).compute(n,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dq(n,e,t,r){if(!n.length)return;if(e.length===0){for(let s=0;s<n.length;++s)r.push(n.subarray(s,s+1));return}if(e.length===1){const s=e[0];let a=n.indexOf(s);for(;a!==-1;){const o=n.subarray(0,a);(!t||o.length!==0)&&r.push(o),n=n.subarray(a+1),a=n.indexOf(s)}(!t||n.length!==0)&&r.push(n);return}let i=0;for(let s=0;s<n.length+1;s++)if(s===n.length||e.indexOf(n[s])!==-1){const a=n.subarray(i,s);(!t||a.length!==0)&&r.push(a),i=s+1}}function uI(n,e,t){const r=n.length,i=[];let s=0,a=0;const o=new Array(r);for(let d=0;d<r;++d){const h=i.length;dq(n[d],e,t,i);const p=i.length-h;o[d]=p,s+=p,a=Math.max(a,p)}const c=gn("int32",s*2),l=new Array(s),u=[r,a];let f=0;for(let d=0;d<r;++d)for(let h=0;h<o[d];++h)c[f*2]=d,c[f*2+1]=h,l[f]=i[f],++f;return[c,l,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fI(n,e){const t=gn("int32",n.length);for(let r=0;r<n.length;++r)t[r]=KP(n[r]).modulo(e).getLowBitsUnsigned();return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dI=En((n,e)=>n-e),hq=Y_((n,e,t,r)=>({real:n-t,imag:e-r})),ty=Pn(Of,dI,hq),pq={kernelName:Of,backendName:"cpu",kernelFunc:ty};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hI(n,e){const t=new Array(n.rank);for(let i=0;i<t.length;i++)t[i]=n.shape[i]*e[i];const r=Et(t,n.dtype);for(let i=0;i<r.values.length;++i){const s=r.indexToLoc(i),a=new Array(n.rank);for(let c=0;c<a.length;c++)a[c]=s[c]%n.shape[c];const o=n.locToIndex(a);r.values[i]=n.values[o]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const du=(n,e)=>{const t=e.value-n.value;return t===0?n.index-e.index:t};function pI(n,e,t=0,r=n.length-1){for(;r>t;){if(r-t>600){const o=r-t+1,c=e-t+1,l=Math.log(o),u=.5*Math.exp(2*l/3),f=.5*Math.sqrt(l*u*(o-u)/o)*Math.sign(c-o/2),d=Math.max(t,Math.floor(e-c*u/o+f)),h=Math.min(r,Math.floor(e+(o-c)*u/o+f));pI(n,e,d,h)}const i=n[e];let s=t,a=r;for(wc(n,t,e),du(n[r],i)>0&&wc(n,t,r);s<a;){for(wc(n,s,a),s++,a--;du(n[s],i)<0;)s=s+1;for(;du(n[a],i)>0;)a=a-1}du(n[t],i)===0?wc(n,t,a):(a=a+1,wc(n,a,r)),a<=e&&(t=a+1),e<=a&&(r=a-1)}}function mI(n,e,t,r,i){const s=e[e.length-1],[a,o]=[n.length/s,s],c=ir(t,a*r),l=ir("int32",a*r);for(let f=0;f<a;f++){const d=f*o,h=n.subarray(d,d+o);let p=new Array(h.length);h.forEach((x,b)=>p[b]={value:x,index:b}),r<p.length&&(pI(p,r),p=p.slice(0,r)),i&&p.sort(du);const g=f*r,m=c.subarray(g,g+r),v=l.subarray(g,g+r);for(let x=0;x<r;x++)m[x]=p[x].value,v[x]=p[x].index}const u=e.slice();return u[u.length-1]=r,[Et(u,t,c),Et(u,"int32",l)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vI(n,e,t,r){const i=St(e,t)[0],s=[1,t[0],1];for(let p=0;p<i;p++)s[0]*=t[p];s[1]=t[i];for(let p=i+1;p<t.length;p++)s[2]*=t[p];const a=new Map,o=new Int32Array(t[i]),c=new jn(s,r,n),l=[],u=s[0]===1&&s[2]===1;for(let p=0;p<t[i];p++){let g;if(u)g=n[p].toString();else{const v=[];for(let x=0;x<s[0];x++)for(let b=0;b<s[2];b++)v.push(c.get(x,p,b));g=v.join(",")}const m=a.get(g);if(m!=null)o[p]=m;else{const v=a.size;a.set(g,v),o[p]=v,l.push(p)}}const f=s.slice();f[1]=a.size;const d=new jn(f,r);l.forEach((p,g)=>{for(let m=0;m<s[0];m++)for(let v=0;v<s[2];v++)d.set(c.get(m,p,v),m,g,v)});const h=t.slice();return h[i]=f[1],{outputValues:d.values,outputShape:h,indices:o}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mq=Object.freeze(Object.defineProperty({__proto__:null,addImpl:TC,bincountImpl:Z_,bincountReduceImpl:AC,bitwiseAndImpl:CC,castImpl:SC,ceilImpl:IC,concatImpl:MC,equalImpl:RC,expImpl:kC,expm1Impl:LC,floorDivImpl:zC,floorImpl:OC,gatherNdImpl:PC,gatherV2Impl:FC,greaterEqualImpl:UC,greaterImpl:$C,lessEqualImpl:VC,lessImpl:BC,linSpaceImpl:GC,logImpl:HC,maxImpl:WC,maximumImpl:qC,minimumImpl:XC,multiplyImpl:Q_,negImpl:KC,notEqualImpl:jC,prodImpl:YC,raggedGatherImpl:ZC,raggedRangeImpl:QC,raggedTensorToTensorImpl:JC,rangeImpl:eI,rsqrtImpl:tI,scatterImpl:xo,sigmoidImpl:tq,simpleAbsImpl:EC,sliceImpl:rI,sparseFillEmptyRowsImpl:iI,sparseReshapeImpl:sI,sparseSegmentReductionImpl:ey,sqrtImpl:iq,squaredDifferenceImpl:aI,staticRegexReplaceImpl:oI,stridedSliceImpl:cI,stringNGramsImpl:lI,stringSplitImpl:uI,stringToHashBucketFastImpl:fI,subImpl:dI,tileImpl:hI,topKImpl:mI,transposeImpl:J_,uniqueImpl:vI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */D3("cpu",()=>new $m,1);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gI=Wt(rf,n=>n>=0?n:Math.exp(n)-1),vq={kernelName:rf,backendName:"cpu",kernelFunc:gI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xI(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{alpha:s}=r;Ge([i],"leakyRelu");const a=ue(i.shape),o=t.data.get(i.dataId).values,c=ir("float32",a);for(let l=0;l<o.length;l++)c[l]=o[l]<0?s*o[l]:o[l];return t.makeTensorInfo(i.shape,"float32",c)}const gq={kernelName:Fp,backendName:"cpu",kernelFunc:xI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xq=En((n,e)=>n<0?e*n:n);function bI(n){const{inputs:e,backend:t}=n,{x:r,alpha:i}=e;Ge([r,i],"prelu");const s=t.data.get(r.dataId).values,a=t.data.get(i.dataId).values,[o,c]=xq(r.shape,i.shape,s,a,"float32");return t.makeTensorInfo(c,"float32",o)}const bq={kernelName:rm,backendName:"cpu",kernelFunc:bI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _I=Wt(Ef,n=>Math.max(0,n)),_q={kernelName:Ef,backendName:"cpu",kernelFunc:_I};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yI=Wt(Sf,n=>Math.min(Math.max(0,n),6)),yq={kernelName:Sf,backendName:"cpu",kernelFunc:yI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qh(n,e,t,r,i){if(t==="linear")return _s({inputs:{x:e},backend:n});if(t==="relu")return _I({inputs:{x:e},backend:n});if(t==="elu")return gI({inputs:{x:e},backend:n});if(t==="relu6")return yI({inputs:{x:e},backend:n});if(t==="prelu")return bI({inputs:{x:e,alpha:r},backend:n});if(t==="leakyrelu")return xI({inputs:{x:e},backend:n,attrs:{alpha:i}});if(t==="sigmoid")return nI({inputs:{x:e},backend:n});throw new Error(`Activation ${t} has not been implemented for the CPU backend.`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function en(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{shape:s}=r,a=ue(i.shape),o=$E(s,a),c=ue(o);R(a===c,()=>`The new shape (${o}) has ${c} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`),t.incRef(i.dataId);const l=t.data.get(i.dataId);if(l.complexTensorInfos!=null){const u=l.complexTensorInfos.real,f=l.complexTensorInfos.imag;u.shape=o,f.shape=o}return{dataId:i.dataId,shape:o,dtype:i.dtype}}const wq={kernelName:sm,backendName:"cpu",kernelFunc:en};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wI(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s}=e,{transposeA:a,transposeB:o}=r;Ge([i,s],"matMul");const c=i.shape.length,l=s.shape.length,u=a?i.shape[c-2]:i.shape[c-1],f=o?s.shape[l-1]:s.shape[l-2],d=a?i.shape[c-1]:i.shape[c-2],h=o?s.shape[l-2]:s.shape[l-1],p=i.shape.slice(0,-2),g=s.shape.slice(0,-2),m=ue(p),v=ue(g),b=pt(i.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,h]);R(u===f,()=>`Error in matMul: inner shapes (${u}) and (${f}) of Tensors with shapes ${i.shape} and ${s.shape} and transposeA=${a} and transposeB=${o} must match.`);const _=a?[m,u,d]:[m,d,u],w=o?[v,h,f]:[v,f,h],E=en({inputs:{x:i},backend:t,attrs:{shape:_}}),S=en({inputs:{x:s},backend:t,attrs:{shape:w}}),T=a?E.shape[1]:E.shape[2],C=a?E.shape[2]:E.shape[1],y=o?S.shape[1]:S.shape[2],A=Math.max(m,v),k=t.data.get(E.dataId).values,M=t.data.get(S.dataId).values,L=Qe(E.shape),z=Qe(S.shape),[D,F,O]=a?[L[0],1,L[1]]:[L[0],L[1],1],[V,J,Q]=o?[1,z[1],z[0]]:[z[1],1,z[0]],de=C*y,le=Et([A,C,y],E.dtype),H=le.values,q=t.blockSize;for(let oe=0;oe<A;oe++){const fe=oe%m,_e=oe%v;for(let xe=0;xe<C;xe+=q){const Se=Math.min(xe+q,C);for(let Me=0;Me<y;Me+=q){const Le=Math.min(Me+q,y);for(let B=0;B<T;B+=q){const bt=Math.min(B+q,T);for(let qe=xe;qe<Se;qe++)for(let Xe=Me;Xe<Le;Xe++){let Oe=0;for(let it=B;it<bt;it++){const rt=k[fe*D+qe*F+it*O],P=M[it*V+Xe*J+_e*Q];Oe+=rt*P}H[oe*de+(qe*y+Xe)]+=Oe}}}}}return t.disposeIntermediateTensorInfo(E),t.disposeIntermediateTensorInfo(S),t.makeTensorInfo(b,le.dtype,le.values)}const Eq={kernelName:Ep,backendName:"cpu",kernelFunc:wI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sq(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s,bias:a,preluActivationWeights:o}=e,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:f}=r;let d,h,p;const g=[];d=wI({inputs:{a:i,b:s},attrs:{transposeA:c,transposeB:l},backend:t}),a&&(h=ol({inputs:{a:d,b:a},backend:t}),g.push(d),d=h),u&&(p=Qh(t,d,u,o,f),g.push(d),d=p);for(const v of g)t.disposeIntermediateTensorInfo(v);return d}const Tq={kernelName:kh,backendName:"cpu",kernelFunc:Sq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Aq=Wt(Hu,n=>Math.acos(n)),Cq={kernelName:Hu,backendName:"cpu",kernelFunc:Aq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iq=Wt(Wu,n=>Math.acosh(n)),Mq={kernelName:Wu,backendName:"cpu",kernelFunc:Iq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rq(n){const{inputs:e,backend:t}=n,r=e;Ge(e,"addN");const i=r.map(o=>t.data.get(o.dataId).values),s=Et(r[0].shape,r[0].dtype),a=s.values;for(let o=0;o<r.length;o++){const c=i[o];for(let l=0;l<a.length;l++)a[l]+=c[l]}return t.makeTensorInfo(s.shape,s.dtype,s.values)}const Nq={kernelName:M0,backendName:"cpu",kernelFunc:Rq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kq(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r;Ge(i,"all");const o=St(s,i.shape);let c=o;const l=pn(c,i.shape.length);let u=i;l!=null&&(u=Nr({inputs:{x:i},backend:t,attrs:{perm:l}}),c=yn(c.length,i.shape.length)),Zn("all",c,u.shape.length);const[f,d]=Wn(u.shape,c),h=ue(d),p=sr(ue(f),u.dtype),g=t.data.get(u.dataId).values;for(let v=0;v<p.length;++v){const x=v*h;let b=g[x];for(let _=0;_<h;++_){const w=g[x+_];b=b&&w}p[v]=b}l!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(f,u.dtype,p);if(a){const v=Cn(f,o),x=en({inputs:{x:m},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(m),x}return m}const Dq={kernelName:R0,backendName:"cpu",kernelFunc:kq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lq(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r;Ge(i,"any");const o=St(s,i.shape);let c=o;const l=pn(c,i.shape.length);let u=i;l!=null&&(u=Nr({inputs:{x:i},backend:t,attrs:{perm:l}}),c=yn(c.length,i.shape.length)),Zn("any",c,u.shape.length);const[f,d]=Wn(u.shape,c),h=ue(d),p=sr(ue(f),u.dtype),g=t.data.get(u.dataId).values;for(let v=0;v<p.length;++v){const x=v*h;let b=g[x];for(let _=0;_<h;++_){const w=g[x+_];b=b||w}p[v]=b}l!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(f,u.dtype,p);if(a){const v=Cn(f,o),x=en({inputs:{x:m},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(m),x}return m}const Oq={kernelName:N0,backendName:"cpu",kernelFunc:Lq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zq(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;Ge(i,"argMax");let a=St(s,i.shape);const o=pn(a,i.shape.length);let c=i;const l=[];o!=null&&(c=Nr({inputs:{x:i},backend:t,attrs:{perm:o}}),l.push(c),a=yn(a.length,c.shape.length)),a=[a[0]],Zn("argMax",a,c.shape.length);const[u,f]=Wn(c.shape,a),d=ue(u),h=sr(d,"int32"),p=ue(f),g=t.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const v=m*p;let x=g[v],b=0;for(let _=0;_<p;++_){const w=g[v+_];w>x&&(x=w,b=_)}h[m]=b}return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.makeTensorInfo(u,"int32",h)}const Pq={kernelName:bp,backendName:"cpu",kernelFunc:zq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fq(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;Ge(i,"argMin");let a=St(s,i.shape);const o=pn(a,i.shape.length);let c=i;const l=[];o!=null&&(c=Nr({inputs:{x:i},backend:t,attrs:{perm:o}}),l.push(c),a=yn(a.length,c.shape.length)),a=[a[0]],Zn("argMin",a,c.shape.length);const[u,f]=Wn(c.shape,a),d=ue(u),h=sr(d,"int32"),p=ue(f),g=t.data.get(c.dataId).values;for(let m=0;m<h.length;++m){const v=m*p;let x=g[v],b=0;for(let _=0;_<p;++_){const w=g[v+_];w<x&&(x=w,b=_)}h[m]=b}return l.forEach(m=>t.disposeIntermediateTensorInfo(m)),t.makeTensorInfo(u,"int32",h)}const $q={kernelName:_p,backendName:"cpu",kernelFunc:Fq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uq=Wt(qu,n=>Math.asin(n)),Bq={kernelName:qu,backendName:"cpu",kernelFunc:Uq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vq=Wt(Xu,n=>Math.asinh(n)),Gq={kernelName:Xu,backendName:"cpu",kernelFunc:Vq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hq=Wt(Ku,n=>Math.atan(n)),Wq={kernelName:Ku,backendName:"cpu",kernelFunc:Hq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qq=En((n,e)=>Math.atan2(n,e)),Xq=Pn(Yu,qq),Kq={kernelName:Yu,backendName:"cpu",kernelFunc:Xq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jq=Wt(ju,n=>Math.atanh(n)),Yq={kernelName:ju,backendName:"cpu",kernelFunc:jq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ny(n,e,t,r,i,s){const a=i.strideHeight,o=i.strideWidth,c=i.dilationHeight,l=i.dilationWidth,u=i.effectiveFilterHeight,f=i.effectiveFilterWidth,d=i.padInfo.top,h=i.padInfo.left,p=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,g=Et(i.outShape,t),m=g.values,v=i.outShape[1]*i.outShape[2]*i.outShape[3],x=i.outShape[2]*i.outShape[3],b=i.outShape[3];for(let _=0;_<i.batchSize;++_){const w=_*v,E=_*r[0];for(let S=0;S<i.inChannels;++S)for(let T=0;T<i.outHeight;++T){const C=T*a-d,y=Math.max(0,C),A=Math.min(i.inHeight,u+C),k=w+T*x;for(let M=0;M<i.outWidth;++M){const L=M*o-h,z=Math.max(0,L),D=Math.min(i.inWidth,f+L);let F=p,O=0,V=0;for(let Q=y;Q<A;Q+=c){const de=E+Q*r[1];for(let le=z;le<D;le+=l){const H=de+le*r[2],q=n[H+S];s==="max"&&q>F?F=q:s==="avg"&&(O+=q,V++)}if(isNaN(F))break}const J=k+M*b+S;m[J]=s==="avg"?O/V:F}}}return g}function EI(n,e,t,r,i=!1,s=!1){const a=Et(r.outShape,"int32"),o=r.strideHeight,c=r.strideWidth,l=r.dilationHeight,u=r.dilationWidth,f=r.effectiveFilterHeight,d=r.effectiveFilterWidth,h=r.padInfo.top,p=r.padInfo.left,g=Et(e,t,n);for(let m=0;m<r.batchSize;++m)for(let v=0;v<r.inChannels;++v)for(let x=0;x<r.outHeight;++x){const b=x*o-h;let _=b;for(;_<0;)_+=l;const w=Math.min(r.inHeight,f+b);for(let E=0;E<r.outWidth;++E){const S=E*c-p;let T=S;for(;T<0;)T+=u;const C=Math.min(r.inWidth,d+S);let y=Number.NEGATIVE_INFINITY,A=-1;for(let k=_;k<w;k+=l){const M=k-b;for(let L=T;L<C;L+=u){const z=L-S,D=g.get(m,k,L,v);D>y&&(y=D,i?A=s?((m*r.inHeight+k)*r.inWidth+L)*r.inChannels+v:(k*r.inWidth+L)*r.inChannels+v:A=M*d+z)}}a.set(A,m,x,E,v)}}return a}function SI(n,e,t,r,i,s){const a=i.strideDepth,o=i.strideHeight,c=i.strideWidth,l=i.dilationDepth,u=i.dilationHeight,f=i.dilationWidth,d=i.effectiveFilterDepth,h=i.effectiveFilterHeight,p=i.effectiveFilterWidth,g=i.padInfo.front,m=i.padInfo.top,v=i.padInfo.left,x=s==="max"?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,b=Et(i.outShape,t),_=b.values,w=i.outShape[1]*i.outShape[2]*i.outShape[3]*i.outShape[4],E=i.outShape[2]*i.outShape[3]*i.outShape[4],S=i.outShape[3]*i.outShape[4],T=i.outShape[4];for(let C=0;C<i.batchSize;++C){const y=C*w,A=C*r[0];for(let k=0;k<i.inChannels;++k)for(let M=0;M<i.outDepth;++M){const L=M*a-g;let z=L;for(;z<0;)z+=l;const D=Math.min(i.inDepth,d+L),F=y+M*E;for(let O=0;O<i.outHeight;++O){const V=O*o-m;let J=V;for(;J<0;)J+=u;const Q=Math.min(i.inHeight,h+V),de=F+O*S;for(let le=0;le<i.outWidth;++le){const H=le*c-v;let q=H;for(;q<0;)q+=f;const oe=Math.min(i.inWidth,p+H),fe=de+le*T;let _e=x,xe=0,Se=0;for(let Le=z;Le<D;Le+=l){const B=A+Le*r[1];for(let bt=J;bt<Q;bt+=u){const qe=B+bt*r[2];for(let Xe=q;Xe<oe;Xe+=f){const Oe=qe+Xe*r[3],it=n[Oe+k];if(s==="max"&&it>_e?_e=it:s==="avg"&&(xe+=it,Se++),isNaN(_e))break}if(isNaN(_e))break}if(isNaN(_e))break}const Me=fe+k;_[Me]=s==="avg"?xe/Math.max(Se,1):_e}}}}return b}function Zq(n,e){const t=Et(e.outShape,"int32"),r=e.strideDepth,i=e.strideHeight,s=e.strideWidth,a=e.dilationDepth,o=e.dilationHeight,c=e.dilationWidth,l=e.effectiveFilterDepth,u=e.effectiveFilterHeight,f=e.effectiveFilterWidth,d=e.padInfo.front,h=e.padInfo.top,p=e.padInfo.left;for(let g=0;g<e.batchSize;++g)for(let m=0;m<e.inChannels;++m)for(let v=0;v<e.outDepth;++v){const x=v*r-d;let b=x;for(;b<0;)b+=a;const _=Math.min(e.inDepth,l+x);for(let w=0;w<e.outHeight;++w){const E=w*i-h;let S=E;for(;S<0;)S+=o;const T=Math.min(e.inHeight,u+E);for(let C=0;C<e.outWidth;++C){const y=C*s-p;let A=y;for(;A<0;)A+=c;const k=Math.min(e.inWidth,f+y);let M=Number.NEGATIVE_INFINITY,L=-1;for(let z=b;z<_;z+=a){const D=z-x;for(let F=S;F<T;F+=o){const O=F-E;for(let V=A;V<k;V+=c){const J=V-y,Q=n.get(g,z,F,V,m);Q>=M&&(M=Q,L=D*u*f+O*u+J)}}}t.set(L,g,v,w,C,m)}}}return t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qq(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;Ge(i,"avgPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:c}=r,l=1;R(or(a,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const u=Ii(i.shape,s,a,l,o,c);let f;if(u.filterWidth===1&&u.filterHeight===1&&Pt(u.inShape,u.outShape))f=_s({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,h=Qe(i.shape),p=ny(d,i.shape,i.dtype,h,u,"avg");f=t.makeTensorInfo(u.outShape,i.dtype,p.values)}return f}const Jq={kernelName:yp,backendName:"cpu",kernelFunc:Qq};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:c,dataFormat:l}=r;Ge(i,"avgPool3d");const u=ta(i.shape,s,a,1,o,c,l),f=t.data.get(i.dataId).values,d=SI(f,i.shape,i.dtype,Qe(i.shape),u,"avg");return t.makeTensorInfo(d.shape,"float32",d.values)}const tX={kernelName:wp,backendName:"cpu",kernelFunc:eX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nX(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:c,dimRoundingMode:l}=r;Ge([i,s],"avgPool3DGrad");const u=ta(s.shape,a,o,1,c,l),f=u.strideDepth,d=u.strideHeight,h=u.strideWidth,p=u.filterDepth,g=u.filterHeight,m=u.filterWidth,v=u.dilationDepth,x=u.dilationHeight,b=u.dilationWidth,_=u.effectiveFilterDepth,w=u.effectiveFilterHeight,E=u.effectiveFilterWidth,S=_-1-u.padInfo.front,T=E-1-u.padInfo.left,C=w-1-u.padInfo.top,y=Et(s.shape,"float32"),A=1/(p*g*m),k=t.bufferSync(i);for(let M=0;M<u.batchSize;++M)for(let L=0;L<u.inChannels;++L)for(let z=0;z<u.inDepth;++z)for(let D=0;D<u.inHeight;++D)for(let F=0;F<u.inWidth;++F){const O=z-S,V=D-C,J=F-T;let Q=0;for(let de=0;de<_;de+=v){const le=(O+de)/f;if(!(le<0||le>=u.outDepth||Math.floor(le)!==le))for(let H=0;H<w;H+=x){const q=(V+H)/d;if(!(q<0||q>=u.outHeight||Math.floor(q)!==q))for(let oe=0;oe<E;oe+=b){const fe=(J+oe)/h;if(fe<0||fe>=u.outWidth||Math.floor(fe)!==fe)continue;const _e=k.get(M,le,q,fe,L);Q+=_e}}}y.set(Q*A,M,z,D,F,L)}return t.makeTensorInfo(y.shape,y.dtype,y.values)}const rX={kernelName:D0,backendName:"cpu",kernelFunc:nX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iX(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,a=s;Ge([i,s],"avgPoolGrad");const{filterSize:o,strides:c,pad:l}=r,u=Ii(a.shape,o,c,1,l),f=u.strideHeight,d=u.strideWidth,h=u.filterHeight,p=u.filterWidth,g=u.dilationHeight,m=u.dilationWidth,v=u.effectiveFilterHeight,x=u.effectiveFilterWidth,b=x-1-u.padInfo.left,_=v-1-u.padInfo.top,w=Et(a.shape,"float32"),E=1/(h*p),S=t.data.get(i.dataId).values,T=Et(i.shape,"float32",S);for(let C=0;C<u.batchSize;++C)for(let y=0;y<u.inChannels;++y)for(let A=0;A<u.inHeight;++A)for(let k=0;k<u.inWidth;++k){const M=A-_,L=k-b;let z=0;for(let D=0;D<v;D+=g){const F=(M+D)/f;if(!(F<0||F>=u.outHeight||Math.floor(F)!==F))for(let O=0;O<x;O+=m){const V=(L+O)/d;if(V<0||V>=u.outWidth||Math.floor(V)!==V)continue;const J=T.get(C,F,V,y);z+=J}}w.set(z*E,C,A,k,y)}return t.makeTensorInfo(w.shape,w.dtype,w.values)}const sX={kernelName:k0,backendName:"cpu",kernelFunc:iX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,scale:s,offset:a,mean:o,variance:c}=e;R(o.shape.length===c.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(a==null||o.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(s==null||o.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks."),Ge([i,o,c,s,a],"batchNorm");let{varianceEpsilon:l}=r;l==null&&(l=.001);const u=t.data.get(i.dataId).values,f=t.data.get(o.dataId).values,d=t.data.get(c.dataId).values,h=s?t.data.get(s.dataId).values:new Float32Array([1]),p=a?t.data.get(a.dataId).values:new Float32Array([0]),g=new Float32Array(u.length),m=p.length,v=h.length,x=d.length,b=f.length;let _=0,w=0,E=0,S=0;for(let T=0;T<u.length;++T)g[T]=p[_++]+(u[T]-f[w++])*h[E++]/Math.sqrt(d[S++]+l),_>=m&&(_=0),w>=b&&(w=0),E>=v&&(E=0),S>=x&&(S=0);return t.makeTensorInfo(i.shape,i.dtype,g)}const oX={kernelName:Op,backendName:"cpu",kernelFunc:aX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,crops:a}=r;Ge([i],"batchToSpaceND");const o=s.reduce((v,x)=>v*x),c=Kf(i.shape,s,o),l=jf(c.length,s.length),u=Yf(i.shape,s,o),f=d_(a,s.length),d=h_(u,a,s.length),h=en({inputs:{x:i},backend:t,attrs:{shape:c}}),p=Nr({inputs:{x:h},backend:t,attrs:{perm:l}}),g=en({inputs:{x:p},backend:t,attrs:{shape:u}}),m=Po({inputs:{x:g},backend:t,attrs:{begin:f,size:d}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),m}const lX={kernelName:Sp,backendName:"cpu",kernelFunc:cX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:a}=r,o=t.data.get(i.dataId).values,c=t.data.get(s.dataId).values,l=Z_(o,c,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,l)}const fX={kernelName:L0,backendName:"cpu",kernelFunc:uX};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dX(n){const{inputs:e,backend:t}=n,{s0:r,s1:i}=e,s=t.data.get(r.dataId).values,a=t.data.get(i.dataId).values,o=pt(Array.from(s),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const hX={kernelName:WE,backendName:"cpu",kernelFunc:dX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pX=Wt(Ju,(n,e)=>{const t=e;return n>t.clipValueMax?t.clipValueMax:n<t.clipValueMin?t.clipValueMin:n}),mX={kernelName:Ju,backendName:"cpu",kernelFunc:pX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vX=n=>{const{x:e}=n.inputs,t=n.backend,r=new Float32Array(ue(e.shape)),i=t.data.get(e.dataId),s=i.complexTensorInfos.real,a=i.complexTensorInfos.imag,o=t.data.get(s.dataId).values,c=t.data.get(a.dataId).values;for(let l=0;l<o.length;l++){const u=o[l],f=c[l];r[l]=Math.hypot(u,f)}return t.makeOutput(r,e.shape,"float32")},gX={kernelName:Tp,backendName:"cpu",kernelFunc:vX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cl(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.data.get(r.dataId).complexTensorInfos.imag,s=t.data.get(i.dataId).values;return t.makeTensorInfo(i.shape,i.dtype,s)}const xX={kernelName:Q0,backendName:"cpu",kernelFunc:cl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ll(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r,s=St(i,e[0].shape)[0],a=e.map(g=>g.shape);l_(a,s);let o=ds(e.map(g=>g.shape),s);if(ue(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const c=e.filter(g=>ue(g.shape)>0);if(c.length===1)return _s({inputs:{x:c[0]},backend:t});if(c[0].dtype==="complex64"){const g=c.map(_=>zo({inputs:{input:_},backend:t})),m=c.map(_=>cl({inputs:{input:_},backend:t})),v=ll({inputs:g,backend:t,attrs:{axis:s}}),x=ll({inputs:m,backend:t,attrs:{axis:s}}),b=Ur({inputs:{real:v,imag:x},backend:t});return g.forEach(_=>t.disposeIntermediateTensorInfo(_)),m.forEach(_=>t.disposeIntermediateTensorInfo(_)),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(x),b}const l=c.map(g=>{const v=[-1,ue(g.shape.slice(s))];return en({inputs:{x:g},backend:t,attrs:{shape:v}})}),u=l.map(g=>({vals:t.data.get(g.dataId).values,shape:g.shape}));o=ds(l.map(g=>g.shape),1);const f=l[0].shape[0]===1,d=MC(u,o,e[0].dtype,f),h=ds(c.map(g=>g.shape),s),p=t.makeTensorInfo(h,e[0].dtype,d);return l.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}const bX={kernelName:Ap,backendName:"cpu",kernelFunc:ll};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TI(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:a,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=r;Ge([i,s],"conv2d");const f=na(c),d=Yn(i.shape,s.shape,a,l,o,u,!1,f),h=d.filterHeight,p=d.filterWidth,g=d.dilationHeight,m=d.dilationWidth,v=d.padInfo.left,x=d.padInfo.top,b=d.dataFormat==="channelsLast",_=new jn(d.outShape,i.dtype),w=Qe(i.shape),E=Qe(s.shape),S=w[0],T=b?w[1]:w[2],C=b?w[2]:1,y=b?1:w[1],A=_.strides[0],k=b?_.strides[1]:_.strides[2],M=b?_.strides[2]:1,L=b?1:_.strides[1],z=t.data.get(i.dataId).values,D=t.data.get(s.dataId).values,F=_.values;for(let O=0;O<d.batchSize;++O){const V=O*S,J=O*A;for(let Q=0;Q<d.outHeight;++Q){const de=J+Q*k,le=Q*d.strideHeight-x;for(let H=0;H<h;++H){const q=le+H*g;if(q<0||q>=d.inHeight)continue;const oe=H*E[0],fe=V+q*T;for(let _e=0;_e<d.outWidth;++_e){const xe=de+_e*M,Se=_e*d.strideWidth-v;for(let Me=0;Me<p;++Me){const Le=Se+Me*m;if(Le<0||Le>=d.inWidth)continue;const B=oe+Me*E[1],bt=fe+Le*C;let qe=B;for(let Xe=0;Xe<d.inChannels;++Xe){const Oe=z[bt+Xe*y];for(let it=0;it<d.outChannels;++it)F[xe+it*L]+=Oe*D[qe+it];qe+=d.outChannels}}}}}}return t.makeTensorInfo(_.shape,_.dtype,F)}const _X={kernelName:Cp,backendName:"cpu",kernelFunc:TI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:a,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=r;Ge([i,s],"conv2dBackpropFilter");const f=na(c),d=Yn(i.shape,u,a,1,o,l,!1,f),{strideHeight:h,strideWidth:p,filterHeight:g,filterWidth:m}=d,v=d.dataFormat==="channelsLast",x=new jn(d.filterShape,"float32"),b=d.padInfo.left,_=d.padInfo.top,w=t.data.get(i.dataId).values,E=t.data.get(s.dataId).values,S=new jn(i.shape,i.dtype,w),T=new jn(s.shape,s.dtype,E);for(let C=0;C<g;++C){const y=Math.max(0,Math.ceil((_-C)/h)),A=Math.min(d.outHeight,(d.inHeight+_-C)/h);for(let k=0;k<m;++k){const M=Math.max(0,Math.ceil((b-k)/p)),L=Math.min(d.outWidth,(d.inWidth+b-k)/p);for(let z=0;z<d.inChannels;++z)for(let D=0;D<d.outChannels;++D){let F=0;for(let O=0;O<d.batchSize;++O)for(let V=y;V<A;++V){const J=C+V*h-_;for(let Q=M;Q<L;++Q){const de=k+Q*p-b;v?F+=S.get(O,J,de,z)*T.get(O,V,Q,D):F+=S.get(O,z,J,de)*T.get(O,D,V,Q)}}x.set(F,C,k,z,D)}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const wX={kernelName:P0,backendName:"cpu",kernelFunc:yX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EX(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{inputShape:a,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=r;Ge([i,s],"conv2dBackpropInput");const f=Qe(s.shape),d=Qe(i.shape);let h=na(l);const p=Yn(a,s.shape,o,1,c,u,!1,h),g=new jn(p.inShape,"float32"),m=g.values,v=t.data.get(i.dataId).values,x=t.data.get(s.dataId).values,[b,_,w]=f,{batchSize:E,filterHeight:S,filterWidth:T,inChannels:C,inHeight:y,inWidth:A,outChannels:k,outHeight:M,outWidth:L,strideHeight:z,strideWidth:D}=p;h=p.dataFormat;const F=S-1-p.padInfo.top,O=T-1-p.padInfo.left,V=h==="channelsLast",J=g.strides[0],Q=V?g.strides[1]:g.strides[2],de=V?g.strides[2]:1,le=V?1:g.strides[1],H=d[0],q=V?d[1]:d[2],oe=V?d[2]:1,fe=V?1:d[1];for(let _e=0;_e<E;++_e)for(let xe=0;xe<C;++xe)for(let Se=0;Se<y;++Se){const Me=Se-F,Le=Math.max(0,Math.ceil(Me/z)),B=Math.min(M,(S+Me)/z);for(let bt=0;bt<A;++bt){const qe=bt-O,Xe=Math.max(0,Math.ceil(qe/D)),Oe=Math.min(L,(T+qe)/D);let it=0;for(let P=Le;P<B;++P){const I=P*z-Me;for(let ne=Xe;ne<Oe;++ne){const me=ne*D-qe,ve=H*_e+q*P+oe*ne,pe=b*(S-1-I)+_*(T-1-me)+w*xe;for(let Be=0;Be<k;++Be){const Te=v[ve+fe*Be],ke=x[pe+Be];it+=Te*ke}}}const rt=J*_e+Q*Se+de*bt+le*xe;m[rt]=it}}return t.makeTensorInfo(g.shape,g.dtype,g.values)}const SX={kernelName:Ip,backendName:"cpu",kernelFunc:EX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:a,pad:o,dilations:c}=r;Ge([i,s],"conv3d");const l=Ba(i.shape,s.shape,a,c,o),{filterDepth:u,filterHeight:f,filterWidth:d,dilationDepth:h,dilationHeight:p,dilationWidth:g,padInfo:m}=l,v=m.front,x=m.left,b=m.top,_=new jn(l.outShape,i.dtype),w=t.data.get(i.dataId).values,E=t.data.get(s.dataId).values,S=_.values,T=Qe(i.shape),C=Qe(s.shape);for(let y=0;y<l.batchSize;++y){const A=y*T[0],k=y*_.strides[0];for(let M=0;M<l.outDepth;++M){const L=k+M*_.strides[1],z=M*l.strideDepth-v;for(let D=0;D<u;++D){const F=z+D*h;if(F<0||F>=l.inDepth)continue;const O=D*C[0],V=A+F*T[1];for(let J=0;J<l.outHeight;++J){const Q=L+J*_.strides[2],de=J*l.strideHeight-b;for(let le=0;le<f;++le){const H=de+le*p;if(H<0||H>=l.inHeight)continue;const q=O+le*C[1],oe=V+H*T[2];for(let fe=0;fe<l.outWidth;++fe){const _e=Q+fe*l.outChannels,xe=fe*l.strideWidth-x;for(let Se=0;Se<d;++Se){const Me=xe+Se*g;if(Me<0||Me>=l.inWidth)continue;const Le=q+Se*C[2],B=oe+Me*l.inChannels;let bt=Le;for(let qe=0;qe<l.inChannels;++qe){const Xe=w[B+qe];for(let Oe=0;Oe<l.outChannels;++Oe)S[_e+Oe]+=Xe*E[bt+Oe];bt+=l.outChannels}}}}}}}}return t.makeTensorInfo(_.shape,_.dtype,_.values)}const AX={kernelName:Mp,backendName:"cpu",kernelFunc:TX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:a,pad:o,filterShape:c}=r;Ge([i,s],"conv3dBackpropFilterV2");const l=Qe(i.shape),u=Qe(s.shape),f=Ba(i.shape,c,a,1,o),d=f.strideDepth,h=f.strideHeight,p=f.strideWidth,g=f.filterDepth,m=f.filterHeight,v=f.filterWidth,x=new jn(f.filterShape,"float32"),b=x.values,[_,w,E,S]=x.strides,T=t.data.get(s.dataId).values,[C,y,A,k]=u,M=t.data.get(i.dataId).values,[L,z,D,F]=l,O=f.padInfo.front,V=f.padInfo.left,J=f.padInfo.top;for(let Q=0;Q<g;++Q){const de=Math.max(0,Math.ceil((O-Q)/d)),le=Math.min(f.outDepth,(f.inDepth+O-Q)/d),H=Q*_;for(let q=0;q<m;++q){const oe=Math.max(0,Math.ceil((J-q)/h)),fe=Math.min(f.outHeight,(f.inHeight+J-q)/h),_e=q*w+H;for(let xe=0;xe<v;++xe){const Se=Math.max(0,Math.ceil((V-xe)/p)),Me=Math.min(f.outWidth,(f.inWidth+V-xe)/p),Le=xe*E+_e;for(let B=0;B<f.inChannels;++B){const bt=B*S+Le;for(let qe=0;qe<f.outChannels;++qe){let Xe=0;for(let Oe=0;Oe<f.batchSize;++Oe){const it=Oe*L,rt=Oe*C;for(let P=de;P<le;++P){const ne=(Q+P*d-O)*z+it,me=P*y+rt;for(let ve=oe;ve<fe;++ve){const Be=(q+ve*h-J)*D+ne,Te=ve*A+me;for(let ke=Se;ke<Me;++ke){const we=(xe+ke*p-V)*F+Be,Fe=ke*k+Te;Xe+=M[we+B]*T[Fe+qe]}}}}b[bt+qe]=Xe}}}}}return t.makeTensorInfo(x.shape,x.dtype,x.values)}const IX={kernelName:F0,backendName:"cpu",kernelFunc:CX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MX(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{pad:a,strides:o,inputShape:c}=r;Ge([i],"conv3dBackpropInputV2");const l=Qe(i.shape),u=Qe(s.shape),f=Ba(c,s.shape,o,1,a),d=new jn(f.inShape,"float32"),h=d.values,[p,g,m,v]=d.strides,x=t.data.get(i.dataId).values,[b,_,w,E]=l,S=t.data.get(s.dataId).values,[T,C,y,A]=u,{batchSize:k,filterDepth:M,filterHeight:L,filterWidth:z,inChannels:D,inDepth:F,inHeight:O,inWidth:V,outChannels:J,outDepth:Q,outHeight:de,outWidth:le,strideDepth:H,strideHeight:q,strideWidth:oe}=f,fe=M-1-f.padInfo.front,_e=L-1-f.padInfo.top,xe=z-1-f.padInfo.left;for(let Se=0;Se<k;++Se)for(let Me=0;Me<D;++Me)for(let Le=0;Le<F;++Le){const B=Le-fe,bt=Math.max(0,Math.ceil(B/H)),qe=Math.min(Q,(M+B)/H);for(let Xe=0;Xe<O;++Xe){const Oe=Xe-_e,it=Math.max(0,Math.ceil(Oe/q)),rt=Math.min(de,(L+Oe)/q);for(let P=0;P<V;++P){const I=P-xe,ne=Math.max(0,Math.ceil(I/oe)),me=Math.min(le,(z+I)/oe);let ve=0;for(let pe=bt;pe<qe;++pe){const Be=pe*H-B;for(let Te=it;Te<rt;++Te){const ke=Te*q-Oe;for(let At=ne;At<me;++At){const we=At*oe-I,Fe=b*Se+_*pe+w*Te+E*At,ut=T*(M-1-Be)+C*(L-1-ke)+y*(z-1-we)+A*Me;for(let at=0;at<J;++at){const Ve=x[Fe+at],It=S[ut+at];ve+=Ve*It}}}}h[p*Se+g*Le+m*Xe+v*P+Me]=ve}}}return t.makeTensorInfo(d.shape,d.dtype,d.values)}const RX={kernelName:$0,backendName:"cpu",kernelFunc:MX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NX=Wt(ef,n=>Math.cos(n)),kX={kernelName:ef,backendName:"cpu",kernelFunc:NX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DX=Wt(tf,n=>Math.cosh(n)),LX={kernelName:tf,backendName:"cpu",kernelFunc:DX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OX(n){const{inputs:e,backend:t,attrs:r}=n,{image:i,boxes:s,boxInd:a}=e,{cropSize:o,method:c,extrapolationValue:l}=r,[u,f,d,h]=i.shape,p=s.shape[0],[g,m]=o,v=Et([p,g,m,h],"float32"),x=t.data.get(s.dataId).values,b=t.data.get(a.dataId).values,_=t.data.get(i.dataId).values,w=Qe(i.shape),E=Qe(v.shape);for(let S=0;S<p;S++){const T=S*4,C=x[T],y=x[T+1],A=x[T+2],k=x[T+3],M=b[S];if(M>=u)continue;const L=g>1?(A-C)*(f-1)/(g-1):0,z=m>1?(k-y)*(d-1)/(m-1):0;for(let D=0;D<g;D++){const F=g>1?C*(f-1)+D*L:.5*(C+A)*(f-1);if(F<0||F>f-1){for(let O=0;O<m;O++)for(let V=0;V<h;V++){const J=V+O*E[2]+D*E[1]+S*E[0];v.values[J]=l}continue}if(c==="bilinear"){const O=Math.floor(F),V=Math.ceil(F),J=F-O;for(let Q=0;Q<m;Q++){const de=m>1?y*(d-1)+Q*z:.5*(y+k)*(d-1);if(de<0||de>d-1){for(let oe=0;oe<h;oe++){const fe=oe+Q*E[2]+D*E[1]+S*E[0];v.values[fe]=l}continue}const le=Math.floor(de),H=Math.ceil(de),q=de-le;for(let oe=0;oe<h;oe++){let fe=oe+le*w[2]+O*w[1]+M*w[0];const _e=_[fe];fe=oe+H*w[2]+O*w[1]+M*w[0];const xe=_[fe];fe=oe+le*w[2]+V*w[1]+M*w[0];const Se=_[fe];fe=oe+H*w[2]+V*w[1]+M*w[0];const Me=_[fe],Le=_e+(xe-_e)*q,B=Se+(Me-Se)*q;fe=oe+Q*E[2]+D*E[1]+S*E[0],v.values[fe]=Le+(B-Le)*J}}}else for(let O=0;O<m;++O){const V=m>1?y*(d-1)+O*z:.5*(y+k)*(d-1);if(V<0||V>d-1){for(let de=0;de<h;de++){const le=de+O*E[2]+D*E[1]+S*E[0];v.values[le]=l}continue}const J=Math.round(V),Q=Math.round(F);for(let de=0;de<h;de++){const le=de+J*w[2]+Q*w[1]+M*w[0],H=de+O*E[2]+D*E[1]+S*E[0];v.values[H]=_[le]}}}}return t.makeTensorInfo(v.shape,v.dtype,v.values)}const zX={kernelName:B0,backendName:"cpu",kernelFunc:OX};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;Ge(i,"cumprod");const c=pn([s],i.shape.length);let l=i;c!=null&&(l=Nr({inputs:{x:i},backend:t,attrs:{perm:c}}));const u=yn(1,i.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumprod in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);const f=Hr(l.dtype,"int32"),d=A0(ue(l.shape),f),h=t.data.get(l.dataId).values,p=l.shape[l.shape.length-1],g=o?(v,x)=>v+p-x-1:(v,x)=>v+x;for(let v=0;v<h.length;v+=p)for(let x=0;x<p;x++){const b=g(v,x);if(x===0)d[b]=a?1:h[b];else{const _=g(v,x-1);d[b]=a?h[_]*d[_]:h[b]*d[_]}}const m=t.makeTensorInfo(l.shape,f,d);if(c!=null){const v=Va(c),x=Nr({inputs:{x:m},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(l),x}return m}const FX={kernelName:U0,backendName:"cpu",kernelFunc:PX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $X(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;Ge(i,"cumsum");const c=pn([s],i.shape.length);let l=i;c!=null&&(l=Nr({inputs:{x:i},backend:t,attrs:{perm:c}}));const u=yn(1,i.shape.length)[0];if(u!==l.shape.length-1)throw new Error(`backend.cumsum in CPU expects an inner-most axis=${l.shape.length-1} but got axis=${u}`);const f=Hr(l.dtype,"int32"),d=sr(ue(l.shape),f),h=t.data.get(l.dataId).values,p=l.shape[l.shape.length-1],g=o?(v,x)=>v+p-x-1:(v,x)=>v+x;for(let v=0;v<h.length;v+=p)for(let x=0;x<p;x++){const b=g(v,x);if(x===0)d[b]=a?0:h[b];else{const _=g(v,x-1);d[b]=a?h[_]+d[_]:h[b]+d[_]}}const m=t.makeTensorInfo(l.shape,f,d);if(c!=null){const v=Va(c),x=Nr({inputs:{x:m},backend:t,attrs:{perm:v}});return t.disposeIntermediateTensorInfo(m),t.disposeIntermediateTensorInfo(l),x}return m}const UX={kernelName:Rp,backendName:"cpu",kernelFunc:$X};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:a,binaryOutput:o}=r;if(i.shape.length===1){const c=t.data.get(i.dataId).values,l=t.data.get(s.dataId).values,u=Z_(c,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,u)}else if(i.shape.length===2){const c=t.bufferSync(i),l=t.bufferSync(s),u=AC(c,l,a,o);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const VX={kernelName:V0,backendName:"cpu",kernelFunc:BX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockSize:s,dataFormat:a}=r;R(a==="NHWC",()=>`Only NHWC dataFormat supported on CPU for depthToSpace. Got ${a}`);const o=i.shape[0],c=i.shape[1],l=i.shape[2],u=i.shape[3],f=c*s,d=l*s,h=u/(s*s),p=t.data.get(i.dataId).values,g=new Float32Array(o*f*d*h);let m=0;for(let v=0;v<o;++v)for(let x=0;x<f;++x){const b=Math.floor(x/s),_=x%s;for(let w=0;w<d;++w){const E=Math.floor(w/s),S=w%s,T=(_*s+S)*h;for(let C=0;C<h;++C){const A=C+T+u*(E+l*(b+c*v));g[m++]=p[A]}}}return t.makeTensorInfo([o,f,d,h],i.dtype,g)}const HX={kernelName:G0,backendName:"cpu",kernelFunc:GX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function AI(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:a,pad:o,dilations:c,dimRoundingMode:l}=r;Ge([i,s],"depthwiseConv2DNative");const u=Qe(i.shape),f=Qe(s.shape);let d=c;d==null&&(d=[1,1]),R(or(a,d),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${d}'`);const h=Yn(i.shape,s.shape,a,d,o,l,!0),{filterHeight:p,filterWidth:g,dilationHeight:m,dilationWidth:v,padInfo:x}=h,b=x.left,_=x.top,w=h.outChannels/h.inChannels,E=new jn(h.outShape,i.dtype),S=t.data.get(i.dataId).values,T=t.data.get(s.dataId).values,C=E.values;for(let y=0;y<h.batchSize;++y){const A=y*u[0],k=y*E.strides[0];for(let M=0;M<h.outHeight;++M){const L=k+M*E.strides[1],z=M*h.strideHeight-_;for(let D=0;D<p;++D){const F=z+D*m;if(F<0||F>=h.inHeight)continue;const O=D*f[0],V=A+F*u[1];for(let J=0;J<h.outWidth;++J){const Q=L+J*E.strides[2],de=J*h.strideWidth-b;for(let le=0;le<g;++le){const H=de+le*v;if(H<0||H>=h.inWidth)continue;const q=O+le*f[1],oe=V+H*h.inChannels;let fe=Q,_e=q;for(let xe=0;xe<h.inChannels;++xe){const Se=S[oe+xe];for(let Me=0;Me<w;++Me)C[fe+Me]+=Se*T[_e+Me];fe+=w,_e+=w}}}}}}return t.makeTensorInfo(E.shape,E.dtype,E.values)}const WX={kernelName:Np,backendName:"cpu",kernelFunc:AI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qX(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:a,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=r;Ge([i,s],"depthwiseConv2dNativeBackpropFilter");const f=Yn(i.shape,u,a,o,c,l,!0),{strideHeight:d,strideWidth:h,filterHeight:p,filterWidth:g}=f,m=new jn(f.filterShape,"float32"),v=f.padInfo.left,x=f.padInfo.top,b=f.outChannels/f.inChannels,_=t.data.get(i.dataId).values,w=new jn(i.shape,i.dtype,_),E=t.data.get(s.dataId).values,S=new jn(s.shape,s.dtype,E);for(let T=0;T<p;++T){const C=Math.max(0,Math.ceil((x-T)/d)),y=Math.min(f.outHeight,(f.inHeight+x-T)/d);for(let A=0;A<g;++A){const k=Math.max(0,Math.ceil((v-A)/h)),M=Math.min(f.outWidth,(f.inWidth+v-A)/h);for(let L=0;L<f.outChannels;++L){const z=Math.trunc(L/b),D=L%b;let F=0;for(let O=0;O<f.batchSize;++O)for(let V=C;V<y;++V){const J=T+V*d-x;for(let Q=k;Q<M;++Q){const de=A+Q*h-v;F+=w.get(O,J,de,z)*S.get(O,V,Q,L)}}m.set(F,T,A,z,D)}}}return t.makeTensorInfo(m.shape,m.dtype,m.values)}const XX={kernelName:H0,backendName:"cpu",kernelFunc:qX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KX(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{strides:a,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=r;Ge([i,s],"depthwiseConv2DNativeBackpropInput");const f=Qe(i.shape),d=Qe(s.shape),h=Yn(u,s.shape,a,o,c,l,!0),p=new jn(h.inShape,"float32"),g=p.values,[m,v,x]=p.strides,b=t.data.get(i.dataId).values,[_,w,E]=f,S=t.data.get(s.dataId).values,[T,C,y]=d,{batchSize:A,filterHeight:k,filterWidth:M,inChannels:L,inHeight:z,inWidth:D,outChannels:F,outHeight:O,outWidth:V,strideHeight:J,strideWidth:Q}=h,de=k-1-h.padInfo.top,le=M-1-h.padInfo.left,H=F/L;for(let q=0;q<A;++q)for(let oe=0;oe<L;++oe)for(let fe=0;fe<z;++fe){const _e=fe-de,xe=Math.max(0,Math.ceil(_e/J)),Se=Math.min(O,(k+_e)/J);for(let Me=0;Me<D;++Me){const Le=Me-le,B=Math.max(0,Math.ceil(Le/Q)),bt=Math.min(V,(M+Le)/Q);let qe=0;for(let Xe=xe;Xe<Se;++Xe){const Oe=Xe*J-_e;for(let it=B;it<bt;++it){const rt=it*Q-Le,P=_*q+w*Xe+E*it,I=T*(k-1-Oe)+C*(M-1-rt)+y*oe;for(let ne=0;ne<H;++ne){const me=oe*H+ne,ve=b[P+me],pe=S[I+ne];qe+=ve*pe}}}g[m*q+v*fe+x*Me+oe]=qe}}return t.makeTensorInfo(p.shape,p.dtype,p.values)}const jX={kernelName:W0,backendName:"cpu",kernelFunc:KX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YX(n){const{inputs:e,backend:t}=n,{x:r}=e,i=ue(r.shape),s=t.data.get(r.dataId).values,a=Et([i,i],r.dtype),o=a.values;for(let l=0;l<s.length;l++)o[l*i+l]=s[l];const c=[...r.shape,...r.shape];return t.makeTensorInfo(c,a.dtype,a.values)}const ZX={kernelName:qE,backendName:"cpu",kernelFunc:YX};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QX={kernelName:kp,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:i}=n,{strides:s,pad:a,dilations:o}=t,c=e,l=c.data.get(r.dataId).values,u=r.shape.length,f=c.data.get(i.dataId).values,d=i.shape.length,{batchSize:h,inHeight:p,inWidth:g,inChannels:m,outHeight:v,outWidth:x,padInfo:b,strideHeight:_,strideWidth:w,filterHeight:E,filterWidth:S,dilationHeight:T,dilationWidth:C,outShape:y}=Gf(r.shape,i.shape,s,a,"NHWC",o),A=ue(y),k=y.length,M=gn(r.dtype,A);for(let z=0;z<h;++z)for(let D=0;D<v;++D){const F=D*_-b.top;for(let O=0;O<x;++O){const V=O*w-b.left;for(let J=0;J<m;++J){let Q=Number.MIN_SAFE_INTEGER;for(let le=0;le<E;++le){const H=F+le*T;if(H>=0&&H<p)for(let q=0;q<S;++q){const oe=V+q*C;if(oe>=0&&oe<g){const fe=us([z,H,oe,J],u,Qe(r.shape)),_e=us([le,q,J],d,Qe(i.shape)),xe=l[fe]+f[_e];xe>Q&&(Q=xe)}}}const de=us([z,D,O,J],k,Qe(y));M[de]=Q}}}return{dataId:c.write(Go(M,r.dtype),y,r.dtype),shape:y,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JX={kernelName:rx,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:i,dy:s}=n,{strides:a,pad:o,dilations:c}=t,l=e,u=Hi(r.shape,l.data.get(r.dataId).values),f=Hi(i.shape,l.data.get(i.dataId).values),{batchSize:d,inHeight:h,inWidth:p,inChannels:g,outHeight:m,outWidth:v,padInfo:x,strideHeight:b,strideWidth:_,filterHeight:w,filterWidth:E,dilationHeight:S,dilationWidth:T,outShape:C}=Gf(r.shape,i.shape,a,o,"NHWC",c);R(s.rank===C.length,()=>`Error in ${rx}, dy must have the same rank as output ${C.length}, but got ${s.rank}`);const y=Hi(C,l.data.get(s.dataId).values),A=VE(i.shape,i.dtype);for(let M=0;M<d;++M)for(let L=0;L<m;++L){const z=L*b-x.top;for(let D=0;D<v;++D){const F=D*_-x.left;for(let O=0;O<g;++O){let V=Number.MIN_SAFE_INTEGER,J=0,Q=0;for(let de=0;de<w;++de){const le=z+de*S;if(le>=0&&le<h)for(let H=0;H<E;++H){const q=F+H*T;if(q>=0&&q<p){const oe=u[M][le][q][O]+f[de][H][O];oe>V&&(V=oe,J=de,Q=H)}}}A[J][Q][O]+=y[M][L][D][O]}}}return{dataId:l.write(Go(A,r.dtype),i.shape,i.dtype),shape:i.shape,dtype:i.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e9={kernelName:nx,backendName:"cpu",kernelFunc:({inputs:n,backend:e,attrs:t})=>{const{x:r,filter:i,dy:s}=n,{strides:a,pad:o,dilations:c}=t,l=e,u=Hi(r.shape,l.data.get(r.dataId).values),f=Hi(i.shape,l.data.get(i.dataId).values),{batchSize:d,inHeight:h,inWidth:p,inChannels:g,outHeight:m,outWidth:v,padInfo:x,strideHeight:b,strideWidth:_,filterHeight:w,filterWidth:E,dilationHeight:S,dilationWidth:T,outShape:C}=Gf(r.shape,i.shape,a,o,"NHWC",c);R(s.rank===C.length,()=>`Error in ${nx}, dy must have the same rank as output ${C.length}, but got ${s.rank}`);const y=Hi(C,l.data.get(s.dataId).values),A=VE(r.shape,r.dtype);for(let M=0;M<d;++M)for(let L=0;L<m;++L){const z=L*b-x.top;for(let D=0;D<v;++D){const F=D*_-x.left;for(let O=0;O<g;++O){let V=Number.MIN_SAFE_INTEGER,J=z<0?0:z,Q=F<0?0:F;for(let de=0;de<w;++de){const le=z+de*S;if(le>=0&&le<h)for(let H=0;H<E;++H){const q=F+H*T;if(q>=0&&q<p){const oe=u[M][le][q][O]+f[de][H][O];oe>V&&(V=oe,J=le,Q=q)}}}A[M][J][Q][O]+=y[M][L][D][O]}}}return{dataId:l.write(Go(A,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t9(n){const{inputs:e,backend:t,attrs:r}=n,{image:i}=e,{canvas:s,options:a}=r,{contextOptions:o,imageOptions:c}=a||{},l=(c==null?void 0:c.alpha)||1,u=(o==null?void 0:o.contextType)||"2d";if(u!=="2d")throw new Error(`Context type ${o.contextType} is not supported by the CPU backend.`);const f=s.getContext(u,(o==null?void 0:o.contextAttributes)||{});if(f==null)throw new Error(`Could not get the context with ${u} type.`);const[d,h]=i.shape.slice(0,2),p=i.shape.length===2?1:i.shape[2],g=t.data.get(i.dataId).values,m=i.dtype==="float32"?255:1,v=new Uint8ClampedArray(h*d*4);for(let b=0;b<d*h;++b){const _=[0,0,0,255*l];for(let E=0;E<p;E++){const S=g[b*p+E];if(i.dtype==="float32"){if(S<0||S>1)throw new Error(`Tensor values for a float32 Tensor must be in the range [0 - 1] but encountered ${S}.`)}else if(i.dtype==="int32"&&(S<0||S>255))throw new Error(`Tensor values for a int32 Tensor must be in the range [0 - 255] but encountered ${S}.`);p===1?(_[0]=S*m,_[1]=S*m,_[2]=S*m):_[E]=S*m}const w=b*4;v[w+0]=Math.round(_[0]),v[w+1]=Math.round(_[1]),v[w+2]=Math.round(_[2]),v[w+3]=Math.round(_[3])}s.width=h,s.height=d;const x=new ImageData(v,h,d);return f.putImageData(x,0,0),i}const n9={kernelName:PP,backendName:"cpu",kernelFunc:t9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sd(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r;Ge(i,"sum");let o;i.dtype==="bool"?o=za({inputs:{x:i},backend:t,attrs:{dtype:"int32"}}):o=_s({inputs:{x:i},backend:t});const c=o.shape.length,l=St(s,o.shape),u=pn(l,c);let f=l,d=o;u!=null&&(d=Nr({inputs:{x:o},backend:t,attrs:{perm:u}}),f=yn(f.length,c)),Zn("sum",f,d.shape.length);const[h,p]=Wn(d.shape,f),g=Hr(d.dtype,"int32");let m=Yh(t,h,g);const v=ue(p),x=t.data.get(m.dataId).values,b=t.data.get(d.dataId).values;for(let _=0;_<x.length;++_){const w=_*v;let E=0;for(let S=0;S<v;++S)E+=b[w+S];x[_]=E}if(a){const _=Cn(m.shape,l),w=m;m=en({inputs:{x:m},backend:t,attrs:{shape:_}}),t.disposeIntermediateTensorInfo(w)}return t.disposeIntermediateTensorInfo(o),u!=null&&t.disposeIntermediateTensorInfo(d),m}const r9={kernelName:fm,backendName:"cpu",kernelFunc:sd};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i9(n){const{inputs:e,backend:t,attrs:r}=n,{equation:i}=r,s=e,{allDims:a,summedDims:o,idDims:c}=y_(i,s.length);E_(a.length,c,s);const{path:l,steps:u}=S_(o,c),f=u.length;let d=null,h=a.length;const p=[];for(let g=0;g<f;++g){for(const m of u[g]){const{permutationIndices:v,expandDims:x}=w_(h,c[m]);let b;T_(v)?b=s[m]:(b=Nr({inputs:{x:s[m]},backend:t,attrs:{perm:v}}),p.push(b));const _=b.shape.slice();for(let w=0;w<x.length;++w)_.splice(x[w],0,1);Pt(b.shape,_)||(b=en({inputs:{x:b},backend:t,attrs:{shape:_}}),p.push(b)),d===null?d=b:(d=Um({inputs:{a:b,b:d},backend:t}),p.push(d))}g<f-1&&(l[g]>=0&&(d=sd({inputs:{x:d},backend:t,attrs:{axis:l[g]-(a.length-h),keepDims:!1}}),p.push(d)),h--)}for(const g of p)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const s9={kernelName:q0,backendName:"cpu",kernelFunc:i9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a9(n){const{inputs:e,backend:t}=n,{dy:r,y:i}=e;Ge([r,i],"eluGrad");const s=new Float32Array(ue(i.shape)),a=t.data.get(i.dataId).values,o=t.data.get(r.dataId).values;for(let c=0;c<a.length;++c){const l=a[c];l>=0?s[c]=o[c]:s[c]=o[c]*(l+1)}return t.makeTensorInfo(i.shape,"float32",s)}const o9={kernelName:X0,backendName:"cpu",kernelFunc:a9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c9=p_,l9=m_,u9=v_,f9=g_,d9=x_,h9=b_,p9=Wt(sf,n=>{const e=Math.sign(n),t=Math.abs(n),r=1/(1+c9*t);return e*(1-((((h9*r+d9)*r+f9)*r+u9)*r+l9)*r*Math.exp(-t*t))}),m9={kernelName:sf,backendName:"cpu",kernelFunc:p9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jh(n){const{inputs:e,backend:t,attrs:r}=n,{input:i}=e,{dim:s}=r,a=i.shape.length,o=i.shape.slice();let c=s;return s<0&&(R(-(a+1)<=s,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),c=a+s+1),o.splice(c,0,1),en({inputs:{x:i},backend:t,attrs:{shape:o}})}const v9={kernelName:Lp,backendName:"cpu",kernelFunc:Jh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const g9=En((n,e)=>n/e),ry=Pn(nf,g9),Nx={kernelName:nf,backendName:"cpu",kernelFunc:ry};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CI(n,e,t){const r=n.shape,i=r[0],s=r[1],a=t.data.get(n.dataId),o=a.complexTensorInfos.real,c=a.complexTensorInfos.imag,l=[i,s],u=ue(l),f=ir("float32",u),d=ir("float32",u);for(let m=0;m<i;m++){const v=Po({inputs:{x:o},backend:t,attrs:{begin:[m,0],size:[1,s]}}),x=Po({inputs:{x:c},backend:t,attrs:{begin:[m,0],size:[1,s]}}),b=Ur({inputs:{real:v,imag:x},backend:t}),{real:_,imag:w}=x9(b,e,t),E=js(_,w);for(let S=0;S<s;S++){const T=__(E,S);f[m*s+S]=T.real,d[m*s+S]=T.imag}t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(x),t.disposeIntermediateTensorInfo(b)}const h=t.makeTensorInfo(l,"float32",f),p=t.makeTensorInfo(l,"float32",d),g=Ur({inputs:{real:h,imag:p},backend:t});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),g}function x9(n,e,t){const r=ue(n.shape),i=t.data.get(n.dataId),s=t.data.get(i.complexTensorInfos.real.dataId).values,a=t.data.get(i.complexTensorInfos.imag.dataId).values;if(b9(r)){const o=kx(s,a,r,e,t),c=[n.shape[0],n.shape[1]];if(e){const l=t.makeTensorInfo(c,"float32",o.real),u=t.makeTensorInfo(c,"float32",o.imag),f=t.makeTensorInfo([],"float32",Ua(r,"float32")),d=_s({inputs:{x:f},backend:t}),h=Nx.kernelFunc({inputs:{a:l,b:f},backend:t}),p=Nx.kernelFunc({inputs:{a:u,b:d},backend:t}),g=t.data.get(h.dataId).values,m=t.data.get(p.dataId).values;return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),{real:g,imag:m}}return o}else{const o=js(s,a),c=_9(o,r,e);return US(c)}}function b9(n){return(n&n-1)===0}function kx(n,e,t,r,i){if(t===1)return{real:n,imag:e};const s=js(n,e),a=t/2,o=BS(s),c=o.real,l=o.imag,u=[c.length],f=i.makeTensorInfo(u,"float32",c),d=i.makeTensorInfo(u,"float32",l),h=Ur({inputs:{real:f,imag:d},backend:i}),p=VS(s),g=p.real,m=p.imag,v=[g.length],x=i.makeTensorInfo(v,"float32",g),b=i.makeTensorInfo(v,"float32",m),_=Ur({inputs:{real:x,imag:b},backend:i}),w=kx(c,l,a,r,i),E=w.real,S=w.imag,T=[E.length],C=i.makeTensorInfo(T,"float32",E),y=i.makeTensorInfo(T,"float32",S),A=Ur({inputs:{real:C,imag:y},backend:i}),k=kx(g,m,a,r,i),M=k.real,L=k.imag,z=[M.length],D=i.makeTensorInfo(z,"float32",M),F=i.makeTensorInfo(z,"float32",L),O=Ur({inputs:{real:D,imag:F},backend:i}),V=HS(t,r),J=[V.real.length],Q=i.makeTensorInfo(J,"float32",V.real),de=i.makeTensorInfo(J,"float32",V.imag),le=Ur({inputs:{real:Q,imag:de},backend:i}),H=Um({inputs:{a:le,b:O},backend:i}),q=ol({inputs:{a:A,b:H},backend:i}),oe=ty({inputs:{a:A,b:H},backend:i}),fe=zo({inputs:{input:q},backend:i}),_e=zo({inputs:{input:oe},backend:i}),xe=cl({inputs:{input:q},backend:i}),Se=cl({inputs:{input:oe},backend:i}),Me=ll({inputs:[fe,_e],backend:i,attrs:{axis:0}}),Le=ll({inputs:[xe,Se],backend:i,attrs:{axis:0}}),B=i.data.get(Me.dataId).values,bt=i.data.get(Le.dataId).values;return i.disposeIntermediateTensorInfo(f),i.disposeIntermediateTensorInfo(d),i.disposeIntermediateTensorInfo(h),i.disposeIntermediateTensorInfo(x),i.disposeIntermediateTensorInfo(b),i.disposeIntermediateTensorInfo(_),i.disposeIntermediateTensorInfo(C),i.disposeIntermediateTensorInfo(y),i.disposeIntermediateTensorInfo(A),i.disposeIntermediateTensorInfo(D),i.disposeIntermediateTensorInfo(F),i.disposeIntermediateTensorInfo(O),i.disposeIntermediateTensorInfo(Q),i.disposeIntermediateTensorInfo(de),i.disposeIntermediateTensorInfo(le),i.disposeIntermediateTensorInfo(H),i.disposeIntermediateTensorInfo(q),i.disposeIntermediateTensorInfo(oe),i.disposeIntermediateTensorInfo(fe),i.disposeIntermediateTensorInfo(xe),i.disposeIntermediateTensorInfo(_e),i.disposeIntermediateTensorInfo(Se),i.disposeIntermediateTensorInfo(Me),i.disposeIntermediateTensorInfo(Le),{real:B,imag:bt}}function _9(n,e,t){const r=new Float32Array(e*2);for(let i=0;i<e;i++){let s=0,a=0;for(let o=0;o<e;o++){const c=WS(i*o,e,t),l=__(n,o);s+=l.real*c.real-l.imag*c.imag,a+=l.real*c.imag+l.imag*c.real}t&&(s/=e,a/=e),GS(r,s,a,i)}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y9(n){const{inputs:e,backend:t}=n,{input:r}=e,i=ue(r.shape),s=r.shape[r.shape.length-1],a=i/s,o=en({inputs:{x:r},backend:t,attrs:{shape:[a,s]}}),c=CI(o,!1,t),l=en({inputs:{x:c},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(c),l}const w9={kernelName:K0,backendName:"cpu",kernelFunc:y9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iy(n){const{backend:e,attrs:t}=n,{shape:r,value:i,dtype:s}=t,a=s||yl(i),o=gn(a,ue(r));return S9(o,i,a),e.makeTensorInfo(r,a,o)}const E9={kernelName:j0,backendName:"cpu",kernelFunc:iy};function S9(n,e,t){n.fill(e)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T9={kernelName:Y0,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,i=t,s=ir(r.dtype,ue(r.shape)),[a,o,c,l]=r.shape,u=i.data.get(r.dataId).values;for(let d=0;d<a;d++){const h=d*c*o*l;for(let p=0;p<o;p++){const g=p*(c*l);for(let m=0;m<c;m++){const v=m*l;for(let x=0;x<l;x++){const b=Math.round(c-m-1),_=h+g+v+x;let w=u[_];if(b>=0&&b<c){const E=b*l,S=h+g+E+x;w=u[S]}s[_]=w}}}}return{dataId:i.write(s,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A9(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:c,pad:l,dataFormat:u,dilations:f,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r;let g=TI({inputs:{x:i,filter:s},backend:t,attrs:{strides:c,pad:l,dataFormat:u,dilations:f,dimRoundingMode:d}});if(a){const m=g;if(u==="NCHW"&&a.shape.length===1&&a.shape[0]!==1){const v=en({inputs:{x:a},backend:t,attrs:{shape:[a.shape[0],1,1]}});g=ol({inputs:{a:g,b:v},backend:t}),t.disposeIntermediateTensorInfo(v)}else g=ol({inputs:{a:g,b:a},backend:t});t.disposeIntermediateTensorInfo(m)}if(h){const m=g;if(u==="NCHW"&&h==="prelu"&&o.shape.length===1&&o.shape[0]!==1){const v=en({inputs:{x:o},backend:t,attrs:{shape:[o.shape[0],1,1]}});g=Qh(t,g,h,v,p),t.disposeIntermediateTensorInfo(v)}else g=Qh(t,g,h,o,p);t.disposeIntermediateTensorInfo(m)}return g}const C9={kernelName:Dh,backendName:"cpu",kernelFunc:A9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I9(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:c,pad:l,dataFormat:u,dilations:f,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r;let g=AI({inputs:{x:i,filter:s},backend:t,attrs:{strides:c,pad:l,dataFormat:u,dilations:f,dimRoundingMode:d}});if(a){const m=g;g=ol({inputs:{a:g,b:a},backend:t}),t.disposeIntermediateTensorInfo(m)}if(h){const m=g;g=Qh(t,g,h,o,p),t.disposeIntermediateTensorInfo(m)}return g}const M9={kernelName:f3,backendName:"cpu",kernelFunc:I9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R9(n){const{inputs:e,backend:t}=n,{params:r,indices:i}=e,s=ue(r.shape),a=i.shape,o=a[a.length-1],[c,l,u,f]=r_(r,i);if(l===0)return t.makeTensorInfo(c,r.dtype,[]);const d=t.data.get(i.dataId).values,h=t.bufferSync(r),p=PC(d,h,r.dtype,l,o,u,f,r.shape,s);return t.makeTensorInfo(c,r.dtype,p.values)}const N9={kernelName:XE,backendName:"cpu",kernelFunc:R9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k9(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,indices:s}=e,{axis:a,batchDims:o}=r;Ge([i,s],"gatherV2");const c=St(a,i.shape)[0],l=t.data.get(s.dataId).values,u=i.shape[c];for(let _=0;_<l.length;++_){const w=l[_];R(w<=u-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${u-1}]`)}let f=o;o==null&&(f=0);const d=ue(s.shape),h=C_(i,s,c,f),p=en({inputs:{x:i},backend:t,attrs:{shape:[h.batchSize,h.outerSize,h.dimSize,h.sliceSize]}}),g=en({inputs:{x:s},backend:t,attrs:{shape:[h.batchSize,d/h.batchSize]}}),m=[h.batchSize,h.outerSize,d/h.batchSize,h.sliceSize],v=t.bufferSync(g),x=t.bufferSync(p),b=FC(x,v,m);return t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.makeTensorInfo(h.outputShape,b.dtype,b.values)}const D9={kernelName:zp,backendName:"cpu",kernelFunc:k9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L9(n){const{inputs:e,backend:t}=n,{input:r}=e,i=ue(r.shape),s=r.shape[r.shape.length-1],a=i/s,o=en({inputs:{x:r},backend:t,attrs:{shape:[a,s]}}),c=CI(o,!0,t),l=en({inputs:{x:c},backend:t,attrs:{shape:r.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(c),l}const O9={kernelName:Z0,backendName:"cpu",kernelFunc:L9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const z9=Wt(df,n=>Number.isFinite(n)?1:0,"bool"),P9={kernelName:df,backendName:"cpu",kernelFunc:z9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F9=Wt(hf,n=>Math.abs(n)===1/0?1:0,"bool"),$9={kernelName:hf,backendName:"cpu",kernelFunc:F9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U9=Wt(pf,n=>Number.isNaN(n)?1:0,"bool"),B9={kernelName:pf,backendName:"cpu",kernelFunc:U9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V9(n){const{backend:e,attrs:t}=n,{start:r,stop:i,num:s}=t,a=GC(r,i,s);return e.makeTensorInfo([a.length],"float32",a)}const G9={kernelName:KE,backendName:"cpu",kernelFunc:V9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H9=Wt(vf,n=>Math.log1p(n)),W9={kernelName:vf,backendName:"cpu",kernelFunc:H9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const q9=En((n,e)=>n&&e),X9=Pn(Bp,q9,null,"bool"),K9={kernelName:Bp,backendName:"cpu",kernelFunc:X9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const j9=Wt(Vp,n=>n?0:1,"bool"),Y9={kernelName:Vp,backendName:"cpu",kernelFunc:j9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Z9=En((n,e)=>n||e),Q9=Pn(Gp,Z9,null,"bool"),J9={kernelName:Gp,backendName:"cpu",kernelFunc:Q9};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e7(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{depthRadius:s,bias:a,alpha:o,beta:c}=r;Ge(i,"LRN");const l=i.shape[3],u=l-1,f=t.data.get(i.dataId).values,d=ue(i.shape),h=new Float32Array(d);function p(g){const m=g%l;let v=g-m+Math.max(0,m-s);const x=g-m+Math.min(m+s,u);let b=0;for(;v<=x;v++){const _=f[v];b+=_*_}return b}for(let g=0;g<d;g++){const m=p(g),v=f[g]*Math.pow(a+o*m,-c);h[g]=v}return t.makeTensorInfo(i.shape,i.dtype,h)}const t7={kernelName:Hp,backendName:"cpu",kernelFunc:e7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function n7(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,y:s,dy:a}=e,{depthRadius:o,bias:c,alpha:l,beta:u}=r;Ge(a,"LRNGrad");const f=ue(a.shape),d=a.shape[3],h=t.data.get(a.dataId).values,p=t.data.get(i.dataId).values,g=t.data.get(s.dataId).values,m=new Float32Array(f),v=f;for(let x=0;x<v;x++){const b=x%d,_=x-b+Math.max(0,b-o),w=x-b+Math.min(d,b+o+1);let E=0;for(let S=_;S<w;S++)E+=Math.pow(p[S],2);E=l*E+c;for(let S=_;S<w;S++){let T=-2*l*u*p[S]*g[x]/E;x===S&&(T+=Math.pow(E,-u)),T*=h[x],m[S]+=T}}return t.makeTensorInfo(a.shape,i.dtype,m)}const r7={kernelName:J0,backendName:"cpu",kernelFunc:n7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reductionIndices:s,keepDims:a}=r,o=t;let c=i.shape;const l=c.length,u=St(s,c);let f=u;const d=pn(f,l);let h=o.data.get(i.dataId).values;if(d!=null){const _=new Array(l);for(let w=0;w<_.length;w++)_[w]=c[d[w]];h=J_(h,c,i.dtype,d,_),f=yn(f.length,l),c=_}Ge(i,"max"),Zn("max",f,l);const[p,g]=Wn(c,f),m=ue(g),v=WC(h,m,p,i.dtype),x=o.write(v,p,i.dtype);let b=p;return a&&(b=Cn(p,u)),{dataId:x,shape:b,dtype:i.dtype}}const i7={kernelName:Wp,backendName:"cpu",kernelFunc:II};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s7(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;Ge(i,"maxPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:c}=r,l=1;R(or(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const u=Ii(i.shape,s,a,l,o,c);let f;if(u.filterWidth===1&&u.filterHeight===1&&Pt(u.inShape,u.outShape))f=_s({inputs:{x:i},backend:t});else{const d=t.data.get(i.dataId).values,h=Qe(i.shape),p=ny(d,i.shape,i.dtype,h,u,"max");f=t.makeTensorInfo(u.outShape,i.dtype,p.values)}return f}const a7={kernelName:qp,backendName:"cpu",kernelFunc:s7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o7(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:c,dataFormat:l}=r;Ge(i,"maxPool3d");const u=ta(i.shape,s,a,1,o,c,l),f=t.data.get(i.dataId).values,d=SI(f,i.shape,i.dtype,Qe(i.shape),u,"max");return t.makeTensorInfo(d.shape,"float32",d.values)}const c7={kernelName:Xp,backendName:"cpu",kernelFunc:o7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function l7(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,{filterSize:a,strides:o,pad:c,dimRoundingMode:l}=r;Ge([i,s],"maxPool3DGrad");const u=ta(s.shape,a,o,1,c,l),f=t.bufferSync(s),d=Zq(f,u),h=u.strideDepth,p=u.strideHeight,g=u.strideWidth,m=u.dilationDepth,v=u.dilationHeight,x=u.dilationWidth,b=u.effectiveFilterDepth,_=u.effectiveFilterHeight,w=u.effectiveFilterWidth,E=b-1-u.padInfo.front,S=w-1-u.padInfo.left,T=_-1-u.padInfo.top,C=Et(s.shape,"float32"),y=t.bufferSync(i);for(let A=0;A<u.batchSize;++A)for(let k=0;k<u.inChannels;++k)for(let M=0;M<u.inDepth;++M)for(let L=0;L<u.inHeight;++L)for(let z=0;z<u.inWidth;++z){const D=M-E,F=L-T,O=z-S;let V=0;for(let J=0;J<b;J+=m){const Q=(D+J)/h;if(!(Q<0||Q>=u.outDepth||Math.floor(Q)!==Q))for(let de=0;de<_;de+=v){const le=(F+de)/p;if(!(le<0||le>=u.outHeight||Math.floor(le)!==le))for(let H=0;H<w;H+=x){const q=(O+H)/g;if(q<0||q>=u.outWidth||Math.floor(q)!==q)continue;const oe=b*_*w-1-d.get(A,Q,le,q,k),fe=J*_*w+de*w+H,_e=oe===fe?1:0;if(_e===0)continue;const xe=y.get(A,Q,le,q,k);V+=xe*_e}}}C.set(V,A,M,L,z,k)}return t.makeTensorInfo(C.shape,C.dtype,C.values)}const u7={kernelName:tb,backendName:"cpu",kernelFunc:l7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f7(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s,output:a}=e,o=s;Ge([s,a],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:f}=r,d=Ii(o.shape,c,l,1,u,f),h=t.data.get(o.dataId).values,p=Et(d.outShape,o.dtype,EI(h,o.shape,o.dtype,d).values),g=d.strideHeight,m=d.strideWidth,v=d.dilationHeight,x=d.dilationWidth,b=d.effectiveFilterHeight,_=d.effectiveFilterWidth,w=_-1-d.padInfo.left,E=b-1-d.padInfo.top,S=Et(o.shape,"float32"),T=t.data.get(i.dataId).values,C=Et(i.shape,"float32",T);for(let y=0;y<d.batchSize;++y)for(let A=0;A<d.inChannels;++A)for(let k=0;k<d.inHeight;++k)for(let M=0;M<d.inWidth;++M){const L=k-E,z=M-w;let D=0;for(let F=0;F<b;F+=v){const O=(L+F)/g;if(!(O<0||O>=d.outHeight||Math.floor(O)!==O))for(let V=0;V<_;V+=x){const J=(z+V)/m;if(J<0||J>=d.outWidth||Math.floor(J)!==J)continue;const Q=b*_-1-p.get(y,O,J,A),de=F*_+V,le=Q===de?1:0;if(le===0)continue;const H=C.get(y,O,J,A);D+=H*le}}S.set(D,y,k,M,A)}return t.makeTensorInfo(S.shape,S.dtype,S.values)}const d7={kernelName:eb,backendName:"cpu",kernelFunc:f7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h7(n,e,t,r,i){const s=Qe(e),a=ny(n,e,t,s,i,"max"),o=EI(n,e,t,i,!0,r);return[a.values,o.values]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p7={kernelName:jE,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=e,c=t;Ge(r,"MaxPoolWithArgmax");const l=c.data.get(r.dataId).values,u=Ii(r.shape,i,s,[1,1],a),[f,d]=h7(l,r.shape,r.dtype,o,u),h=c.write(f,u.outShape,r.dtype),p=c.write(d,u.outShape,r.dtype);return[{dataId:h,shape:u.outShape,dtype:r.dtype},{dataId:p,shape:u.outShape,dtype:"int32"}]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m7(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r,o=St(s,i.shape),l=Wn(i.shape,o)[1],u=ue(l),f=[],d=t.makeTensorInfo([],"float32",new Float32Array([u]));f.push(d);const h=za({inputs:{x:i},backend:t,attrs:{dtype:"float32"}});f.push(h);const p=ry({inputs:{a:h,b:d},backend:t});f.push(p);const g=sd({inputs:{x:p},backend:t,attrs:{axis:s,keepDims:a}});return f.forEach(m=>t.disposeIntermediateTensorInfo(m)),g}const v7={kernelName:Kp,backendName:"cpu",kernelFunc:m7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g7(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r;Ge(i,"min");const o=St(s,i.shape);let c=o;const l=pn(c,i.shape.length);let u=i;l!=null&&(u=Nr({inputs:{x:i},backend:t,attrs:{perm:l}}),c=yn(c.length,i.shape.length)),Zn("min",c,u.shape.length);const[f,d]=Wn(u.shape,c),h=ue(d),p=sr(ue(f),u.dtype),g=t.data.get(u.dataId).values;for(let v=0;v<p.length;++v){const x=v*h;let b=g[x];for(let _=0;_<h;++_){const w=g[x+_];(Number.isNaN(w)||w<b)&&(b=w)}p[v]=b}l!=null&&t.disposeIntermediateTensorInfo(u);const m=t.makeTensorInfo(f,u.dtype,p);if(a){const v=Cn(f,o),x=en({inputs:{x:m},backend:t,attrs:{shape:v}});return t.disposeIntermediateTensorInfo(m),x}return m}const x7={kernelName:jp,backendName:"cpu",kernelFunc:g7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b7(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{paddings:s,mode:a}=r;Ge(i,"mirrorPad");const o=s.map((b,_)=>b[0]+i.shape[_]+b[1]),c=s.map(b=>b[0]),l=s.map((b,_)=>b[0]+i.shape[_]),u=a==="reflect"?0:1,f=t.data.get(i.dataId).values,d=i.shape.length,h=Qe(i.shape),p=ue(o),g=o.length,m=Qe(o),v=ir(i.dtype,p);for(let b=0;b<p;b++){let _=wl(b,g,m);for(let E=0;E<g;E++)_[E]<c[E]?_[E]=c[E]*2-_[E]-u:_[E]>=l[E]&&(_[E]=(l[E]-1)*2-_[E]+u);_=_.map((E,S)=>E-c[S]);const w=us(_,d,h);v[b]=f[w]}return{dataId:t.write(v,o,i.dtype),shape:o,dtype:i.dtype}}const _7={kernelName:Yp,backendName:"cpu",kernelFunc:b7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const y7=En((n,e)=>{const t=n%e;return n<0&&e<0||n>=0&&e>=0?t:(t+e)%e}),w7=Pn(bf,y7),E7={kernelName:bf,backendName:"cpu",kernelFunc:w7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function MI(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{dim:s}=r,a=i.shape.length;let o=s;if(o===-1&&(o=a-1),o!==a-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${a} and dim was ${o}`);const c=St([o],i.shape),l=II({inputs:{x:i},backend:t,attrs:{reductionIndices:c,keepDims:!1}}),u=Cn(l.shape,c),f=en({inputs:{x:l},backend:t,attrs:{shape:u}}),d=ty({inputs:{a:i,b:f},backend:t}),h=DC({inputs:{x:d},backend:t}),p=sd({inputs:{x:h},backend:t,attrs:{axis:c,keepDims:!1}}),g=en({inputs:{x:p},backend:t,attrs:{shape:u}}),m=ry({inputs:{a:h,b:g},backend:t});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),m}const S7={kernelName:pm,backendName:"cpu",kernelFunc:MI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T7(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{numSamples:s,seed:a,normalized:o}=r;Ge(i,"multinomial");const c=o?i:MI({inputs:{logits:i},backend:t,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],f=t.data.get(c.dataId).values,d=[l,s],h=sr(ue(d),"int32");for(let p=0;p<l;++p){const g=p*u,m=new Float32Array(u-1);m[0]=f[g];for(let b=1;b<m.length;++b)m[b]=m[b-1]+f[g+b];const v=Gb.alea(a.toString()),x=p*s;for(let b=0;b<s;++b){const _=v();h[x+b]=m.length;for(let w=0;w<m.length;w++)if(_<m[w]){h[x+b]=w;break}}}return o||t.disposeIntermediateTensorInfo(c),t.makeTensorInfo(d,"int32",h)}const A7={kernelName:YE,backendName:"cpu",kernelFunc:T7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C7=Qb;function I7(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:c}=r;Ge(i,"NonMaxSuppression");const l=t.data.get(i.dataId).values,u=t.data.get(s.dataId).values,{selectedIndices:f}=C7(l,u,a,o,c);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const M7={kernelName:nb,backendName:"cpu",kernelFunc:I7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const R7=Jb;function N7(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=r;Ge(i,"NonMaxSuppressionPadded");const u=t.data.get(i.dataId).values,f=t.data.get(s.dataId).values,{selectedIndices:d,validOutputs:h}=R7(u,f,a,o,c,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([h]))]}const k7={kernelName:rb,backendName:"cpu",kernelFunc:N7};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D7=e_;function L7(n){const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=r;Ge(i,"NonMaxSuppressionWithScore");const u=t.data.get(i.dataId).values,f=t.data.get(s.dataId).values,d=a,h=o,p=c,g=l,{selectedIndices:m,selectedScores:v}=D7(u,f,d,h,p,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const O7={kernelName:ib,backendName:"cpu",kernelFunc:L7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z7(n){const{inputs:e,backend:t,attrs:r}=n,{indices:i}=e,{dtype:s,depth:a,onValue:o,offValue:c}=r;Ge(i,"oneHot");const l=ue(i.shape),u=new Float32Array(l*a);u.fill(c);const f=t.data.get(i.dataId).values;for(let d=0;d<l;++d)f[d]>=0&&f[d]<a&&(u[d*a+f[d]]=o);return t.makeTensorInfo([...i.shape,a],s,u)}const P7={kernelName:em,backendName:"cpu",kernelFunc:z7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ep(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("zerosLike is not supported for string tensors");if(r.dtype==="complex64"){const i=zo({inputs:{input:r},backend:t}),s=ep({inputs:{x:i},backend:t}),a=cl({inputs:{input:r},backend:t}),o=ep({inputs:{x:a},backend:t}),c=Ur({inputs:{real:s,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),c}else return iy({backend:t,attrs:{shape:r.shape,value:0,dtype:r.dtype}})}const F7={kernelName:gm,backendName:"cpu",kernelFunc:ep};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RI(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported for string tensors");if(r.dtype==="complex64"){const i=zo({inputs:{input:r},backend:t}),s=RI({inputs:{x:i},backend:t}),a=cl({inputs:{input:r},backend:t}),o=ep({inputs:{x:a},backend:t}),c=Ur({inputs:{real:s,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),c}else return iy({backend:t,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}const $7={kernelName:Jp,backendName:"cpu",kernelFunc:RI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NI(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r;if(e.length===1)return Jh({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const s=e[0].shape,a=e[0].dtype;e.forEach(u=>{S0(s,u.shape,"All tensors passed to stack must have matching shapes"),R(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=e.map(u=>{const f=Jh({inputs:{input:u},backend:t,attrs:{dim:i}});return o.push(f),f}),l=ll({inputs:c,backend:t,attrs:{axis:i}});return o.forEach(u=>t.disposeIntermediateTensorInfo(u)),l}const U7={kernelName:tm,backendName:"cpu",kernelFunc:NI};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B7(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{paddings:s,constantValue:a}=r;Ge(i,"pad");const o=s.map((x,b)=>x[0]+i.shape[b]+x[1]),c=s.map(x=>x[0]),l=t.data.get(i.dataId).values,u=ue(i.shape),f=i.shape.length,d=Qe(i.shape),h=ue(o),p=o.length,g=Qe(o),m=ir(i.dtype,h);a!==0&&m.fill(a);for(let x=0;x<u;x++){const _=wl(x,f,d).map((E,S)=>E+c[S]),w=us(_,p,g);m[w]=l[x]}return{dataId:t.write(m,o,i.dtype),shape:o,dtype:i.dtype}}const kI={kernelName:nm,backendName:"cpu",kernelFunc:B7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V7=En((n,e)=>Math.pow(n,e)),G7=Pn(yf,V7),H7={kernelName:yf,backendName:"cpu",kernelFunc:G7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W7(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:i,paramsDenseValues:s,indices:a}=e,o=i.map(m=>t.data.get(m.dataId).values),c=i.map(m=>m.shape),l=t.data.get(s.dataId).values,u=t.data.get(a.dataId).values,[f,d,h]=ZC(o,c,l,s.shape,s.dtype,u,a.shape),p=f.map(m=>t.makeTensorInfo([m.length],"int32",m)),g=t.makeTensorInfo(h,s.dtype,d);return p.concat([g])}const q7={kernelName:ZE,backendName:"cpu",kernelFunc:W7};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X7(n){const{inputs:e,backend:t}=n,{starts:r,limits:i,deltas:s}=e,a=t.data.get(r.dataId).values,o=t.data.get(i.dataId).values,c=t.data.get(s.dataId).values,[l,u]=QC(a,r.shape,r.dtype,o,i.shape,c,s.shape),f=t.makeTensorInfo([l.length],"int32",l),d=t.makeTensorInfo([u.length],r.dtype,u);return[f,d]}const K7={kernelName:QE,backendName:"cpu",kernelFunc:X7};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j7(n){const{inputs:e,backend:t,attrs:r}=n,{shape:i,values:s,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:c}=r,l=t.data.get(i.dataId).values,u=t.data.get(s.dataId).values,f=t.data.get(a.dataId).values,d=o.map(m=>t.data.get(m.dataId).values),h=o.map(m=>m.shape),[p,g]=JC(l,i.shape,u,s.shape,s.dtype,f,a.shape,d,h,c);return t.makeTensorInfo(p,s.dtype,g)}const Y7={kernelName:JE,backendName:"cpu",kernelFunc:j7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z7(n){const{backend:e,attrs:t}=n,{start:r,stop:i,dtype:s,step:a}=t,o=eI(r,i,a,s);return e.makeTensorInfo([o.length],s,o)}const Q7={kernelName:sb,backendName:"cpu",kernelFunc:Z7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const J7=Wt(wf,n=>1/n),eK={kernelName:wf,backendName:"cpu",kernelFunc:J7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tK(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r;Ge(i,"resizeBilinear");const c=Qe(i.shape),[l,u]=o,[f,d,h,p]=i.shape,g=t.data.get(i.dataId).values,m=new Float32Array(ue([f,l,u,p])),v=[s&&l>1?d-1:d,s&&u>1?h-1:h],x=[s&&l>1?l-1:l,s&&u>1?u-1:u];let b=0;const _=v[0]/x[0],w=v[1]/x[1];for(let E=0;E<f;E++)for(let S=0;S<l;S++){let T;a?T=_*(S+.5)-.5:T=_*S;const C=Math.max(0,Math.floor(T)),y=T-C,A=Math.min(d-1,Math.ceil(T)),k=E*c[0]+C*c[1],M=E*c[0]+A*c[1];for(let L=0;L<u;L++){let z;a?z=w*(L+.5)-.5:z=w*L;const D=Math.max(0,Math.floor(z)),F=z-D,O=Math.min(h-1,Math.ceil(z)),V=k+D*c[2],J=M+D*c[2],Q=k+O*c[2],de=M+O*c[2];for(let le=0;le<p;le++){const H=g[V+le],q=g[J+le],oe=g[Q+le],fe=g[de+le],_e=H+(oe-H)*F,xe=q+(fe-q)*F,Se=_e+(xe-_e)*y;m[b++]=Se}}}return t.makeTensorInfo([f,l,u,p],"float32",m)}const nK={kernelName:om,backendName:"cpu",kernelFunc:tK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rK(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:a}=r;Ge([s,i],"resizeBilinearGrad");const o=Qe(i.shape),[c,l,u,f]=i.shape,[,d,h]=s.shape,p=new Float32Array(c*l*u*f),g=[a&&d>1?l-1:l,a&&h>1?u-1:u],m=[a&&d>1?d-1:d,a&&h>1?h-1:h],v=g[0]/m[0],x=g[1]/m[1],b=t.data.get(s.dataId).values;let _=0;for(let w=0;w<c;w++){const E=w*o[0];for(let S=0;S<d;S++){const T=S*v,C=Math.floor(T),y=Math.min(Math.ceil(T),l-1),A=E+C*o[1],k=E+y*o[1],M=T-C,L=1-M;for(let z=0;z<h;z++){const D=z*x,F=Math.floor(D),O=Math.min(Math.ceil(D),u-1),V=D-F,J=1-V,Q=A+F*o[2],de=A+O*o[2],le=k+F*o[2],H=k+O*o[2],q=L*J,oe=L*V,fe=M*J,_e=M*V;for(let xe=0;xe<f;xe++){const Se=b[_++];p[Q+xe]+=Se*q,p[de+xe]+=Se*oe,p[le+xe]+=Se*fe,p[H+xe]+=Se*_e}}}}return t.makeTensorInfo([c,u,l,f],"float32",p)}const iK={kernelName:cb,backendName:"cpu",kernelFunc:rK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sK(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r;Ge(i,"resizeNearestNeighbor");const c=Qe(i.shape),[l,u]=o,[f,d,h,p]=i.shape,g=t.data.get(i.dataId).values,m=new Float32Array(f*l*u*p),v=[s&&l>1?d-1:d,s&&u>1?h-1:h],x=[s&&l>1?l-1:l,s&&u>1?u-1:u],b=v[0]/x[0],_=v[1]/x[1];let w=0;for(let E=0;E<f;E++){const S=E*c[0];for(let T=0;T<l;T++){const C=a?b*(T+.5):b*T;let y=Math.min(d-1,s?Math.round(C):Math.floor(C));a&&(y=Math.max(0,y));const A=S+y*c[1];for(let k=0;k<u;k++){const M=a?_*(k+.5):_*k;let L=Math.min(h-1,s?Math.round(M):Math.floor(M));a&&(L=Math.max(0,L));const z=A+L*c[2];for(let D=0;D<p;D++){const F=g[z+D];m[w++]=F}}}}return t.makeTensorInfo([f,l,u,p],i.dtype,m)}const aK={kernelName:am,backendName:"cpu",kernelFunc:sK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oK(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:a}=r;Ge([s,i],"resizeNearestNeighborGrad");const o=Qe(i.shape),c=Qe(s.shape),[l,u,f,d]=i.shape,[,h,p]=s.shape,g=new Float32Array(l*u*f*d),m=t.data.get(s.dataId).values,v=[a&&h>1?u-1:u,a&&p>1?f-1:f],x=[a&&h>1?h-1:h,a&&p>1?p-1:p],b=v[0]/x[0],_=v[1]/x[1],w=1/b,E=1/_,S=Math.ceil(w)*2+2,T=Math.ceil(E)*2+2;for(let C=0;C<l;C++){const y=C*o[0];for(let A=0;A<u;A++){const k=y+A*o[1],M=Math.floor(A*w),L=Math.floor(M-S/2);for(let z=0;z<f;z++){const D=k+z*o[2],F=Math.floor(z*E),O=Math.floor(F-T/2);for(let V=0;V<d;V++){let J=0;for(let Q=0;Q<S;Q++){const de=Q+L;if(de<0||de>=h)continue;const le=y+de*c[1],H=de*b,q=Math.min(u-1,a?Math.round(H):Math.floor(H));if(A===q)for(let oe=0;oe<T;oe++){const fe=oe+O;if(fe<0||fe>=p)continue;const _e=le+fe*c[2],xe=fe*_,Se=Math.min(f-1,a?Math.round(xe):Math.floor(xe));z===Se&&(J+=m[_e+V])}}g[D+V]=J}}}}return t.makeTensorInfo(i.shape,i.dtype,g)}const cK={kernelName:ob,backendName:"cpu",kernelFunc:oK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lK(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dims:s}=r;Ge(i,"reverse");const a=i.shape.length,o=St(s,i.shape);if(a===0)return _s({inputs:{x:i},backend:t});const c=new jn(i.shape,i.dtype),l=t.bufferSync(i);for(let u=0;u<c.size;u++){const f=c.indexToLoc(u),d=f.slice();o.forEach(h=>d[h]=i.shape[h]-1-d[h]),c.set(l.get(...d),...f)}return t.makeTensorInfo(c.shape,c.dtype,c.values)}const uK={kernelName:cm,backendName:"cpu",kernelFunc:lK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fK={kernelName:mb,backendName:"cpu",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:i,fillValue:s,center:a}=e,o=t,c=ir(r.dtype,ue(r.shape)),[l,u,f,d]=r.shape,[h,p]=f_(a,u,f),g=255,m=Math.sin(i),v=Math.cos(i),x=o.data.get(r.dataId).values;for(let _=0;_<l;_++){const w=_*f*u*d;for(let E=0;E<u;E++){const S=E*(f*d);for(let T=0;T<f;T++){const C=T*d;for(let y=0;y<d;y++){const A=[l,E,T,y],k=A[2],M=A[1];let L=(k-h)*v-(M-p)*m,z=(k-h)*m+(M-p)*v;L=Math.round(L+h),z=Math.round(z+p);let D=s;if(typeof s!="number"&&(y===3?D=g:D=s[y]),L>=0&&L<f&&z>=0&&z<u){const O=z*(f*d),V=L*d,J=w+O+V+y;D=x[J]}const F=w+S+C+y;c[F]=D}}}}return{dataId:o.write(c,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dK=Wt(Tf,n=>{const e=Math.floor(n);return n-e<.5?Math.floor(n):n-e>.5?Math.ceil(n):e%2===0?e:e+1}),hK={kernelName:Tf,backendName:"cpu",kernelFunc:dK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pK(n){const{inputs:e,backend:t,attrs:r}=n,{indices:i,updates:s}=e,{shape:a}=r,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:f}=Xo(s,i,a),d=!0,h=t.bufferSync(i),p=t.bufferSync(s),g=xo(h,p,a,f,l,c,o,u,0,d);return t.makeTensorInfo(a,g.dtype,g.values)}const mK={kernelName:e3,backendName:"cpu",kernelFunc:pK};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vK(n,e){let t=0,r=n.length,i=0;for(;t<r;)i=Math.floor((t+r)/2),n[i]<e?t=i+1:r=i;return r}function gK(n,e){let t=0,r=n.length,i=0;for(;t<r;)i=Math.floor((t+r)/2),n[i]<=e?t=i+1:r=i;return r}function xK(n,e,t,r,i,s){const a=gn("int32",t*i);for(let o=0;o<t;++o){const c=n.slice(o*r,(o+1)*r),l=o*i;for(let u=0;u<i;++u)a[l+u]=s==="left"?vK(c,e[u+l]):gK(c,e[u+l])}return a}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bK(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:i,values:s}=e,{side:a}=r,o=t.data.get(i.dataId).values,c=t.data.get(s.dataId).values,l=xK(o,c,i.shape[0],i.shape[1],s.shape[1],a);return t.makeTensorInfo(s.shape,"int32",l)}const _K={kernelName:n3,backendName:"cpu",kernelFunc:bK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yK(n){const{inputs:e,backend:t}=n,{condition:r,t:i,e:s}=e;Ge([r,i,s],"select");const a=r.shape.length,o=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,l=t.data.get(s.dataId).values,u=Hr(i.dtype,s.dtype),f=sr(ue(i.shape),u);let d=0;const h=a===0||a>1||i.shape.length===1?1:ue(i.shape.slice(1));for(let p=0;p<o.length;p++)for(let g=0;g<h;g++)o[p]===1?f[d++]=c[p]:f[d++]=l[p];return t.makeTensorInfo(i.shape,u,f)}const wK={kernelName:lm,backendName:"cpu",kernelFunc:yK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EK=Cm,SK=Im,TK=Wt(Cf,n=>n>=0?SK*n:EK*(Math.exp(n)-1)),AK={kernelName:Cf,backendName:"cpu",kernelFunc:TK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CK=Wt(Rf,n=>n<0?-1:n>0?1:0),IK={kernelName:Rf,backendName:"cpu",kernelFunc:CK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MK=Wt(If,n=>Math.sin(n)),RK={kernelName:If,backendName:"cpu",kernelFunc:MK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NK=Wt(Mf,n=>Math.sinh(n)),kK={kernelName:Mf,backendName:"cpu",kernelFunc:NK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DK=11920928955078125e-23,dw=Math.log(DK)+2,LK=Wt(kf,n=>{const e=n>-dw,t=n<dw,r=Math.exp(n);let i;return t?i=r:e?i=n:i=Math.log(1+r),i}),OK={kernelName:kf,backendName:"cpu",kernelFunc:LK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zK(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,paddings:a}=r;Ge([i],"spaceToBatchND");const o=ue(s),c=[[0,0]];c.push(...a);for(let E=1+s.length;E<i.shape.length;++E)c.push([0,0]);const l=kI.kernelFunc({inputs:{x:i},backend:t,attrs:{paddings:c,constantValue:0}}),u=Kf(l.shape,s,o,!1),f=jf(u.length,s.length,!1),d=Yf(l.shape,s,o,!1),g=en({inputs:{x:l},backend:t,attrs:{shape:u}}),x=Nr({inputs:{x:g},backend:t,attrs:{perm:f}}),w=en({inputs:{x},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(x),w}const PK={kernelName:dm,backendName:"cpu",kernelFunc:zK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FK(n){const{inputs:e,backend:t}=n,{indices:r,values:i,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
        ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
        ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.data.get(r.dataId).values,c=t.data.get(i.dataId).values,l=t.data.get(s.dataId).values,u=t.data.get(a.dataId).values[0],[f,d,h,p,g]=iI(o,r.shape,r.dtype,c,i.dtype,l,u);return[t.makeTensorInfo(d,r.dtype,f),t.makeTensorInfo([d[0]],i.dtype,h),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(m=>Number(m)))),t.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const $K={kernelName:r3,backendName:"cpu",kernelFunc:FK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UK(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:i,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape
        ${r.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape
        ${i.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const a=Array.from(t.data.get(i.dataId).values),o=t.data.get(r.dataId).values,c=Array.from(t.data.get(s.dataId).values),[l,u,f]=sI(o,r.shape,r.dtype,a,c);return[t.makeTensorInfo(u,r.dtype,l),t.makeTensorInfo([f.length],s.dtype,new Int32Array(f))]}const BK={kernelName:i3,backendName:"cpu",kernelFunc:UK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VK(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
          ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
          ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(r.dataId).values,o=t.data.get(i.dataId).values,c=t.data.get(s.dataId).values,[l,u]=ey(a,r.shape,r.dtype,o,c,!0);return t.makeTensorInfo(u,r.dtype,l)}const GK={kernelName:s3,backendName:"cpu",kernelFunc:VK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HK(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
         ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
         ${s.shape}`);if(i.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const a=t.data.get(r.dataId).values,o=t.data.get(i.dataId).values,c=t.data.get(s.dataId).values,[l,u]=ey(a,r.shape,r.dtype,o,c);return t.makeTensorInfo(u,r.dtype,l)}const WK={kernelName:a3,backendName:"cpu",kernelFunc:HK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qK(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:i,sparseValues:s,defaultValue:a}=e,{outputShape:o}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:f,outputSize:d}=Xo(s,i,o),h=!1,p=t.bufferSync(i);let g;switch(s.dtype){case"bool":{const m=t.bufferSync(s),v=!!t.data.get(a.dataId).values[0];g=xo(p,m,o,d,u,l,c,f,v,h);break}case"float32":{const m=t.bufferSync(s),v=t.data.get(a.dataId).values[0];g=xo(p,m,o,d,u,l,c,f,v,h);break}case"int32":{const m=t.bufferSync(s),v=t.data.get(a.dataId).values[0];g=xo(p,m,o,d,u,l,c,f,v,h);break}case"string":{const m=t.bufferSync(s),v=Na(t.data.get(a.dataId).values[0]);g=xo(p,m,o,d,u,l,c,f,v,h);break}default:throw new Error(`Unsupported type ${s.dtype}`)}return t.makeTensorInfo(o,g.dtype,g.values)}const XK={kernelName:o3,backendName:"cpu",kernelFunc:qK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KK(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{numOrSizeSplits:s,axis:a}=r,o=St(a,i.shape)[0],c=A_(i,s,o),l=new Array(i.shape.length).fill(0),u=i.shape.slice();return c.map(f=>{const d=[...u];d[o]=f;const h=Po({inputs:{x:i},backend:t,attrs:{begin:l,size:d}});return l[o]+=f,h})}const jK={kernelName:hm,backendName:"cpu",kernelFunc:KK};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YK={kernelName:lb,backendName:"cpu",kernelFunc:({inputs:n,backend:e})=>{const{x:t}=n,r=e;Ge(t,"square");const i=r.data.get(t.dataId).values,s=new Float32Array(i.length);for(let o=0;o<i.length;++o){const c=i[o];s[o]=c*c}return{dataId:r.write(s,t.shape,t.dtype),shape:t.shape,dtype:t.dtype}}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZK=Wt($f,(n,e)=>{const t=e;return isNaN(n)?NaN:n>0?1:t.alpha}),QK={kernelName:$f,backendName:"cpu",kernelFunc:ZK};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JK(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,end:a,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:f,shrinkAxisMask:d}=r;Ge(i,"stridedSlice");const{finalShapeSparse:h,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:v,begin:x,end:b,strides:_}=c_(i.shape,s,a,o,c,l,u,f,d);let w;if(g)w=en({inputs:{x:i},backend:t,attrs:{shape:p}});else if(m||v){R(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const E=s_(x,b,_),S=Po({inputs:{x:i},backend:t,attrs:{begin:x,size:E}});w=en({inputs:{x:S},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(S)}else{const E=t.bufferSync(i),S=cI(h,E,_,x);w=t.makeTensorInfo(p,S.dtype,S.values)}return w}const ej={kernelName:fb,backendName:"cpu",kernelFunc:JK};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tj(n){const{inputs:e,backend:t,attrs:r}=n,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:f}=e,d=t.data.get(u.dataId).values,h=t.data.get(f.dataId).values,[p,g]=lI(d,h,i,s,a,o,c,l);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(f.shape,"int32",g)]}const nj={kernelName:c3,backendName:"cpu",kernelFunc:tj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rj(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:i}=r,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.data.get(s.dataId).values,c=t.data.get(a.dataId).values[0],[l,u,f]=uI(o,c,i),d=u.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const ij={kernelName:l3,backendName:"cpu",kernelFunc:rj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sj(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:i}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=t.data.get(s.dataId).values,o=fI(a,i);return t.makeTensorInfo(s.shape,"int32",o)}const aj={kernelName:u3,backendName:"cpu",kernelFunc:sj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oj=Wt(zf,n=>Math.tan(n)),cj={kernelName:zf,backendName:"cpu",kernelFunc:oj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lj=Wt(Pf,n=>Math.tanh(n)),uj={kernelName:Pf,backendName:"cpu",kernelFunc:lj};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fj(n){const{inputs:e,backend:t}=n,{tensor:r,indices:i,updates:s}=e,{sliceRank:a,numUpdates:o,sliceSize:c,strides:l,outputSize:u}=Xo(s,i,r.shape),f=!1,d=t.bufferSync(i),h=t.bufferSync(s),p=t.bufferSync(r),g=xo(d,h,r.shape,u,c,o,a,l,p,f);return t.makeTensorInfo(r.shape,g.dtype,g.values)}const dj={kernelName:t3,backendName:"cpu",kernelFunc:fj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hj(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reps:s}=r;Ge(i,"tile");const a=hI(t.bufferSync(i),s);return t.makeTensorInfo(a.shape,a.dtype,a.values)}const pj={kernelName:Ff,backendName:"cpu",kernelFunc:hj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mj(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{k:s,sorted:a}=r;Ge(i,"topk");const o=t.data.get(i.dataId).values,[c,l]=mI(o,i.shape,i.dtype,s,a);return[t.makeTensorInfo(c.shape,c.dtype,c.values),t.makeTensorInfo(l.shape,l.dtype,l.values)]}const vj={kernelName:db,backendName:"cpu",kernelFunc:mj};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gj(n){const{inputs:e,attrs:t,backend:r}=n,{image:i,transforms:s}=e,{interpolation:a,fillMode:o,fillValue:c,outputShape:l}=t,[u,f,d,h]=i.shape,[p,g]=l??[f,d],m=[u,p,g,h],v=Qe(i.shape),x=v[0],b=v[1],_=v[2],w=Qe(m),E=w[0],S=w[1],T=w[2],C=ir(i.dtype,ue(m));C.fill(c);const y=r.data.get(i.dataId).values,A=r.data.get(s.dataId).values;for(let M=0;M<u;++M){const L=s.shape[0]===1?A:A.subarray(M*8,M*8+8);for(let z=0;z<p;++z)for(let D=0;D<g;++D)for(let F=0;F<h;++F){let O;const V=L[6]*D+L[7]*z+1;if(V===0)continue;const J=(L[0]*D+L[1]*z+L[2])/V,Q=(L[3]*D+L[4]*z+L[5])/V,de=hw(J,d,o),le=hw(Q,f,o);switch(a){case"nearest":O=Ej(y,f,d,x,b,_,M,le,de,F,c);break;case"bilinear":O=Sj(y,f,d,x,b,_,M,le,de,F,c);break;default:throw new Error(`Error in Transform: Expect 'nearest' or 'bilinear', but got ${a}`)}const H=M*E+z*S+D*T+F;C[H]=O}return r.makeTensorInfo(m,i.dtype,C)}return{dataId:r.write(C,m,i.dtype),shape:i.shape,dtype:i.dtype}}const xj={kernelName:hb,backendName:"cpu",kernelFunc:gj};function hw(n,e,t){switch(t){case"reflect":return bj(n,e);case"wrap":return _j(n,e);case"nearest":return wj(n,e);case"constant":default:return yj(n)}}function bj(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=2*e;t<r&&(t=r*Math.trunc(-t/r)+t),t=t<-e?t+r:-t-1}else if(t>e-1)if(e<=1)t=0;else{const r=2*e;t-=r*Math.trunc(t/r),t>=e&&(t=r-t-1)}return To(0,t,e-1)}function _j(n,e){let t=n;if(t<0)if(e<=1)t=0;else{const r=e-1;t+=e*(Math.trunc(-t/r)+1)}else if(t>e-1)if(e<=1)t=0;else{const r=e-1;t-=e*Math.trunc(t/r)}return To(0,t,e-1)}function yj(n,e){return n}function wj(n,e){return To(0,n,e-1)}function hu(n,e,t,r,i,s,a,o,c,l,u){const f=a*r+o*i+c*s+l;return 0<=o&&o<e&&0<=c&&c<t?n[f]:u}function Ej(n,e,t,r,i,s,a,o,c,l,u){const f=Math.round(o),d=Math.round(c);return hu(n,e,t,r,i,s,a,f,d,l,u)}function Sj(n,e,t,r,i,s,a,o,c,l,u){const f=Math.floor(o),d=Math.floor(c),h=f+1,p=d+1,g=(p-c)*hu(n,e,t,r,i,s,a,f,d,l,u)+(c-d)*hu(n,e,t,r,i,s,a,f,p,l,u),m=(p-c)*hu(n,e,t,r,i,s,a,h,d,l,u)+(c-d)*hu(n,e,t,r,i,s,a,h,p,l,u);return(h-o)*g+(o-f)*m}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tj(n){const{inputs:e,attrs:t,backend:r}=n,{axis:i}=t,{x:s}=e;Ge(s,"unique");const a=r.data.get(s.dataId).values,{outputValues:o,outputShape:c,indices:l}=vI(a,i,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}const Aj={kernelName:pb,backendName:"cpu",kernelFunc:Tj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cj(n){const{inputs:e,backend:t,attrs:r}=n,{value:i}=e;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i.shape.length,o=i.shape[s],c=new Array(a-1);let l=0;for(let h=0;h<a;h++)h!==s&&(c[l++]=i.shape[h]);const u=new Array(a).fill(0),f=i.shape.slice();f[s]=1;const d=new Array(o);for(let h=0;h<d.length;h++){u[s]=h;const p=Po({inputs:{x:i},backend:t,attrs:{begin:u,size:f}});d[h]=en({inputs:{x:p},backend:t,attrs:{shape:c}}),t.disposeIntermediateTensorInfo(p)}return d}const Ij={kernelName:mm,backendName:"cpu",kernelFunc:Cj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mj(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,segmentIds:s}=e,{numSegments:a}=r;Ge(i,"unsortedSegmentSum");const o=i.shape.length,c=s.shape.length,l=[],u=[],f=o-c;let d=s;for(let p=0;p<f;++p){const g=Jh({inputs:{input:d},backend:t,attrs:{dim:p+1}});d=g,u.push(g)}for(let p=0;p<a;++p){const g=Ua(p,"int32"),m=t.makeTensorInfo([],"int32",g),v=NC({inputs:{a:m,b:d},backend:t}),x=za({inputs:{x:v},backend:t,attrs:{dtype:"float32"}}),b=Um({inputs:{a:x,b:i},backend:t}),_=sd({inputs:{x:b},backend:t,attrs:{axis:0,keepDims:!1}});l.push(_),u.push(m),u.push(v),u.push(x),u.push(b),u.push(_)}const h=NI({inputs:l,backend:t,attrs:{axis:0}});return u.forEach(p=>t.disposeIntermediateTensorInfo(p)),h}const Rj={kernelName:vm,backendName:"cpu",kernelFunc:Mj};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nj=[Tq,s8,Cq,Mq,f8,Nq,Dq,Oq,Pq,$q,Bq,Gq,Wq,Kq,Yq,Jq,tX,rX,sX,Eq,oX,lX,fX,h8,hX,l8,m8,mX,a8,gX,bX,_X,wX,SX,AX,IX,RX,kX,LX,zX,FX,UX,VX,HX,WX,XX,jX,ZX,QX,JX,e9,n9,s9,vq,o9,v8,m9,g8,v9,b8,w9,E9,T9,y8,E8,C9,M9,N9,D9,T8,C8,o8,O9,xX,P9,$9,B9,gq,M8,N8,G9,D8,W9,K9,Y9,J9,t7,r7,i7,O8,a7,c7,u7,d7,p7,v7,x7,P8,_7,E7,A7,$8,B8,M7,k7,O7,G8,P7,$7,U7,kI,H7,bq,q8,q7,K7,Y7,Q7,c8,Nx,eK,_q,yq,wq,nK,iK,aK,cK,uK,fK,hK,eq,mK,_K,wK,AK,nq,IK,RK,kK,rq,S7,OK,PK,$K,BK,GK,WK,XK,jK,aq,YK,cq,uq,QK,ej,nj,ij,aj,pq,r9,cj,uj,dj,pj,vj,xj,H8,Aj,Ij,Rj,F7];for(const n of Nj)d3(n);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ho={},th={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function kj(n,e){ho[n]=e}function Zi(n,e){if(!(n in ho)||e!=null){const r=Lj(n,e);if(r!==null)ho[n]=r;else return console.log("Could not get context for WebGL version",n),null}const t=ho[n];return t==null||t.isContextLost()?(delete ho[n],Zi(n)):(t.disable(t.DEPTH_TEST),t.disable(t.STENCIL_TEST),t.disable(t.BLEND),t.disable(t.DITHER),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SAMPLE_COVERAGE),t.enable(t.SCISSOR_TEST),t.enable(t.CULL_FACE),t.cullFace(t.BACK),ho[n])}function Dj(n){if(!ie().getBool("IS_SAFARI")&&typeof OffscreenCanvas<"u"&&n===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function Lj(n,e){if(n!==1&&n!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const t=e??Dj(n);return t.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete ho[n]},!1),ie().getBool("SOFTWARE_WEBGL_ENABLED")&&(th.failIfMajorPerformanceCaveat=!1),n===1?t.getContext("webgl",th)||t.getContext("experimental-webgl",th):t.getContext("webgl2",th)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var Du;(function(n){n[n.DENSE=0]="DENSE",n[n.SHARED_BATCH=1]="SHARED_BATCH"})(Du||(Du={}));var ei;(function(n){n[n.RENDER=0]="RENDER",n[n.UPLOAD=1]="UPLOAD",n[n.PIXELS=2]="PIXELS",n[n.DOWNLOAD=3]="DOWNLOAD"})(ei||(ei={}));var Kn;(function(n){n[n.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",n[n.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",n[n.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",n[n.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",n[n.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Kn||(Kn={}));function ad(n,e){return[e,n]}function Oj(n,e){return n*e}function nh(n){const e=ue(n),t=Math.ceil(e/4);return Qg(t)}function Rl(n,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(n/2))]}function zj(n,e){const[t,r]=Rl(n,e);return t*r*4}function sy(n,e){const t=n;let r,i,s,a,o,c,l,u,f,d;return ie().getNumber("WEBGL_VERSION")===2?(r=t.R32F,i=t.R16F,s=t.RGBA16F,a=t.RGBA32F,o=t.RED,l=4,u=1,f=t.HALF_FLOAT,d=t.FLOAT,c=t.RGBA8):(r=n.RGBA,i=n.RGBA,s=n.RGBA,a=t.RGBA,o=n.RGBA,l=4,u=4,f=e!=null?e.HALF_FLOAT_OES:null,d=n.FLOAT,c=n.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:a,textureFormatFloat:o,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:f,textureTypeFloat:d}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ne(n,e){const t=e();return ie().getBool("DEBUG")&&Pj(n),t}function Pj(n){const e=n.getError();if(e!==n.NO_ERROR)throw new Error("WebGL Error: "+Bj(n,e))}const Fj=596e-10,$j=65504;function Uj(n){return!!(ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||n===0||Fj<Math.abs(n)&&Math.abs(n)<$j)}function Bj(n,e){switch(e){case n.NO_ERROR:return"NO_ERROR";case n.INVALID_ENUM:return"INVALID_ENUM";case n.INVALID_VALUE:return"INVALID_VALUE";case n.INVALID_OPERATION:return"INVALID_OPERATION";case n.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case n.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case n.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function rh(n,e){return ra(n,()=>n.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function Vj(n,e){const t=ra(n,()=>n.createShader(n.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(Ne(n,()=>n.shaderSource(t,e)),Ne(n,()=>n.compileShader(t)),n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw console.log(n.getShaderInfoLog(t)),new Error("Failed to compile vertex shader.");return t}function Gj(n,e){const t=ra(n,()=>n.createShader(n.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(Ne(n,()=>n.shaderSource(t,e)),Ne(n,()=>n.compileShader(t)),ie().get("ENGINE_COMPILE_ONLY"))return t;if(n.getShaderParameter(t,n.COMPILE_STATUS)===!1)throw DI(e,n.getShaderInfoLog(t)),new Error("Failed to compile fragment shader.");return t}const Hj=/ERROR: [0-9]+:([0-9]+):/g;function DI(n,e){const t=Hj.exec(e);if(t==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(n);return}const r=+t[1],i=n.split(`
`),s=i.length.toString().length+2,a=i.map((f,d)=>Pc((d+1).toString(),s)+f);let o=0;for(let f=0;f<a.length;f++)o=Math.max(a[f].length,o);const c=a.slice(0,r-1),l=a.slice(r-1,r),u=a.slice(r);console.log(c.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${Pc(l[0],o)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function Wj(n){return ra(n,()=>n.createProgram(),"Unable to create WebGLProgram.")}function qj(n,e){if(Ne(n,()=>n.linkProgram(e)),!ie().get("ENGINE_COMPILE_ONLY")&&n.getProgramParameter(e,n.LINK_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function jv(n,e){if(Ne(n,()=>n.validateProgram(e)),n.getProgramParameter(e,n.VALIDATE_STATUS)===!1)throw console.log(n.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function Xj(n,e){const t=ra(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ne(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),Ne(n,()=>n.bufferData(n.ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function Kj(n,e){const t=ra(n,()=>n.createBuffer(),"Unable to create WebGLBuffer");return Ne(n,()=>n.bindBuffer(n.ELEMENT_ARRAY_BUFFER,t)),Ne(n,()=>n.bufferData(n.ELEMENT_ARRAY_BUFFER,e,n.STATIC_DRAW)),t}function jj(n){return ra(n,()=>n.createTexture(),"Unable to create WebGLTexture.")}function Yj(n,e){const t=ie().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(n<=0||e<=0){const r=`[${n}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(n>t||e>t){const r=`[${n}x${e}]`,i=`[${t}x${t}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+i+".")}}function Zj(n){return ra(n,()=>n.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function pw(n,e,t,r,i,s,a){const o=n.getAttribLocation(e,t);return o===-1?!1:(Ne(n,()=>n.bindBuffer(n.ARRAY_BUFFER,r)),Ne(n,()=>n.vertexAttribPointer(o,i,n.FLOAT,!1,s,a)),Ne(n,()=>n.enableVertexAttribArray(o)),!0)}function Qj(n,e,t){rY(n,t),Ne(n,()=>n.activeTexture(n.TEXTURE0+t)),Ne(n,()=>n.bindTexture(n.TEXTURE_2D,e))}function Jj(n,e,t){return ra(n,()=>n.getUniformLocation(e,t),'uniform "'+t+'" not present in program.')}function eY(n,e,t){return n.getUniformLocation(e,t)}function tY(n,e,t,r){Ne(n,()=>Qj(n,e,r)),Ne(n,()=>n.uniform1i(t,r))}function Yv(n,e,t){Ne(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,t)),Ne(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,e,0))}function mw(n,e){Ne(n,()=>n.bindFramebuffer(n.FRAMEBUFFER,e)),Ne(n,()=>n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,null,0))}function ih(n){const e=n.checkFramebufferStatus(n.FRAMEBUFFER);if(e!==n.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+nY(n,e))}function nY(n,e){switch(e){case n.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case n.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case n.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function ra(n,e,t){const r=Ne(n,()=>e());if(r==null)throw new Error(t);return r}function rY(n,e){const t=n.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+n.TEXTURE0;if(r<n.TEXTURE0||r>t){const i=`[gl.TEXTURE0, gl.TEXTURE${t}]`;throw new Error(`textureUnit must be in ${i}.`)}}function ul(n,e=2){return ue(n.slice(0,n.length-e))}function fl(n){if(n.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[n.length>1?n[n.length-2]:1,n[n.length-1]]}function sh(n){let e=[1,1,1];return n.length===0||n.length===1&&n[0]===1||(e=[ul(n),...fl(n)]),e}function iY(n,e=!1){let t=ie().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=ie().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&ie().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=t/2),e&&(t=t*2,r=r*2,n=n.map((o,c)=>c>=n.length-2?E0(n[c]):n[c]),n.length===1&&(n=[2,n[0]])),n.length!==2&&(n=$a(n).newShape);let i=ue(n),s=null;n.length<=1&&i<=t?s=[1,i]:n.length===2&&n[0]<=t&&n[1]<=t?s=n:n.length===3&&n[0]*n[1]<=t&&n[2]<=t?s=[n[0]*n[1],n[2]]:n.length===3&&n[0]<=t&&n[1]*n[2]<=t?s=[n[0],n[1]*n[2]]:n.length===4&&n[0]*n[1]*n[2]<=t&&n[3]<=t?s=[n[0]*n[1]*n[2],n[3]]:n.length===4&&n[0]<=t&&n[1]*n[2]*n[3]<=t&&(s=[n[0],n[1]*n[2]*n[3]]);const a=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||a)if(e){const o=ul(n);let c=2,l=2;n.length&&([c,l]=fl(n)),i=o*(c/2)*(l/2),s=Qg(i).map(u=>u*2)}else s=Qg(i);return s}function ah(n){return n%2===0}function tp(n,e){if(n=n.slice(-2),e=e.slice(-2),Pt(n,e)||!n.length||!e.length||n[0]===0||n[1]===0||e[0]===0||e[1]===0)return!0;if(n.length!==e.length){const t=n[n.length-1],r=e[e.length-1];if(t===r||ah(t)&&ah(r)&&(n[0]===1||e[0]===1))return!0}return n[1]===e[1]&&ah(n[0])&&ah(e[0])}let Zv,Qv;function sY(n){if(Zv==null){const e=Zi(n);Zv=e.getParameter(e.MAX_TEXTURE_SIZE)}return Zv}function aY(n){if(Qv==null){const e=Zi(n);Qv=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,Qv)}function oY(n){if(n===0)return 0;let e;const t=Zi(n);return bi(t,"EXT_disjoint_timer_query_webgl2")&&n===2?e=2:bi(t,"EXT_disjoint_timer_query")?e=1:e=0,e}function bi(n,e){return n.getExtension(e)!=null}function vw(n){try{if(Zi(n)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function cY(n){if(n===0)return!1;const e=Zi(n);if(n===1){if(!bi(e,"OES_texture_float"))return!1}else if(!bi(e,"EXT_color_buffer_float"))return!1;return Dx(e)}function lY(n){if(n===0)return!1;const e=Zi(n);if(n===1){if(!bi(e,"OES_texture_float")||!bi(e,"WEBGL_color_buffer_float"))return!1}else{if(bi(e,"EXT_color_buffer_float"))return Dx(e);const r="EXT_color_buffer_half_float";if(bi(e,r)){const i=e.getExtension(r);return uY(e,i)}return!1}return Dx(e)}function Dx(n){const e=sy(n),t=n.createTexture();n.bindTexture(n.TEXTURE_2D,t);const r=1,i=1;n.texImage2D(n.TEXTURE_2D,0,e.internalFormatFloat,r,i,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,s),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,t,0);const a=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(t),n.deleteFramebuffer(s),a}function uY(n,e){const t=sy(n,e),r=n.createTexture();n.bindTexture(n.TEXTURE_2D,r);const i=1,s=1;n.texImage2D(n.TEXTURE_2D,0,t.internalFormatHalfFloat,i,s,0,t.textureFormatFloat,t.textureTypeHalfFloat,null);const a=n.createFramebuffer();n.bindFramebuffer(n.FRAMEBUFFER,a),n.framebufferTexture2D(n.FRAMEBUFFER,n.COLOR_ATTACHMENT0,n.TEXTURE_2D,r,0);const o=n.checkFramebufferStatus(n.FRAMEBUFFER)===n.FRAMEBUFFER_COMPLETE;return n.bindTexture(n.TEXTURE_2D,null),n.bindFramebuffer(n.FRAMEBUFFER,null),n.deleteTexture(r),n.deleteFramebuffer(a),o}function fY(n){return n!==2?!1:Zi(n).fenceSync!=null}function od(n,e){Array.isArray(n)||(n=[n]),n.forEach(t=>{t!=null&&R(t.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const We=ie();We.registerFlag("HAS_WEBGL",()=>We.getNumber("WEBGL_VERSION")>0);We.registerFlag("WEBGL_VERSION",()=>vw(2)?2:vw(1)?1:0);We.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);We.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>We.get("WEBGL_VERSION")===2);We.registerFlag("WEBGL_CPU_FORWARD",()=>!0);We.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);We.registerFlag("WEBGL_PACK",()=>We.getBool("HAS_WEBGL"));We.registerFlag("WEBGL_PACK_NORMALIZATION",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_PACK_CLIP",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_PACK_REDUCE",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_LAZILY_UNPACK",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_CONV_IM2COL",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",()=>We.getBool("WEBGL_PACK"));We.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>sY(We.getNumber("WEBGL_VERSION")));We.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>aY(We.getNumber("WEBGL_VERSION")));We.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const n=We.getNumber("WEBGL_VERSION");return n===0?0:oY(n)});We.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>We.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!M3());We.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>cY(We.getNumber("WEBGL_VERSION")));We.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>We.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:We.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));We.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>lY(We.getNumber("WEBGL_VERSION")));We.registerFlag("WEBGL_FENCE_API_ENABLED",()=>fY(We.getNumber("WEBGL_VERSION")));We.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>We.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);We.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${n}.`)});We.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>M3()?1:-1,n=>{if(typeof n!="number")throw new Error(`WEBGL_FLUSH_THRESHOLD must be a number but got ${n}.`);if(n<0&&n!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${n}.`)});We.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);We.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);We.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);We.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);We.registerFlag("WEBGL_EXP_CONV",()=>!1);We.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>We.getBool("IS_TEST"));We.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);We.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);We.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);We.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function br(){let n,e,t,r,i,s,a,o,c,l;return ie().getNumber("WEBGL_VERSION")===2?(n="#version 300 es",e="in",t="out",r="in",i="texture",s="outputColor",a="out vec4 outputColor;",o=ie().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",c="",l=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(n="",e="attribute",t="varying",r="varying",i="texture2D",s="gl_FragColor",a="",o=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,c=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,l=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:n,attribute:e,varyingVs:t,varyingFs:r,texture2D:i,output:s,defineOutput:a,defineSpecialNaN:o,defineSpecialInf:c,defineRound:l}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yo(n,e,t="index"){const r=Qe(e);return r.map((i,s)=>{const a=`int ${n[s]} = ${t} / ${i}`,o=s===r.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * ${i}`:`index -= ${n[s]} * ${i}`;return`${a}; ${o};`}).join("")}function Bm(n,e,t="index"){const r=Qe(e);return r.map((i,s)=>{const a=`int ${n[s]} = ${t} / outShapeStrides[${s}]`,o=s===r.length-1?`int ${n[s+1]} = ${t} - ${n[s]} * outShapeStrides[${s}]`:`index -= ${n[s]} * outShapeStrides[${s}]`;return`${a}; ${o};`}).join("")}function dY(n,e){const t=n.length,r=n.map(s=>`${e}[${s}]`),i=new Array(t-1);i[t-2]=r[t-1];for(let s=t-3;s>=0;--s)i[s]=`(${i[s+1]} * ${r[s+1]})`;return i}function hY(n,e,t="index"){const r=n.map((s,a)=>a),i=dY(r,e);return i.map((s,a)=>{const o=`int ${n[a]} = ${t} / ${i[a]}`,c=a===i.length-1?`int ${n[a+1]} = ${t} - ${n[a]} * ${i[a]}`:`index -= ${n[a]} * ${i[a]}`;return`${o}; ${c};`}).join("")}function ay(n){const e=Qe(n).map(t=>t.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function oy(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const LI=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:OI}=rG;function pY(n,e,t){const r=[];if(n.forEach(h=>{const p=ue(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),t.enableShapeUniforms){const{uniformShape:g}=cy(t.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(g.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),t.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}t.customUniforms&&t.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});const i=r.join(`
`),s=n.map(h=>mY(h,e,t.packedInputs,t.enableShapeUniforms)).join(`
`),a=e.texShape,o=br(),c=xY(o);let l,u,f=yY(o);return e.isPacked?(l=vY(e.logicalShape,a,t.enableShapeUniforms),u=_Y(o)):(l=gY(e.logicalShape,a,t.enableShapeUniforms),u=bY(o)),t.packedInputs&&(f+=TY),[f,c,u,i,l,s,t.userCode].join(`
`)}function Nl(n,e=!1){const t=n.shapeInfo.logicalShape;switch(t.length){case 0:return PY(n,e);case 1:return $Y(n,e);case 2:return BY(n,e);case 3:return GY(n,e);case 4:return WY(n,e);case 5:return qY(n);case 6:return XY(n);default:throw new Error(`${t.length}-D input sampling is not yet supported`)}}function zI(n,e){switch(n.shapeInfo.logicalShape.length){case 0:return zY(n);case 1:return FY(n,e);case 2:return UY(n,e);case 3:return VY(n,e);default:return HY(n,e)}}function mY(n,e,t=!1,r){let i="";t?i+=zI(n,r):i+=Nl(n,r);const s=n.shapeInfo.logicalShape,a=e.logicalShape;return s.length<=a.length&&(t?i+=KY(n,e):i+=jY(n,e)),i}function vY(n,e,t){switch(n.length){case 0:return PI();case 1:return AY(n,e,t);case 2:return LY(n,e,t);case 3:return IY(n,e,t);default:return RY(n,e,t)}}function gY(n,e,t){switch(n.length){case 0:return PI();case 1:return CY(n,e,t);case 2:return OY(n,e,t);case 3:return MY(n,e,t);case 4:return NY(n,e,t);case 5:return kY(n,e);case 6:return DY(n,e);default:throw new Error(`${n.length}-D output sampling is not yet supported`)}}function xY(n){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${n.texture2D}(textureSampler, uv).r;
    }
  `}function bY(n){return`
    void setOutput(float val) {
      ${n.output} = vec4(val, 0, 0, 0);
    }
  `}function _Y(n){return`
    void setOutput(vec4 val) {
      ${n.output} = val;
    }
  `}function yY(n){return`${n.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${n.varyingFs} vec2 resultUV;
    ${n.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${n.defineSpecialNaN}
    ${n.defineSpecialInf}
    ${n.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${wY}
    ${EY}
    ${SY}
  `}const wY=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,EY=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,SY=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,TY=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function PI(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function AY(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?t?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function CY(n,e,t){return e[0]===1?t?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?t?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:t?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function IY(n,e,t){if(t)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[2]/2),s=i*Math.ceil(n[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function MY(n,e,t){if(t)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${Bm(["r","c","d"],n)}
    return ivec3(r, c, d);
  }
`;const r=Yo(["r","c","d"],n);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function RY(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(n[n.length-1]/2),s=i*Math.ceil(n[n.length-2]/2);let a=s,o="",c="b, r, c";for(let l=2;l<n.length-1;l++)a*=n[n.length-l-1],o=`
      int b${l} = index / ${a};
      index -= b${l} * ${a};
    `+o,c=`b${l}, `+c;return`
    ivec${n.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${o}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${n.length}(${c});
    }
  `}function NY(n,e,t){if(t)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${Bm(["r","c","d","d2"],n)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Yo(["r","c","d","d2"],n);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function kY(n,e){const t=Yo(["r","c","d","d2","d3"],n);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function DY(n,e){const t=Yo(["r","c","d","d2","d3","d4"],n);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${t}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function LY(n,e,t){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Pt(n,e))return t?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const i=Math.ceil(n[1]/2);return t?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function OY(n,e,t){return Pt(n,e)?t?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:n[1]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:n[0]===1?t?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:t?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${n[1]};
      int c = index - r * ${n[1]};
      return ivec2(r, c);
    }
  `}function Zo(n){return`offset${n}`}function zY(n){const e=n.name,t="get"+e.charAt(0).toUpperCase()+e.slice(1),r=br();return`
    vec4 ${t}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function PY(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`float ${r}() {return ${t};}`;const[i,s]=n.shapeInfo.texShape;if(i===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${t}, halfCR);
      }
    `;const a=Zo(t);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], ${a});
      return sampleTexture(${t}, uv);
    }
  `;const[o,c]=n.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${o}, ${c}, ${a});
      return sampleTexture(${t}, uv);
    }
  `}function FY(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=n.shapeInfo.texShape,s=br();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${t}, uv);
    }
  `;const a=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${a[0]}, ${a[1]}, index);
      return ${s.texture2D}(${t}, uv);
    }
  `}function $Y(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1);if(n.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${kl(n)}
      }
    `;const i=n.shapeInfo.texShape,s=i[0],a=i[1];if(a===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${t}, halfCR);
      }
    `;const o=Zo(t);return a===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / float(${t}TexShape[0]));
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${o}) + 0.5) / ${s}.0);
        return sampleTexture(${t}, uv);
      }
    `:s===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / float(${t}TexShape[1]), 0.5);
        return sampleTexture(${t}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${o}) + 0.5) / ${a}.0, 0.5);
        return sampleTexture(${t}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${t}TexShape[0], ${t}TexShape[1], index + ${o});
      return sampleTexture(${t}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${a}, index + ${o});
      return sampleTexture(${t}, uv);
    }
  `}function UY(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,a=s[0],o=s[1],c=br();if(s!=null&&Pt(t,s))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${c.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${o}.0, ${a}.0);

        return ${c.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `;const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(t[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${l[0]}, ${l[1]}, row, col);
      return ${c.texture2D}(${r}, uv);
    }
  `}function BY(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape;if(s!=null&&Pt(t,s)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const d=s[0],h=s[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:a,keptDims:o}=$a(t),c=a;if(c.length<t.length){const d=Dl(n,c),h=["row","col"];return`
      ${Nl(d,e)}
      float ${i}(int row, int col) {
        return ${i}(${Ll(h,o)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${t[1]}, 1)));
        ${kl(n)}
      }
    `;const l=s[0],u=s[1],f=Zo(r);return u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${l}.0);
      return sampleTexture(${r}, uv);
    }
  `:l===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${f}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${f}), vec3(${t[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${f};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${t[1]} + col + ${f};
    vec2 uv = uvFromFlat(${l}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function VY(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n.shapeInfo.texShape,a=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(t[0]===1){const d=t.slice(1),h=[1,2],p=Dl(n,d),g=["b","row","col"];return`
        ${zI(p,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Ll(g,h)});
        }
      `}const o=br();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `;const c=a[0],l=a[1],u=Math.ceil(t[2]/2),f=u*Math.ceil(t[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${c}, ${l}, ${f}, ${u}, b, row, col);
      return ${o.texture2D}(${r}, uv);
    }
  `}function GY(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[1]*t[2],a=t[2],{newShape:o,keptDims:c}=$a(t),l=o;if(l.length<t.length){const g=Dl(n,l),m=["row","col","depth"];return`
        ${Nl(g,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Ll(m,c)});
        }
      `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${a}, 1)));
        ${kl(n)}
      }
    `;const u=n.shapeInfo.texShape,f=u[0],d=u[1],h=n.shapeInfo.flatOffset;if(d===s&&h==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${a}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${d}.0, ${f}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(d===a&&h==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${t[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${d}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `;const p=Zo(r);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${a} + depth + ${p};
        vec2 uv = uvFromFlat(${f}, ${d}, index);
        return sampleTexture(${r}, uv);
      }
  `}function HY(n,e){const t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=br();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${t}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${t}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${t}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${t}TexShape[0]) / 2.0), ceil(float(${t}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${t}, uv);
    }
  `;const s=n.shapeInfo.logicalShape,a=s.length,o=n.shapeInfo.texShape,c=[Math.ceil(o[0]/2),Math.ceil(o[1]/2)],l=c[0],u=c[1],f=Math.ceil(s[a-1]/2);let d=f*Math.ceil(s[a-2]/2),h="int b, int row, int col",p=`b * ${d} + (row / 2) * ${f} + (col / 2)`;for(let g=2;g<a-1;g++)h=`int b${g}, `+h,d*=s[a-g-1],p=`b${g} * ${d} + `+p;return`
    vec4 ${r}(${h}) {
      int index = ${p};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${l});
      return ${i.texture2D}(${t}, uv);
    }
  `}function WY(n,e){const t=n.shapeInfo.logicalShape,r=n.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t[3],a=t[2]*s,o=t[1]*a,{newShape:c,keptDims:l}=$a(t);if(c.length<t.length){const x=Dl(n,c),b=["row","col","depth","depth2"];return`
      ${Nl(x,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Ll(b,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${o}, ${a}, ${s}, 1)));
        ${kl(n)}
      }
    `;const u=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,d=f[0],h=f[1],p=`int stride2 = ${r}Shape[3];`,g=`int stride1 = ${r}Shape[2] * stride2;`,m=`int stride0 = ${r}Shape[1] * stride1;`;if(h===o&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${p}
        ${g}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${a}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(h===s&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${t[1]*t[2]}, ${t[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${r}, uv);
      }
    `;const v=Zo(r);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${g}
      ${m}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${v});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${d}, ${h}, index + ${v});
      return sampleTexture(${r}, uv);
    }
  `}function qY(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),i=e[4],s=e[3]*i,a=e[2]*s,o=e[1]*a,{newShape:c,keptDims:l}=$a(e);if(c.length<e.length){const g=Dl(n,c),m=["row","col","depth","depth2","depth3"];return`
      ${Nl(g)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Ll(m,l)});
      }
    `}if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${o}, ${a}, ${s}, ${i})) +
          depth3;
        ${kl(n)}
      }
    `;const u=n.shapeInfo.flatOffset,f=n.shapeInfo.texShape,d=f[0],h=f[1];if(h===o&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${a}, ${s}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(h===i&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${d}.0);
        return sampleTexture(${t}, uv);
      }
    `;const p=Zo(t);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${o} + col * ${a} + depth * ${s} +
          depth2 * ${i} + depth3 + ${p};
      vec2 uv = uvFromFlat(${d}, ${h}, index);
      return sampleTexture(${t}, uv);
    }
  `}function XY(n){const e=n.shapeInfo.logicalShape,t=n.name,r="get"+t.charAt(0).toUpperCase()+t.slice(1),{newShape:i,keptDims:s}=$a(e);if(i.length<e.length){const m=Dl(n,i),v=["row","col","depth","depth2","depth3","depth4"];return`
      ${Nl(m)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Ll(v,s)});
      }
    `}const a=e[5],o=e[4]*a,c=e[3]*o,l=e[2]*c,u=e[1]*l;if(n.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${l}, ${c}, ${o})) +
          dot(
            vec2(depth3, depth4),
            vec2(${a}, 1)));
        ${kl(n)}
      }
    `;const f=n.shapeInfo.flatOffset,d=n.shapeInfo.texShape,h=d[0],p=d[1];if(p===u&&f==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${l}, ${c}, ${o}, ${a})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;if(p===a&&f==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${t}, uv);
      }
    `;const g=Zo(t);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${l} + depth * ${c} +
          depth2 * ${o} + depth3 * ${a} + depth4 + ${g};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${t}, uv);
    }
  `}function kl(n){const e=n.name,t=ue(n.shapeInfo.logicalShape);return t<2?`return ${e};`:`
    for (int i = 0; i < ${t}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function KY(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),i="get"+r+"AtOutCoords",s=n.shapeInfo.logicalShape.length,a=e.logicalShape.length,o=OI(n.shapeInfo.logicalShape,e.logicalShape),c=jt(a),l=a-s;let u;const f=["x","y","z","w","u","v"];s===0?u="":a<2&&o.length>=1?u="coords = 0;":u=o.map(x=>`coords.${f[x+l]} = 0;`).join(`
`);let d="";a<2&&s>0?d="coords":d=n.shapeInfo.logicalShape.map((x,b)=>`coords.${f[b+l]}`).join(", ");let h="return outputValue;";const g=ue(n.shapeInfo.logicalShape)===1,v=ue(e.logicalShape)===1;if(s===1&&!g&&!v)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(g&&!v)a===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(o.length){const x=s-2,b=s-1;o.indexOf(x)>-1&&o.indexOf(b)>-1?h="return vec4(outputValue.x);":o.indexOf(x)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":o.indexOf(b)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${c} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${d});
      ${h}
    }
  `}function jY(n,e){const t=n.name,r=t.charAt(0).toUpperCase()+t.slice(1),i="get"+r+"AtOutCoords",s=e.texShape,a=n.shapeInfo.texShape,o=n.shapeInfo.logicalShape.length,c=e.logicalShape.length;if(!n.shapeInfo.isUniform&&o===c&&n.shapeInfo.flatOffset==null&&Pt(a,s))return`
      float ${i}() {
        return sampleTexture(${t}, resultUV);
      }
    `;const l=jt(c),u=OI(n.shapeInfo.logicalShape,e.logicalShape),f=c-o;let d;const h=["x","y","z","w","u","v"];o===0?d="":c<2&&u.length>=1?d="coords = 0;":d=u.map(g=>`coords.${h[g+f]} = 0;`).join(`
`);let p="";return c<2&&o>0?p="coords":p=n.shapeInfo.logicalShape.map((g,m)=>`coords.${h[m+f]}`).join(", "),`
    float ${i}() {
      ${l} coords = getOutputCoords();
      ${d}
      return get${r}(${p});
    }
  `}function jt(n){if(n<=1)return"int";if(n===2)return"ivec2";if(n===3)return"ivec3";if(n===4)return"ivec4";if(n===5)return"ivec5";if(n===6)return"ivec6";throw Error(`GPU for rank ${n} is not yet supported`)}function cy(n,e,t){const{newShape:r,keptDims:i}=$a(e),s=e.length,a=n&&s===3&&e[0]===1,o=a?e.slice(1):r,c=!n&&s>1&&!Pt(e,t)&&r.length<s||a;return{useSqueezeShape:c,uniformShape:c?o:e,keptDims:i}}function Dl(n,e){const t=JSON.parse(JSON.stringify(n));return t.shapeInfo.logicalShape=e,t}function Ll(n,e){return e.map(t=>n[t]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YY(n,e,t,r){const i=t.map((u,f)=>{const d={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(d.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[f],shapeInfo:d}}),s=i.map(u=>u.shapeInfo),a={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},o=pY(i,a,e),c=Gj(n.gl,o),l=n.createProgram(c);return ie().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:c,source:o,webGLProgram:l,inShapeInfos:s,outShapeInfo:a,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(n.buildVao(l),Object.assign({program:e,fragmentShader:c,source:o,webGLProgram:l,inShapeInfos:s,outShapeInfo:a},FI(n,e,l)))}function FI(n,e,t){const r=[],i=[];let s,a,o,c=null,l=null;l=n.getUniformLocation(t,"NAN",!1),ie().getNumber("WEBGL_VERSION")===1&&(c=n.getUniformLocation(t,"INFINITY",!1));const u=!1;for(const f of e.variableNames){const d={name:f,uniform:n.getUniformLocation(t,f,u),offset:n.getUniformLocation(t,`offset${f}`,u)};e.enableShapeUniforms&&(d.shape=n.getUniformLocation(t,`${f}Shape`,u),d.texShape=n.getUniformLocation(t,`${f}TexShape`,u)),r.push(d)}if(e.enableShapeUniforms&&(s=n.getUniformLocation(t,"outShape",u),o=n.getUniformLocation(t,"outShapeStrides",u),a=n.getUniformLocation(t,"outTexShape",u)),e.customUniforms)for(const f of e.customUniforms)i.push(n.getUniformLocation(t,f.name,u));return{variablesLocations:r,customUniformLocations:i,infLoc:c,nanLoc:l,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:a}}function gw(n,e){if(n.length!==e.length)throw Error(`Binary was compiled with ${n.length} inputs, but was executed with ${e.length} inputs`);n.forEach((t,r)=>{const i=t.logicalShape,s=e[r],a=s.shape;if(!Pt(i,a))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${a} must match`);if(t.isUniform&&s.isUniform)return;const o=t.texShape,c=s.isUniform?null:s.texData.texShape;if(!Pt(o,c))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${o} and ${c} must match`)})}function ZY(n,e,t,r,i){e.program.enableShapeUniforms||(gw(e.inShapeInfos,t),gw([e.outShapeInfo],[r]));const s=r.texData.texture,a=r.texData.texShape;r.texData.isPacked?n.setOutputPackedMatrixTexture(s.texture,a[0],a[1]):n.setOutputMatrixTexture(s.texture,a[0],a[1]),n.setProgram(e.webGLProgram),n.bindVertexArray(e.webGLProgram.vao),ie().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&n.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&n.gl.uniform1f(e.nanLoc,NaN);for(let c=0;c<t.length;++c){const l=t[c],{uniform:u,offset:f,shape:d,texShape:h}=e.variablesLocations[c];if(d){const{uniformShape:p}=cy(e.program.packedInputs,l.shape,l.texData.texShape);switch(p.length){case 1:n.gl.uniform1iv(d,new Int32Array(p));break;case 2:n.gl.uniform2iv(d,new Int32Array(p));break;case 3:n.gl.uniform3iv(d,new Int32Array(p));break;case 4:n.gl.uniform4iv(d,new Int32Array(p));break}}if(h&&n.gl.uniform2i(h,l.texData.texShape[0],l.texData.texShape[1]),u!=null){if(l.isUniform){if(ue(l.shape)<2)n.gl.uniform1f(u,l.uniformValues[0]);else{let p=l.uniformValues;p instanceof Float32Array||(p=new Float32Array(p)),n.gl.uniform1fv(u,p)}continue}l.texData.slice!=null&&f!=null&&n.gl.uniform1i(f,l.texData.slice.flatOffset),n.setInputMatrixTexture(l.texData.texture.texture,u,c)}}const o=e.outShapeLocation;if(o)switch(r.shape.length){case 1:n.gl.uniform1iv(o,new Int32Array(r.shape));break;case 2:n.gl.uniform2iv(o,new Int32Array(r.shape));break;case 3:n.gl.uniform3iv(o,new Int32Array(r.shape));break;case 4:n.gl.uniform4iv(o,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const c=Qe(r.shape);switch(r.shape.length){case 2:n.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(c));break;case 3:n.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(c));break;case 4:n.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(c));break}}if(e.outTexShapeLocation&&n.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&i)for(let c=0;c<e.program.customUniforms.length;++c){const l=e.program.customUniforms[c],u=e.customUniformLocations[c],f=i[c];if(l.type==="float")n.gl.uniform1fv(u,f);else if(l.type==="vec2")n.gl.uniform2fv(u,f);else if(l.type==="vec3")n.gl.uniform3fv(u,f);else if(l.type==="vec4")n.gl.uniform4fv(u,f);else if(l.type==="int")n.gl.uniform1iv(u,f);else if(l.type==="ivec2")n.gl.uniform2iv(u,f);else if(l.type==="ivec3")n.gl.uniform3iv(u,f);else if(l.type==="ivec4")n.gl.uniform4iv(u,f);else throw Error(`uniform type ${l.type} is not supported yet.`)}n.executeProgram()}function QY(n,e,t){let r="";e.concat(t).forEach(a=>{const o=a.texData!=null&&a.texData.slice!=null&&a.texData.slice.flatOffset>0;if(n.enableShapeUniforms&&!a.isUniform){const c=a.texData.texShape,{useSqueezeShape:l,uniformShape:u,keptDims:f}=cy(n.packedInputs,a.shape,c);let d="",h="",p="";if(u.length===1&&n.packedInputs){const w=[Math.ceil(c[0]/2),Math.ceil(c[1]/2)];d=`${w[0]>1}_${w[1]>1}`}else if(u.length===2&&!n.packedInputs)h=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!n.packedInputs){const w=Qe(u);p=`${w[0]===c[1]}_${w[w.length-1]===c[1]}`}const g=a.shape.length,m=u.length===2&&Pt(a.shape,c),v=ue(a.shape)===1,x=il(a.shape,t.shape),b=!n.packedInputs&&g===t.shape.length&&Pt(c,t.texData.texShape),_=n.packedInputs||u.length>2?"":`${c[0]>1}_${c[1]>1}`;r+=`${g}_${b}_${l?f:""}_${u.length}_${v}_${x}_${m}_${d}_${h}_${p}_${_}_${o}`}else{const c=a.isUniform?"uniform":a.texData.texShape;r+=`${a.shape}_${c}_${o}`}});const i=n.userCode;let s=n.constructor.name;return s+="_"+r+"_"+i+`${ie().getNumber("WEBGL_VERSION")}`,s}function lr(n){return ie().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&n<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JY{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=Du.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=br();this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Bm(["r","c","d"],e):Yo(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eZ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=Du.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=br();this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?Bm(["r","c","d"],e):Yo(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tZ{constructor(e){this.variableNames=["A"],this.outTexUsage=ei.DOWNLOAD;const t=br();this.outputShape=e,this.userCode=`
      ${LI}

      void main() {
        float x = getAAtOutCoords();
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nZ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=ei.DOWNLOAD;const t=br();this.outputShape=e,this.userCode=`
      ${LI}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${t.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rZ={R:0,G:1,B:2,A:3};class xw{constructor(e,t=!1,r="RGBA"){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const i=br();this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length);let s="result";t&&(s="floor(result * 255. + 0.5)");let a="";for(let o=0;o<r.length;o++){const c=r[o];a+=`
          if(offset == ${o}) {
            result = values[${rZ[c]}];
          }`}this.userCode=`
      ${this.enableShapeUniforms?oy():ay(e)}

      void main() {
        ivec3 coords = getOutputCoords();
        int flatIndex = getFlatIndex(coords);
        float result = 0.;
        int offset = imod(flatIndex, ${r.length});

        flatIndex = idiv(flatIndex, ${r.length}, 1.);

        int r = flatIndex / texShape[1];
        if (r < texShape[0]) {
          int c = imod(flatIndex, texShape[1]);
          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
          vec4 values = ${i.texture2D}(A, uv);
          ${a}
        }
        ${i.output} = vec4(${s}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iZ{constructor(e,t=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=br();this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length);let i="",s="result";t&&(s="floor(result * 255. + 0.5)");for(let a=0;a<=1;a++)for(let o=0;o<=1;o++){const c=a*2+o;i+=`
          localCoords = coords;
          if(localCoords[2] + ${o} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${o};
          if (localCoords[1] + ${a} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${a};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${c}] = values[0];
            } else if (offset == 1) {
              result[${c}] = values[1];
            } else if (offset == 2) {
              result[${c}] = values[2];
            } else {
              result[${c}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?oy():ay(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${r.output} = ${s};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sZ(n){const e=br(),t=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return Vj(n,t)}function aZ(n){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return Xj(n,e)}function oZ(n){const e=new Uint16Array([0,1,2,2,1,3]);return Kj(n,e)}function cd(n,e,t,r,i,s){Yj(e,t);const a=jj(n),o=n.TEXTURE_2D;return Ne(n,()=>n.bindTexture(o,a)),Ne(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_S,n.CLAMP_TO_EDGE)),Ne(n,()=>n.texParameteri(o,n.TEXTURE_WRAP_T,n.CLAMP_TO_EDGE)),Ne(n,()=>n.texParameteri(o,n.TEXTURE_MIN_FILTER,n.NEAREST)),Ne(n,()=>n.texParameteri(o,n.TEXTURE_MAG_FILTER,n.NEAREST)),ie().getNumber("WEBGL_VERSION")===1?Ne(n,()=>n.texImage2D(o,0,r,e,t,0,i,s,null)):Ne(n,()=>n.texStorage2D(o,1,r,e,t)),Ne(n,()=>n.bindTexture(n.TEXTURE_2D,null)),{texture:a,texShape:[t,e]}}function $I(n){return n.internalFormatFloat}function cZ(n,e,t,r){const[i,s]=ad(e,t);return cd(n,i,s,$I(r),r.textureFormatFloat,n.FLOAT)}function UI(n){return n.internalFormatHalfFloat}function lZ(n,e,t,r){const[i,s]=ad(e,t);return cd(n,i,s,UI(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function BI(n){return n.downloadTextureFormat}function uZ(n,e,t,r){const[i,s]=ad(e,t);return cd(n,i,s,BI(r),n.RGBA,n.UNSIGNED_BYTE)}function VI(n){return n.internalFormatPackedFloat}function fZ(n,e,t,r){const[i,s]=Rl(e,t);return cd(n,i,s,VI(r),n.RGBA,n.FLOAT)}function GI(n){return n.internalFormatPackedHalfFloat}function dZ(n,e,t,r){const[i,s]=Rl(e,t);return cd(n,i,s,GI(r),n.RGBA,r.textureTypeHalfFloat)}function hZ(n,e,t){return Ne(n,()=>n.bindBuffer(n.ARRAY_BUFFER,t)),pw(n,e,"clipSpacePos",t,3,20,0)&&pw(n,e,"uv",t,2,20,12)}function pZ(n,e,t,r,i,s){Ne(n,()=>n.bindTexture(n.TEXTURE_2D,e));let a,o,c;i instanceof Uint8Array?(a=new Uint8Array(t*r*4),o=n.UNSIGNED_BYTE,c=n.RGBA):(a=new Float32Array(t*r*4),o=n.FLOAT,c=s.internalFormatPackedFloat),a.set(i),ie().getNumber("WEBGL_VERSION")===2?Ne(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t,r,n.RGBA,o,a)):Ne(n,()=>n.texImage2D(n.TEXTURE_2D,0,c,t,r,0,n.RGBA,o,a)),Ne(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function mZ(n,e,t){Ne(n,()=>n.bindTexture(n.TEXTURE_2D,e)),t.data instanceof Uint8Array?ie().getNumber("WEBGL_VERSION")===2?Ne(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,t.width,t.height,n.RGBA,n.UNSIGNED_BYTE,t.data)):Ne(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,t.width,t.height,0,n.RGBA,n.UNSIGNED_BYTE,t.data)):ie().getNumber("WEBGL_VERSION")===2?Ne(n,()=>n.texSubImage2D(n.TEXTURE_2D,0,0,0,n.RGBA,n.UNSIGNED_BYTE,t)):Ne(n,()=>n.texImage2D(n.TEXTURE_2D,0,n.RGBA,n.RGBA,n.UNSIGNED_BYTE,t)),Ne(n,()=>n.bindTexture(n.TEXTURE_2D,null))}function vZ(n,e,t,r){const i=n.createBuffer();Ne(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,i));const o=4*4*e*t;return Ne(n,()=>n.bufferData(n.PIXEL_PACK_BUFFER,o,n.STREAM_READ)),Ne(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,0)),Ne(n,()=>n.bindBuffer(n.PIXEL_PACK_BUFFER,null)),i}function gZ(n,e,t){const r=n,i=new Float32Array(t);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function xZ(n,e,t,r){const[i,s]=ad(e,t),a=4,o=new Uint8Array(Oj(e*t,a));return Ne(n,()=>n.readPixels(0,0,i,s,r.downloadTextureFormat,n.UNSIGNED_BYTE,o)),new Float32Array(o.buffer)}function bZ(n,e,t,r,i,s,a,o){const c=n,l=new Float32Array(zj(s,a));return c.bindBuffer(c.PIXEL_PACK_BUFFER,e),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}function _Z(n,e,t){const r=new Float32Array(e*t*4);return Ne(n,()=>n.readPixels(0,0,t,e,n.RGBA,n.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Jv{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=ie().getNumber("WEBGL_VERSION");if(e!=null?(this.gl=e,kj(t,e)):this.gl=Zi(t),e=this.gl,ie().getNumber("WEBGL_VERSION")===2){const s=e;this.createVertexArray=()=>Ne(s,()=>s.createVertexArray()),this.bindVertexArray=a=>Ne(s,()=>s.bindVertexArray(a)),this.deleteVertexArray=a=>Ne(s,()=>s.deleteVertexArray(a)),this.getVertexArray=()=>Ne(s,()=>s.getParameter(s.VERTEX_ARRAY_BINDING))}else if(e!=null){const s=e.getExtension("OES_vertex_array_object");if(s==null)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>Ne(e,()=>s.createVertexArrayOES()),this.bindVertexArray=a=>Ne(e,()=>s.bindVertexArrayOES(a)),this.deleteVertexArray=a=>Ne(e,()=>s.deleteVertexArrayOES(a)),this.getVertexArray=()=>Ne(e,()=>e.getParameter(s.VERTEX_ARRAY_BINDING_OES))}let r="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ie().getNumber("WEBGL_VERSION")===1){const s="OES_texture_float",a="OES_texture_half_float";if(this.textureFloatExtension=rh(this.gl,s),bi(this.gl,a))this.textureHalfFloatExtension=rh(this.gl,a);else if(ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),bi(this.gl,i))this.colorBufferHalfFloatExtension=rh(this.gl,i);else if(ie().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",bi(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(bi(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=aZ(this.gl),this.indexBuffer=oZ(this.gl),this.framebuffer=Zj(this.gl),this.textureConfig=sy(this.gl,this.textureHalfFloatExtension)}get debug(){return ie().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;Ne(e,()=>e.finish()),Ne(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),Ne(e,()=>e.deleteFramebuffer(this.framebuffer)),Ne(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),Ne(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),Ne(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),cZ(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),lZ(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),uZ(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),mZ(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,r,i){this.throwIfDisposed(),pZ(this.gl,e,t,r,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),dZ(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),fZ(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(mw(this.gl,this.framebuffer),this.outputTexture=null),Ne(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,r){return this.downloadMatrixDriver(e,()=>xZ(this.gl,t,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,t,r,i,s,a){return bZ(this.gl,e,t,r,i,s,a,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return gZ(this.gl,e,t)}createBufferFromTexture(e,t,r){this.bindTextureToFrameBuffer(e);const i=vZ(this.gl,t,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,r;if(ie().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,s=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const a=i.clientWaitSync(s,0,0);return a===i.ALREADY_SIGNALED||a===i.CONDITION_SATISFIED},t=s}else ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(t,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:t,isFencePassed:r}}downloadMatrixFromPackedTexture(e,t,r){return this.downloadMatrixDriver(e,()=>_Z(this.gl,t,r))}createProgram(e){this.throwIfDisposed();const t=this.gl;this.vertexShader==null&&(this.vertexShader=sZ(t));const r=Wj(t);Ne(t,()=>t.attachShader(r,this.vertexShader)),Ne(t,()=>t.attachShader(r,e)),qj(t,r);const i=Object.assign(r,{vao:this.createVertexArray()});return this.debug&&jv(t,i),i}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;Ne(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer)),hZ(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&(Ne(this.gl,()=>this.gl.deleteProgram(e)),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&jv(this.gl,this.program),Ne(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,t,r=!0){return this.throwIfDisposed(),r?Jj(this.gl,e,t):eY(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),Ne(this.gl,()=>this.gl.getAttribLocation(e,t))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,r){this.throwIfDisposed(),this.throwIfNoProgram(),tY(this.gl,e,t,r)}setOutputMatrixTexture(e,t,r){this.setOutputMatrixTextureDriver(e,r,t)}setOutputPackedMatrixTexture(e,t,r){this.throwIfDisposed();const[i,s]=Rl(t,r);this.setOutputMatrixTextureDriver(e,i,s)}setOutputMatrixWriteRegion(e,t,r,i){this.setOutputMatrixWriteRegionDriver(r,e,i,t)}setOutputPackedMatrixWriteRegion(e,t,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&jv(this.gl,this.program),ih(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const t=this.getVertexArray();console.assert(t===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}Ne(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),Ne(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=rh(this.gl,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(i.TIME_ELAPSED_EXT,s),s}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const t=this.gl,r=this.getQueryTimerExtensionWebGL2();t.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await s2(()=>this.disposed||this.isQueryAvailable(e,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(t===0)return null;if(t===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(t===0)return!0;if(t===2){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),i=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(t=>{this.addItemToPoll(()=>e.isFencePassed(),()=>t())})}pollItems(){const e=yZ(this.itemsToPoll.map(t=>t.isDoneFn));for(let t=0;t<=e;++t){const{resolveFn:r}=this.itemsToPoll[t];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in ie().platform&&(r=ie().platform.setTimeoutCustom.bind(ie().platform)),s2(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),Yv(this.gl,e,this.framebuffer),this.debug&&ih(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(Yv(this.gl,this.outputTexture,this.framebuffer),this.debug&&ih(this.gl)):mw(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const r=t();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,t,r){this.throwIfDisposed();const i=this.gl;Yv(i,e,this.framebuffer),this.debug&&ih(i),this.outputTexture=e,Ne(i,()=>i.viewport(0,0,t,r)),Ne(i,()=>i.scissor(0,0,t,r))}setOutputMatrixWriteRegionDriver(e,t,r,i){this.throwIfDisposed(),Ne(this.gl,()=>this.gl.scissor(e,t,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function yZ(n){let e=0;for(;e<n.length&&n[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:wZ,bincountImpl:HI,bincountReduceImpl:EZ,bitwiseAndImpl:SZ,castImpl:TZ,ceilImpl:AZ,concatImpl:CZ,equalImpl:IZ,expImpl:MZ,expm1Impl:RZ,floorImpl:NZ,gatherNdImpl:kZ,gatherV2Impl:DZ,greaterImpl:LZ,greaterEqualImpl:OZ,lessImpl:zZ,lessEqualImpl:PZ,linSpaceImpl:FZ,logImpl:$Z,maxImpl:UZ,maximumImpl:BZ,minimumImpl:VZ,multiplyImpl:GZ,negImpl:HZ,notEqualImpl:WZ,prodImpl:qZ,raggedGatherImpl:XZ,raggedRangeImpl:KZ,raggedTensorToTensorImpl:jZ,rangeImpl:YZ,rsqrtImpl:ZZ,scatterImpl:QZ,sigmoidImpl:JZ,simpleAbsImpl:WI,sliceImpl:eQ,sparseFillEmptyRowsImpl:tQ,sparseReshapeImpl:nQ,sparseSegmentReductionImpl:qI,sqrtImpl:rQ,staticRegexReplaceImpl:iQ,stridedSliceImpl:sQ,stringNGramsImpl:aQ,stringSplitImpl:oQ,stringToHashBucketFastImpl:cQ,subImpl:lQ,tileImpl:uQ,topKImpl:fQ,transposeImpl:ly,uniqueImpl:dQ}=mq;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XI(n,e){return["x","y","z","w","u","v"].slice(0,e).map(t=>`${n}.${t}`)}function vr(n,e){return e===1?[n]:XI(n,e)}function hQ(n,e){if(n===1)return"rc";let t="";for(let r=0;r<n;r++)t+=e[r],r<n-1&&(t+=",");return t}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pQ{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=lr(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const t=vr("rc",this.rank),r=jt(this.rank),i=this.getOutOfBoundsCondition(t),s=this.getSetup(t),a=this.getOutput(t);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${a}));
          }
        }
      `}}getSourceCoordsArr(e){const t=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let s=`${r===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let a=2;a<this.rank;a++)s=`${e[e.length-1-a]},`+s;t.push(s)}return t}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let t="";for(let r=this.rank-2;r<this.rank;r++)t+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(t+="||");return t}getSetup(e){if(this.rank===1)return"";const t=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${t[0]};
      int c = ${t[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const t=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${t[0]}),
            cEdge ? 0. : getA(${t[1]}),
            rEdge ? 0. : getA(${t[2]}),
            rEdge || cEdge ? 0. : getA(${t[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KI{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length);let r="";for(let i=0;i<4;i++){let s="thisRC = rc;";i%2===1&&(s+="thisRC.z += 1;"),i>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${mQ(t,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?oy():ay(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function mQ(n,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?hY(["r","c","d"],"inputShape"):Yo(["r","c","d"],n)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vQ{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,r){const i=_w(t,r),s=yw(e,i,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const a=bw(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=a,this.log();const c=this.freeTextures[s].pop();return this.usedTextures[s].push(c),c}let o;return i===Kn.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===Kn.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===Kn.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===Kn.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===Kn.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(o),this.numUsedTextures++,this._numBytesAllocated+=a,this.log(),o}releaseTexture(e,t,r,i){if(this.freeTextures==null)return;const s=_w(r,i),a=yw(t,s,i);a in this.freeTextures||(this.freeTextures[a]=[]);const o=bw(t,s,this.gpgpu.gl,this.gpgpu.textureConfig,i),c=ie().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");c!==-1&&this._numBytesAllocated>c?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[a].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const l=this.usedTextures[a],u=l&&l.indexOf(e);if(u==null||u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");l[u]=l[l.length-1],l.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const t=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*t)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(t=>{this.gpgpu.deleteMatrixTexture(t.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function gQ(n,e){const t=n;if(e===t.R32F)return 4;if(e===t.R16F)return 2;if(e===t.RGBA32F)return 16;if(e===n.RGBA)return 16;if(e===t.RGBA16F)return 8;if(e===t.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function bw(n,e,t,r,i){const s=xQ(e,r);let a;if(i){const[c,l]=Rl(n[0],n[1]);a=c*l}else{const[c,l]=ad(n[0],n[1]);a=c*l}const o=gQ(t,s);return a*o}function xQ(n,e){switch(n){case Kn.PACKED_2X2_FLOAT32:return VI(e);case Kn.PACKED_2X2_FLOAT16:return GI(e);case Kn.UNPACKED_FLOAT32:return $I(e);case Kn.UNPACKED_FLOAT16:return UI(e);case Kn.PACKED_4X1_UNSIGNED_BYTE:return BI(e);default:throw new Error(`Unknown physical texture type ${n}`)}}function bQ(n){return ie().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?n?Kn.PACKED_2X2_FLOAT32:Kn.UNPACKED_FLOAT32:n?Kn.PACKED_2X2_FLOAT16:Kn.UNPACKED_FLOAT16}function _w(n,e){if(n===ei.UPLOAD)return Kn.PACKED_2X2_FLOAT32;if(n===ei.RENDER||n==null)return bQ(e);if(n===ei.DOWNLOAD||n===ei.PIXELS)return Kn.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${n}`)}function yw(n,e,t){return`${n[0]}_${n[1]}_${e}_${t}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class os{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${t}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Ri="if (isnan(x)) return x;",_Q="return x;",ww="return abs(x);",yQ="return (x >= 0.0) ? x : (exp(x) - 1.0);",wQ=Ri+`
  return (x < 0.0) ? 0.0 : x;
`,EQ=Ri+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,va="return x;",SQ="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TQ="return x;",AQ=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,CQ=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,IQ=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,MQ="return 1.0 / (1.0 + exp(-1.0 * x));";class wa{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${t}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RQ{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length);const t=e.length,r=vr("rc",t),i=jt(t),s=hQ(t,r),a=r.slice(-2),o=t<=1?"rc":`vec2(${a.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${o}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NQ=xS,kQ=1e-7,DQ=1e-4,oh={};function LQ(n){return n in oh||(oh[n]={}),oh[n]}const OQ=ie().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),zQ=600;function PQ(){return ie().global.screen==null?1024:ie().global.screen.height*ie().global.screen.width*window.devicePixelRatio*zQ/1024/1024}class Vm extends w0{nextDataId(){return Vm.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ie().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(e!=null){if(e instanceof Jv)t=e;else{const r=Zi(ie().getNumber("WEBGL_VERSION"),e);t=new Jv(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=Zi(ie().getNumber("WEBGL_VERSION"));t=new Jv(r),this.binaryCache=LQ(ie().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new vQ(this.gpgpu),this.numMBBeforeWarning=PQ(),this.texData=new FE(this,Fr())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,r,i,s,a){const o=this.makeTensorInfo(t,r),c=this.texData.get(o.dataId);c.isPacked=!1,c.texture={texture:e,texShape:[i,s]},c.texShape=[i,s];const l=sh(t),u=new xw(l,!1,a),f=this.runWebGLProgram(u,[o],r,[[i,s]]);return f.shape=t,c.texture=null,this.disposeIntermediateTensorInfo(o),f.dataId}write(e,t,r){if((ie().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ie().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:t,dtype:r,values:e,usage:ei.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const t=this.texData.get(e);t.refCount++}decRef(e){if(this.texData.has(e)){const t=this.texData.get(e);t.refCount--}}move(e,t,r,i,s){if(ie().getBool("DEBUG")&&this.checkNumericalProblems(t),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:i,values:t,usage:ei.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:r,dtype:i,complexTensorInfos:s,slice:a,shape:o,isPacked:c}=t;if(a!=null){let d;c?d=new wa(o,va):d=new os(o,va);const h=this.runWebGLProgram(d,[{dataId:e,shape:o,dtype:i}],i),p=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),p}if(r!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return r;const l=this.activeTimers!=null;let u;l&&(u=wr());let f;if(i==="complex64"){const d=this.readSync(s.real.dataId),h=this.readSync(s.imag.dataId);f=js(d,h)}else f=this.getValuesFromTexture(e);return l&&(this.downloadWaitMs+=wr()-u),this.convertAndCacheOnCPU(e,f)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(g=>p.push(g))}const t=this.texData.get(e),{values:r,shape:i,slice:s,dtype:a,complexTensorInfos:o,isPacked:c}=t;if(s!=null){let p;c?p=new wa(i,va):p=new os(i,va);const g=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:a}],a),m=this.read(g.dataId);return this.disposeIntermediateTensorInfo(g),m}if(r!=null)return this.convertAndCacheOnCPU(e);if(ie().getBool("DEBUG")&&!ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ie().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let l=null,u;if(a!=="complex64"&&ie().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const p=this.texData.get(u.dataId);l=this.gpgpu.createBufferFromTexture(p.texture.texture,...nh(i))}this.pendingRead.set(e,[]),a!=="complex64"&&await this.gpgpu.createAndWaitForFence();let f;if(a==="complex64"){const p=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]),g=p[0],m=p[1];f=js(g,m)}else if(l==null)f=this.getValuesFromTexture(e);else{const p=ue(i);f=this.gpgpu.downloadFloat32MatrixFromBuffer(l,p)}if(u!=null&&this.disposeIntermediateTensorInfo(u),l!=null){const p=this.gpgpu.gl;Ne(p,()=>p.deleteBuffer(l))}const d=this.convertAndCacheOnCPU(e,f),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(p=>p(d)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Fr().removeDataId(e,this),this.pendingDeletes--),d}readToGPU(e,t={}){const r=this.texData.get(e),{values:i,shape:s,slice:a,dtype:o,isPacked:c,texture:l}=r;if(o==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(a!=null){let h;c?h=new wa(s,va):h=new os(s,va);const p=this.runWebGLProgram(h,[{dataId:e,shape:s,dtype:o}],o),g=this.readToGPU(p,t);return this.disposeIntermediateTensorInfo(p),g}if(l==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,t.customTexShape),f=Fr().makeTensorFromTensorInfo(u),d=this.texData.get(u.dataId);return Object.assign({tensorRef:f},d.texture)}bufferSync(e){const t=this.readSync(e.dataId);if(e.dtype==="string")try{const r=t.map(i=>Na(i));return Et(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Et(e.shape,e.dtype,t)}checkNumericalProblems(e){if(e!=null)for(let t=0;t<e.length;t++){const r=e[t];if(!Uj(r))throw ie().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:t,dtype:r,isPacked:i}=this.texData.get(e),s=ue(t);if(ie().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const d=this.decode(e),h=this.texData.get(d.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...nh(t)).subarray(0,s);return this.disposeIntermediateTensorInfo(d),p}const a=ie().getBool("WEBGL_PACK")&&i===!0,o=a?sh(t):t,c=a?new nZ(o):new tZ(o),l=this.runWebGLProgram(c,[{shape:o,dtype:r,dataId:e}],"float32"),u=this.texData.get(l.dataId),f=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(l),f}timerAvailable(){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,r=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e();const s=Ao(this.activeTimers.map(c=>c.query)).filter(c=>c!=null),a=Ao(this.activeTimers.map(c=>c.name)).filter(c=>c!=null);this.activeTimers=t,i&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const c=await Promise.all(s);o.kernelMs=SP(c),o.getExtraProfileInfo=()=>c.map((l,u)=>({name:a[u],ms:l})).map(l=>`${l.name}: ${l.ms}`).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:wr(),endMs:null}}endTimer(e){return ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=wr(),e)}async getQueryTime(e){if(ie().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e,t=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,t),this.disposeData(r.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:r,texShape:i,usage:s,isPacked:a,slice:o}=this.texData.get(e),c=o&&o.origDataId||e,l=this.dataRefCount.get(c);l>1?this.dataRefCount.set(c,l-1):(this.dataRefCount.delete(c),t!=null&&(this.numBytesInGPU-=this.computeBytes(i,r),this.textureManager.releaseTexture(t,i,s,a)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,t=OQ){return ie().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&ue(r.shape)<t)}getGPGPUContext(){return this.gpgpu}where(e){Qr("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return NQ(e.shape,t)}packedUnaryOp(e,t,r){const i=new wa(e.shape,t),s=this.compileAndRun(i,[e],r);return Fr().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=WI(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(ie().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,ww,e.dtype);const t=new os(e.shape,ww),r=this.compileAndRun(t,[e]);return Fr().makeTensorFromTensorInfo(r)}makeTensorInfo(e,t,r){let i;if(t==="string"&&r!=null&&r.length>0&&Gu(r[0])){const s=r.map(a=>Ca(a));i=this.write(s,e,t)}else i=this.write(r,e,t);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:t}}makeOutput(e,t,r){return Fr().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,r),this)}unpackTensor(e){const t=new RQ(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new pQ(e.shape),r=!0;return this.runWebGLProgram(t,[e],e.dtype,null,r)}packedReshape(e,t){const r=[ul(e.shape),...fl(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},s=[ul(t),...fl(t)],a=new KI(s,r),o=!0,c=[r],l=this.runWebGLProgram(a,[i],e.dtype,c,o);return{dataId:l.dataId,shape:t,dtype:l.dtype}}decode(e,t){const r=this.texData.get(e),{isPacked:i,shape:s,dtype:a}=r;if(t!=null){const d=ue(s),h=t[0]*t[1]*4;R(d<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const o=sh(s);let c;i?c=new eZ(o):c=new JY(o);const l=!0,u=[t??nh(o)],f=this.runWebGLProgram(c,[{shape:o,dtype:a,dataId:e}],a,u,l,t);return{dtype:a,shape:s,dataId:f.dataId}}runWebGLProgram(e,t,r,i,s=!1,a){const o=this.makeTensorInfo(e.outputShape,r),c=this.texData.get(o.dataId);if(e.packedOutput&&(c.isPacked=!0),e.outPackingScheme===Du.DENSE){const v=a??nh(e.outputShape);c.texShape=v.map(x=>x*2)}if(e.outTexUsage!=null&&(c.usage=e.outTexUsage),ue(o.shape)===0)return c.values=ir(o.dtype,0),o;const l=[],u=t.map(v=>{if(v.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let x=this.texData.get(v.dataId);if(x.texture==null){if(!e.packedInputs&&ue(v.shape)<=ie().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:v.shape,texData:null,isUniform:!0,uniformValues:x.values};e.packedInputs&&(x.isPacked=!0,x.shape=v.shape)}if(this.uploadToGPU(v.dataId),!!x.isPacked!=!!e.packedInputs)v=x.isPacked?this.unpackTensor(v):this.packTensor(v),l.push(v),x=this.texData.get(v.dataId);else if(x.isPacked&&!tp(x.shape,v.shape)){const b=v,_=v.shape;v.shape=x.shape,v=this.packedReshape(v,_),l.push(v),x=this.texData.get(v.dataId),b.shape=_}return{shape:v.shape,texData:x,isUniform:!1}});this.uploadToGPU(o.dataId);const f={shape:o.shape,texData:c,isUniform:!1},d=QY(e,u,f),h=this.getAndSaveBinary(d,()=>YY(this.gpgpu,e,u,f)),p=this.activeTimers!=null;let g;p&&(g=this.startTimer()),ie().get("ENGINE_COMPILE_ONLY")||ZY(this.gpgpu,h,u,f,i),l.forEach(v=>this.disposeIntermediateTensorInfo(v)),p&&(g=this.endTimer(g),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(g)}));const m=ie().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const v=wr();v-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=v)}if(!ie().getBool("WEBGL_LAZILY_UNPACK")&&c.isPacked&&s===!1){const v=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),v}return o}compileAndRun(e,t,r,i,s=!1){return r=r||t[0].dtype,this.runWebGLProgram(e,t,r,i,s)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ie().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(t=>{this.gpgpu.deleteProgram(this.binaryCache[t].webGLProgram),delete this.binaryCache[t]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=te(()=>{if(!ie().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ie().getBool("DEBUG");ie().set("DEBUG",!1);const t=this.abs(zt(1e-8)).dataSync()[0];if(ie().set("DEBUG",e),t>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?kQ:DQ}uploadToGPU(e){const t=this.texData.get(e),{shape:r,dtype:i,values:s,texture:a,usage:o,isPacked:c}=t;if(a!=null)return;const l=this.activeTimers!=null;let u;l&&(u=wr());let f=t.texShape;if(f==null&&(f=iY(r,c),t.texShape=f),s!=null){const d=sh(r);let h,p=f[1],g=f[0];const m=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(c||!m)&&([p,g]=Rl(f[0],f[1])),c?h=new iZ(d,m):h=new xw(d,m);const v=m?[g,p]:f,x=this.makeTensorInfo(v,i),b=this.texData.get(x.dataId);m?b.usage=ei.PIXELS:b.usage=ei.UPLOAD,b.texShape=v,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(x.dataId),p,g,s);const _=[[g,p]],w=!0,E=this.runWebGLProgram(h,[x],i,_,w),S=this.texData.get(E.dataId);t.texShape=S.texShape,t.isPacked=S.isPacked,t.usage=S.usage,ie().get("ENGINE_COMPILE_ONLY")?this.disposeData(E.dataId):(t.texture=S.texture,t.values=null,this.texData.delete(E.dataId)),this.disposeIntermediateTensorInfo(x),l&&(this.uploadWaitMs+=wr()-u)}else{const d=this.acquireTexture(f,o,i,c);t.texture=d}}convertAndCacheOnCPU(e,t){const r=this.texData.get(e),{dtype:i}=r;return t!=null&&(r.values=FQ(t,i)),r.values}acquireTexture(e,t,r,i){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,t,i)}computeBytes(e,t){return e[0]*e[1]*Nh(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}else{for(const[,t]of Object.entries(this.binaryCache)){const r=new Promise(i=>{try{this.checkCompletion_(t),i(!0)}catch(s){throw s}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await OS(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(DI(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:r,infLoc:i,nanLoc:s,outShapeLocation:a,outShapeStridesLocation:o,outTexShapeLocation:c}=FI(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=r,e.infLoc=i,e.nanLoc=s,e.outShapeLocation=a,e.outShapeStridesLocation=o,e.outTexShapeLocation=c}}createTensorFromGPUData(e,t,r){e.channels=e.channels||"RGBA";const{texture:i,height:s,width:a,channels:o}=e,c=Fr().backend;if(!c.gpgpu.gl.isTexture(i))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const l=c.writeTexture(i,t,r,s,a,o);return Fr().makeTensorFromDataId(l,t,r,c)}}Vm.nextDataId=0;function FQ(n,e){if(e==="float32"||e==="complex64")return n;if(e==="int32"||e==="bool"){const t=e==="int32"?new Int32Array(n.length):new Uint8Array(n.length);for(let r=0;r<t.length;++r)t[r]=Math.round(n[r]);return t}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */R3()&&D3("webgl",()=>new Vm,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uy=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class Fo{constructor(e,t,r){this.variableNames=["A","B"],this.outputShape=pt(t,r),this.enableShapeUniforms=lr(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qo=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class Ol{constructor(e,t,r,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=pt(t,r);const s=this.outputShape.length;this.enableShapeUniforms=lr(s);let a="";if(i)if(s===0||ue(this.outputShape)===1)a=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(a=`
          ${jt(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?a+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:a+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const c=vr("coords",s);this.enableShapeUniforms?a+=`
            bool nextRowOutOfBounds =
              (${c[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${c[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:a+=`
            bool nextRowOutOfBounds =
              (${c[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${c[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${a}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qr(n){const{inputs:e,backend:t}=n,{x:r}=e;return t.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const $Q={kernelName:ff,backendName:"webgl",kernelFunc:qr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ka(n){const{inputs:e,backend:t}=n,{real:r,imag:i}=e,s=t.makeTensorInfo(r.shape,"complex64"),a=t.texData.get(s.dataId),o=qr({inputs:{x:r},backend:t}),c=qr({inputs:{x:i},backend:t});return a.complexTensorInfos={real:o,imag:c},s}const UQ={kernelName:z0,backendName:"webgl",kernelFunc:Ka};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jI="return (a < 0.) ? b * a : a;",YI=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function BQ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{alpha:s}=r,a=t.makeTensorInfo([],"float32",Ua(s,"float32")),o=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ol(YI,i.shape,a.shape):new Fo(jI,i.shape,a.shape),c=t.runWebGLProgram(o,[i,a],"float32");return t.disposeIntermediateTensorInfo(a),c}const VQ={kernelName:Fp,backendName:"webgl",kernelFunc:BQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZI="return (a < 0.) ? b * a : a;",QI=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function GQ(n){const{inputs:e,backend:t}=n,{x:r,alpha:i}=e,s=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ol(QI,r.shape,i.shape):new Fo(ZI,r.shape,i.shape);return t.runWebGLProgram(s,[r,i],"float32")}const HQ={kernelName:rm,backendName:"webgl",kernelFunc:GQ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zl="if (isnan(x)) return x;";function Nt({opSnippet:n,packedOpSnippet:e,cpuKernelImpl:t,dtype:r}){return({inputs:i,backend:s})=>{const{x:a}=i,o=s,c=r||a.dtype;if(o.shouldExecuteOnCPU([a])&&t!=null){const f=o.texData.get(a.dataId),d=t(f.values,c);return o.makeTensorInfo(a.shape,c,d)}const l=ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return l?u=new wa(a.shape,e):u=new os(a.shape,n),o.runWebGLProgram(u,[a],c)}}function Qn({opSnippet:n,packedOpSnippet:e,checkOutOfBounds:t=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:a,backend:o})=>{const{a:c,b:l}=a,u=o;if(r&&c.dtype==="complex64"){const p=u.texData.get(c.dataId),g=u.texData.get(l.dataId),[m,v]=[[p.complexTensorInfos.real,g.complexTensorInfos.real],[p.complexTensorInfos.imag,g.complexTensorInfos.imag]].map(b=>{const[_,w]=b,E={dataId:_.dataId,dtype:_.dtype,shape:c.shape},S={dataId:w.dataId,dtype:w.dtype,shape:l.shape},T=new Fo(n,c.shape,l.shape);return u.runWebGLProgram(T,[E,S],Hr(_.dtype,w.dtype))}),x=Ka({inputs:{real:m,imag:v},backend:u});return u.disposeIntermediateTensorInfo(m),u.disposeIntermediateTensorInfo(v),x}const f=s||Hr(c.dtype,l.dtype);if((c.dtype==="string"||l.dtype==="string"||u.shouldExecuteOnCPU([c,l]))&&i!=null){const p=u.texData.get(c.dataId).values,g=u.texData.get(l.dataId).values,m=c.dtype==="string"?Ys(p):p,v=c.dtype==="string"?Ys(g):g,[x,b]=i(c.shape,l.shape,m,v,f),_=u.makeTensorInfo(b,f),w=u.texData.get(_.dataId);return w.values=x,_}const d=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let h;return d?h=new Ol(e,c.shape,l.shape,t):h=new Fo(n,c.shape,l.shape),u.runWebGLProgram(h,[c,l],f)}}function Lu(n,e=!1){if(n==="linear")return e?TQ:_Q;if(n==="relu")return e?CQ:wQ;if(n==="elu")return e?AQ:yQ;if(n==="relu6")return e?IQ:EQ;if(n==="prelu")return e?QI:ZI;if(n==="leakyrelu")return e?YI:jI;if(n==="sigmoid")return e?MQ:SQ;throw new Error(`Activation ${n} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JI{constructor(e,t,r,i=!1,s=!1,a=!1,o=null,c=!1,l=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=lr(this.outputShape.length);const u=i?e[1]:e[2],f=Math.ceil(u/2),d=i?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],g=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",v="";o&&(c?m=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${o}
        }`:l?m=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${o}
        }`:m=`vec4 activation(vec4 x) {
          ${o}
        }`,v="result = activation(result);");const x=a?"result += getBiasAtOutCoords();":"";a&&this.variableNames.push("bias"),c&&this.variableNames.push("preluActivationWeights"),l&&this.variableNames.push("leakyreluAlpha");let b="rc.x",_="rc.x";e[0]<t[0]?b=`imod(rc.x, ${e[0]})`:t[0]<e[0]&&(_=`imod(rc.x, ${t[0]})`),this.userCode=`
      ${m}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${f}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        int batchA = ${b};
        int batchB = ${_};
        for (int i = 0; i < ${f}; i++) {
          vec4 a = getMatrixA(batchA, ${d});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${g[0]});
          result += (${p[1]} * ${g[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${x}

        ${v}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ew={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class Sw{constructor(e,t,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=pt(t,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tw="return a * b;";function fy(n){const{inputs:e,backend:t}=n,{a:r,b:i}=e,s=Hr(r.dtype,i.dtype);if(r.dtype==="complex64"){const o=t.texData.get(r.dataId),c=t.texData.get(i.dataId),l=new Sw(Ew.REAL,r.shape,i.shape),u=new Sw(Ew.IMAG,r.shape,i.shape),f=[{dataId:o.complexTensorInfos.real.dataId,dtype:o.complexTensorInfos.real.dtype,shape:r.shape},{dataId:o.complexTensorInfos.imag.dataId,dtype:o.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:c.complexTensorInfos.real.dataId,dtype:c.complexTensorInfos.real.dtype,shape:i.shape},{dataId:c.complexTensorInfos.imag.dataId,dtype:c.complexTensorInfos.imag.dtype,shape:i.shape}],d=t.runWebGLProgram(l,f,"float32"),h=t.runWebGLProgram(u,f,"float32"),p=Ka({inputs:{real:d,imag:h},backend:t});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),p}if(t.shouldExecuteOnCPU([r,i])){const o=t.texData.get(r.dataId),c=t.texData.get(i.dataId),[l,u]=GZ(r.shape,i.shape,o.values,c.values,s),f=t.makeTensorInfo(u,s),d=t.texData.get(f.dataId);return d.values=l,f}let a;return ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?a=new Ol(Tw,r.shape,i.shape):a=new Fo(Tw,r.shape,i.shape),t.runWebGLProgram(a,[r,i],s)}const WQ={kernelName:_f,backendName:"webgl",kernelFunc:fy};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qQ(n,e,t){const r=[ul(n.shape),...fl(n.shape)],i={dtype:n.dtype,shape:r,dataId:n.dataId},s=[ul(e),...fl(e)],a=new KI(s,r),o=!0,c=[r],l=t.runWebGLProgram(a,[i],n.dtype,c,o);return{dataId:l.dataId,shape:e,dtype:l.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ae(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{shape:s}=r,a=t,o=ue(i.shape),c=$E(s,o),l=ue(c);R(o===l,()=>`The new shape (${c}) has ${l} elements and the old shape (${i.shape}) has ${o} elements. The new shape and old shape must have the same number of elements.`);const u=a.texData.get(i.dataId);return u.isPacked&&!tp(i.shape,c)&&!(u.texture!==null&&tp(u.shape,c))?qQ(i,c,a):(a.incRef(i.dataId),{dataId:i.dataId,shape:c,dtype:i.dtype})}const XQ={kernelName:sm,backendName:"webgl",kernelFunc:Ae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Aw{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:a}=e;this.outputShape=[i,a];const o=Math.floor(r/4)*4,c=r%4;let l="sumValue += dot(values, ones);";if(t!=null){const f=1/t;l=`sumValue += dot(values * ${el(f)?f.toPrecision(2):f}, ones);`}let u="";s%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${o}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${l}
        }

        int inIdx = inOffset + ${o};
        if (${c===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${l}
        } else if (${c===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${l}
        } else if (${c===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${l}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KQ{constructor(e,t){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:a}=e;this.outputShape=[i,a];let o="0.0",c="";t==="prod"?o="1.0":t==="min"?(o="1.0 / 1e-20",c="min"):t==="max"&&(o="-1.0 / 1e-20",c="max");let l=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="sum"?l="sumValue":t==="prod"?l="prodValue":t==="all"?l="allValue":t==="any"&&(l="anyValue");const u=Math.floor(r/4)*4,f=r%4;let d=`
      if (${t==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${t==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${c}(values, minMaxValue);
        if (${t==="min"} || ${t==="max"}) {
          minMaxValue = ${c}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";t==="all"?(o="1.0",d=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):t==="any"&&(o="0.0",d=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let p="";s%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${o};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${o});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${f===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${f===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${d}
        } else if (${f===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${d}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jQ(n){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const t=e.length?e[e.length-1].outSize:n[1],r=Am(t);e.push({inSize:t,windowSize:r,outSize:Math.ceil(t/r)})}return e}function Jo(n,e,t,r){const i=jQ(n.shape);let s=n;for(let a=0;a<i.length;a++){const{inSize:o,windowSize:c,outSize:l}=i[a];let u,f;t==="mean"?u=a===0?new Aw({windowSize:c,inSize:o,batchSize:n.shape[0],outSize:l},o):new Aw({windowSize:c,inSize:o,batchSize:n.shape[0],outSize:l}):u=new KQ({windowSize:c,inSize:o,batchSize:n.shape[0],outSize:l},t),f=s,s=r.runWebGLProgram(u,[s],e),f.dataId!==n.dataId&&r.disposeIntermediateTensorInfo(f)}return s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class YQ{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let a=0;a<r.length;a++)r[a]=e[t[a]];this.outputShape=r,this.rank=r.length;const i=jt(this.rank),s=ZQ(t);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}}function ZQ(n){const e=n.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let i=0;i<n.length;i++)r[n[i]]=t[i];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class QQ{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let u=0;u<r.length;u++)r[u]=e[t[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=jt(this.rank),s=XI("rc",this.rank),a=new Array(this.rank);for(let u=0;u<t.length;u++)a[t[u]]=s[u];const o=`vec2(${a.slice(-2).join()})`,c=`++${s[this.rank-1]} < ${r[this.rank-1]}`,l=`getChannel(getA(${a.join()}), ${o})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${l};
      if(${c}) {
        result[1] = ${l};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${l};
        if(${c}) {
          result[3] = ${l};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gm(n,e,t){const r=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new QQ(n.shape,e):new YQ(n.shape,e);return t.runWebGLProgram(r,[n],n.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JQ(n,e,t,r){const i=e,s=n.shape.length,a=St(i,n.shape);let o=a;const c=pn(o,s),l=c!=null;let u=n;l&&(u=Gm(n,c,r),o=yn(o.length,s)),Zn("sum",o,s);const[f,d]=Wn(u.shape,o);let h=f;t&&(h=Cn(f,a));const p=ue(d),m=ue(n.shape)/p,v=Ae({inputs:{x:u},attrs:{shape:[m,p]},backend:r}),x=gb(n.dtype),b=Jo(v,x,"sum",r),_=Ae({inputs:{x:b},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(b),l&&r.disposeIntermediateTensorInfo(u),_}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hm(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r;return JQ(i,s,a,t)}const eJ={kernelName:fm,backendName:"webgl",kernelFunc:Hm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xr(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{perm:s}=r,a=t,o=i.shape.length,c=new Array(o);for(let u=0;u<c.length;u++)c[u]=i.shape[s[u]];let l;if(a.shouldExecuteOnCPU([i])){const f=a.texData.get(i.dataId).values,d=ly(f,i.shape,i.dtype,s,c);l=a.makeTensorInfo(c,i.dtype);const h=a.texData.get(l.dataId);h.values=d}else l=Gm(i,s,a);return l}const tJ={kernelName:Fc,backendName:"webgl",kernelFunc:xr};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eM=1e3;function np({a:n,b:e,transposeA:t,transposeB:r,backend:i,bias:s=null,preluActivationWeights:a=null,leakyreluAlpha:o=0,activation:c=null}){const l=n.shape.length,u=e.shape.length,f=t?n.shape[l-2]:n.shape[l-1],d=r?e.shape[u-1]:e.shape[u-2],h=t?n.shape[l-1]:n.shape[l-2],p=r?e.shape[u-2]:e.shape[u-1],g=n.shape.slice(0,-2),m=e.shape.slice(0,-2),v=ue(g),x=ue(m),_=pt(n.shape.slice(0,-2),e.shape.slice(0,-2)).concat([h,p]);R(f===d,()=>`Error in matMul: inner shapes (${f}) and (${d}) of Tensors with shapes ${n.shape} and ${e.shape} and transposeA=${t} and transposeB=${r} must match.`);const w=t?[v,f,h]:[v,h,f],E=r?[x,p,d]:[x,d,p],S=Ae({inputs:{x:n},backend:i,attrs:{shape:w}}),T=Ae({inputs:{x:e},backend:i,attrs:{shape:E}}),C=[S,T],y=Math.max(v,x),A=t?S.shape[1]:S.shape[2],k=s!=null,M=a!=null,L=c==="leakyrelu",z=c!=null?Lu(c,!0):null,D=k||M||L||z!=null;let F;if((h===1||p===1)&&A>eM&&D===!1){let V=S,J=T;t&&(V=xr({inputs:{x:S},backend:i,attrs:{perm:[0,2,1]}}),C.push(V)),r&&(J=xr({inputs:{x:T},backend:i,attrs:{perm:[0,2,1]}}),C.push(J));const Q=p!==1,de=p===1;let le=V;Q&&(le=Ae({inputs:{x:V},backend:i,attrs:{shape:[y,A,1]}}),C.push(le));const H=p===1?2:1;let q=J;de&&(q=Ae({inputs:{x:J},backend:i,attrs:{shape:[y,1,A]}}),C.push(q));const oe=fy({inputs:{a:le,b:q},backend:i});F=Hm({inputs:{x:oe},backend:i,attrs:{axis:H,keepDims:!0}}),C.push(oe)}else{const V=Hr(n.dtype,e.dtype),J=new JI(w,E,[y,h,p],t,r,k,z,M,L),Q=[S,T];if(s!=null&&Q.push(s),M&&Q.push(a),L){const de=i.makeTensorInfo([],"float32",Ua(o,"float32"));Q.push(de),C.push(de)}F=i.runWebGLProgram(J,Q,V)}const O=Ae({inputs:{x:F},backend:i,attrs:{shape:_}});C.push(F);for(const V of C)i.disposeIntermediateTensorInfo(V);return O}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nJ(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s,bias:a,preluActivationWeights:o}=e,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:f}=r;return np({a:i,b:s,transposeA:c,transposeB:l,backend:t,bias:a,preluActivationWeights:o,leakyreluAlpha:f,activation:u})}const rJ={kernelName:kh,backendName:"webgl",kernelFunc:nJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Cw="return abs(x);";function iJ(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const s=t.texData.get(r.dataId),a=WI(s.values);return t.makeTensorInfo(r.shape,r.dtype,a)}let i;return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new wa(r.shape,Cw):i=new os(r.shape,Cw),t.runWebGLProgram(i,[r],r.dtype)}const sJ={kernelName:xp,backendName:"webgl",kernelFunc:iJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aJ=Ri+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,oJ=Nt({opSnippet:aJ}),cJ={kernelName:Hu,backendName:"webgl",kernelFunc:oJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lJ=Ri+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,uJ=Nt({opSnippet:lJ}),fJ={kernelName:Wu,backendName:"webgl",kernelFunc:uJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iw="return a + b;",dJ=Qn({opSnippet:Iw,packedOpSnippet:Iw,supportsComplex:!0,cpuKernelImpl:wZ}),hJ={kernelName:El,backendName:"webgl",kernelFunc:dJ};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pJ{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);const r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mJ{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map((s,a)=>`T${a}`);const r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bh(n){const{inputs:e,backend:t}=n,r=e;if(r.length===1)return qr({inputs:{x:r[0]},backend:t});if(r.length>ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const c=Math.floor(r.length/2),l=bh({inputs:r.slice(0,c),backend:t}),u=bh({inputs:r.slice(c),backend:t});return bh({inputs:[l,u],backend:t})}const i=r.map(c=>c.dtype).reduce((c,l)=>Hr(c,l)),s=r.map(c=>c.shape),o=ie().getBool("WEBGL_PACK")?new mJ(r[0].shape,s):new pJ(r[0].shape,s);return t.runWebGLProgram(o,r,i)}const vJ={kernelName:M0,backendName:"webgl",kernelFunc:bh};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,c=St(s,i.shape);let l=c;const u=pn(l,o);let f=i;u!=null&&(f=xr({inputs:{x:i},backend:t,attrs:{perm:u}}),l=yn(l.length,o)),Zn("all",l,o);const[d,h]=Wn(f.shape,l),p=ue(h),g=Ae({inputs:{x:f},backend:t,attrs:{shape:[-1,p]}}),m=Jo(g,g.dtype,"all",t);let v;if(a){const x=Cn(d,c);v=Ae({inputs:{x:m},backend:t,attrs:{shape:x}})}else v=Ae({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(f),v}const xJ={kernelName:R0,backendName:"webgl",kernelFunc:gJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,c=St(s,i.shape);let l=c;const u=pn(l,o);let f=i;u!=null&&(f=xr({inputs:{x:i},backend:t,attrs:{perm:u}}),l=yn(l.length,o)),Zn("any",l,o);const[d,h]=Wn(f.shape,l),p=ue(h),g=Ae({inputs:{x:f},backend:t,attrs:{shape:[-1,p]}}),m=Jo(g,g.dtype,"any",t);let v;if(a){const x=Cn(d,c);v=Ae({inputs:{x:m},backend:t,attrs:{shape:x}})}else v=Ae({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(f),v}const _J={kernelName:N0,backendName:"webgl",kernelFunc:bJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yJ{constructor(e,t,r){this.variableNames=["A"];const{windowSize:i,batchSize:s,outSize:a}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,a];const o=t==="max"?">":"<",c=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${c};
          float candidate = getA(batch, inIdx);
          if (candidate ${o} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wJ{constructor(e,t,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,R(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const s=e[e.length-1],a=Math.ceil(s/t);this.outputShape=e.slice(0,-1),a>1&&this.outputShape.push(a),i||this.variableNames.push("bestIndicesA");const o=this.outputShape,c=o.length,l=jt(c),u=vr("coords",c);let f,d;if(a===1){d=c+1;const T=jt(d);f=`
        ${T} sourceLocR = ${T}(${u.join()}, 0);
        ++${u[c-1]};
        ${T} sourceLocG = ${T}(${u.join()}, 0);
        ++${u[c-2]};
        ${T} sourceLocA = ${T}(${u.join()}, 0);
        --${u[c-1]};
        ${T} sourceLocB = ${T}(${u.join()}, 0);
        --${u[c-2]};`}else d=c,f=`
        ${l} sourceLocR = coords;
        ++${u[c-1]};
        ${l} sourceLocG = coords;
        ++${u[c-2]};
        ${l} sourceLocA = coords;
        --${u[c-1]};
        ${l} sourceLocB = coords;
        --${u[c-2]};`;const h=["x","y","z","w","u","v"].slice(0,d),p="."+h[d-1],g=h.map(T=>"int "+T),m=vr("sourceLocR",d-1).concat("inIdx.r"),v=vr("sourceLocG",d-1).concat("inIdx.g"),x=vr("sourceLocB",d-1).concat("inIdx.b"),b=vr("sourceLocA",d-1).concat("inIdx.a"),_=r==="max"?"greaterThan":"lessThan",w=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${m.join()}),
                             getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${x.join()}),
                             getBestIndicesAChannel(${b.join()})));`,E=`vec4(
            getAChannel(${m.join()}),
            hasNextCol ? getAChannel(${v.join()}) : 0.,
            hasNextRow ? getAChannel(${x.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${b.join()}) : 0.)`,S=i?"":`
      float getBestIndicesAChannel(${g.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${g.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${S}
      void main() {
        ${l} coords = getOutputCoords();
        bool hasNextCol = ${u[c-1]} < ${o[c-1]-1};
        bool hasNextRow = ${u[c-2]} < ${o[c-2]-1};
        ${f}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${t};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${E};

        for (int i = 0; i < ${t}; i++) {
          inIdx = srcIdx;
          ${w}
          vec4 candidate = ${E};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${_}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tM(n,e,t,r=null){let i=e.shape[0],s=e.shape[1];r!=null&&(i=r.shape[0],s=r.shape[1]);const a=Am(s),o={windowSize:a,inSize:s,batchSize:i,outSize:Math.ceil(s/a)},c=new yJ(o,t,r==null),l=[e];r!=null&&l.push(r);const u=n.runWebGLProgram(c,l,"int32");if(u.shape[1]===1)return u;const f=tM(n,e,t,u);return n.disposeIntermediateTensorInfo(u),f}function nM(n,e,t,r=null){const i=r!=null?r.shape:e.shape,s=i[i.length-1],a=Am(s),o=new wJ(i,a,t,r==null),c=r==null?[e]:[e,r],l=n.runWebGLProgram(o,c,"int32");if(l.shape.length===e.shape.length){const u=nM(n,e,t,l);return n.disposeIntermediateTensorInfo(l),u}return l}function rM(n,e,t,r){const i=[t];if(Zn("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.shape.length),!ie().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const s=[],a=n.texData.get(e.dataId),o=a!==null&&a.isPacked;let c=e;o&&(c=n.unpackTensor(e),s.push(c));const[l,u]=Wn(c.shape,i),f=ue(u),d=Ae({inputs:{x:c},backend:n,attrs:{shape:[-1,f]}});s.push(d);const h=tM(n,d,r);s.push(h);const p=Ae({inputs:{x:h},backend:n,attrs:{shape:l}});return s.forEach(g=>n.disposeIntermediateTensorInfo(g)),p}return nM(n,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;let a=St(s,i.shape);const o=pn(a,i.shape.length);let c=i;const l=[];o!=null&&(c=xr({inputs:{x:i},backend:t,attrs:{perm:o}}),l.push(c),a=yn(a.length,c.shape.length)),Zn("argMax",[a[0]],c.shape.length);const u=rM(t,c,a[0],"max");return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),u}const SJ={kernelName:bp,backendName:"webgl",kernelFunc:EJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s}=r;let a=St(s,i.shape);const o=pn(a,i.shape.length);let c=i;const l=[];o!=null&&(c=xr({inputs:{x:i},backend:t,attrs:{perm:o}}),l.push(c),a=yn(a.length,c.shape.length)),Zn("argMin",[a[0]],c.shape.length);const u=rM(t,c,a[0],"min");return l.forEach(f=>t.disposeIntermediateTensorInfo(f)),u}const AJ={kernelName:_p,backendName:"webgl",kernelFunc:TJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CJ=Ri+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,IJ=Nt({opSnippet:CJ}),MJ={kernelName:qu,backendName:"webgl",kernelFunc:IJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const RJ=Ri+"return log(x + sqrt(x * x + 1.0));",NJ=Nt({opSnippet:RJ}),kJ={kernelName:Xu,backendName:"webgl",kernelFunc:NJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DJ=Ri+`
  return atan(x);
`,LJ=Nt({opSnippet:DJ}),OJ={kernelName:Ku,backendName:"webgl",kernelFunc:LJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zJ=uy+`
  return atan(a, b);
`,PJ=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qo+`
  return result;
`,FJ=Qn({opSnippet:zJ,packedOpSnippet:PJ}),$J={kernelName:Yu,backendName:"webgl",kernelFunc:FJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UJ=Ri+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,BJ=Nt({opSnippet:UJ}),VJ={kernelName:ju,backendName:"webgl",kernelFunc:BJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ou{constructor(e,t,r,i=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,f=e.effectiveFilterHeight,d=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const g=t==="avg",m=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,v=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let x="0.0";if(g||(x="-1.0 / 1e-20"),r){const T=">=";this.userCode=`
        const ivec2 strides = ivec2(${o}, ${c});
        const ivec2 pads = ivec2(${h}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${f};
              wR += ${l}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${d};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${T} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?s?m:v:`wR * ${d} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const b="max";let _=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(_="avgValue / max(count, 1.0)");const w=Math.floor(a/4)*4,E=a%4,S=`
      if (${g}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${b}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${o}, ${c});
      const ivec2 pads = ivec2(${h}, ${p});
      const float initializationValue = ${x};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${x});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${f};
            wR += ${l}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${w}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${S}
          }

          int xC = xCCorner + ${w};
          if (${E===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${E===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${S}
          } else if (${E===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${S}
          }
        }
        setOutput(${_});
      }
    `}}class dy{constructor(e,t,r,i=!1,s=!1){if(this.variableNames=["x"],t==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const a=e.filterWidth,o=e.strideDepth,c=e.strideHeight,l=e.strideWidth,u=e.dilationDepth,f=e.dilationHeight,d=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,g=e.effectiveFilterWidth,m=e.padInfo.front,v=e.padInfo.top,x=e.padInfo.left;this.outputShape=e.outShape;const b=t==="avg";let _="0.0";if(b||(_="-1.0 / 1e-20"),r){const y=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${o}, ${c}, ${l});
        const ivec3 pads = ivec3(${m}, ${v}, ${x});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${f}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${g};
                  wC += ${d}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${y} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${g} +
                      wR * ${g} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const w="max";let E=`${t}(${t}(${t}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;t==="avg"&&(E="avgValue / max(count, 1.0)");const S=Math.floor(a/4)*4,T=a%4,C=`
      if (${b}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${w}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${o}, ${c}, ${l});
      const ivec3 pads = ivec3(${m}, ${v}, ${x});
      const float initializationValue = ${_};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${_});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${f}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${S}; wC += 4) {
              int xC = xCCorner + wC * ${d};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                getValue(batch, xD, xR, xC + 3 * ${d}, ch)
              );

              ${C}
            }

            int xC = xCCorner + ${S};
            if (${T===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${C}
            } else if (${T===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                initializationValue,
                initializationValue
              );

              ${C}
            } else if (${T===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${d}, ch),
                getValue(batch, xD, xR, xC + 2 * ${d}, ch),
                initializationValue
              );

              ${C}
            }
          }
        }
        setOutput(${E});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;od(i,"avgPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:c}=r,l=1;R(or(a,l),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const u=Ii(i.shape,s,a,l,o,c);if(u.filterWidth===1&&u.filterHeight===1&&Pt(u.inShape,u.outShape))return qr({inputs:{x:i},backend:t});const f=new Ou(u,"avg",!1);return t.runWebGLProgram(f,[i],"float32")}const HJ={kernelName:yp,backendName:"webgl",kernelFunc:GJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WJ(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:a,pad:o,dimRoundingMode:c,dataFormat:l}=r,u=[1,1,1],f=ta(i.shape,s,a,u,o,c,l),d=new dy(f,"avg",!1);return t.runWebGLProgram(d,[i],"float32")}const qJ={kernelName:wp,backendName:"webgl",kernelFunc:WJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XJ{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,a=e.dilationHeight,o=e.dilationWidth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=c-1-e.padInfo.top,f=l-1-e.padInfo.left,d=1/(t*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${f});
      const float avgMultiplier = float(${d});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${c};
            wR += ${a}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${l};
            wC+= ${o}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class KJ{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,i=e.filterWidth,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,f=e.effectiveFilterDepth,d=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=f-1-e.padInfo.front,g=d-1-e.padInfo.top,m=h-1-e.padInfo.left,v=1/(t*r*i);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${g}, ${m});
      const float avgMultiplier = float(${v});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${f};
            wD += ${c}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${d};
              wR += ${l}) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jJ(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,a=s,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=r,f=[1,1,1],d=ta(a.shape,o,c,f,l,u),h=new KJ(d);return t.runWebGLProgram(h,[i],a.dtype)}const YJ={kernelName:D0,backendName:"webgl",kernelFunc:jJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZJ(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,a=s;od([i,s],"avgPoolGrad");const{filterSize:o,strides:c,pad:l}=r,u=Ii(a.shape,o,c,1,l),f=new XJ(u);return t.runWebGLProgram(f,[i],a.dtype)}const QJ={kernelName:k0,backendName:"webgl",kernelFunc:ZJ};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JJ(n){const{inputs:e,backend:t,attrs:r}=n,{a:i,b:s}=e,{transposeA:a,transposeB:o}=r;return np({a:i,b:s,transposeA:a,transposeB:o,backend:t})}const eee={kernelName:Ep,backendName:"webgl",kernelFunc:JJ};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tee{constructor(e,t,r,i,s,a){this.outputShape=[],this.variableNames=["x","mean","variance"],pt(e,t),pt(e,r);let o="0.0";i!=null&&(pt(e,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let c="1.0";s!=null&&(pt(e,s),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${o};
        float scale = ${c};
        float inv = scale * inversesqrt(variance + float(${a}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nee{constructor(e,t,r,i,s,a){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],pt(e,t),pt(e,r);let o="vec4(0.0)";i!=null&&(pt(e,i),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let c="vec4(1.0)";s!=null&&(pt(e,s),this.variableNames.push("scale"),c="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${o};
        vec4 scale = ${c};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${a}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ree=({inputs:n,backend:e,attrs:t})=>{const{x:r,mean:i,variance:s,offset:a,scale:o}=n;R(i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),R(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),R(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:c}=t;c==null&&(c=.001);const l=[r,i,s];let u=null;a!=null&&(u=a.shape,l.push(a));let f=null;o!=null&&(f=o.shape,l.push(o));const d=ie().getBool("WEBGL_PACK_NORMALIZATION")?new nee(r.shape,i.shape,s.shape,u,f,c):new tee(r.shape,i.shape,s.shape,u,f,c);return e.runWebGLProgram(d,l,l[0].dtype)},iee={kernelName:Op,backendName:"webgl",kernelFunc:ree};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class see{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=jt(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=aee(this.rank);let i;const s=e.map((a,o)=>`sourceLoc.${Lx[o]} = start[${o}] + coords.${Lx[o]};`);i=`
        ${t} sourceLoc;
        ${t} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${r}));
      }
    `}}const Lx=["x","y","z","w","u","v"];function aee(n){if(n===1)return"sourceLoc";if(n<=6)return Lx.slice(0,n).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oee{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=jt(this.rank),r=vr("coords",this.rank),i=vr("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,a=`getChannel(getSource(${i.join()}), ${s})`,o=`
      result.x = ${a};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${a};
        --${i[this.rank-1]};
      }
    `,c=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${a};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${a};
        }
      }
    `,l=this.rank<=4?`sourceLoc = coords +
            ${t}(${e.map((u,f)=>`start[${f}]`).join()});`:e.map((u,f)=>`${i[f]} = ${r[f]} + start[${f}];`).join(`
`);this.userCode=`
      void main() {
        ${t} coords = getOutputCoords();
        ${t} sourceLoc;
        ${l}
        vec4 result = vec4(0.);
        ${o}
        ${c}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cee(n,e,t,r){const i=r.texData.get(n.dataId),s=r.makeTensorInfo(t,n.dtype),a=r.texData.get(s.dataId);Object.assign(a,i),a.refCount=1,a.shape=t,a.dtype=n.dtype;let o=o_(e,Qe(n.shape));i.slice&&(o+=i.slice.flatOffset),a.slice={flatOffset:o,origDataId:i.slice&&i.slice.origDataId||n.dataId};const c=r.dataRefCount.get(a.slice.origDataId)||1;return r.dataRefCount.set(a.slice.origDataId,c+1),s}function Pl(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,size:a}=r,[o,c]=Tm(i,s,a);if(i_(i,o,c),ue(c)===0)return t.makeTensorInfo(c,i.dtype,[]);if(t.shouldExecuteOnCPU([i])||i.dtype==="string"){const f=t.texData.get(i.dataId),d=eQ(f.values,o,c,i.shape,i.dtype);return t.makeTensorInfo(c,i.dtype,d)}const{isPacked:l}=t.texData.get(i.dataId),u=a_(i.shape,o,c);if(l||!u){const f=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new oee(c):new see(c),d=[o];return t.runWebGLProgram(f,[i],i.dtype,d)}return t.uploadToGPU(i.dataId),cee(i,o,c,t)}const lee={kernelName:um,backendName:"webgl",kernelFunc:Pl};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uee=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,crops:a}=r;R(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const o=s.reduce((x,b)=>x*b),c=Kf(i.shape,s,o),l=jf(c.length,s.length),u=Yf(i.shape,s,o),f=d_(a,s.length),d=h_(u,a,s.length),h=[],p=Ae({inputs:{x:i},backend:t,attrs:{shape:c}}),g=xr({inputs:{x:p},backend:t,attrs:{perm:l}}),m=Ae({inputs:{x:g},backend:t,attrs:{shape:u}}),v=Pl({inputs:{x:m},backend:t,attrs:{begin:f,size:d}});return h.push(p),h.push(g),h.push(m),h.forEach(x=>t.disposeIntermediateTensorInfo(x)),v},fee={kernelName:Sp,backendName:"webgl",kernelFunc:uee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dee(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:a}=r,o=t.readSync(i.dataId),c=t.readSync(s.dataId),l=HI(o,c,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,l)}const hee={kernelName:L0,backendName:"webgl",kernelFunc:dee};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pee=`
  int r = int(a.r) & int(b.r);
  int g = int(a.g) & int(b.g);
  int rb = int(a.b) & int(b.b);
  int ra = int(a.a) & int(b.a);
  return vec4(r, g, rb, ra);
`,mee=`
  return float(int(a.r) & int(b.r));
`;function vee(n){const{inputs:e,backend:t}=n,{a:r,b:i}=e,s=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS"),a=ie().getNumber("WEBGL_VERSION");if(t.shouldExecuteOnCPU([r,i])||a===1){const c=t.texData.get(r.dataId).values,l=t.texData.get(i.dataId).values,[u,f]=SZ(r.shape,i.shape,c,l,r.dtype),d=t.makeTensorInfo(f,r.dtype),h=t.texData.get(d.dataId);return h.values=u,d}let o;return s?o=new Ol(pee,r.shape,i.shape,!1):o=new Fo(mee,r.shape,i.shape),t.runWebGLProgram(o,[r,i],r.dtype)}const gee={kernelName:O0,backendName:"webgl",kernelFunc:vee};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xee(n){const{inputs:e,backend:t}=n,{s0:r,s1:i}=e,s=t.readSync(r.dataId),a=t.readSync(i.dataId),o=pt(Array.from(s),Array.from(a));return t.makeTensorInfo([o.length],"int32",Int32Array.from(o))}const bee={kernelName:WE,backendName:"webgl",kernelFunc:xee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _ee="return float(a != b);",iM=Qn({opSnippet:_ee,cpuKernelImpl:WZ,dtype:"bool"}),yee={kernelName:Qp,backendName:"webgl",kernelFunc:iM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ld(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.texData.get(r.dataId);return qr({inputs:{x:i.complexTensorInfos.real},backend:t})}const wee={kernelName:ab,backendName:"webgl",kernelFunc:ld};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eee="return float(int(x));";function See(n,e){const t=new os(n.shape,Eee),r=e.runWebGLProgram(t,[n],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ox(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dtype:s}=r;if(s==="complex64"){if(i.dtype==="complex64")return qr({inputs:{x:i},backend:t});const a=Un(i.shape),o=Ox({inputs:{x:i},backend:t,attrs:{dtype:"float32"}}),c=Ka({inputs:{real:o,imag:a},backend:t});return a.dispose(),t.disposeIntermediateTensorInfo(o),c}if(i.dtype==="complex64"){const a=ld({inputs:{input:i},backend:t}),o=Ox({inputs:{x:a},backend:t,attrs:{dtype:s}});return t.disposeIntermediateTensorInfo(a),o}if(!UE(i.dtype,s)){const a=qr({inputs:{x:i},backend:t});return{dataId:a.dataId,shape:a.shape,dtype:s}}if(t.shouldExecuteOnCPU([i])){const a=t.texData.get(i.dataId).values,[o,c,l]=TZ(a,i.shape,i.dtype,s);return t.makeTensorInfo(o,c,l)}if(s==="int32")return See(i,t);if(s==="bool"){const a=t.makeTensorInfo([],"bool",ir("bool",1)),c=iM({inputs:{a:i,b:a},backend:t});return t.disposeIntermediateTensorInfo(a),c}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}const Tee={kernelName:Zu,backendName:"webgl",kernelFunc:Ox};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mw="return ceil(x);",Aee=Nt({opSnippet:Mw,packedOpSnippet:Mw,cpuKernelImpl:AZ}),Cee={kernelName:Qu,backendName:"webgl",kernelFunc:Aee};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Iee{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mee{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ree(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{clipValueMin:s,clipValueMax:a}=r;let o;ie().getBool("WEBGL_PACK_CLIP")?o=new Mee(i.shape):o=new Iee(i.shape);const c=[[s],[a]];return t.runWebGLProgram(o,[i],i.dtype,c)}const Nee={kernelName:Ju,backendName:"webgl",kernelFunc:Ree};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kee{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rw(n,e){return{dataId:e.dataId,dtype:e.dtype,shape:n.shape}}function Dee(n){const{inputs:e,backend:t}=n,{x:r}=e,i=t.texData.get(r.dataId),s=new kee(r.shape),a=[Rw(r,i.complexTensorInfos.real),Rw(r,i.complexTensorInfos.imag)];return t.runWebGLProgram(s,a,a[0].dtype)}const Lee={kernelName:Tp,backendName:"webgl",kernelFunc:Dee};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oee{constructor(e){this.outputShape=[],this.outputShape=ds(e,1),this.variableNames=e.map((a,o)=>`T${o}`);const t=new Array(e.length-1);t[0]=e[0][1];for(let a=1;a<t.length;a++)t[a]=t[a-1]+e[a][1];const r=[`if (yC < ${t[0]}) setOutput(getT0(yR, yC));`];for(let a=1;a<t.length;a++){const o=t[a-1];r.push(`else if (yC < ${t[a]}) setOutput(getT${a}(yR, yC-${o}));`)}const i=t.length,s=t[t.length-1];r.push(`else setOutput(getT${i}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zee{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=ds(e,t);const r=this.outputShape,i=r.length,s=jt(i),a=vr("coords",i),o=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((g,m)=>`T${m}`);const c=new Array(e.length-1);c[0]=e[0][t];for(let g=1;g<c.length;g++)c[g]=c[g-1]+e[g][t];const l=o[t],u=o.slice(-2),f=o.join();let d=`if (${l} < ${c[0]}) {
        return getChannel(
            getT0(${f}), vec2(${u.join()}));
        }`;for(let g=1;g<c.length;g++){const m=c[g-1];d+=`
        if (${l} < ${c[g]}  && ${l} >= ${c[g-1]}) {
          return getChannel(
            getT${g}(${ch(o,l,m)}),
            vec2(${ch(u,l,m)}));
        }`}const h=c.length,p=c[c.length-1];d+=`
        return getChannel(
          getT${h}(${ch(o,l,p)}),
          vec2(${ch(u,l,p)}));`,this.userCode=`
      float getValue(${o.map(g=>"int "+g)}) {
        ${d}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${a}), 0., 0., 0.);

        ${a[i-1]} = ${a[i-1]} + 1;
        if (${a[i-1]} < ${r[i-1]}) {
          result.g = getValue(${a});
        }

        ${a[i-2]} = ${a[i-2]} + 1;
        if (${a[i-2]} < ${r[i-2]}) {
          result.a = getValue(${a});
        }

        ${a[i-1]} = ${a[i-1]} - 1;
        if (${a[i-2]} < ${r[i-2]} &&
            ${a[i-1]} < ${r[i-1]}) {
          result.b = getValue(${a});
        }
        setOutput(result);
      }
    `}}function ch(n,e,t){const r=n.indexOf(e);return n.map((s,a)=>a===r?`${s} - ${t}`:s).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wm(n){const{inputs:e,backend:t}=n,{input:r}=e,i=t.texData.get(r.dataId);return qr({inputs:{x:i.complexTensorInfos.imag},backend:t})}const Pee={kernelName:Q0,backendName:"webgl",kernelFunc:Wm};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pu(n,e,t){const r=n[0].dtype;if(r==="complex64"){const h=n.map(x=>ld({inputs:{input:x},backend:t})),p=n.map(x=>Wm({inputs:{input:x},backend:t})),g=pu(h,e,t),m=pu(p,e,t),v=Ka({inputs:{real:g,imag:m},backend:t});return h.forEach(x=>t.disposeIntermediateTensorInfo(x)),p.forEach(x=>t.disposeIntermediateTensorInfo(x)),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),v}let i=t.shouldExecuteOnCPU(n);if(r==="string"&&(i=!0),i){const h=n.map(_=>{const E=[-1,ue(_.shape.slice(e))];return Ae({inputs:{x:_},backend:t,attrs:{shape:E}})}),p=h.map(_=>({vals:t.readSync(_.dataId),shape:_.shape})),g=ds(h.map(_=>_.shape),1),m=h[0].shape[0]===1,v=CZ(p,g,r,m),x=ds(n.map(_=>_.shape),e),b=t.makeTensorInfo(x,r,v);return h.forEach(_=>t.disposeIntermediateTensorInfo(_)),b}const s=n.filter(h=>ue(h.shape)>0),a=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(s.length===1){const h=a?new os(n[0].shape,va):new wa(n[0].shape,va);return t.runWebGLProgram(h,n,r)}const o=ie().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>o){const h=[];for(let g=0;g<s.length;g+=o){const m=s.slice(g,g+o);h.push(pu(m,e,t))}const p=pu(h,e,t);for(const g of h)t.disposeIntermediateTensorInfo(g);return p}if(a){const h=new zee(s.map(p=>p.shape),e);return t.runWebGLProgram(h,s,r)}const{tensors2D:c,outShape:l}=Fee(s,e,t),u=new Oee(c.map(h=>h.shape)),f=t.runWebGLProgram(u,c,r);c.forEach(h=>t.disposeIntermediateTensorInfo(h));const d=Ae({inputs:{x:f},attrs:{shape:l},backend:t});return t.disposeIntermediateTensorInfo(f),d}function Fee(n,e,t){const r=ds(n.map(s=>s.shape),e);return{tensors2D:n.map(s=>Ae({inputs:{x:s},attrs:{shape:[-1,ue(s.shape.slice(e))]},backend:t})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sM(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r,s=St(i,e[0].shape)[0],a=e.map(l=>l.shape);l_(a,s);const o=ds(e.map(l=>l.shape),s);if(ue(o)===0)return t.makeTensorInfo(o,e[0].dtype,[]);const c=e.filter(l=>ue(l.shape)>0);return c.length===1?qr({inputs:{x:c[0]},backend:t}):pu(c,s,t)}const $ee={kernelName:Ap,backendName:"webgl",kernelFunc:sM};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aM{constructor(e,t=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const a=e.padInfo.top,o=e.padInfo.left,c=e.strideHeight,l=e.strideWidth,u=e.dilationHeight,f=e.dilationWidth,d=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,g=e.inChannels%4,m=e.dataFormat==="channelsLast",v=m?1:2,x=m?2:3,b=m?3:1;let _="",w="";r&&(i?_=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?_=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:_=`
          float activation(float x) {
            ${r}
          }
        `,w="result = activation(result);");const E=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${_}

      const ivec2 strides = ivec2(${c}, ${l});
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${b}];

        ivec2 xRCCorner =
            ivec2(coords[${v}], coords[${x}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${d}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${f};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${m}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${g===1}) {

              if (${m}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${g===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${m}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${g===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${m}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${E}
        ${w}
        setOutput(result);
      }
    `}}class Uee{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,r=e.padInfo.top,i=e.padInfo.left,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,c=e.dilationDepth,l=e.dilationHeight,u=e.dilationWidth,f=e.filterDepth,d=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,g=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${a}, ${o});
      const ivec3 pads = ivec3(${t}, ${r}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${f}; wF++) {
          int xF = xFCorner + wF * ${c};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${d}; wR++) {
            int xR = xRCorner + wR * ${l};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${g===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${g===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${g===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class oM{constructor(e,t=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=lr(this.outputShape.length);const a=e.padInfo.left,o=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,f=u;let d=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let m=0;m<u;m++)d+=`
           vec4 xTexelC${m*2};
           int xTexelC${m*2}Ready;
           vec4 xTexelC${m*2+1};
           int xTexelC${m*2+1}Ready;
           vec4 xC${m};`;d+=`
     for (int r = 0; r < ${l}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let m=0;m<u;m++)d+=`
           xTexelC${m*2} = vec4(0.0);
           xTexelC${m*2}Ready = 0;
           xTexelC${m*2+1} = vec4(0.0);
           xTexelC${m*2+1}Ready = 0;
           xC${m} = vec4(0.0);`;d+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let m=0;m<(f+1)/2;m++){const v=m*2;if(d+=`
           xC = xCCorner + ${v*c};
           `,o===1){if(v<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }
               `,c===1&&v>0?d+=`
                 xC${v} = vec4(xTexelC${v-2}.zw, xTexelC${v}.xy);
                 `:d+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${v} = vec4(previous.zw, xTexelC${v}.xy);
                   } else {
                     xC${v} = vec4(0.0, 0.0, xTexelC${v}.xy);
                   }
                   `):d+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xC${v} = xTexelC${v};
                 `,v+1<u)){const x=a%2===0?E0(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(d+=`
                   xCOffset = xC + imod(pads[1], 2) + ${x};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                     xTexelC${v+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${v+1}.zw = vec2(0.0);
                     }
                     xTexelC${v+1}Ready = 1;
                   }
                   `,c>1?d+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${v+1} = vec4(previous.zw, xTexelC${v+1}.xy);
                     } else {
                      xC${v+1} = vec4(0.0, 0.0, xTexelC${v+1}.xy);
                     }
                     `:d+=`
                     xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.xy);
                     `):x===1?d+=`
                     xC${v+1} = xTexelC${v};
                     `:d+=`
                     xCOffset = xC + ${x};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                       xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${v+1}.zw = vec2(0.0);
                       }
                       xTexelC${v+1}Ready = 1;
                     }

                     xC${v+1} = xTexelC${v+1};
                     `}}else v<u&&(a%2===1?(d+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.0);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
               `,v+1<u&&(d+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${v+1} = vec4(xTexelC${v+1}.xy, final.xy);
                 `)):(d+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${v}Ready == 0) {
                   xTexelC${v} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${v}.zw = vec2(0.0);
                   }
                   xTexelC${v}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${v+1}Ready == 0) {
                   xTexelC${v+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${v+1}.zw = vec2(0.);
                   }
                   xTexelC${v+1}Ready = 1;
                 }

                 xC${v} = vec4(
                   xTexelC${v}.xy, xTexelC${v+1}.xy);
               `,v+1<u&&(d+=`
                   xC${v+1} = vec4(xTexelC${v}.zw, xTexelC${v+1}.zw);
                 `)));v<u&&(d+=`
             wTexel = getW(r, ${v}, d1, d2);
             dotProd += xC${v}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${v}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,v+1<u&&(d+=`
               wTexel = getW(r, ${v+1}, d1, d2);
               dotProd += xC${v+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${v+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}d+=`
     }
   `,d+=`
     }
   `,d+=`
     }
   `;let h="",p="";r&&(i?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:h=`vec4 activation(vec4 x) {
           ${r}
         }`,p="result = activation(result);");const g=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${d}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${g}
         ${p}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bee{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=lr(this.outputShape.length);const{dataFormat:r}=t,i=br(),s=r==="channelsLast",a=s?1:2,o=s?2:3,c=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let l="";for(let u=0;u<=1;u++)for(let f=0;f<=1;f++)l+=`
          blockIndex = rc.z + ${f};
          pos = rc.y + ${u};

          ${c}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${a}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${o}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+f}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+f}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${l}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rp(n,e){const t=n.length;return t>=3?e?[...n.slice(0,-3),n[t-3]*n[t-2],n[t-1]]:[...n.slice(0,-3),n[t-3],n[t-2]*n[t-1]]:!e&&t===1&&n[0]>1?[n[0],1]:null}function cM({x:n,filter:e,convInfo:t,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const c=n.shape,l=r.texData.get(n.dataId),u=t.inChannels,f=c[0]*c[1]*c[2],d=t.outChannels,h=t.dataFormat==="channelsLast",p=!1,g=!1;let m;const v=[];if(s!=null){const _=rp(s.shape,h);_!=null&&(s=Ae({inputs:{x:s},backend:r,attrs:{shape:_}}),v.push(s))}if(i!=null){const _=rp(i.shape,h);_!=null&&(i=Ae({inputs:{x:i},backend:r,attrs:{shape:_}}),v.push(i))}if(!((f===1||d===1)&&u>eM)&&l.isPacked&&h&&l.texture!=null&&c[2]%2!==0&&Pt(l.shape.slice(-3),c.slice(-3))){const _=c[0]*c[1]*(c[2]+1),w={dataId:n.dataId,shape:[1,_,t.inChannels],dtype:n.dtype},E=l.shape;l.shape=l.shape.slice(),l.shape[l.shape.length-2]++,R(tp(l.shape,w.shape),()=>`packed reshape ${l.shape} to ${w.shape} isn't free`);const S=Ae({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}});v.push(S);const T=np({a:w,b:S,backend:r,transposeA:p,transposeB:g,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a}),C=r.texData.get(T.dataId);R(C.isPacked,()=>"batchMatMul result is expected to be packed"),l.shape=E,C.shape=t.outShape,m=qr({inputs:{x:T},backend:r}),m.shape=t.outShape,v.push(T)}else{const _=t.outHeight*t.outWidth,w=Ae({inputs:{x:n},backend:r,attrs:{shape:h?[t.batchSize,_,t.inChannels]:[t.batchSize,t.inChannels,_]}}),E=Ae({inputs:{x:e},backend:r,attrs:{shape:[1,t.inChannels,t.outChannels]}}),S=np({a:h?w:E,b:h?E:w,transposeA:!h,transposeB:g,backend:r,bias:i,activation:o,preluActivationWeights:s,leakyreluAlpha:a});m=Ae({inputs:{x:S},backend:r,attrs:{shape:t.outShape}}),v.push(w),v.push(E),v.push(S)}for(const _ of v)r.disposeIntermediateTensorInfo(_);return m}function lM({x:n,filter:e,convInfo:t,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:a=0,activation:o=null}){const{filterWidth:c,filterHeight:l,inChannels:u,outWidth:f,outHeight:d,dataFormat:h}=t,p=h==="channelsLast",g=c*l*u,m=d*f,v=[t.batchSize,g,m],x=!0,b=!1,_=[];if(s!=null){const O=rp(s.shape,p);O!=null&&(s=Ae({inputs:{x:s},backend:r,attrs:{shape:O}}),_.push(s))}if(i!=null){const O=rp(i.shape,p);O!=null&&(i=Ae({inputs:{x:i},backend:r,attrs:{shape:O}}),_.push(i))}const w=Ae({inputs:{x:e},backend:r,attrs:{shape:[1,g,ue(e.shape)/g]}});_.push(w);const E=new Bee(v,t),S=[n.shape,[t.padInfo.top,t.padInfo.left],[t.strideHeight,t.strideWidth],[t.dilationHeight,t.dilationWidth],[t.inChannels],[t.filterWidth*t.inChannels],[t.outWidth]],T=r.runWebGLProgram(E,[n],"float32",S),C=Ae({inputs:{x:T},backend:r,attrs:{shape:v}});_.push(T),_.push(C);const y=i!=null,A=s!=null,k=o==="leakyrelu",M=o?Lu(o,!0):null,L=new JI(p?C.shape:w.shape,p?w.shape:C.shape,p?[t.batchSize,m,t.outChannels]:[t.batchSize,t.outChannels,m],x,b,y,M,A,k),z=p?[C,w]:[w,C];if(i&&z.push(i),A&&z.push(s),k){const O=r.makeTensorInfo([],"float32",Ua(a,"float32"));z.push(O),_.push(O)}const D=r.runWebGLProgram(L,z,"float32"),F=Ae({inputs:{x:D},backend:r,attrs:{shape:t.outShape}});_.push(D);for(const O of _)r.disposeIntermediateTensorInfo(O);return F}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vee(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:a,pad:o,dataFormat:c,dilations:l,dimRoundingMode:u}=r,f=na(c),d=Yn(i.shape,s.shape,a,l,o,u,!1,f);let h;if(d.filterHeight===1&&d.filterWidth===1&&d.dilationHeight===1&&d.dilationWidth===1&&d.strideHeight===1&&d.strideWidth===1&&(d.padInfo.type==="SAME"||d.padInfo.type==="VALID"))h=cM({x:i,filter:s,convInfo:d,backend:t});else if(d.strideWidth<=2&&f==="channelsLast"&&ie().getBool("WEBGL_EXP_CONV")){const g=new oM(d),m=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];h=t.runWebGLProgram(g,[i,s],"float32",m)}else if(ie().getBool("WEBGL_CONV_IM2COL"))h=lM({x:i,filter:s,convInfo:d,backend:t});else{const g=new aM(d);h=t.runWebGLProgram(g,[i,s],"float32")}const p=Ae({inputs:{x:h},backend:t,attrs:{shape:d.outShape}});return t.disposeIntermediateTensorInfo(h),p}const Gee={kernelName:Cp,backendName:"webgl",kernelFunc:Vee};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Hee{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,i=e.padInfo.top,s=e.padInfo.left,a=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              ${a?`float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);`:`float dyValue = getDy(b, d2, yR, yC);
              float xValue = getX(b, d1, xR, xC);
              dotProd += (xValue * dyValue);`}
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Wee{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,a=e.dataFormat==="channelsLast",o=t-1-e.padInfo.top,c=r-1-e.padInfo.left,l=a?1:2,u=a?2:3,f=a?3:1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${f}];

        ivec2 dyCorner = ivec2(coords[${l}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${a}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class qee{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,r=e.strideHeight,i=e.strideWidth,s=e.padInfo.front,a=e.padInfo.top,o=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${t} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${a};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${o};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Xee{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,r=e.filterHeight,i=e.filterWidth,s=e.strideDepth,a=e.strideHeight,o=e.strideWidth,c=t-1-e.padInfo.front,l=r-1-e.padInfo.top,u=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${c}, ${l}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${t}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${t} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${a}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${o}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kee(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:a,pad:o,dataFormat:c,dimRoundingMode:l,filterShape:u}=r,f=na(c),d=Yn(i.shape,u,a,1,o,l,!1,f),h=new Hee(d);return t.runWebGLProgram(h,[i,s],"float32")}const jee={kernelName:P0,backendName:"webgl",kernelFunc:Kee};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yee{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=lr(this.outputShape.length);const t=e.filterHeight,r=e.filterWidth,i=t-1-e.padInfo.top,s=r-1-e.padInfo.left;this.userCode=`
      const ivec2 pads = ivec2(${i}, ${s});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];

        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        vec4 result = vec4(0.);
        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / strides[0];
          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);
          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            int wCPerm = ${r} - 1 - wC;

            float dyC = float(dyCCorner + wC) / strides[1];
            bool idyCVal = (dyC >= 0.0) && (dyC < ${e.outWidth}.0)
              && (fract(dyC) == 0.0);
            int idyC = int(dyC);

            float dyC2 = float(dyCCorner + wC + 1) / strides[1];
            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ${e.outWidth}.0)
              && (fract(dyC2) == 0.0);
            int idyC2 = int(dyC2);

            if (idyCVal && idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?
                  dySample : getDy(batch, idyR, idyC2, d2);

                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));

                dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample2.xy : dySample2.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC, d2);
                vec2 dyValue = mod(float(idyC), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.xy += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            } else if (idyCVal2) {
              for (int d2 = 0; d2 < ${e.outChannels}; d2 += 2) {
                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);
                vec4 dySample = getDy(batch, idyR, idyC2, d2);
                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?
                  dySample.xy : dySample.zw;
                result.zw += vec2(dot(dyValue, wValue.xy),
                  dot(dyValue, wValue.zw));
              }
            }
          }
        }
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zee(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{inputShape:a,strides:o,pad:c,dataFormat:l,dimRoundingMode:u}=r,f=na(l),d=Yn(a,s.shape,o,1,c,u,!1,f);if(ie().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&f==="channelsLast"){const h=[[d.strideHeight,d.strideWidth]],p=new Yee(d);return t.runWebGLProgram(p,[i,s],"float32",h)}else{const h=new Wee(d);return t.runWebGLProgram(h,[i,s],"float32")}}const Qee={kernelName:Ip,backendName:"webgl",kernelFunc:Zee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jee(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:a,pad:o,dilations:c}=r,l=Ba(i.shape,s.shape,a,c,o),u=new Uee(l);return t.runWebGLProgram(u,[i,s],"float32")}const ete={kernelName:Mp,backendName:"webgl",kernelFunc:Jee};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tte(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:a,pad:o,filterShape:c}=r,l=Ba(i.shape,c,a,1,o),u=new qee(l);return t.runWebGLProgram(u,[i,s],"float32")}const nte={kernelName:F0,backendName:"webgl",kernelFunc:tte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rte(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{pad:a,strides:o,inputShape:c}=r,l=Ba(c,s.shape,o,1,a),u=new Xee(l);return t.runWebGLProgram(u,[i,s],"float32")}const ite={kernelName:$0,backendName:"webgl",kernelFunc:rte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ste=zl+`
  return cos(x);
`,ate=`
  vec4 result = cos(x);
  bvec4 isNaN = isnan(x);
  ${Qo}
  return result;
`,ote=Nt({opSnippet:ste,packedOpSnippet:ate}),cte={kernelName:ef,backendName:"webgl",kernelFunc:ote};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lte=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,ute=Nt({opSnippet:lte}),fte={kernelName:tf,backendName:"webgl",kernelFunc:ute};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dte{constructor(e,t,r,i,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[a,o,c,l]=e,[u]=t,[f,d]=r;this.outputShape=[u,f,d,l];const h=i==="bilinear"?1:0,[p,g]=[`${o-1}.0`,`${c-1}.0`],[m,v,x]=f>1?[`${(o-1)/(f-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[b,_,w]=d>1?[`${(c-1)/(d-1)}`,"(x2-x1) * width_ratio",`x1*${g} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${g}`];this.userCode=`
      const float height_ratio = float(${m});
      const float width_ratio = float(${b});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${a}) {
          return;
        }

        float height_scale = ${v};
        float width_scale = ${_};

        float in_y = ${x};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${w};
        if( in_x < 0.0 || in_x > ${g} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hte=n=>{const{inputs:e,backend:t,attrs:r}=n,{image:i,boxes:s,boxInd:a}=e,{cropSize:o,method:c,extrapolationValue:l}=r,u=new dte(i.shape,s.shape,o,c,l);return t.runWebGLProgram(u,[i,s,a],"float32")},pte={kernelName:B0,backendName:"webgl",kernelFunc:hte};var zu;(function(n){n.Prod="*",n.Sum="+"})(zu||(zu={}));class Nw{constructor(e,t,r,i){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,a=this.op===zu.Prod?"1.0":"0.0",o=r?a:`getX(${kw(s,"coords",this.op)})`,c=this.outputShape[this.outputShape.length-1];let l="",u="";r?(l=i?`end != ${c-1}`:"end != 0",u=i?"end + 1":"end - 1"):(l=i?`end + pow2 < ${c}`:"end >= pow2",u=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${jt(s)} coords = getOutputCoords();
        int end = ${Dw(s,"coords",this.op)};
        float val = ${o};
        int pow2 = int(pow(2.0, index));
        if (${l}) {
          int idx = ${u};
          ${Dw(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${kw(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function kw(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.x, ${e}.y`;if(n===3)return`${e}.x, ${e}.y, ${e}.z`;if(n===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}function Dw(n,e,t){if(n===1)return`${e}`;if(n===2)return`${e}.y`;if(n===3)return`${e}.z`;if(n===4)return`${e}.w`;throw new Error(`Cumulative ${t} for rank ${n} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uM(n,e,t,r,i,s){const a=e.shape.length,o=pn([r],a);let c=e;o!=null&&(c=xr({inputs:{x:e},backend:t,attrs:{perm:o}}));const l=yn(1,a)[0];if(l!==a-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=c.shape[l];let f=qr({inputs:{x:c},backend:t});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const h=new Nw(n,c.shape,!1,s),p=[[d]],g=f;f=t.runWebGLProgram(h,[f],f.dtype,p),t.disposeIntermediateTensorInfo(g)}if(i){const d=new Nw(n,c.shape,i,s),h=f;f=t.runWebGLProgram(d,[f],f.dtype),t.disposeIntermediateTensorInfo(h)}if(o!=null){const d=Va(o),h=xr({inputs:{x:f},backend:t,attrs:{perm:d}});return t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(c),h}return f}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mte(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;return uM(zu.Prod,i,t,s,a,o)}const vte={kernelName:U0,backendName:"webgl",kernelFunc:mte};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gte(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,exclusive:a,reverse:o}=r;return uM(zu.Sum,i,t,s,a,o)}const xte={kernelName:Rp,backendName:"webgl",kernelFunc:gte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bte(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,weights:s}=e,{size:a,binaryOutput:o}=r;if(i.shape.length===1){const c=t.readSync(i.dataId),l=t.readSync(s.dataId),u=HI(c,l,s.dtype,s.shape,a);return t.makeTensorInfo([a],s.dtype,u)}else if(i.shape.length===2){const c=t.bufferSync(i),l=t.bufferSync(s),u=EZ(c,l,a,o);return t.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const _te={kernelName:V0,backendName:"webgl",kernelFunc:bte};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yte{constructor(e,t,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${t};
      int offset_h = imod(h, ${t});
      int in_w = w / ${t};
      int offset_w = imod(w, ${t});
      int offset_d = (offset_h * ${t} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wte(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockSize:s,dataFormat:a}=r,o=i.shape[0],c=a==="NHWC"?i.shape[1]:i.shape[2],l=a==="NHWC"?i.shape[2]:i.shape[3],u=a==="NHWC"?i.shape[3]:i.shape[1],f=c*s,d=l*s,h=u/(s*s),p=a==="NHWC"?[o,f,d,h]:[o,h,f,d],g=new yte(p,s,a);return t.runWebGLProgram(g,[i],i.dtype)}const Ete={kernelName:G0,backendName:"webgl",kernelFunc:wte};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fM{constructor(e,t=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=lr(this.outputShape.length);const a=e.filterHeight,o=e.filterWidth,c=e.outChannels/e.inChannels;let l="",u="";r&&(i?l=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?l=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:l=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${l}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${c};
        int q = d2 - d1 * ${c};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${a}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${o}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${f}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dM{constructor(e,t=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=lr(this.outputShape.length);const a=e.outChannels/e.inChannels,o=e.padInfo.left,c=e.strideWidth,l=e.dilationWidth,u=e.filterHeight,f=e.filterWidth,d=f;let h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<f;v++)h+=`
          vec4 xTexelC${v*2};
          int xTexelC${v*2}Ready;
          vec4 xTexelC${v*2+1};
          int xTexelC${v*2+1}Ready;
          vec4 xC${v};`;h+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let v=0;v<f;v++)h+=`
          xTexelC${v*2} = vec4(0.0);
          xTexelC${v*2}Ready = 0;
          xTexelC${v*2+1} = vec4(0.0);
          xTexelC${v*2+1}Ready = 0;
          xC${v} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let v=0;v<(d+1)/2;v++){const x=v*2;if(h+=`
          xC = xCCorner + ${x*l};
          `,c===1){if(x<f&&(o%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }
              `,l===1&&x>0?h+=`
                xC${x} = vec4(xTexelC${x-2}.zw, xTexelC${x}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${x} = vec4(previous.zw, xTexelC${x}.xy);
                  } else {
                    xC${x} = vec4(0.0, 0.0, xTexelC${x}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xC${x} = xTexelC${x};
                `,x+1<f)){const b=o%2===0?E0(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${b};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                    xTexelC${x+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${x+1}.zw = vec2(0.0);
                    }
                    xTexelC${x+1}Ready = 1;
                  }
                  `,l>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${x+1} = vec4(previous.zw, xTexelC${x+1}.xy);
                    } else {
                     xC${x+1} = vec4(0.0, 0.0, xTexelC${x+1}.xy);
                    }
                    `:h+=`
                    xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.xy);
                    `):b===1?h+=`
                    xC${x+1} = xTexelC${x};
                    `:h+=`
                    xCOffset = xC + ${b};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                      xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${x+1}.zw = vec2(0.0);
                      }
                      xTexelC${x+1}Ready = 1;
                    }

                    xC${x+1} = xTexelC${x+1};
                    `}}else x<f&&(o%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.0);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
              `,x+1<f&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${x+1} = vec4(xTexelC${x+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${x}Ready == 0) {
                  xTexelC${x} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${x}.zw = vec2(0.0);
                  }
                  xTexelC${x}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${x+1}Ready == 0) {
                  xTexelC${x+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${x+1}.zw = vec2(0.);
                  }
                  xTexelC${x+1}Ready = 1;
                }

                xC${x} = vec4(
                  xTexelC${x}.xy, xTexelC${x+1}.xy);
              `,x+1<f&&(h+=`
                  xC${x+1} = vec4(xTexelC${x}.zw, xTexelC${x+1}.zw);
                `)));x<f&&(h+=`
            wTexel = getW(r, ${x}, d1, q);
            dotProd += xC${x} * vec4(wTexel.xz, wTexel.xz);
          `,x+1<f&&(h+=`
              wTexel = getW(r, ${x+1}, d1, q);
              dotProd += xC${x+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let p="",g="";r&&(i?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:p=`vec4 activation(vec4 x) {
          ${r}
        }`,g="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${a};
        int q = d2 - d1 * ${a};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${m}
        ${g}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ste(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:a,pad:o,dilations:c,dimRoundingMode:l}=r;let u=c;u==null&&(u=[1,1]),R(or(a,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${a} and dilations '${u}'`);const f=Yn(i.shape,s.shape,a,u,o,l,!0);let d;ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&f.strideWidth<=2&&f.outChannels/f.inChannels===1?d=new dM(f):d=new fM(f);const h=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];return t.runWebGLProgram(d,[i,s],"float32",h)}const Tte={kernelName:Np,backendName:"webgl",kernelFunc:Ste};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ate{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,r=e.strideWidth,i=e.padInfo.top,s=e.padInfo.left,a=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${a} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${t} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class Cte{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,a=t-1-e.padInfo.top,o=r-1-e.padInfo.left,c=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${o});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${t}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${t} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${c}; dm++) {
              int d2 = d1 * ${c} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ite(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,dy:s}=e,{strides:a,dilations:o,pad:c,dimRoundingMode:l,filterShape:u}=r,f=Yn(i.shape,u,a,o,c,l,!0),d=new Ate(f);return t.runWebGLProgram(d,[i,s],"float32")}const Mte={kernelName:H0,backendName:"webgl",kernelFunc:Ite};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rte(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,filter:s}=e,{strides:a,dilations:o,pad:c,dimRoundingMode:l,inputShape:u}=r,f=Yn(u,s.shape,a,o,c,l,!0),d=new Cte(f);return t.runWebGLProgram(d,[i,s],"float32")}const Nte={kernelName:W0,backendName:"webgl",kernelFunc:Rte};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kte{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dte(n){const{inputs:e,backend:t}=n,{x:r}=e,i=[...r.shape,...r.shape],s=ue(r.shape),a=Ae({inputs:{x:r},backend:t,attrs:{shape:[s]}}),o=new kte(s),c=t.runWebGLProgram(o,[a],a.dtype),l=Ae({inputs:{x:c},backend:t,attrs:{shape:i}});return t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(c),l}const Lte={kernelName:qE,backendName:"webgl",kernelFunc:Dte};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ote{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:r,padInfo:i,strideHeight:s,strideWidth:a,filterHeight:o,filterWidth:c,dilationHeight:l,dilationWidth:u}=e,{top:f,left:d}=i;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${a});
      const ivec2 pads = ivec2(${f}, ${d});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${o}; h++) {
          int hIn = hBeg + h * ${l};

          if (hIn >= 0 && hIn < ${t}) {
            for (int w = 0; w < ${c}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zte(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s}=e,{strides:a,pad:o,dilations:c}=r,l=Gf(i.shape,s.shape,a,o,"NHWC",c);let u;const f=new Ote(l);u=t.runWebGLProgram(f,[i,s],"float32");const d=Ae({inputs:{x:u},backend:t,attrs:{shape:l.outShape}});return t.disposeIntermediateTensorInfo(u),d}const Pte={kernelName:kp,backendName:"webgl",kernelFunc:zte};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fte(n){const{inputs:e,backend:t,attrs:r}=n,{equation:i}=r,s=e,{allDims:a,summedDims:o,idDims:c}=y_(i,s.length);E_(a.length,c,s);const{path:l,steps:u}=S_(o,c),f=u.length;let d=null,h=a.length;const p=[];for(let g=0;g<f;++g){for(const m of u[g]){const{permutationIndices:v,expandDims:x}=w_(h,c[m]);let b;T_(v)?b=s[m]:(b=xr({inputs:{x:s[m]},backend:t,attrs:{perm:v}}),p.push(b));const _=b.shape.slice();for(let w=0;w<x.length;++w)_.splice(x[w],0,1);Pt(b.shape,_)||(b=Ae({inputs:{x:b},backend:t,attrs:{shape:_}}),p.push(b)),d===null?d=b:(d=fy({inputs:{a:b,b:d},backend:t}),p.push(d))}g<f-1&&(l[g]>=0&&(d=Hm({inputs:{x:d},backend:t,attrs:{axis:l[g]-(a.length-h),keepDims:!1}}),p.push(d)),h--)}for(const g of p)g!==d&&t.disposeIntermediateTensorInfo(g);return d}const $te={kernelName:q0,backendName:"webgl",kernelFunc:Fte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ute="return (x >= 0.0) ? x : (exp(x) - 1.0);",Bte=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,Vte=Nt({opSnippet:Ute,packedOpSnippet:Bte}),Gte={kernelName:rf,backendName:"webgl",kernelFunc:Vte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hte="return (b >= 0.0) ? a : a * (b + 1.0);",Wte=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,qte=n=>{const{inputs:e,backend:t}=n,{dy:r,y:i}=e,s=ie().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new Ol(Wte,r.shape,i.shape):new Fo(Hte,r.shape,i.shape);return t.runWebGLProgram(s,[r,i],r.dtype)},Xte={kernelName:X0,backendName:"webgl",kernelFunc:qte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kte=`
  return vec4(equal(a, b));
`,jte="return float(a == b);",Yte=Qn({opSnippet:jte,packedOpSnippet:Kte,dtype:"bool",cpuKernelImpl:IZ}),Zte={kernelName:Dp,backendName:"webgl",kernelFunc:Yte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qte=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${p_};
  float a1 = ${m_};
  float a2 = ${v_};
  float a3 = ${g_};
  float a4 = ${x_};
  float a5 = ${b_};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,Jte=Nt({opSnippet:Qte}),ene={kernelName:sf,backendName:"webgl",kernelFunc:Jte};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tne=zl+`
  return exp(x);
`,nne=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,hM=Nt({opSnippet:tne,packedOpSnippet:nne,cpuKernelImpl:MZ,dtype:"float32"}),rne={kernelName:af,backendName:"webgl",kernelFunc:hM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zx(n){const{inputs:e,attrs:t,backend:r}=n,{dim:i}=t,{input:s}=e,a=s.shape.length,o=s.shape.slice();let c=i;return i<0&&(R(-(a+1)<=i,()=>`Axis must be in the interval [${-(a+1)}, ${a}]`),c=a+i+1),o.splice(c,0,1),Ae({inputs:{x:s},backend:r,attrs:{shape:o}})}const ine={kernelName:Lp,backendName:"webgl",kernelFunc:zx};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lw="return exp(x) - 1.0;",sne=Nt({opSnippet:Lw,packedOpSnippet:Lw,cpuKernelImpl:RZ}),ane={kernelName:of,backendName:"webgl",kernelFunc:sne};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ow{constructor(e,t,r){this.variableNames=["real","imag"];const i=t[1];this.outputShape=t;const s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,a=r?`${i}.0`:"1.0";let o;if(e==="real")o="return real * expR - imag * expI;";else if(e==="imag")o="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${o}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${a};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pM(n,e,t){const r=t.texData.get(n.dataId),i=ue(n.shape),s=n.shape[n.shape.length-1],a=i/s,o=Ae({inputs:{x:n},backend:t,attrs:{shape:[a,s]}}),c=o.shape,l=new Ow("real",c,e),u=new Ow("imag",c,e),f=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:c},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:c}],d=t.runWebGLProgram(l,f,"float32"),h=t.runWebGLProgram(u,f,"float32"),p=Ka({inputs:{real:d,imag:h},backend:t});t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h);const g=Ae({inputs:{x:p},backend:t,attrs:{shape:n.shape}});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(p),g}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function one(n){const{inputs:e,backend:t}=n,{input:r}=e;return pM(r,!1,t)}const cne={kernelName:K0,backendName:"webgl",kernelFunc:one};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class lne{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ud(n){const{backend:e,attrs:t}=n,{shape:r,value:i}=t;let{dtype:s}=t;if(s=s||yl(i),s==="string"){const a=gn(s,ue(r));return a.fill(i),e.makeTensorInfo(r,s,a)}else{const a=new lne(r,i),o=[[i]];return e.runWebGLProgram(a,[],s,o)}}const une={kernelName:j0,backendName:"webgl",kernelFunc:ud};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fne{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${t} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${t}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dne={kernelName:Y0,backendName:"webgl",kernelFunc:({inputs:n,backend:e})=>{const{image:t}=n,r=e,i=new fne(t.shape);return r.runWebGLProgram(i,[t],t.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const zw="return floor(x);",hne=Nt({opSnippet:zw,packedOpSnippet:zw,cpuKernelImpl:NZ}),pne={kernelName:cf,backendName:"webgl",kernelFunc:hne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mne=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,vne=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,gne=Qn({opSnippet:mne,packedOpSnippet:vne,dtype:"int32"}),xne={kernelName:lf,backendName:"webgl",kernelFunc:gne};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bne{constructor(e){this.variableNames=["A"];const t=br(),[r,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);

        vec4 values = ${t.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _ne{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=br(),[r,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${r}.0);
            vec4 values = ${t.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${t.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yne={kernelName:$P,backendName:"webgl",kernelFunc:wne};let yc,eg=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function wne(n){const{inputs:e,backend:t,attrs:r}=n;let{pixels:i}=e;const{numChannels:s}=r,a=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,o=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[c,l]=a?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[l,c],f=[l,c,s];if(o||a){const g=ie().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(yc==null||g!==eg)&&(eg=g,yc=document.createElement("canvas").getContext("2d",{willReadFrequently:eg})),yc.canvas.width=c,yc.canvas.height=l,yc.drawImage(i,0,0,c,l),i=yc.canvas}const d=t.makeTensorInfo(u,"int32");t.texData.get(d.dataId).usage=ei.PIXELS,t.gpgpu.uploadPixelDataToTexture(t.getTexture(d.dataId),i);const h=ie().getBool("WEBGL_PACK")?new _ne(f):new bne(f),p=t.runWebGLProgram(h,[d],"int32");return t.disposeData(d.dataId),p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ene(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:c,pad:l,dataFormat:u,dilations:f,dimRoundingMode:d,activation:h,leakyreluAlpha:p}=r,g=na(u),m=Yn(i.shape,s.shape,c,f,l,d,!1,g);let v;const x=[],b=a!=null,_=o!=null,w=h==="leakyrelu",E=()=>{const T=[i,s],C=(y,A)=>{if(A==="NCHW"&&y.shape.length===1&&y.shape[0]!==1){const k=Ae({inputs:{x:y},backend:t,attrs:{shape:[y.shape[0],1,1]}});return x.push(k),k}return y};if(b&&T.push(C(a,u)),_&&T.push(C(o,u)),w){const y=t.makeTensorInfo([],"float32",Ua(p,"float32"));T.push(y),x.push(y)}return T};if(m.filterHeight===1&&m.filterWidth===1&&m.dilationHeight===1&&m.dilationWidth===1&&m.strideHeight===1&&m.strideWidth===1&&(m.padInfo.type==="SAME"||m.padInfo.type==="VALID"))v=cM({x:i,filter:s,convInfo:m,backend:t,bias:a,activation:h,preluActivationWeights:o,leakyreluAlpha:p});else if(m.strideWidth<=2&&g==="channelsLast"&&ie().getBool("WEBGL_EXP_CONV")){const T=h?Lu(h,!0):null,C=new oM(m,b,T,_,w),y=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],A=E();v=t.runWebGLProgram(C,A,"float32",y)}else if(ie().getBool("WEBGL_CONV_IM2COL"))v=lM({x:i,filter:s,convInfo:m,backend:t,bias:a,activation:h,preluActivationWeights:o,leakyreluAlpha:p});else{const T=h?Lu(h,!1):null,C=new aM(m,b,T,_,w),y=E();v=t.runWebGLProgram(C,y,"float32")}const S=Ae({inputs:{x:v},backend:t,attrs:{shape:m.outShape}});return x.push(v),x.forEach(T=>t.disposeIntermediateTensorInfo(T)),S}const Sne={kernelName:Dh,backendName:"webgl",kernelFunc:Ene};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tne(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,filter:s,bias:a,preluActivationWeights:o}=e,{strides:c,pad:l,dilations:u,dimRoundingMode:f,activation:d,leakyreluAlpha:h}=r,p=[];let g=u;g==null&&(g=[1,1]),R(or(c,g),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${c} and dilations '${g}'`);const m=Yn(i.shape,s.shape,c,g,l,f,!0),v=ie().getBool("WEBGL_PACK_DEPTHWISECONV")&&m.strideWidth<=2&&m.outChannels/m.inChannels===1,x=d?Lu(d,v):null,b=[i,s],_=a!=null,w=o!=null,E=d==="leakyrelu";if(_&&b.push(a),w&&b.push(o),E){const y=t.makeTensorInfo([],"float32",Ua(h,"float32"));b.push(y),p.push(y)}let S;v?S=new dM(m,_,x,w,E):S=new fM(m,_,x,w,E);const T=[[m.padInfo.top,m.padInfo.left],[m.strideHeight,m.strideWidth],[m.dilationHeight,m.dilationWidth],[m.inHeight,m.inWidth]],C=t.runWebGLProgram(S,b,"float32",T);return p.forEach(y=>t.disposeIntermediateTensorInfo(y)),C}const Ane={kernelName:f3,backendName:"webgl",kernelFunc:Tne};class Cne{constructor(e,t,r,i){this.sliceDim=e,this.strides=t,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=r;const s=jt(r.length);let a=`
    int index;`;for(let o=0;o<this.sliceDim;o++)a+=`
          index = round(getIndices(coords[0], ${o}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[o]};
          flattenIndex += index * ${this.strides[o]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${a}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ine(n){const{inputs:e,backend:t}=n,{params:r,indices:i}=e,s=i.shape,a=s[s.length-1],o=ue(r.shape),[c,l,u,f]=r_(r,i),d=Ae({inputs:{x:i},backend:t,attrs:{shape:[l,a]}}),h=Ae({inputs:{x:r},backend:t,attrs:{shape:[ue(r.shape)/u,u]}});if(t.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const v=t.readSync(i.dataId),x=t.bufferSync(r),b=kZ(v,x,r.dtype,l,a,u,f,r.shape,o);return t.makeTensorInfo(c,r.dtype,b.values)}const p=new Cne(a,f,[l,u],r.shape),g=t.runWebGLProgram(p,[h,d],h.dtype),m=Ae({inputs:{x:g},backend:t,attrs:{shape:c}});return t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(g),m}const Mne={kernelName:XE,backendName:"webgl",kernelFunc:Ine};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rne{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const r=jt(this.rank),i=Nne(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function Nne(n,e){const t=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<n.length;i++)i===2?r.push("index"):r.push(`${t[i]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mM(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,indices:s}=e,{axis:a,batchDims:o}=r,c=St(a,i.shape)[0];if(ie().get("DEBUG")){const x=t.readSync(s.dataId),b=i.shape[c];for(let _=0;_<x.length;++_){const w=x[_];R(w<=b-1&&w>=0,()=>`GatherV2: the index value ${w} is not in [0, ${b-1}]`)}}const l=C_(i,s,c,o),u=ue(s.shape),f=[],d=Ae({inputs:{x:i},backend:t,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),h=Ae({inputs:{x:s},backend:t,attrs:{shape:[l.batchSize,u/l.batchSize]}});f.push(d),f.push(h);const p=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(t.shouldExecuteOnCPU([i,s])||i.dtype==="string"){const x=t.bufferSync(h),b=t.bufferSync(d),_=DZ(b,x,p);return f.forEach(w=>t.disposeIntermediateTensorInfo(w)),t.makeTensorInfo(l.outputShape,_.dtype,_.values)}const g=new Rne(d.shape,p),m=t.runWebGLProgram(g,[d,h],d.dtype);f.push(m);const v=Ae({inputs:{x:m},backend:t,attrs:{shape:l.outputShape}});return f.forEach(x=>t.disposeIntermediateTensorInfo(x)),v}const kne={kernelName:zp,backendName:"webgl",kernelFunc:mM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dne="return float(a > b);",Lne=`
  return vec4(greaterThan(a, b));
`,One=Qn({opSnippet:Dne,packedOpSnippet:Lne,cpuKernelImpl:LZ,dtype:"bool"}),zne={kernelName:Pp,backendName:"webgl",kernelFunc:One};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pne="return float(a >= b);",Fne=`
  return vec4(greaterThanEqual(a, b));
`,$ne=Qn({opSnippet:Pne,packedOpSnippet:Fne,dtype:"bool",cpuKernelImpl:OZ}),Une={kernelName:uf,backendName:"webgl",kernelFunc:$ne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bne(n){const{inputs:e,backend:t}=n,{input:r}=e;return pM(r,!0,t)}const Vne={kernelName:Z0,backendName:"webgl",kernelFunc:Bne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gne="return float(!isnan(x) && !isinf(x));",Hne=Nt({opSnippet:Gne,dtype:"bool"}),Wne={kernelName:df,backendName:"webgl",kernelFunc:Hne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qne="return float(isinf(x));",Xne=Nt({opSnippet:qne,dtype:"bool"}),Kne={kernelName:hf,backendName:"webgl",kernelFunc:Xne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jne="return float(isnan(x));",Yne=Nt({opSnippet:jne,dtype:"bool"}),Zne={kernelName:pf,backendName:"webgl",kernelFunc:Yne};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qne="return float(a < b);",Jne=`
  return vec4(lessThan(a, b));
`,ere=Qn({opSnippet:Qne,packedOpSnippet:Jne,cpuKernelImpl:zZ,dtype:"bool"}),tre={kernelName:$p,backendName:"webgl",kernelFunc:ere};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nre="return float(a <= b);",rre=`
  return vec4(lessThanEqual(a, b));
`,ire=Qn({opSnippet:nre,packedOpSnippet:rre,cpuKernelImpl:PZ,dtype:"bool"}),sre={kernelName:Up,backendName:"webgl",kernelFunc:ire};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function are(n){const{backend:e,attrs:t}=n,{start:r,stop:i,num:s}=t,a=FZ(r,i,s);return e.makeTensorInfo([a.length],"float32",a)}const ore={kernelName:KE,backendName:"webgl",kernelFunc:are};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const cre=zl+`
  return x < 0.0 ? 0./0. : log(x);
`,lre=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,ure=Nt({opSnippet:cre,packedOpSnippet:lre,cpuKernelImpl:$Z}),fre={kernelName:mf,backendName:"webgl",kernelFunc:ure};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dre=zl+`
  return log(1.0 + x);
`,hre=Nt({opSnippet:dre}),pre={kernelName:vf,backendName:"webgl",kernelFunc:hre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mre="return float(a >= 1.0 && b >= 1.0);",vre=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,gre=Qn({opSnippet:mre,packedOpSnippet:vre,dtype:"bool"}),xre={kernelName:Bp,backendName:"webgl",kernelFunc:gre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bre="return float(!(x >= 1.0));",_re=Nt({opSnippet:bre}),yre={kernelName:Vp,backendName:"webgl",kernelFunc:_re};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wre="return float(a >= 1.0 || b >= 1.0);",Ere=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,Sre=Qn({opSnippet:wre,packedOpSnippet:Ere,dtype:"bool"}),Tre={kernelName:Gp,backendName:"webgl",kernelFunc:Sre};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Are{constructor(e,t,r,i,s){this.variableNames=["x"],this.outputShape=[];const a=t,o=e[3]-1;this.outputShape=e;let c;const l=`float(${r}) + float(${i}) * sum`;s===.5?c=`inversesqrt(${l})`:s===1?c=`1.0/(${l})`:c=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${a}; j <= ${a}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${o}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${c};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cre{constructor(e,t,r,i,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const a=t,o=e[3]-1;this.outputShape=e;let c;const l=`float(${r}) + float(${i}) * sum`;s===.5?c=`inversesqrt(${l})`:s===1?c=`1.0/(${l})`:c=`exp(log(${l}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${a};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${a}; j <= ${a}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${o}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${c};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ire=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{depthRadius:s,bias:a,alpha:o,beta:c}=r,l=ie().getBool("WEBGL_PACK_NORMALIZATION")?new Cre(i.shape,s,a,o,c):new Are(i.shape,s,a,o,c);return t.runWebGLProgram(l,[i],i.dtype)},Mre={kernelName:Hp,backendName:"webgl",kernelFunc:Ire};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Rre{constructor(e,t,r,i,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=r,this.alpha=i,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${t})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${t} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${s})
                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nre=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i,y:s,dy:a}=e,{depthRadius:o,bias:c,alpha:l,beta:u}=r,f=new Rre(i.shape,o,c,l,u);return t.runWebGLProgram(f,[i,s,a],i.dtype)},kre={kernelName:J0,backendName:"webgl",kernelFunc:Nre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dre(n,e,t,r){const i=ue(e),a=ue(n.shape)/i,o=Ae({inputs:{x:n},attrs:{shape:[a,i]},backend:r}),c=Jo(o,n.dtype,"max",r),l=Ae({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(c),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vM(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reductionIndices:s,keepDims:a}=r,o=i.shape.length,c=St(s,i.shape);let l=c;const u=pn(l,o),f=u!=null,d=t.shouldExecuteOnCPU([i]);let h=i;if(f){if(d){const b=t.texData.get(h.dataId).values,_=new Array(o);for(let S=0;S<_.length;S++)_[S]=i.shape[u[S]];const w=ly(b,i.shape,i.dtype,u,_);h=t.makeTensorInfo(_,i.dtype);const E=t.texData.get(h.dataId);E.values=w}else h=Gm(i,u,t);l=yn(l.length,o)}Zn("max",l,o);const[p,g]=Wn(h.shape,l);let m=p;a&&(m=Cn(p,c));let v;if(d){const b=t.texData.get(h.dataId).values,_=UZ(b,ue(g),m,i.dtype);v=t.makeTensorInfo(m,i.dtype);const w=t.texData.get(v.dataId);w.values=_}else v=Dre(h,g,m,t);return f&&t.disposeIntermediateTensorInfo(h),v}const Lre={kernelName:Wp,backendName:"webgl",kernelFunc:vM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ore=uy+`
  return max(a, b);
`,zre=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qo+`
  return result;
`,Pre=Qn({opSnippet:Ore,packedOpSnippet:zre,cpuKernelImpl:BZ}),Fre={kernelName:gf,backendName:"webgl",kernelFunc:Pre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $re(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;od(i,"maxPool");const{filterSize:s,strides:a,pad:o,dimRoundingMode:c}=r,l=1;R(or(a,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${a} and dilations '${l}'`);const u=Ii(i.shape,s,a,l,o,c);if(u.filterWidth===1&&u.filterHeight===1&&Pt(u.inShape,u.outShape))return qr({inputs:{x:i},backend:t});const f=new Ou(u,"max",!1);return t.runWebGLProgram(f,[i],i.dtype)}const Ure={kernelName:qp,backendName:"webgl",kernelFunc:$re};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bre(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{filterSize:s,strides:a,pad:o,dataFormat:c,dimRoundingMode:l}=r,u=[1,1,1],f=ta(i.shape,s,a,u,o,l,c),d=new dy(f,"max",!1);return t.runWebGLProgram(d,[i],i.dtype)}const Vre={kernelName:Xp,backendName:"webgl",kernelFunc:Bre};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gre{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,r=e.strideWidth,i=e.dilationHeight,s=e.effectiveFilterHeight,a=e.effectiveFilterWidth,o=s-1-e.padInfo.top,c=a-1-e.padInfo.left,l=s*a-1;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${c});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${t}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${a}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${l} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${a} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class Hre{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,r=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,a=e.dilationHeight,o=e.dilationWidth,c=e.effectiveFilterDepth,l=e.effectiveFilterHeight,u=e.effectiveFilterWidth,f=c-1-e.padInfo.front,d=l-1-e.padInfo.top,h=u-1-e.padInfo.left,p=c*l*u-1;this.userCode=`
      const ivec3 pads = ivec3(${f}, ${d}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${c};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${t}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${l};
              wR += ${a}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${o}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${l} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wre(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s}=e,a=s,{filterSize:o,strides:c,pad:l,dimRoundingMode:u}=r,f=[1,1,1],d=ta(a.shape,o,c,f,l,u),h=new dy(d,"max",!0),p=t.runWebGLProgram(h,[a],a.dtype),g=new Hre(d),m=t.runWebGLProgram(g,[i,p],a.dtype);return t.disposeIntermediateTensorInfo(p),m}const qre={kernelName:tb,backendName:"webgl",kernelFunc:Wre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xre(n){const{inputs:e,backend:t,attrs:r}=n,{dy:i,input:s,output:a}=e,o=s;od([s,a],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:f}=r,d=Ii(o.shape,c,l,1,u,f),h=!0,p=new Ou(d,"max",h),g=t.runWebGLProgram(p,[o],o.dtype),m=new Gre(d),v=t.runWebGLProgram(m,[i,g],o.dtype);return t.disposeIntermediateTensorInfo(g),v}const Kre={kernelName:eb,backendName:"webgl",kernelFunc:Xre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jre(n,e,t,r){let i=new Ou(t,"max",!1);const s=r.runWebGLProgram(i,[n],"float32");i=new Ou(t,"max",!0,!0,e);const a=r.runWebGLProgram(i,[n],"float32");return[s,a]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Yre={kernelName:jE,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{filterSize:i,strides:s,pad:a,includeBatchInIndex:o}=e,c=t;R(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const l=[1,1];R(or(s,l),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${l}'`);const u=Ii(r.shape,i,s,l,a),[f,d]=jre(r,o,u,c);return[f,d]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zre(n,e,t,r){const i=ue(e),a=ue(n.shape)/i,o=Ae({inputs:{x:n},attrs:{shape:[a,i]},backend:r}),c=Jo(o,"float32","mean",r),l=Ae({inputs:{x:c},attrs:{shape:t},backend:r});return r.disposeIntermediateTensorInfo(o),r.disposeIntermediateTensorInfo(c),l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qre={kernelName:Kp,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{x:r}=n,{keepDims:i,axis:s}=e,a=t,o=r.shape.length,c=St(s,r.shape);let l=c;const u=pn(l,o),f=u!=null,d=a.shouldExecuteOnCPU([r]),h=[];let p=r;if(f){if(d){const _=a.texData.get(p.dataId).values,w=new Array(o);for(let T=0;T<w.length;T++)w[T]=r.shape[u[T]];const E=ly(_,r.shape,r.dtype,u,w);p=a.makeTensorInfo(w,r.dtype);const S=a.texData.get(p.dataId);S.values=E}else p=Gm(r,u,a);h.push(p),l=yn(l.length,o)}Zn("sum",l,o);const[g,m]=Wn(p.shape,l);let v=g;i&&(v=Cn(g,c));const x=Zre(p,m,v,a);for(const b of h)a.disposeIntermediateTensorInfo(b);return x}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jre(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,c=St(s,i.shape);let l=c;const u=pn(l,o);let f=i;u!=null&&(f=xr({inputs:{x:i},backend:t,attrs:{perm:u}}),l=yn(l.length,i.shape.length)),Zn("min",l,o);const[d,h]=Wn(f.shape,l),p=ue(h),g=Ae({inputs:{x:f},backend:t,attrs:{shape:[-1,p]}}),m=Jo(g,g.dtype,"min",t);let v;if(a){const x=Cn(d,c);v=Ae({inputs:{x:m},backend:t,attrs:{shape:x}})}else v=Ae({inputs:{x:m},backend:t,attrs:{shape:d}});return t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(m),u!=null&&t.disposeIntermediateTensorInfo(f),v}const eie={kernelName:jp,backendName:"webgl",kernelFunc:Jre};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tie=uy+`
  return min(a, b);
`,nie=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+Qo+`
  return result;
`,rie=Qn({opSnippet:tie,packedOpSnippet:nie,cpuKernelImpl:VZ}),iie={kernelName:xf,backendName:"webgl",kernelFunc:rie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class sie{constructor(e,t,r){this.variableNames=["x"],this.outputShape=t.map((u,f)=>u[0]+e[f]+u[1]);const i=e.length,s=jt(i),a=t.map(u=>u[0]).join(","),o=t.map((u,f)=>u[0]+e[f]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),l=r==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${l};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${l};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${o});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${l};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${l};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${c}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aie{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map((p,g)=>p[0]+e[g]+p[1]);const i=e.length,s=jt(i),a=t.map(p=>p[0]).join(","),o=t.map((p,g)=>p[0]+e[g]).join(","),c=vr("rc",i),l=vr("source",i),u=`${c[i-1]} < ${this.outputShape[i-1]}`,f=i===1?"source":`vec2(${l.slice(-2).join()})`,d=r==="reflect"?0:1;let h="";if(i===1){const p=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${d};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${d};
        }
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${f});
        ${c[i-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${f});
        }
      `}else{const p=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${d}) +
                gte * ((end - 1) * 2 - source + ${d});
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${l.join()}), ${f});
        ${c[i-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${l.join()}), ${f});
        }
        rc = outputLoc;
        ${c[i-2]} += 1;
        if(${c[i-2]} < ${this.outputShape[i-2]}) {
          ${p}
          result[2] = getChannel(getX(${l.join()}), ${f});
          ${c[i-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${l.join()}), ${f});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${o});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oie=({inputs:n,backend:e,attrs:t})=>{const{x:r}=n,{paddings:i,mode:s}=t,a=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new aie(r.shape,i,s):new sie(r.shape,i,s);return e.runWebGLProgram(a,[r],r.dtype)},cie={kernelName:Yp,backendName:"webgl",kernelFunc:oie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lie=`if (b == 0.0) return NAN;
  return mod(a, b);`,uie=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+Qo+`
  return result;
`,fie=Qn({opSnippet:lie,packedOpSnippet:uie}),die={kernelName:bf,backendName:"webgl",kernelFunc:fie};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hie{constructor(e,t,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${t-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${t-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pie=`
if (a == b) {
  return 1.0;
};
return a / b;`,mie=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,gM=Qn({opSnippet:pie,packedOpSnippet:mie,checkOutOfBounds:!0}),vie={kernelName:nf,backendName:"webgl",kernelFunc:gM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pw="return a - b;",xM=Qn({opSnippet:Pw,packedOpSnippet:Pw,supportsComplex:!0,cpuKernelImpl:lQ}),gie={kernelName:Of,backendName:"webgl",kernelFunc:xM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bM(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{dim:s}=r,a=St([s],i.shape),o=vM({inputs:{x:i},backend:t,attrs:{reductionIndices:a,keepDims:!1}}),c=Cn(o.shape,a),l=Ae({inputs:{x:o},backend:t,attrs:{shape:c}}),u=xM({inputs:{a:i,b:l},backend:t}),f=hM({inputs:{x:u},backend:t}),d=Hm({inputs:{x:f},backend:t,attrs:{axis:a,keepDims:!1}}),h=Ae({inputs:{x:d},backend:t,attrs:{shape:c}}),p=gM({inputs:{a:f,b:h},backend:t});return t.disposeIntermediateTensorInfo(o),t.disposeIntermediateTensorInfo(l),t.disposeIntermediateTensorInfo(u),t.disposeIntermediateTensorInfo(f),t.disposeIntermediateTensorInfo(d),t.disposeIntermediateTensorInfo(h),p}const xie={kernelName:pm,backendName:"webgl",kernelFunc:bM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bie(n){const{inputs:e,backend:t,attrs:r}=n,{logits:i}=e,{numSamples:s,seed:a,normalized:o}=r,c=o?i:bM({inputs:{logits:i},backend:t,attrs:{dim:i.shape.length-1}}),l=c.shape[0],u=c.shape[1],f=new hie(l,u,s),d=[[a]],h=t.runWebGLProgram(f,[c],"int32",d);return o||t.disposeIntermediateTensorInfo(c),h}const _ie={kernelName:YE,backendName:"webgl",kernelFunc:bie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yie=Ri+`
  return -x;
`,wie=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function Eie(n){const{inputs:e,backend:t}=n,{x:r}=e;if(t.shouldExecuteOnCPU([r])){const s=t.texData.get(r.dataId),[a,o]=HZ(s.values,r.shape,r.dtype);return t.makeTensorInfo(o,r.dtype,a)}let i;return ie().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new wa(r.shape,wie):i=new os(r.shape,yie),t.runWebGLProgram(i,[r],r.dtype)}const Sie={kernelName:Zp,backendName:"webgl",kernelFunc:Eie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tie=Qb;function Aie(n){Qr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:c}=r,l=t.readSync(i.dataId),u=t.readSync(s.dataId),{selectedIndices:f}=Tie(l,u,a,o,c);return t.makeTensorInfo([f.length],"int32",new Int32Array(f))}const Cie={kernelName:nb,backendName:"webgl",kernelFunc:Aie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iie=Jb;function Mie(n){Qr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:c,padToMaxOutputSize:l}=r,u=t.readSync(i.dataId),f=t.readSync(s.dataId),{selectedIndices:d,validOutputs:h}=Iie(u,f,a,o,c,l);return[t.makeTensorInfo([d.length],"int32",new Int32Array(d)),t.makeTensorInfo([],"int32",new Int32Array([h]))]}const Rie={kernelName:rb,backendName:"webgl",kernelFunc:Mie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nie=e_;function kie(n){Qr("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:t,attrs:r}=n,{boxes:i,scores:s}=e,{maxOutputSize:a,iouThreshold:o,scoreThreshold:c,softNmsSigma:l}=r,u=t.readSync(i.dataId),f=t.readSync(s.dataId),d=a,h=o,p=c,g=l,{selectedIndices:m,selectedScores:v}=Nie(u,f,d,h,p,g);return[t.makeTensorInfo([m.length],"int32",new Int32Array(m)),t.makeTensorInfo([v.length],"float32",new Float32Array(v))]}const Die={kernelName:ib,backendName:"webgl",kernelFunc:kie};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Lie{constructor(e,t,r,i){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Oie=n=>{const{inputs:e,backend:t,attrs:r}=n,{indices:i}=e,{dtype:s,depth:a,onValue:o,offValue:c}=r,l=ue(i.shape),u=new Lie(l,a,o,c),f=Ae({inputs:{x:i},backend:t,attrs:{shape:[l]}}),d=t.runWebGLProgram(u,[f],s);t.disposeIntermediateTensorInfo(f);const h=[...i.shape,a],p=Ae({inputs:{x:d},backend:t,attrs:{shape:h}});return t.disposeIntermediateTensorInfo(d),p},zie={kernelName:em,backendName:"webgl",kernelFunc:Oie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ip(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="complex64"){const i=ld({inputs:{input:r},backend:t}),s=ip({inputs:{x:i},backend:t}),a=Wm({inputs:{input:r},backend:t}),o=ip({inputs:{x:a},backend:t}),c=Ka({inputs:{real:s,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),c}else return ud({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:t})}const Pie={kernelName:gm,backendName:"webgl",kernelFunc:ip};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _M(n){const{inputs:e,backend:t}=n,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const i=ld({inputs:{input:r},backend:t}),s=_M({inputs:{x:i},backend:t}),a=Wm({inputs:{input:r},backend:t}),o=ip({inputs:{x:a},backend:t}),c=Ka({inputs:{real:s,imag:o},backend:t});return t.disposeIntermediateTensorInfo(i),t.disposeIntermediateTensorInfo(s),t.disposeIntermediateTensorInfo(a),t.disposeIntermediateTensorInfo(o),c}else return ud({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:t})}const Fie={kernelName:Jp,backendName:"webgl",kernelFunc:_M};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ie(n){const{inputs:e,backend:t,attrs:r}=n,{axis:i}=r;if(e.length===1)return zx({inputs:{input:e[0]},backend:t,attrs:{dim:i}});const s=e[0].shape,a=e[0].dtype;e.forEach(u=>{S0(s,u.shape,"All tensors passed to stack must have matching shapes"),R(a===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const o=[],c=e.map(u=>{const f=zx({inputs:{input:u},backend:t,attrs:{dim:i}});return o.push(f),f}),l=sM({inputs:c,backend:t,attrs:{axis:i}});return o.forEach(u=>t.disposeIntermediateTensorInfo(u)),l}const Uie={kernelName:tm,backendName:"webgl",kernelFunc:$ie};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Bie{constructor(e,t,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((l,u)=>l[0]+e[u]+l[1]);const i=e.length,s=jt(i),a=t.map(l=>l[0]).join(","),o=t.map((l,u)=>l[0]+e[u]).join(","),c=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${a};
        int end = ${o};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${a});
      ${s} end = ${s}(${o});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${c}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Vie{constructor(e,t,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map((g,m)=>g[0]+e[m]+g[1]);const i=e.length,s=jt(i),a=t.map(g=>g[0]).join(","),o=t.map((g,m)=>g[0]+e[m]).join(","),c=vr("rc",i),l=vr("source",i),u=`${c[i-1]} < ${this.outputShape[i-1]}`,f=i===1?"source":`vec2(${l.slice(-2).join()})`,d=[`${s} rc = outputLoc;`,`${c[i-1]} += 1;
       if(${u}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${c[i-2]} += 1;
       if(${c[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${c[i-1]} += 1;
         if(${u}) {`],h=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let g=0,m=i===1?2:4;g<m;g++)p+=`
        ${d[g]}
        if (${h}) {
          result[${g}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${g}] = getChannel(getX(${l.join()}), ${f});
        }
      `;p+=i===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${a});
      const ${s} end = ${s}(${o});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yM=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{paddings:s,constantValue:a}=r;if(ue(i.shape)===0){const l=s.map((u,f)=>u[0]+i.shape[f]+u[1]);return ud({backend:t,attrs:{shape:l,value:a,dtype:i.dtype}})}const o=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Vie(i.shape,s,a):new Bie(i.shape,s,a),c=[[a]];return t.runWebGLProgram(o,[i],i.dtype,c)},Gie={kernelName:nm,backendName:"webgl",kernelFunc:yM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hie=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,Wie=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+Qo+`
  return result;
`,qie=Qn({opSnippet:Hie,packedOpSnippet:Wie}),Xie={kernelName:yf,backendName:"webgl",kernelFunc:qie};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kie(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{axis:s,keepDims:a}=r,o=i.shape.length,c=[],l=St(s,i.shape);let u=l;const f=pn(u,o);let d=i;f!=null&&(d=xr({inputs:{x:i},backend:t,attrs:{perm:f}}),u=yn(u.length,o),c.push(d)),Zn("prod",u,o);let h;if(t.shouldExecuteOnCPU([d])){const p=t.texData.get(d.dataId).values,{outVals:g,outShape:m,outDtype:v}=qZ(d.shape,d.dtype,p,u);h=t.makeTensorInfo(m,v,g)}else{const[p,g]=Wn(d.shape,u),m=ue(g),v=Ae({inputs:{x:d},backend:t,attrs:{shape:[-1,m]}}),x=gb(i.dtype),b=Jo(v,x,"prod",t);h=Ae({inputs:{x:b},backend:t,attrs:{shape:p}}),c.push(v),c.push(b)}if(a){c.push(h);const p=Cn(h.shape,l);h=Ae({inputs:{x:h},backend:t,attrs:{shape:p}})}return c.forEach(p=>t.disposeIntermediateTensorInfo(p)),h}const jie={kernelName:im,backendName:"webgl",kernelFunc:Kie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yie(n){const{inputs:e,backend:t,attrs:r}=n,{paramsNestedSplits:i,paramsDenseValues:s,indices:a}=e,{outputRaggedRank:o}=r,c=i.map(v=>t.readSync(v.dataId)),l=i.map(v=>v.shape),u=t.readSync(s.dataId),f=t.readSync(a.dataId),[d,h,p]=XZ(c,l,u,s.shape,s.dtype,f,a.shape,o),g=d.map(v=>t.makeTensorInfo([v.length],"int32",v)),m=t.makeTensorInfo(p,s.dtype,h);return g.concat([m])}const Zie={kernelName:ZE,backendName:"webgl",kernelFunc:Yie};/**
 * @license
 * Copyright 2022 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qie(n){const{inputs:e,backend:t}=n,{starts:r,limits:i,deltas:s}=e,a=t.readSync(r.dataId),o=t.readSync(i.dataId),c=t.readSync(s.dataId),[l,u]=KZ(a,r.shape,r.dtype,o,i.shape,c,s.shape),f=t.makeTensorInfo([l.length],"int32",l),d=t.makeTensorInfo([u.length],r.dtype,u);return[f,d]}const Jie={kernelName:QE,backendName:"webgl",kernelFunc:Qie};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ese(n){const{inputs:e,backend:t,attrs:r}=n,{shape:i,values:s,defaultValue:a,rowPartitionTensors:o}=e,{rowPartitionTypes:c}=r,l=t.readSync(i.dataId),u=t.readSync(s.dataId),f=t.readSync(a.dataId),d=o.map(m=>t.readSync(m.dataId)),h=o.map(m=>m.shape),[p,g]=jZ(l,i.shape,u,s.shape,s.dtype,f,a.shape,d,h,c);return t.makeTensorInfo(p,s.dtype,g)}const tse={kernelName:JE,backendName:"webgl",kernelFunc:ese};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wM=n=>{const{backend:e,attrs:t}=n,{start:r,stop:i,step:s,dtype:a}=t,o=YZ(r,i,s,a);return e.makeTensorInfo([o.length],a,o)},nse={kernelName:sb,backendName:"webgl",kernelFunc:wM};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rse="return 1.0 / x;",ise=Nt({opSnippet:rse}),sse={kernelName:wf,backendName:"webgl",kernelFunc:ise};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ase=Ri+`
  return (x < 0.0) ? 0.0 : x;
`,ose=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cse=Nt({opSnippet:ase,packedOpSnippet:ose}),lse={kernelName:Ef,backendName:"webgl",kernelFunc:cse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const use=Ri+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,fse=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,dse=Nt({opSnippet:use,packedOpSnippet:fse}),hse={kernelName:Sf,backendName:"webgl",kernelFunc:dse};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pse{constructor(e,t,r,i,s){this.variableNames=["A"],this.outputShape=[];const[a,o,c,l]=e;this.outputShape=[a,t,r,l];const u=[i&&t>1?o-1:o,i&&r>1?c-1:c],f=[i&&t>1?t-1:t,i&&r>1?r-1:r];let d;s?d="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":d="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/f[0]},
          ${u[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mse{constructor(e,t,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,c,l]=e;this.outputShape=[a,t,r,l];const u=[i&&t>1?o-1:o,i&&r>1?c-1:c],f=[i&&t>1?t-1:t,i&&r>1?r-1:r];let d;s?d="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":d="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/f[0]},
          ${u[1]/f[1]},
          ${u[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${d};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vse(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r,[c,l]=o,u=ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new mse(i.shape,c,l,s,a):new pse(i.shape,c,l,s,a);return t.runWebGLProgram(u,[i],"float32")}const gse={kernelName:om,backendName:"webgl",kernelFunc:vse};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xse{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,s]=t,[,a,o]=e,c=[r&&a>1?i-1:i,r&&o>1?s-1:s],l=[r&&a>1?a-1:a,r&&o>1?o-1:o],u=c[0]/l[0],f=c[1]/l[1],d=1/u,h=1/f,p=Math.ceil(d)*2+2,g=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${f});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bse(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:a}=r,o=new xse(s.shape,i.shape,a);return t.runWebGLProgram(o,[s],s.dtype)}const _se={kernelName:cb,backendName:"webgl",kernelFunc:bse};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yse{constructor(e,t,r,i,s){this.variableNames=["A"],this.outputShape=[];const[a,o,c,l]=e;this.outputShape=[a,t,r,l];const u=[i&&t>1?o-1:o,i&&r>1?c-1:c],f=[i&&t>1?t-1:t,i&&r>1?r-1:r],d=i?"0.5":"0.0";let h;s?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/f[0]},
          ${u[1]/f[1]});
      const vec2 inputShapeRC = vec2(${o}.0, ${c}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wse{constructor(e,t,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[a,o,c,l]=e;this.outputShape=[a,t,r,l];const u=[i&&t>1?o-1:o,i&&r>1?c-1:c],f=[i&&t>1?t-1:t,i&&r>1?r-1:r],d=i?"0.5":"0.0";let h;s?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/f[0]},
          ${u[1]/f[1]},
          ${u[1]/f[1]});
      const vec3 inputShapeRC = vec3(${o}.0, ${c}.0,
                                     ${c}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${d})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${l-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ese(n){const{inputs:e,backend:t,attrs:r}=n,{images:i}=e,{alignCorners:s,halfPixelCenters:a,size:o}=r,[c,l]=o,u=ie().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new wse(i.shape,c,l,s,a):new yse(i.shape,c,l,s,a);return t.runWebGLProgram(u,[i],i.dtype)}const Sse={kernelName:am,backendName:"webgl",kernelFunc:Ese};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Tse{constructor(e,t,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,i,s]=t,[,a,o]=e,c=[r&&a>1?i-1:i,r&&o>1?s-1:s],l=[r&&a>1?a-1:a,r&&o>1?o-1:o],u=c[0]/l[0],f=c[1]/l[1],d=1/u,h=1/f,p=Math.ceil(d)*2+2,g=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${f});

        const float invHeightScale = float(${d});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${g});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${a}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${o}) {
              continue;
            }

            float sourceFracRow =
              float(${c[0]}) *
                (float(dyR) / float(${l[0]}));

            float sourceFracCol =
                float(${c[1]}) *
                  (float(dyC) / float(${l[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ase(n){const{inputs:e,backend:t,attrs:r}=n,{images:i,dy:s}=e,{alignCorners:a}=r,o=new Tse(s.shape,i.shape,a);return t.runWebGLProgram(o,[s],s.dtype)}const Cse={kernelName:ob,backendName:"webgl",kernelFunc:Ase};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Ise{constructor(e,t){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=o=>t.indexOf(o)!==-1&&e[o]!==1?`${e[o]} - coords[${o}] - 1`:`coords[${o}]`,s=e.map((o,c)=>i(c)).join(","),a=jt(r);this.userCode=`
      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mse{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const i=vr("rc",r),s=`${i[r-1]} + 1 < ${this.outputShape[r-1]}`,a=`${i[r-2]} + 1 < ${this.outputShape[r-2]}`,o=jt(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${o} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${c(i.slice())};
          if(${s}){
            result.g = ${l(i.slice())};
          }
          if(${a}) {
            result.b = ${u(i.slice())};
            if(${s}) {
              result.a = ${f(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function c(p){return d(p)}function l(p){return p[r-1]="("+p[r-1]+" + 1)",d(p)}function u(p){return p[r-2]="("+p[r-2]+" + 1)",d(p)}function f(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",d(p)}function d(p){const g=e.map((x,b)=>h(b,p)),m=g.join(","),v=g.slice(-2).join(",");return`getChannel(getX(${m}), vec2(${v}))`}function h(p,g){return t.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${g[p]} - 1`:`${g[p]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rse(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{dims:s}=r,a=i.shape.length,o=St(s,i.shape);if(a===0)return qr({inputs:{x:i},backend:t});const c=ie().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Mse(i.shape,o):new Ise(i.shape,o);return t.runWebGLProgram(c,[i],i.dtype)}const Nse={kernelName:cm,backendName:"webgl",kernelFunc:Rse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kse{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],i=e[2];this.outputShape=e;let s="";typeof t=="number"?s=`float outputValue = ${t.toFixed(2)};`:s=`
        vec3 fill = vec3(${t.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dse={kernelName:mb,backendName:"webgl",kernelFunc:({inputs:n,attrs:e,backend:t})=>{const{image:r}=n,{radians:i,fillValue:s,center:a}=e,o=t,c=new kse(r.shape,s),[l,u]=f_(a,r.shape[1],r.shape[2]),f=[[l,u,Math.sin(i),Math.cos(i)]];return o.runWebGLProgram(c,[r],r.dtype,f)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lse=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Ose=Nt({opSnippet:Lse}),zse={kernelName:Tf,backendName:"webgl",kernelFunc:Ose};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pse="return inversesqrt(x);",Fse=Nt({opSnippet:Pse,cpuKernelImpl:ZZ}),$se={kernelName:Af,backendName:"webgl",kernelFunc:Fse};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class hy{constructor(e,t,r,i,s,a,o=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.outputShape=a;const l=jt(s.length),u=jt(a.length);let f="";r===1?f="i":r===2&&(f="i, j");const d=`getIndices(${f})`;let h="";i===1?h="i":i===2&&(h="i, coords[1]");const p=`getUpdates(${h})`;let g="";c&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,v=t>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${t}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${v};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${p};
              found = true;
            }
          }
          setOutput(mix(${m}, sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Use{constructor(e,t,r,i,s,a,o=!0,c=!1){this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=a;const l=jt(s.length),u=jt(a.length);let f="";r===1?f="i":r===2&&(f="i, j");const d=`getIndices(${f})`;let h="";i===1?h="i":i===2&&(h="i, coords[1]");const p=`getUpdates(${h})`;let g="";c&&(g="coords[0], coords[1]");const m=`getDefaultValue(${g})`,v=t>1?"strides[j]":"strides",x=t>1?"strides[j + 1]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${u} coords = getOutputCoords();
          vec4 sum = vec4(0.);
          vec4 found = vec4(0.);
          for (int i = 0; i < ${e}; i+=2) {
            ivec2 flattenedIndex = ivec2(0);
            for (int j = 0; j < ${t}; j+=2) {
              ivec4 index = round(${d});
              flattenedIndex += index.xz * ${v};
              if (j + 1 < ${t}) {
                flattenedIndex += index.yw * ${x};
              }
            }
            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||
                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {
              vec4 updVals = ${p};
              if (flattenedIndex[0] == coords[0]) {
                sum.xy += updVals.xy;
                found.xy = vec2(1.);
              } else if (flattenedIndex[0] == coords[0] + 1) {
                sum.zw += updVals.xy;
                found.zw = vec2(1.);
              }
              if (flattenedIndex[1] == coords[0]) {
                sum.xy += updVals.zw;
                found.xy = vec2(1.);
              } else if (flattenedIndex[1] == coords[0] + 1) {
                sum.zw += updVals.zw;
                found.zw = vec2(1.);
              }
            }
          }
          setOutput(mix(${m}, sum, found));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bse(n){const{inputs:e,backend:t,attrs:r}=n,{indices:i,updates:s}=e,{shape:a}=r,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:f}=Xo(s,i,a),d=[f/l,l];if(f===0)return t.makeTensorInfo(a,i.dtype);const h=Ae({inputs:{x:i},backend:t,attrs:{shape:[c,o]}}),p=Ae({inputs:{x:s},backend:t,attrs:{shape:[c,l]}}),g=t.makeTensorInfo([],"float32",new Float32Array([0]));let m;ie().getBool("WEBGL_PACK")?m=new Use(c,o,h.shape.length,p.shape.length,u,d):m=new hy(c,o,h.shape.length,p.shape.length,u,d);const v=t.runWebGLProgram(m,[p,h,g],p.dtype),x=Ae({inputs:{x:v},backend:t,attrs:{shape:a}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(v),t.disposeIntermediateTensorInfo(g),x}const Vse={kernelName:e3,backendName:"webgl",kernelFunc:Bse};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gse{constructor(e,t,r,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const s="while (left < right) {",a=`for (int i = 0; i < ${Math.ceil(Math.log2(t+1))}; ++i) { if (left >= right) break;`,o=ie().getNumber("WEBGL_VERSION")===2?s:a,c=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${o}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${c} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hse(n){const{inputs:e,backend:t,attrs:r}=n,{sortedSequence:i,values:s}=e,{side:a}=r,o=new Gse(i.shape[0],i.shape[1],s.shape[1],a),c=[[i.shape[1]]];return t.runWebGLProgram(o,[i,s],"int32",c)}const Wse={kernelName:n3,backendName:"webgl",kernelFunc:Hse};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qse{constructor(e,t,r){this.variableNames=["c","a","b"],this.outputShape=t;let i,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",i="resRC";else{const o=["resRC.x","resRC.y","resRC.z","resRC.w"],c=[],l=[];for(let u=0;u<t.length;u++)l.push(`${o[u]}`),u<e&&c.push(`${o[u]}`);i=c.join(),s=l.join()}const a=jt(r);this.userCode=`
      void main() {
        ${a} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xse(n){const{inputs:e,backend:t}=n,{condition:r,t:i,e:s}=e,a=new qse(r.shape.length,i.shape,i.shape.length);return t.runWebGLProgram(a,[r,i,s],Hr(i.dtype,s.dtype))}const Kse={kernelName:lm,backendName:"webgl",kernelFunc:Xse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jse=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${Cm};
  float scale = ${Im};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,Yse=Nt({opSnippet:jse}),Zse={kernelName:Cf,backendName:"webgl",kernelFunc:Yse};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qse=zl+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,Jse=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,eae=Nt({opSnippet:Qse,packedOpSnippet:Jse,cpuKernelImpl:JZ}),tae={kernelName:Nf,backendName:"webgl",kernelFunc:eae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nae=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,rae=Nt({opSnippet:nae}),iae={kernelName:Rf,backendName:"webgl",kernelFunc:rae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sae=zl+`
  return sin(x);
`,aae=`
  vec4 result = sin(x);
  bvec4 isNaN = isnan(x);
  ${Qo}
  return result;
`,oae=Nt({opSnippet:sae,packedOpSnippet:aae}),cae={kernelName:If,backendName:"webgl",kernelFunc:oae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lae=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,uae=Nt({opSnippet:lae}),fae={kernelName:Mf,backendName:"webgl",kernelFunc:uae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dae=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,hae=Nt({opSnippet:dae}),pae={kernelName:kf,backendName:"webgl",kernelFunc:hae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mae=n=>{const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{blockShape:s,paddings:a}=r;R(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const o=s.reduce((v,x)=>v*x),c=[[0,0]];c.push(...a);for(let v=1+s.length;v<i.shape.length;++v)c.push([0,0]);const l=[],u=yM({inputs:{x:i},backend:t,attrs:{paddings:c,constantValue:0}}),f=Kf(u.shape,s,o,!1),d=jf(f.length,s.length,!1),h=Yf(u.shape,s,o,!1),p=Ae({inputs:{x:u},backend:t,attrs:{shape:f}}),g=xr({inputs:{x:p},backend:t,attrs:{perm:d}}),m=Ae({inputs:{x:g},backend:t,attrs:{shape:h}});return l.push(u),l.push(p),l.push(g),l.forEach(v=>t.disposeIntermediateTensorInfo(v)),m},vae={kernelName:dm,backendName:"webgl",kernelFunc:mae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gae(n){const{inputs:e,backend:t}=n,{indices:r,values:i,denseShape:s,defaultValue:a}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(a.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${a.shape}`);const o=t.readSync(r.dataId),c=t.readSync(i.dataId),l=t.readSync(s.dataId),u=t.readSync(a.dataId)[0],[f,d,h,p,g]=tQ(o,r.shape,r.dtype,c,i.dtype,l,u);return[t.makeTensorInfo(d,r.dtype,f),t.makeTensorInfo([d[0]],i.dtype,h),t.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(m=>Number(m)))),t.makeTensorInfo([g.length],r.dtype,new Int32Array(g))]}const xae={kernelName:r3,backendName:"webgl",kernelFunc:gae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bae(n){const{inputs:e,backend:t}=n,{inputIndices:r,inputShape:i,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const a=Array.from(t.readSync(i.dataId)),o=t.readSync(r.dataId),c=Array.from(t.readSync(s.dataId)),[l,u,f]=nQ(o,r.shape,r.dtype,a,c);return[t.makeTensorInfo(u,r.dtype,l),t.makeTensorInfo([f.length],s.dtype,new Int32Array(f))]}const _ae={kernelName:i3,backendName:"webgl",kernelFunc:bae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yae(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);const a=t.readSync(r.dataId),o=t.readSync(i.dataId),c=t.readSync(s.dataId),[l,u]=qI(a,r.shape,r.dtype,o,c,!0);return t.makeTensorInfo(u,r.dtype,l)}const wae={kernelName:s3,backendName:"webgl",kernelFunc:yae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eae(n){const{inputs:e,backend:t}=n,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);const a=t.readSync(r.dataId),o=t.readSync(i.dataId),c=t.readSync(s.dataId),[l,u]=qI(a,r.shape,r.dtype,o,c);return t.makeTensorInfo(u,r.dtype,l)}const Sae={kernelName:a3,backendName:"webgl",kernelFunc:Eae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tae(n){const{inputs:e,backend:t,attrs:r}=n,{sparseIndices:i,sparseValues:s,defaultValue:a}=e,{outputShape:o}=r,{sliceRank:c,numUpdates:l,sliceSize:u,strides:f,outputSize:d}=Xo(s,i,o),h=!1;if(s.dtype==="string"){const v=t.bufferSync(i),x=t.bufferSync(s),b=Na(t.readSync(a.dataId)[0]),_=QZ(v,x,o,d,u,l,c,f,b,h);return t.makeTensorInfo(o,_.dtype,_.values)}const p=new hy(l,c,i.shape.length,s.shape.length,f,[d,1],h),g=t.runWebGLProgram(p,[s,i,a],s.dtype),m=Ae({inputs:{x:g},backend:t,attrs:{shape:o}});return t.disposeIntermediateTensorInfo(g),m}const Aae={kernelName:o3,backendName:"webgl",kernelFunc:Tae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cae(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{numOrSizeSplits:s,axis:a}=r,o=St(a,i.shape)[0],c=A_(i,s,o),l=i.shape.length,u=new Array(l).fill(0),f=i.shape.slice();return c.map(d=>{const h=[...f];h[o]=d;const p=Pl({inputs:{x:i},backend:t,attrs:{begin:u,size:h}});return u[o]+=d,p})}const Iae={kernelName:hm,backendName:"webgl",kernelFunc:Cae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fw="return sqrt(x);",Mae=Nt({opSnippet:Fw,packedOpSnippet:Fw,cpuKernelImpl:rQ}),Rae={kernelName:Df,backendName:"webgl",kernelFunc:Mae};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Nae="return x * x;",kae=Nt({opSnippet:Nae}),Dae={kernelName:lb,backendName:"webgl",kernelFunc:kae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $w="return (a - b) * (a - b);",Lae=Qn({opSnippet:$w,packedOpSnippet:$w}),Oae={kernelName:Lf,backendName:"webgl",kernelFunc:Lae};/**
 * @license
 * Copyright 2023 Google LLC.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zae(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e;if(i.dtype!=="string")throw new Error("Input must be of datatype string");const s=t.readSync(i.dataId),a=Ys(s),o=iQ(a,"string",r);return t.makeTensorInfo(i.shape,"string",o)}const Pae={kernelName:ub,backendName:"webgl",kernelFunc:zae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fae({inputs:n,attrs:e,backend:t}){const{x:r}=n,i=Ri+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new os(r.shape,i);return t.runWebGLProgram(s,[r],r.dtype)}const $ae={kernelName:$f,backendName:"webgl",kernelFunc:Fae};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Uae{constructor(e,t,r){this.variableNames=["x"],this.outputShape=r;const i=r.length,s=jt(r.length),a=jt(r.length);let o="";if(i===1)o="coords * strides + begin";else{let c=0;o=r.map((l,u)=>(c++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${c-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${t});

      void main() {
        ${a} coords = getOutputCoords();
        setOutput(getX(${o}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bae(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{begin:s,end:a,strides:o,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:f,shrinkAxisMask:d}=r,{finalShapeSparse:h,finalShape:p,isIdentity:g,sliceDim0:m,isSimpleSlice:v,begin:x,end:b,strides:_}=c_(i.shape,s,a,o,c,l,u,f,d);let w;if(g)w=Ae({inputs:{x:i},backend:t,attrs:{shape:p}});else if(m||v){R(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const S=s_(x,b,_),T=Pl({inputs:{x:i},backend:t,attrs:{begin:x,size:S}});w=Ae({inputs:{x:T},backend:t,attrs:{shape:p}}),t.disposeIntermediateTensorInfo(T)}else if(t.shouldExecuteOnCPU([i])){const T=t.readSync(i.dataId),C=Et(i.shape,i.dtype,T),y=sQ(h,C,_,x);w=t.makeTensorInfo(p,i.dtype,y.values)}else{const T=new Uae(x,_,h);w=t.runWebGLProgram(T,[i],i.dtype)}const E=Ae({inputs:{x:w},backend:t,attrs:{shape:p}});return t.disposeIntermediateTensorInfo(w),E}const Vae={kernelName:fb,backendName:"webgl",kernelFunc:Bae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gae(n){const{inputs:e,backend:t,attrs:r}=n,{separator:i,nGramWidths:s,leftPad:a,rightPad:o,padWidth:c,preserveShortSequences:l}=r,{data:u,dataSplits:f}=e,d=t.readSync(u.dataId),h=t.readSync(f.dataId),[p,g]=aQ(d,h,i,s,a,o,c,l);return[t.makeTensorInfo([p.length],"string",p),t.makeTensorInfo(f.shape,"int32",g)]}const Hae={kernelName:c3,backendName:"webgl",kernelFunc:Gae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wae(n){const{inputs:e,backend:t,attrs:r}=n,{skipEmpty:i}=r,{input:s,delimiter:a}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(a.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${a.shape}`);const o=t.readSync(s.dataId),c=t.readSync(a.dataId)[0],[l,u,f]=oQ(o,c,i),d=u.length;return[t.makeTensorInfo([d,2],"int32",l),t.makeTensorInfo([d],"string",u),t.makeTensorInfo([2],"int32",new Int32Array(f))]}const qae={kernelName:l3,backendName:"webgl",kernelFunc:Wae};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xae(n){const{inputs:e,backend:t,attrs:r}=n,{numBuckets:i}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const a=t.readSync(s.dataId),o=cQ(a,i);return t.makeTensorInfo(s.shape,"int32",o)}const Kae={kernelName:u3,backendName:"webgl",kernelFunc:Xae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jae="return tan(x);",Yae=Nt({opSnippet:jae}),Zae={kernelName:zf,backendName:"webgl",kernelFunc:Yae};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qae=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,Jae=Nt({opSnippet:Qae}),eoe={kernelName:Pf,backendName:"webgl",kernelFunc:Jae};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function toe(n){const{inputs:e,backend:t,attrs:r}=n,{tensor:i,indices:s,updates:a}=e,{sliceRank:o,numUpdates:c,sliceSize:l,strides:u,outputSize:f}=Xo(a,s,i.shape),d=[f/l,l];if(f===0)return t.makeTensorInfo(i.shape,s.dtype);const h=Ae({inputs:{x:s},backend:t,attrs:{shape:[c,o]}}),p=Ae({inputs:{x:a},backend:t,attrs:{shape:[c,l]}}),g=Ae({inputs:{x:i},backend:t,attrs:{shape:d}}),m=new hy(c,o,h.shape.length,p.shape.length,u,d,!1,!0),v=t.runWebGLProgram(m,[p,h,g],g.dtype),x=Ae({inputs:{x:v},backend:t,attrs:{shape:i.shape}});return t.disposeIntermediateTensorInfo(h),t.disposeIntermediateTensorInfo(p),t.disposeIntermediateTensorInfo(g),t.disposeIntermediateTensorInfo(v),x}const noe={kernelName:t3,backendName:"webgl",kernelFunc:toe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class roe{constructor(e,t){this.variableNames=["A"];const r=new Array(e.length);for(let a=0;a<r.length;a++)r[a]=e[a]*t[a];this.outputShape=r,this.rank=r.length;const i=jt(this.rank),s=ioe(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}}function ioe(n){const e=n.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${n[0]})`;const t=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<n.length;i++)r.push(`imod(${t[i]}, ${n[i]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EM(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{reps:s}=r;if(i.dtype==="string"||i.shape.length>5){const c=t.readSync(i.dataId),l=i.dtype==="string"?c.map(d=>Na(d)):c,u=Et(i.shape,i.dtype,l),f=uQ(u,s);return t.makeTensorInfo(f.shape,f.dtype,f.values)}const a=new roe(i.shape,s);return t.runWebGLProgram(a,[i],i.dtype)}const soe={kernelName:Ff,backendName:"webgl",kernelFunc:EM};class aoe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class ooe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function io(n,e){e!==null&&n.disposeIntermediateTensorInfo(e)}function Uw(n){let e=1;for(;e<n;)e*=2;return e}function coe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i}=e,{k:s,sorted:a}=r,o=ie().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=ie().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=i.shape,u=l[l.length-1];if(t.shouldExecuteOnCPU([i])||u<o||s>c){const y=t.readSync(i.dataId),[A,k]=fQ(y,l,i.dtype,s,a);return[t.makeTensorInfo(A.shape,A.dtype,A.values),t.makeTensorInfo(k.shape,k.dtype,k.values)]}if(s===0)return l[l.length-1]=0,[t.makeTensorInfo(l,i.dtype,[]),t.makeTensorInfo(l,"int32",[])];if(u===1)return[i,ud({attrs:{shape:l,dtype:"int32",value:0},backend:t})];const f=t.texData.get(i.dataId),d=f!==null&&f.isPacked,h=d?t.unpackTensor(i):i,g=ue(l)/u,m=Ae({inputs:{x:h},attrs:{shape:[g,u]},backend:t});d&&io(t,h);const v=Uw(s),x=Uw(u);let b=null;const _=()=>b===null?[m,m]:[m,b],w=(y,A,k)=>{const M=_(),L=new aoe(k),D=[[u],[b===null?1:0],[Number.NEGATIVE_INFINITY],[y],[A]],F=b;b=t.runWebGLProgram(L,M,"int32",D),io(t,F)};for(let y=1;y<v;y*=2){const A=y*2;for(let k=y;k>=1;k/=2)w(A,k,[g,x])}for(let y=x;y>v;y/=2){const A=_(),k=new ooe([g,y/2]),L=[[u],[b===null?1:0],[v]],z=b;b=t.runWebGLProgram(k,A,"int32",L),io(t,z);const D=v/2,F=D*2;for(let O=D;O>=1;O/=2)w(F,O,b.shape)}let E=b;b=Pl({inputs:{x:b},backend:t,attrs:{begin:0,size:[g,s]}}),io(t,E);let S=mM({inputs:{x:m,indices:b},backend:t,attrs:{axis:1,batchDims:1}});io(t,m);const T=l.slice(0,-1);T.push(s),E=b,b=Ae({inputs:{x:b},attrs:{shape:T},backend:t}),io(t,E);const C=S;return S=Ae({inputs:{x:S},attrs:{shape:T},backend:t}),io(t,C),[S,b]}const loe={kernelName:db,backendName:"webgl",kernelFunc:coe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class uoe{constructor(e,t,r,i,s,a){this.variableNames=["Image","Transforms"],this.outputShape=a;const o=r==="nearest"?1:2;let c;switch(i){case"constant":c=1;break;case"reflect":c=2;break;case"wrap":c=3;break;case"nearest":c=4;break;default:c=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${c} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${c} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${t}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${t}));
                float mapY = mapCoord(inY, float(${e}));

                if (${o} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function foe(n){const{inputs:e,backend:t,attrs:r}=n,{image:i,transforms:s}=e,{interpolation:a,fillMode:o,fillValue:c,outputShape:l}=r,[u,f,d,h]=i.shape,[p,g]=l??[f,d],m=[u,p,g,h],v=new uoe(f,d,a,o,c,m);return t.runWebGLProgram(v,[i,s],"float32")}const doe={kernelName:hb,backendName:"webgl",kernelFunc:foe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hoe(n){const{inputs:e,attrs:t,backend:r}=n,{axis:i}=t,{x:s}=e;od(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const a=r.readSync(s.dataId),{outputValues:o,outputShape:c,indices:l}=dQ(a,i,s.shape,s.dtype);return[r.makeTensorInfo(c,s.dtype,o),r.makeTensorInfo([l.length],"int32",l)]}const poe={kernelName:pb,backendName:"webgl",kernelFunc:hoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function moe(n){const{inputs:e,backend:t,attrs:r}=n,{value:i}=e;let{axis:s}=r;s<0&&(s+=i.shape.length);const a=i,o=a.shape.length,c=i.shape[s],l=new Array(o-1);let u=0;for(let g=0;g<o;g++)g!==s&&(l[u++]=a.shape[g]);const f=[],d=new Array(o).fill(0),h=a.shape.slice();h[s]=1;const p=new Array(c);for(let g=0;g<p.length;g++){d[s]=g;const m=Pl({inputs:{x:a},backend:t,attrs:{begin:d,size:h}}),v=Ae({inputs:{x:m},backend:t,attrs:{shape:l}});p[g]=v,f.push(m)}return f.forEach(g=>t.disposeIntermediateTensorInfo(g)),p}const voe={kernelName:mm,backendName:"webgl",kernelFunc:moe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class goe{constructor(e,t){this.variableNames=["x","segmentIds"];const r=e.windowSize,i=e.batchSize,s=e.inSize,a=e.numSegments,o=a*Math.ceil(s/r);this.outputShape=[i,o];const c="0.0",l="sumValue",u=Math.floor(r/4)*4,f=r%4,d=`
        sumValue += dot(values, segFilter);
    `;let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let p="";s%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${c};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${a})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${a})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${d}
        }

        int inIdx = inOffset + ${u};
        if (${f===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${d}
        } else if (${f===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${d}
        } else if (${f===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${d}
        }
        setOutput(${l});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xoe(n){const{inputs:e,backend:t,attrs:r}=n,{x:i,segmentIds:s}=e,{numSegments:a}=r,o=i.shape.length,c=[];let l=0;const u=pn([l],o);let f=i;u!=null&&(f=xr({inputs:{x:i},backend:t,attrs:{perm:u}}),c.push(f),l=yn(1,o)[0]);const d=iT(f.shape,l,a),h=ue([f.shape[l]]),p=Ae({inputs:{x:f},backend:t,attrs:{shape:[-1,h]}});c.push(p);const g=gb(i.dtype),m=(_,w,E,S,T)=>{const C=_.shape[0],y=_.shape[1],A=rT(y,T),k={windowSize:A,inSize:y,batchSize:C,numSegments:T},M=new goe(k,w),L=t.compileAndRun(M,[_,E],S);if(c.push(L),L.shape[1]===T)return L;const z=wM({backend:t,attrs:{start:0,stop:T,step:1,dtype:"float32"}}),D=EM({inputs:{x:z},backend:t,attrs:{reps:[y/A]}});return c.push(z),c.push(D),m(L,w,D,S,T)},v=m(p,"unsortedSegmentSum",s,g,a),x=Ae({inputs:{x:v},backend:t,attrs:{shape:d}});let b=x;if(u!=null){c.push(x);const _=Va(u);b=xr({inputs:{x:b},backend:t,attrs:{perm:_}})}return c.forEach(_=>t.disposeIntermediateTensorInfo(_)),b}const boe={kernelName:vm,backendName:"webgl",kernelFunc:xoe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const _oe=[rJ,sJ,cJ,fJ,hJ,vJ,xJ,_J,SJ,AJ,MJ,kJ,OJ,$J,VJ,HJ,qJ,YJ,QJ,eee,iee,fee,hee,gee,bee,Tee,Cee,Nee,UQ,Lee,$ee,Gee,jee,Qee,ete,nte,ite,cte,fte,pte,vte,xte,_te,Ete,Tte,Mte,Nte,Lte,Pte,$te,Gte,Xte,Zte,ene,rne,ine,ane,cne,une,dne,pne,xne,yne,Sne,Ane,Mne,kne,zne,Une,$Q,Vne,Pee,Wne,Kne,Zne,VQ,tre,sre,ore,fre,pre,xre,yre,Tre,Mre,kre,Lre,Fre,Ure,Vre,qre,Kre,Yre,Qre,eie,iie,cie,die,_ie,WQ,Sie,Cie,Rie,Die,yee,zie,Fie,Uie,Gie,Xie,HQ,jie,Zie,Jie,tse,nse,wee,vie,sse,lse,hse,XQ,gse,_se,Sse,Cse,Nse,Dse,zse,$se,Vse,Wse,Kse,Zse,tae,iae,cae,fae,lee,xie,pae,vae,xae,_ae,wae,Sae,Aae,Iae,Rae,Dae,Oae,Pae,$ae,Vae,Hae,qae,Kae,gie,eJ,Zae,eoe,noe,soe,loe,doe,tJ,poe,voe,boe,Pie];for(const n of _oe)d3(n);async function yoe(n){return te(()=>{const e=Ie(n,"bool"),t=e.any([0,1,3]).arraySync().flat(),r=e.any([0,2,3]).arraySync().flat(),i=e.any([1,2,3]).arraySync().flat(),s=[t.findIndex(Boolean),r.findIndex(Boolean),i.findIndex(Boolean)],a=[t.findLastIndex(Boolean),r.findLastIndex(Boolean),i.findLastIndex(Boolean)];return{minCoords:s,maxCoords:a}})}async function woe(n,e){return te(()=>{let t=Ie(n,"bool"),r=xn(t,0,e);for(let i=1;i<e;i++){const s=kb(t,[3,3,3],1,"same"),a=Do(s,t),o=xn(a,i,r);He([r,t,a]),r=o,t=s}return r})}async function da(n,e=255,t){return te(()=>{let r=Ki(n,t),i=Ie(r,"bool"),s=xn(i,0,e);He(r);for(let a=1;a<e;a++){const o=kb(i,[2,2,2],1,"same"),c=Do(o,i),l=xn(c,a,s);He([s,i,c]),s=l,i=o}return Ki(s,t)})}async function dn(n,e=31,t,r){return te(()=>{const i=[0,1,2,3,4];[i[0],i[r]]=[i[r],i[0]];let s=xb([1,0,0,0,1,1,1,1],[2,2,2,1,1],"float32").transpose(i),a=Ki(n,t),o=Ie(a,"bool"),c=xn(o,0,e);for(let l=1;l<e;l++){const f=W3(o,s,1,"same").cast("bool"),d=Do(f,o),h=xn(d,l,c);He([c,o,d]),c=h,o=f}return Ki(c,t)})}async function Eoe(n,e){let t=[await da(n,e,[2,1,0]),await da(n,e,[1,0]),await da(n,e,[2,0]),await da(n,e,[0]),await da(n,e,[2,1]),await da(n,e,[1]),await da(n,e,[2]),await da(n,e,[])],r=nr(t,0);return He(t),r}async function Soe(n){const e=[[await dn(n,31,[2,1,0],2),await dn(n,31,[2,1,0],1),await dn(n,31,[2,1,0],0)],[await dn(n,31,[1,0],2),await dn(n,31,[1,0],1),await dn(n,31,[1,0],0)],[await dn(n,31,[2,0],2),await dn(n,31,[2,0],1),await dn(n,31,[2,0],0)],[await dn(n,31,[0],2),await dn(n,31,[0],1),await dn(n,31,[0],0)],[await dn(n,31,[2,1],2),await dn(n,31,[2,1],1),await dn(n,31,[2,1],0)],[await dn(n,31,[1],2),await dn(n,31,[1],1),await dn(n,31,[1],0)],[await dn(n,31,[2],2),await dn(n,31,[2],1),await dn(n,31,[2],0)],[await dn(n,31,[],2),await dn(n,31,[],1),await dn(n,31,[],0)]],t=[];for(let i of e){const s=i[0],a=i[1],o=i[2];t.push(te(()=>Aoe(s,a,o,n))),He([s,a,o])}let r=nr(t,0);return He(t),r}function Toe(n,e,t){return te(()=>{const r=e-n;return t.sub(n).div(r)})}function Aoe(n,e,t,r){return te(()=>{const i=n.clipByValue(0,31),s=e.clipByValue(0,31),a=t.clipByValue(0,31),o=r.clipByValue(0,1),c=i.mul(2048),l=s.mul(64),u=a.mul(2);return o.add(u).add(l).add(c)})}function Coe(n,e,t){return Math.max(e,Math.min(t,n))}const Ps=Ioe();function Ioe(){const n=new ArrayBuffer(4),e=new Float32Array(n),t=new Uint32Array(n),r=new Uint32Array(512),i=new Uint32Array(512);for(let c=0;c<256;++c){const l=c-127;l<-27?(r[c]=0,r[c|256]=32768,i[c]=24,i[c|256]=24):l<-14?(r[c]=1024>>-l-14,r[c|256]=1024>>-l-14|32768,i[c]=-l-1,i[c|256]=-l-1):l<=15?(r[c]=l+15<<10,r[c|256]=l+15<<10|32768,i[c]=13,i[c|256]=13):l<128?(r[c]=31744,r[c|256]=64512,i[c]=24,i[c|256]=24):(r[c]=31744,r[c|256]=64512,i[c]=13,i[c|256]=13)}const s=new Uint32Array(2048),a=new Uint32Array(64),o=new Uint32Array(64);for(let c=1;c<1024;++c){let l=c<<13,u=0;for(;!(l&8388608);)l<<=1,u-=8388608;l&=-8388609,u+=947912704,s[c]=l|u}for(let c=1024;c<2048;++c)s[c]=939524096+(c-1024<<13);for(let c=1;c<31;++c)a[c]=c<<23;a[31]=1199570944,a[32]=2147483648;for(let c=33;c<63;++c)a[c]=2147483648+(c-32<<23);a[63]=3347054592;for(let c=1;c<64;++c)c!==32&&(o[c]=1024);return{floatView:e,uint32View:t,baseTable:r,shiftTable:i,mantissaTable:s,exponentTable:a,offsetTable:o}}function tg(n){Math.abs(n)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),n=Coe(n,-65504,65504),Ps.floatView[0]=n;const e=Ps.uint32View[0],t=e>>23&511;return Ps.baseTable[t]+((e&8388607)>>Ps.shiftTable[t])}function Bw(n){const e=n>>10;return Ps.uint32View[0]=Ps.mantissaTable[Ps.offsetTable[e]+(n&1023)]+Ps.exponentTable[e],Ps.floatView[0]}const Moe=(n,e)=>`

    // Compute the min and max values of the trilinear interpolation inside a single cell
    vec2 computeCellExtrema(int cellX, int cellY, int cellZ)
    {
        float minValue = 1.0;
        float maxValue = 0.0;

        for (int localZ = 0; localZ < 2; ++localZ) {
        for (int localY = 0; localY < 2; ++localY) {
        for (int localX = 0; localX < 2; ++localX) {
        
            int voxelZ = clamp(cellZ - 1 + localZ, 0, ${n[2]-1});
            int voxelY = clamp(cellY - 1 + localY, 0, ${n[1]-1});
            int voxelX = clamp(cellX - 1 + localX, 0, ${n[0]-1});
            
            float voxelValue = getA(voxelX, voxelY, voxelZ, 3); // raw scalar value

            minValue = min(minValue, voxelValue);
            maxValue = max(maxValue, voxelValue);

        }}}
        
        return vec2(minValue, maxValue);
    }

    // Compute the extrema across all cells in a block
    vec2 computeBlockExtrema(int blockX, int blockY, int blockZ)
    {
        int startX = blockX * ${e};
        int startY = blockY * ${e};
        int startZ = blockZ * ${e};

        int endX = startX + ${e};
        int endY = startY + ${e};
        int endZ = startZ + ${e};

        float minValue = 1.0;
        float maxValue = 0.0;

        for (int cellZ = startZ; cellZ < endZ; ++cellZ) {
        for (int cellY = startY; cellY < endY; ++cellY) {
        for (int cellX = startX; cellX < endX; ++cellX) {
            
            vec2 cellExtrema = computeCellExtrema(cellX, cellY, cellZ);

            minValue = min(minValue, cellExtrema.x);
            maxValue = max(maxValue, cellExtrema.y);

        }}}

        minValue = clamp(minValue, 0.0, 1.0);
        maxValue = clamp(maxValue, 0.0, 1.0);

        return vec2(minValue, maxValue);
    }

    void main()
    {
        ivec4 outputCoords = getOutputCoords();

        int blockX = outputCoords.x;
        int blockY = outputCoords.y;
        int blockZ = outputCoords.z;

        vec2 blockExtrema = computeBlockExtrema(blockX, blockY, blockZ);

        int outputChannel = outputCoords.w;
        if (outputChannel == 0) 
        {
            setOutput(blockExtrema.x); // min value
        } 
        else 
        {
            setOutput(blockExtrema.y); // max value
        }
    }
`,Roe=(n,e)=>`
    
    // Compute the extrema of the tricubic interpolation in a single cell
    vec2 computeCellExtrema(int cellX, int cellY, int cellZ)
    {
        // Bernstein elevation coefficients (order 1 → order 3)
        const vec2 BernsteinElevations[4] = vec2[4](
            vec2(1.0, 0.0),
            vec2(2.0 / 3.0, 1.0 / 3.0),
            vec2(1.0 / 3.0, 2.0 / 3.0),
            vec2(0.0, 1.0)
        );

        // Bernstein contribution coefficients for mixed-order derivatives
        const vec2 BernsteinContributions[4] = vec2[4](
            vec2(0.0, 0.0),
            vec2(-1.0 / 4.0, 0.0),
            vec2(0.0, -1.0 / 4.0),
            vec2(0.0, 0.0)
        );

        float minValue = 1.0;
        float maxValue = 0.0;

        for (int coeffZ = 0; coeffZ < 4; ++coeffZ) {
        for (int coeffY = 0; coeffY < 4; ++coeffY) {
        for (int coeffX = 0; coeffX < 4; ++coeffX) {

            float bernsteinCoeff = 0.0;

            for (int localZ = 0; localZ < 2; ++localZ) {
            for (int localY = 0; localY < 2; ++localY) {
            for (int localX = 0; localX < 2; ++localX) {

                int voxelZ = clamp(cellZ - 1 + localZ, 0, ${n[2]-1});
                int voxelY = clamp(cellY - 1 + localY, 0, ${n[1]-1});
                int voxelX = clamp(cellX - 1 + localX, 0, ${n[0]-1});

                float elevateZ = BernsteinElevations[coeffZ][localZ];
                float elevateY = BernsteinElevations[coeffY][localY];
                float elevateX = BernsteinElevations[coeffX][localX];

                float contributeZ = BernsteinContributions[coeffZ][localZ];
                float contributeY = BernsteinContributions[coeffY][localY];
                float contributeX = BernsteinContributions[coeffX][localX];

                vec4 voxelFeatures = vec4(
                    getA(voxelX, voxelY, voxelZ, 0), // fxx
                    getA(voxelX, voxelY, voxelZ, 1), // fyy
                    getA(voxelX, voxelY, voxelZ, 2), // fzz
                    getA(voxelX, voxelY, voxelZ, 3)  // f
                );

                vec4 contributions = vec4(contributeX, contributeY, contributeZ, 1.0);
                float elevation = elevateX * elevateY * elevateZ;

                float voxelCoeff = dot(voxelFeatures, contributions) * elevation;
                bernsteinCoeff += voxelCoeff;

            }}} 

            minValue = min(minValue, bernsteinCoeff);
            maxValue = max(maxValue, bernsteinCoeff);

        }}} 

        return vec2(minValue, maxValue);
    }

    // Compute extrema over all cells in the block
    vec2 computeBlockExtrema(int blockX, int blockY, int blockZ)
    {
        int startX = blockX * ${e};
        int startY = blockY * ${e};
        int startZ = blockZ * ${e};

        int endX = startX + ${e};
        int endY = startY + ${e};
        int endZ = startZ + ${e};

        float minValue = 1.0;
        float maxValue = 0.0;

        for (int cellZ = startZ; cellZ < endZ; ++cellZ) {
        for (int cellY = startY; cellY < endY; ++cellY) {
        for (int cellX = startX; cellX < endX; ++cellX) {

            vec2 cellExtrema = computeCellExtrema(cellX, cellY, cellZ);

            minValue = min(minValue, cellExtrema.x);
            maxValue = max(maxValue, cellExtrema.y);

        }}}

        minValue = clamp(minValue, 0.0, 1.0);
        maxValue = clamp(maxValue, 0.0, 1.0);

        return vec2(minValue, maxValue);
    }

    void main()
    {
        ivec4 outputCoords = getOutputCoords();

        int blockX = outputCoords.x;
        int blockY = outputCoords.y;
        int blockZ = outputCoords.z;
        
        vec2 blockExtrema = computeBlockExtrema(blockX, blockY, blockZ);

        int outputChannel = outputCoords.w;
        if (outputChannel == 0) 
        {
            setOutput(blockExtrema.x);
        } 
        else 
        {
            setOutput(blockExtrema.y);
        }
    }
`;class Noe{constructor(e,t,r){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!1,this.outputShape=e.map(i=>Math.ceil((i+1)/t)),this.outputShape[3]=2,this.userCode=r==0?Moe(e,t):Roe(e,t)}}function koe(n,e,t=1){const r=new Noe(n.shape,e,t),s=Vf().compileAndRun(r,[n]);return Fr().makeTensorFromTensorInfo(s)}class Doe{constructor(e,t,r,i,s,a){this.variableNames=["A"];const[o,c,l,u]=e;this.outputShape=[t,r,i,u];const f=[s&&t>1?o-1:o,s&&r>1?c-1:c,s&&i>1?l-1:l],d=[s&&t>1?t-1:t,s&&r>1?r-1:r,s&&i>1?i-1:i],h=f.map((g,m)=>g/d[m]),p=a?"(vec3(dhw) + vec3(0.5)) * scaleFactors - vec3(0.5)":"vec3(dhw) * scaleFactors";this.userCode=`
        const vec3 scaleFactors = vec3(${h[0]}, ${h[1]}, ${h[2]});
        const vec3 inputShape = vec3(${o}.0, ${c}.0, ${l}.0);

        void main() 
        {
            ivec4 coords = getOutputCoords();
            int d = coords[0];
            int h = coords[1];
            int w = coords[2];
            int c = coords[3];

            ivec3 dhw = ivec3(d, h, w);
            vec3 sourceFracIndex = ${p};

            vec3 floorIndex = clamp(floor(sourceFracIndex), vec3(0.0), inputShape - 1.0);
            vec3 ceilIndex  = clamp(ceil(sourceFracIndex),  vec3(0.0), inputShape - 1.0);
            vec3 frac = sourceFracIndex - floorIndex;

            float c000 = getA(int(floorIndex.x), int(floorIndex.y), int(floorIndex.z), c);
            float c001 = getA(int(floorIndex.x), int(floorIndex.y), int(ceilIndex.z),  c);
            float c010 = getA(int(floorIndex.x), int(ceilIndex.y),  int(floorIndex.z), c);
            float c011 = getA(int(floorIndex.x), int(ceilIndex.y),  int(ceilIndex.z),  c);
            float c100 = getA(int(ceilIndex.x),  int(floorIndex.y), int(floorIndex.z), c);
            float c101 = getA(int(ceilIndex.x),  int(floorIndex.y), int(ceilIndex.z),  c);
            float c110 = getA(int(ceilIndex.x),  int(ceilIndex.y),  int(floorIndex.z), c);
            float c111 = getA(int(ceilIndex.x),  int(ceilIndex.y),  int(ceilIndex.z),  c);

            float c00 = mix(c000, c001, frac.z);
            float c01 = mix(c010, c011, frac.z);
            float c10 = mix(c100, c101, frac.z);
            float c11 = mix(c110, c111, frac.z);

            float c0 = mix(c00, c01, frac.y);
            float c1 = mix(c10, c11, frac.y);

            float value = mix(c0, c1, frac.x);

            setOutput(value);
        }
        `}}function Loe(n,e,t,r,i=!1,s=!1){const a=Vf(),o=new Doe(n.shape,e,t,r,i,s),c=a.compileAndRun(o,[n]);return Fr().makeTensorFromTensorInfo(c)}class Ooe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!1;const[t,r,i,s]=e;this.outputShape=[t,r,i,4],this.userCode=`
        void main() 
        {
            ivec4 outputCoords = getOutputCoords();

            int voxelZ = outputCoords[0];
            int voxelY = outputCoords[1];
            int voxelX = outputCoords[2];

            float F = getA(voxelZ, voxelY, voxelX, 0);

            int outputChannel = outputCoords[3];

            if (outputChannel == 3)
            {
                setOutput(F);
            }

            if (outputChannel == 2)
            {
                ivec2 frontBack = clamp(voxelZ + ivec2(-1, 1), 0, ${t-1});

                float Fzz = getA(frontBack.x, voxelY, voxelX, 0) + 
                            getA(frontBack.y, voxelY, voxelX, 0) - F * 2.0;

                setOutput(Fzz);
            }

            if (outputChannel == 1)
            {
                ivec2 topBottom = clamp(voxelY + ivec2(-1, 1), 0, ${r-1});

                float Fyy = getA(voxelZ, topBottom.x, voxelX, 0) + 
                            getA(voxelZ, topBottom.y, voxelX, 0) - F * 2.0;

                setOutput(Fyy);
            }

            if (outputChannel == 0)
            {
                ivec2 leftRight = clamp(voxelX + ivec2(-1, 1), 0, ${i-1});

                float Fxx = getA(voxelZ, voxelY, leftRight.x, 0) + 
                            getA(voxelZ, voxelY, leftRight.y, 0) - F * 2.0;

                setOutput(Fxx);
            }
        }
        `}}function zoe(n){const e=Vf(),t=new Ooe(n.shape),r=e.compileAndRun(t,[n]);return Fr().makeTensorFromTensorInfo(r)}class Poe{constructor(e,t){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!1;const[r,i,s]=e;this.outputShape=[r,i,s,1],this.userCode=`
        void main() 
        {
            ivec4 coords = getOutputCoords();
            int z = coords[0];
            int y = coords[1];
            int x = coords[2];
            int c = coords[3];

            float minVal = getA(z, y, x, 0);
            float maxVal = getA(z, y, x, 1);
            float occupied = (minVal <= ${t} && ${t} <= maxVal) ? 255.0 : 0.0;

            setOutput(occupied);
        }
        `}}function Foe(n,e){const t=Vf(),r=new Poe(n.shape,e),i=t.compileAndRun(r,[n]);return Fr().makeTensorFromTensorInfo(i)}class $oe extends Js{constructor(){super(),this.viewer=new dl,this.renderer=this.viewer.renderer,this.resources=this.viewer.resources,this.uniforms=this.viewer.material.uniforms,this.defines=this.viewer.material.defines,this.stride=this.uniforms.u_distance_map.value.stride,this.threshold=this.uniforms.u_rendering.value.isovalue,this.interpolationMethod=this.defines.INTERPOLATION_METHOD,this.skippingMethod=this.defines.SKIPPING_METHOD,this.resources.on("ready",async()=>{await this.setTensorflow(),await this.setComputes(),this.trigger("ready")})}async setTensorflow(){console.time("setTensorflow"),hF(),await mF(),await pF("webgl"),console.timeEnd("setTensorflow")}async setComputes(){console.time("setComputes"),await this.computeIntensityMap(),await this.downscaleIntensityMap(),await this.computeTrilaplacianIntensityMap(),He(this.intensityMap.tensor),await this.computeBlockExtremaMap(),He(this.trilaplacianIntensityMap.tensor),await this.computeOccupancyMap(),await this.computeDistanceMap(),await this.computeAnisotropicDistanceMap(),await this.computeExtendedAnisotropicDistanceMap(),He(this.occupancyMap.tensor),console.timeEnd("setComputes")}async onThresholdChange(){console.time("onThresholdChange"),this.threshold=this.uniforms.u_rendering.value.isovalue,await this.computeOccupancyMap(),await this.computeDistanceMap(),await this.computeAnisotropicDistanceMap(),await this.computeExtendedAnisotropicDistanceMap(),He(this.occupancyMap.tensor),console.timeEnd("onThresholdChange")}async onStrideChange(){console.time("onStrideChange"),this.stride=this.uniforms.u_distance_map.value.stride,await this.uploadTrilaplacianIntensityMap(),await this.computeBlockExtremaMap(),He(this.trilaplacianIntensityMap.tensor),await this.computeOccupancyMap(),await this.computeDistanceMap(),await this.computeAnisotropicDistanceMap(),await this.computeExtendedAnisotropicDistanceMap(),He(this.occupancyMap.tensor),console.timeEnd("onStrideChange")}async onInterpolationChange(){console.time("onInterpolationChange"),this.interpolationMethod=this.defines.INTERPOLATION_METHOD,await this.uploadTrilaplacianIntensityMap(),await this.computeBlockExtremaMap(),He(this.trilaplacianIntensityMap.tensor),await this.computeOccupancyMap(),await this.computeBoundingBox(),await this.computeDistanceMap(),await this.computeAnisotropicDistanceMap(),await this.computeExtendedAnisotropicDistanceMap(),He(this.occupancyMap.tensor),console.timeEnd("onInterpolationChange")}async computeIntensityMap(){console.time("computeIntensityMap");const e=this.resources.items.intensityMap;this.intensityMap={},this.intensityMap.dimensions=new $().fromArray(e.dimensions),this.intensityMap.spacing=new $().fromArray(e.spacing),this.intensityMap.size=new $().fromArray(e.size),this.intensityMap.invDimensions=new $().fromArray(e.dimensions.map(r=>1/r)),this.intensityMap.invSpacing=new $().fromArray(e.spacing.map(r=>1/r)),this.intensityMap.invSize=new $().fromArray(e.size.map(r=>1/r)),this.intensityMap.spacingLength=new $().fromArray(e.spacing).length(),this.intensityMap.sizeLength=new $().fromArray(e.size).length(),this.intensityMap.numVoxels=e.dimensions.reduce((r,i)=>r*i,1),this.intensityMap.maxVoxels=e.dimensions.reduce((r,i)=>r+i,-2),this.intensityMap.shape=e.dimensions.toReversed().concat(1),this.intensityMap.tensor=te(()=>{const r=new Float32Array(e.data),i=Bv(r,this.intensityMap.shape);return Toe(e.min,e.max,i)}),this.intensityMap.array=new Uint16Array(this.intensityMap.tensor.size);const t=this.intensityMap.tensor.dataSync();for(let r=0;r<this.intensityMap.array.length;++r)this.intensityMap.array[r]=tg(t[r]);console.timeEnd("computeIntensityMap")}async downscaleIntensityMap(){console.time("downscaleIntensityMap");const e=this.intensityMap.tensor.shape.map(i=>Math.ceil(i*.5)),t=Loe(this.intensityMap.tensor,e[0],e[1],e[2],!1,!0);He(this.intensityMap.tensor),this.intensityMap.tensor=t,this.intensityMap.dimensions=new $().fromArray(this.intensityMap.tensor.shape.slice(0,3).toReversed()),this.intensityMap.size=new $().copy(this.intensityMap.size),this.intensityMap.spacing=new $().copy(this.intensityMap.size).divide(this.intensityMap.dimensions),this.intensityMap.invDimensions=new $().fromArray(this.intensityMap.dimensions.toArray().map(i=>1/i)),this.intensityMap.invSpacing=new $().fromArray(this.intensityMap.spacing.toArray().map(i=>1/i)),this.intensityMap.invSize=new $().fromArray(this.intensityMap.size.toArray().map(i=>1/i)),this.intensityMap.spacingLength=this.intensityMap.spacing.length(),this.intensityMap.sizeLength=this.intensityMap.size.length(),this.intensityMap.numVoxels=this.intensityMap.dimensions.toArray().reduce((i,s)=>i*s,1),this.intensityMap.maxVoxels=this.intensityMap.dimensions.toArray().reduce((i,s)=>i+s,-2),this.intensityMap.shape=this.intensityMap.tensor.shape,this.intensityMap.array=null,this.intensityMap.array=new Uint16Array(this.intensityMap.tensor.size);const r=this.intensityMap.tensor.dataSync();for(let i=0;i<this.intensityMap.array.length;++i)this.intensityMap.array[i]=tg(r[i]);console.timeEnd("downscaleIntensityMap")}async computeTrilaplacianIntensityMap(){console.time("computeTrilaplacianIntensityMap"),this.trilaplacianIntensityMap={},this.trilaplacianIntensityMap.tensor=zoe(this.intensityMap.tensor),this.trilaplacianIntensityMap.array=new Uint16Array(this.trilaplacianIntensityMap.tensor.size);const e=this.trilaplacianIntensityMap.tensor.dataSync();for(let t=0;t<this.trilaplacianIntensityMap.array.length;++t)this.trilaplacianIntensityMap.array[t]=tg(e[t]);this.trilaplacianIntensityMap.shape=this.trilaplacianIntensityMap.tensor.shape,this.trilaplacianIntensityMap.dimensions=this.intensityMap.dimensions,this.trilaplacianIntensityMap.spacing=this.intensityMap.spacing,this.trilaplacianIntensityMap.size=this.intensityMap.size,this.trilaplacianIntensityMap.invDimensions=this.intensityMap.invDimensions,this.trilaplacianIntensityMap.invSpacing=this.intensityMap.invSpacing,this.trilaplacianIntensityMap.invSize=this.intensityMap.invSize,this.trilaplacianIntensityMap.spacingLength=this.intensityMap.spacingLength,this.trilaplacianIntensityMap.sizeLength=this.intensityMap.sizeLength,this.trilaplacianIntensityMap.numVoxels=this.intensityMap.numVoxels,this.trilaplacianIntensityMap.maxVoxels=this.intensityMap.maxVoxels,console.timeEnd("computeTrilaplacianIntensityMap")}async computeBlockExtremaMap(){console.time("computeBlockExtremaMap"),this.blockExtremaMap={},this.blockExtremaMap.tensor=koe(this.trilaplacianIntensityMap.tensor,this.stride,this.interpolationMethod),this.blockExtremaMap.array=new Float32Array(this.blockExtremaMap.tensor.size),this.blockExtremaMap.stride=this.stride,this.blockExtremaMap.invStride=1/this.blockExtremaMap.stride,this.blockExtremaMap.shape=this.blockExtremaMap.tensor.shape,this.blockExtremaMap.dimensions=new $().fromArray(this.blockExtremaMap.shape.slice(0,3).toReversed()),this.blockExtremaMap.spacing=new $().copy(this.intensityMap.spacing).multiplyScalar(this.blockExtremaMap.stride),this.blockExtremaMap.size=new $().copy(this.blockExtremaMap.dimensions).multiply(this.blockExtremaMap.spacing),this.blockExtremaMap.invDimensions=new $().fromArray(this.blockExtremaMap.dimensions.toArray().map(e=>1/e)),this.blockExtremaMap.invSpacing=new $().fromArray(this.blockExtremaMap.spacing.toArray().map(e=>1/e)),this.blockExtremaMap.invSize=new $().fromArray(this.blockExtremaMap.size.toArray().map(e=>1/e)),console.timeEnd("computeBlockExtremaMap")}async computeOccupancyMap(){console.time("computeOccupancyMap"),this.occupancyMap={},this.occupancyMap.tensor=Foe(this.blockExtremaMap.tensor,this.threshold),this.occupancyMap.array=new Uint8Array(this.occupancyMap.tensor.dataSync()),this.occupancyMap.threshold=this.threshold,this.occupancyMap.stride=this.blockExtremaMap.stride,this.occupancyMap.shape=this.blockExtremaMap.shape,this.occupancyMap.dimensions=this.blockExtremaMap.dimensions,this.occupancyMap.spacing=this.blockExtremaMap.spacing,this.occupancyMap.size=this.blockExtremaMap.size,this.occupancyMap.invStride=this.blockExtremaMap.invStride,this.occupancyMap.invDimensions=this.blockExtremaMap.invDimensions,this.occupancyMap.invSpacing=this.blockExtremaMap.invSpacing,this.occupancyMap.invSize=this.blockExtremaMap.invSize,this.occupancyMap.numBlocks=this.blockExtremaMap.dimensions.toArray().reduce((e,t)=>e*t,1),console.timeEnd("computeOccupancyMap")}async computeBoundingBox(){console.time("computeBoundingBox");const{minCoords:e,maxCoords:t}=await yoe(this.occupancyMap.tensor);this.boundingBox={},this.boundingBox.minCoords=e,this.boundingBox.maxCoords=t,this.boundingBox.minBlockCoords=new $().fromArray(this.boundingBox.minCoords),this.boundingBox.maxBlockCoords=new $().fromArray(this.boundingBox.maxCoords),this.boundingBox.minCellCoords=this.boundingBox.minBlockCoords.clone().addScalar(0).multiplyScalar(this.occupancyMap.stride),this.boundingBox.maxCellCoords=this.boundingBox.maxBlockCoords.clone().addScalar(1).multiplyScalar(this.occupancyMap.stride).subScalar(1),this.boundingBox.minPosition=this.boundingBox.minBlockCoords.clone().addScalar(0).multiplyScalar(this.occupancyMap.stride).subScalar(.5),this.boundingBox.maxPosition=this.boundingBox.maxBlockCoords.clone().addScalar(1).multiplyScalar(this.occupancyMap.stride).subScalar(.5),this.boundingBox.blockDimensions=new $().subVectors(this.boundingBox.maxBlockCoords,this.boundingBox.minBlockCoords).addScalar(1),this.boundingBox.cellDimensions=new $().subVectors(this.boundingBox.maxCellCoords,this.boundingBox.minCellCoords).addScalar(1),this.boundingBox.maxCells=this.boundingBox.cellDimensions.toArray().reduce((r,i)=>r+i,-2),this.boundingBox.maxBlocks=this.boundingBox.blockDimensions.toArray().reduce((r,i)=>r+i,-2),this.boundingBox.maxCellsPerBlock=this.occupancyMap.stride*3-2,console.timeEnd("computeBoundingBox")}async computeDistanceMap(){console.time("computeDistanceMap"),this.distanceMap={},this.distanceMap.tensor=await woe(this.occupancyMap.tensor,255),this.distanceMap.array=new Uint8Array(this.distanceMap.tensor.dataSync()),He(this.distanceMap.tensor),this.distanceMap.threshold=this.occupancyMap.threshold,this.distanceMap.stride=this.occupancyMap.stride,this.distanceMap.shape=this.occupancyMap.shape,this.distanceMap.dimensions=this.occupancyMap.dimensions,this.distanceMap.spacing=this.occupancyMap.spacing,this.distanceMap.size=this.occupancyMap.size,this.distanceMap.invStride=this.occupancyMap.invStride,this.distanceMap.invDimensions=this.occupancyMap.invDimensions,this.distanceMap.invSpacing=this.occupancyMap.invSpacing,this.distanceMap.invSize=this.occupancyMap.invSize,this.distanceMap.numBlocks=this.occupancyMap.numBlocks,console.timeEnd("computeDistanceMap")}async computeAnisotropicDistanceMap(){console.time("computeAnisotropicDistanceMap"),this.anisotropicDistanceMap={},this.anisotropicDistanceMap.tensor=await Eoe(this.occupancyMap.tensor,63),this.anisotropicDistanceMap.array=new Uint8Array(this.anisotropicDistanceMap.tensor.dataSync()),He(this.anisotropicDistanceMap.tensor),this.anisotropicDistanceMap.threshold=this.occupancyMap.threshold,this.anisotropicDistanceMap.stride=this.occupancyMap.stride,this.anisotropicDistanceMap.shape=this.occupancyMap.shape,this.anisotropicDistanceMap.dimensions=new $(this.occupancyMap.dimensions.x,this.occupancyMap.dimensions.y,this.occupancyMap.dimensions.z*8),this.anisotropicDistanceMap.spacing=this.occupancyMap.spacing,this.anisotropicDistanceMap.size=this.occupancyMap.size,this.anisotropicDistanceMap.invStride=this.occupancyMap.invStride,this.anisotropicDistanceMap.invDimensions=this.occupancyMap.invDimensions,this.anisotropicDistanceMap.invSpacing=this.occupancyMap.invSpacing,this.anisotropicDistanceMap.invSize=this.occupancyMap.invSize,this.anisotropicDistanceMap.numBlocks=this.occupancyMap.numBlocks,console.timeEnd("computeAnisotropicDistanceMap")}async computeExtendedAnisotropicDistanceMap(){console.time("computeExtendedAnisotropicDistanceMap"),this.extendedAnisotropicDistanceMap={},this.extendedAnisotropicDistanceMap.tensor=await Soe(this.occupancyMap.tensor),this.extendedAnisotropicDistanceMap.array=new Uint16Array(this.extendedAnisotropicDistanceMap.tensor.dataSync()),He(this.extendedAnisotropicDistanceMap.tensor),this.extendedAnisotropicDistanceMap.threshold=this.occupancyMap.threshold,this.extendedAnisotropicDistanceMap.stride=this.occupancyMap.stride,this.extendedAnisotropicDistanceMap.shape=this.occupancyMap.shape,this.extendedAnisotropicDistanceMap.dimensions=new $(this.occupancyMap.dimensions.x,this.occupancyMap.dimensions.y,this.occupancyMap.dimensions.z*8),this.extendedAnisotropicDistanceMap.spacing=this.occupancyMap.spacing,this.extendedAnisotropicDistanceMap.size=this.occupancyMap.size,this.extendedAnisotropicDistanceMap.invStride=this.occupancyMap.invStride,this.extendedAnisotropicDistanceMap.invDimensions=this.occupancyMap.invDimensions,this.extendedAnisotropicDistanceMap.invSpacing=this.occupancyMap.invSpacing,this.extendedAnisotropicDistanceMap.invSize=this.occupancyMap.invSize,this.extendedAnisotropicDistanceMap.numBlocks=this.occupancyMap.numBlocks,console.timeEnd("computeExtendedAnisotropicDistanceMap")}async uploadIntensityMap(){if(this.intensityMap.array){console.time("uploadIntensityMap");const e=new Float32Array(this.intensityMap.array.length);for(let t=0;t<this.intensityMap.array.length;++t)e[t]=Bw(this.intensityMap.array[t]);this.intensityMap.tensor=Bv(e,this.intensityMap.shape),console.timeEnd("uploadIntensityMap")}else await this.computeIntensityMap()}async uploadTrilaplacianIntensityMap(){if(this.trilaplacianIntensityMap.array){console.time("uploadTrilaplacianIntensityMap");const e=new Float32Array(this.trilaplacianIntensityMap.array.length);for(let t=0;t<this.trilaplacianIntensityMap.array.length;++t)e[t]=Bw(this.trilaplacianIntensityMap.array[t]);this.trilaplacianIntensityMap.tensor=Bv(e,this.trilaplacianIntensityMap.shape),console.timeEnd("uploadTrilaplacianIntensityMap")}else await this.computeTrilaplacianIntensityMap()}destroy(){this.intensityMap&&(He(this.intensityMap.tensor),this.intensityMap.tensor=null,this.intensityMap.array=null,this.intensityMap=null),this.trilaplacianIntensityMap&&(this.trilaplacianIntensityMap.array=null,this.trilaplacianIntensityMap=null),this.blockExtremaMap&&(He(this.blockExtremaMap.tensor),this.blockExtremaMap.tensor=null,this.blockExtremaMap.array=null,this.blockExtremaMap=null),this.occupancyMap&&(He(this.occupancyMap.tensor),this.occupancyMap.tensor=null,this.occupancyMap.array=null,this.occupancyMap=null),this.boundingBox&&(this.boundingBox=null),this.distanceMap&&(He(this.distanceMap.tensor),this.distanceMap.tensor=null,this.distanceMap.array=null,this.distanceMap=null),this.anisotropicDistanceMap&&(He(this.anisotropicDistanceMap.tensor),this.anisotropicDistanceMap.tensor=null,this.anisotropicDistanceMap.array=null,this.anisotropicDistanceMap=null),this.extendedAnisotropicDistanceMap&&(He(this.extendedAnisotropicDistanceMap.tensor),this.extendedAnisotropicDistanceMap.tensor=null,this.extendedAnisotropicDistanceMap.array=null,this.extendedAnisotropicDistanceMap=null),this.viewer=null,this.renderer=null,this.resources=null,this.uniforms=null,console.log("ISOComputes destroyed.")}}class Uoe extends Js{constructor(){super(),this.viewer=new dl,this.resources=this.viewer.resources,this.computes=this.viewer.computes,this.computes.on("ready",()=>{this.setTextures(),this.trigger("ready")})}async setTextures(){this.textureColorMaps(),this.textureIntensityMap(),this.textureTrilaplacianIntensityMap(),this.textureOccupancyMap(),this.textureDistanceMap(),this.textureAnisotropicDistanceMap(),this.textureExtendedAnisotropicDistanceMap()}async onThresholdChange(){this.occupancyMap&&(this.occupancyMap.image.data.set(this.computes.occupancyMap.array),this.occupancyMap.needsUpdate=!0),this.distanceMap&&(this.distanceMap.image.data.set(this.computes.distanceMap.array),this.distanceMap.needsUpdate=!0),this.anisotropicDistanceMap&&(this.anisotropicDistanceMap.image.data.set(this.computes.anisotropicDistanceMap.array),this.anisotropicDistanceMap.needsUpdate=!0),this.extendedAnisotropicDistanceMap&&(this.extendedAnisotropicDistanceMap.image.data.set(this.computes.extendedAnisotropicDistanceMap.array),this.extendedAnisotropicDistanceMap.needsUpdate=!0)}async onStrideChange(){this.occupancyMap&&this.occupancyMap.dispose(),this.distanceMap&&this.distanceMap.dispose(),this.anisotropicDistanceMap&&this.anisotropicDistanceMap.dispose(),this.extendedAnisotropicDistanceMap&&this.extendedAnisotropicDistanceMap.dispose(),this.textureOccupancyMap(),this.textureDistanceMap(),this.textureAnisotropicDistanceMap(),this.textureExtendedAnisotropicDistanceMap()}async onInterpolationChange(){this.occupancyMap&&(this.occupancyMap.image.data.set(this.computes.occupancyMap.array),this.occupancyMap.needsUpdate=!0),this.distanceMap&&(this.distanceMap.image.data.set(this.computes.distanceMap.array),this.distanceMap.needsUpdate=!0),this.anisotropicDistanceMap&&(this.anisotropicDistanceMap.image.data.set(this.computes.anisotropicDistanceMap.array),this.anisotropicDistanceMap.needsUpdate=!0),this.extendedAnisotropicDistanceMap&&(this.extendedAnisotropicDistanceMap.image.data.set(this.computes.extendedAnisotropicDistanceMap.array),this.extendedAnisotropicDistanceMap.needsUpdate=!0)}textureColorMaps(){this.resources.items.colorMaps&&(console.time("textureColorMaps"),this.colorMaps=this.resources.items.colorMaps,this.colorMaps.colorSpace=Xn,this.colorMaps.minFilter=Rn,this.colorMaps.magFilter=Rn,this.colorMaps.generateMipmaps=!1,this.colorMaps.needsUpdate=!0,console.timeEnd("textureColorMaps"))}textureIntensityMap(){this.computes.intensityMap&&(console.time("textureIntensityMap"),this.intensityMap=this.createTexture(this.computes.intensityMap.array,this.computes.intensityMap.dimensions,mp,Us,Rn,Rn),this.intensityMap.internalFormat="R16F",this.intensityMap.unpackAlignment=1,console.timeEnd("textureIntensityMap"))}textureTrilaplacianIntensityMap(){this.computes.trilaplacianIntensityMap&&(console.time("textureTrilaplacianIntensityMap"),this.trilaplacianIntensityMap=this.createTexture(this.computes.trilaplacianIntensityMap.array,this.computes.trilaplacianIntensityMap.dimensions,Jr,Us,Rn,Rn),this.trilaplacianIntensityMap.internalFormat="RGBA16F",this.trilaplacianIntensityMap.unpackAlignment=4,console.timeEnd("textureTrilaplacianIntensityMap"))}textureExtremaMap(){this.computes.extremaMap&&(console.time("textureExtremaMap"),this.extremaMap=this.createTexture(this.computes.extremaMap.array,this.computes.extremaMap.dimensions,Jx,Us,cn,cn),this.extremaMap.internalFormat="RG16F",this.extremaMap.unpackAlignment=2,console.timeEnd("textureExtremaMap"))}textureOccupancyMap(){this.computes.occupancyMap&&(console.time("textureOccupancyMap"),this.occupancyMap=this.createTexture(this.computes.occupancyMap.array,this.computes.occupancyMap.dimensions,po,yi,cn,cn),this.occupancyMap.internalFormat="R8UI",this.occupancyMap.unpackAlignment=1,console.timeEnd("textureOccupancyMap"))}textureDistanceMap(){this.computes.distanceMap&&(console.time("textureDistanceMap"),this.distanceMap=this.createTexture(this.computes.distanceMap.array,this.computes.distanceMap.dimensions,po,yi,cn,cn),this.distanceMap.internalFormat="R8UI",this.distanceMap.unpackAlignment=1,console.timeEnd("textureDistanceMap"))}textureAnisotropicDistanceMap(){this.computes.anisotropicDistanceMap&&(console.time("textureAnisotropicDistanceMap"),this.anisotropicDistanceMap=this.createTexture(this.computes.anisotropicDistanceMap.array,this.computes.anisotropicDistanceMap.dimensions,po,yi,cn,cn),this.anisotropicDistanceMap.internalFormat="R8UI",this.anisotropicDistanceMap.unpackAlignment=1,console.timeEnd("textureAnisotropicDistanceMap"))}textureExtendedAnisotropicDistanceMap(){this.computes.extendedAnisotropicDistanceMap&&(console.time("textureExtendedAnisotropicDistanceMap"),this.extendedAnisotropicDistanceMap=this.createTexture(this.computes.extendedAnisotropicDistanceMap.array,this.computes.extendedAnisotropicDistanceMap.dimensions,po,wo,cn,cn),this.extendedAnisotropicDistanceMap.internalFormat="R16UI",this.extendedAnisotropicDistanceMap.unpackAlignment=1,console.timeEnd("textureExtendedAnisotropicDistanceMap"))}destroy(){this.colorMaps&&(this.colorMaps.dispose(),this.colorMaps=null),this.intensityMap&&(this.intensityMap.dispose(),this.intensityMap=null),this.trilaplacianIntensityMap&&(this.trilaplacianIntensityMap.dispose(),this.trilaplacianIntensityMap=null),this.occupancyMap&&(this.occupancyMap.dispose(),this.occupancyMap=null),this.distanceMap&&(this.distanceMap.dispose(),this.distanceMap=null),this.anisotropicDistanceMap&&(this.anisotropicDistanceMap.dispose(),this.anisotropicDistanceMap=null),this.extendedAnisotropicDistanceMap&&(this.extendedAnisotropicDistanceMap.dispose(),this.extendedAnisotropicDistanceMap=null),this.viewer=null,this.resources=null,this.computes=null,console.log("ISOTextures destroyed.")}createTexture(e,t,r,i,s,a){const o=new pE(e,...t);return o.format=r,o.type=i,o.minFilter=s,o.magFilter=a,o.generateMipmaps=!1,o.needsUpdate=!0,o.bytes=this.sizeTexture(o),o}sizeTexture(e){const t=e.type==pi?4:e.type==Us||e.type==wo?2:1;return e.image.data.length*t}}const kc=class kc extends Js{constructor(){if(super(),kc.instance)return kc.instance;kc.instance=this,this.experience=new Uo,this.scene=this.experience.scene,this.resources=this.experience.resources,this.renderer=this.experience.renderer,this.camera=this.experience.camera,this.sizes=this.experience.sizes,this.debug=this.experience.debug,this.material=bP(),this.computes=new $oe,this.textures=new Uoe,this.textures.on("ready",()=>{this.setGeometry(),this.setMaterial(),this.setMesh(),this.gui=new _P,this.trigger("ready"),console.log("ISOViewer",this)})}setGeometry(){this.geometry=new gl(1,1,1)}setMaterial(){const e=this.material.uniforms,t=this.computes.intensityMap,r=this.computes.distanceMap;e.u_textures.value.colormaps=this.textures.colorMaps,e.u_textures.value.trilinear_volume=this.textures.intensityMap,e.u_textures.value.tricubic_volume=this.textures.trilaplacianIntensityMap,e.u_textures.value.occupancy=this.textures.occupancyMap,e.u_textures.value.isotropic_distance=this.textures.distanceMap,e.u_textures.value.anisotropic_distance=this.textures.anisotropicDistanceMap,e.u_textures.value.extended_distance=this.textures.extendedAnisotropicDistanceMap,e.u_volume.value.dimensions.copy(t.dimensions),e.u_volume.value.inv_dimensions.copy(t.invDimensions),e.u_volume.value.blocks.copy(r.dimensions),e.u_volume.value.spacing.copy(t.spacing),e.u_volume.value.size.copy(t.dimensions).multiply(t.spacing),e.u_volume.value.anisotropy.copy(t.spacing).normalize(),e.u_volume.value.stride=r.stride;const i=new lt().makeScale(...t.dimensions),s=new lt().makeTranslation(.5,.5,.5);e.u_volume.value.grid_matrix.multiplyMatrices(i,s);const a=this.material.defines;a.MAX_CELLS=t.dimensions.toArray().reduce((o,c)=>o+c,0),a.MAX_BLOCKS=r.dimensions.toArray().reduce((o,c)=>o+c,0),a.MAX_TRACES=a.MAX_CELLS*5,a.MAX_CELLS_PER_BLOCK=r.stride*3,a.MAX_TRACES_PER_BLOCK=a.MAX_CELLS_PER_BLOCK*5,a.MAX_GROUPS=Math.ceil(a.MAX_CELLS/a.MAX_CELLS_PER_BLOCK),a.MAX_BLOCKS_PER_GROUP=Math.ceil(a.MAX_BLOCKS/a.MAX_GROUPS)}setMesh(){const e=this.computes.intensityMap.size;this.mesh=new gr(this.geometry,this.material),this.mesh.scale.copy(e),this.scene.add(this.mesh)}async onThresholdChange(e){const t=this.material.uniforms;t.u_rendering.value.isovalue=e,await this.computes.onThresholdChange(),await this.textures.onThresholdChange()}async onStrideChange(e){const t=this.material.uniforms;t.u_distance_map.value.stride=e,await this.computes.onStrideChange(),await this.textures.onStrideChange(),t.u_textures.value.occupancy=this.textures.occupancyMap,t.u_textures.value.isotropic_distance=this.textures.distanceMap,t.u_textures.value.anisotropic_distance=this.textures.anisotropicDistanceMap,t.u_textures.value.extended_distance=this.textures.extendedAnisotropicDistanceMap,t.u_volume.value.blocks.copy(this.computes.distanceMap.dimensions),t.u_volume.value.stride=this.computes.distanceMap.stride;const r=this.material.defines;r.MAX_CELLS=this.computes.intensityMap.dimensions.toArray().reduce((i,s)=>i+s,0),r.MAX_BLOCKS=this.computes.distanceMap.dimensions.toArray().reduce((i,s)=>i+s,0),r.MAX_TRACES=r.MAX_CELLS*5,r.MAX_CELLS_PER_BLOCK=this.computes.distanceMap.stride*3,r.MAX_TRACES_PER_BLOCK=r.MAX_CELLS_PER_BLOCK*5,r.MAX_GROUPS=Math.ceil(r.MAX_CELLS/r.MAX_CELLS_PER_BLOCK),r.MAX_BLOCKS_PER_GROUP=Math.ceil(r.MAX_BLOCKS/r.MAX_GROUPS),this.material.needsUpdate=!0}async onInterpolationChange(e){this.material.defines.INTERPOLATION_METHOD=e,await this.computes.onInterpolationChange(),await this.textures.onInterpolationChange(),this.material.needsUpdate=!0}destroy(){this.computes&&(this.computes.destroy(),this.computes=null),this.textures&&(this.textures.destroy(),this.textures=null),this.mesh&&(this.scene.remove(this.mesh),this.mesh.geometry.dispose(),this.mesh.material.dispose(),this.mesh=null),this.gui&&(this.gui.destroy(),this.gui=null),this.scene=null,this.resources=null,this.renderer=null,this.camera=null,this.sizes=null,this.debug=null,console.log("ISOViewer destroyed")}};re(kc,"instance",null);let dl=kc;class Boe extends Js{constructor(){super(),this.experience=new Uo,this.scene=this.experience.scene,this.resources=this.experience.resources,this.camera=this.experience.camera,this.viewer=new dl,this.viewer.on("ready",()=>{this.camera.instance.position.copy(this.viewer.computes.intensityMap.size),this.trigger("ready")})}destroy(){this.disposeScene(),this.viewer&&(this.viewer.destroy(),this.viewer=null),this.scene=null,this.camera=null,this.resources=null,this.experience=null,console.log("World destroyed")}disposeScene(){this.scene.traverse(e=>{if(e instanceof gr){e.geometry.dispose();for(const t in e.material){const r=e.material[t];r&&typeof r.dispose=="function"&&r.dispose()}}})}}function Vw(n,e){if(e===XR)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),n;if(e===Gg||e===cE){let t=n.getIndex();if(t===null){const a=[],o=n.getAttribute("position");if(o!==void 0){for(let c=0;c<o.count;c++)a.push(c);n.setIndex(a),t=n.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),n}const r=t.count-2,i=[];if(e===Gg)for(let a=1;a<=r;a++)i.push(t.getX(0)),i.push(t.getX(a)),i.push(t.getX(a+1));else for(let a=0;a<r;a++)a%2===0?(i.push(t.getX(a)),i.push(t.getX(a+1)),i.push(t.getX(a+2))):(i.push(t.getX(a+2)),i.push(t.getX(a+1)),i.push(t.getX(a)));i.length/3!==r&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=n.clone();return s.setIndex(i),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),n}class Voe extends Fa{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(t){return new Xoe(t)}),this.register(function(t){return new Koe(t)}),this.register(function(t){return new rce(t)}),this.register(function(t){return new ice(t)}),this.register(function(t){return new sce(t)}),this.register(function(t){return new Yoe(t)}),this.register(function(t){return new Zoe(t)}),this.register(function(t){return new Qoe(t)}),this.register(function(t){return new Joe(t)}),this.register(function(t){return new qoe(t)}),this.register(function(t){return new ece(t)}),this.register(function(t){return new joe(t)}),this.register(function(t){return new nce(t)}),this.register(function(t){return new tce(t)}),this.register(function(t){return new Hoe(t)}),this.register(function(t){return new ace(t)}),this.register(function(t){return new oce(t)})}load(e,t,r,i){const s=this;let a;if(this.resourcePath!=="")a=this.resourcePath;else if(this.path!==""){const l=gu.extractUrlBase(e);a=gu.resolveURL(l,this.path)}else a=gu.extractUrlBase(e);this.manager.itemStart(e);const o=function(l){i?i(l):console.error(l),s.manager.itemError(e),s.manager.itemEnd(e)},c=new h0(this.manager);c.setPath(this.path),c.setResponseType("arraybuffer"),c.setRequestHeader(this.requestHeader),c.setWithCredentials(this.withCredentials),c.load(e,function(l){try{s.parse(l,a,function(u){t(u),s.manager.itemEnd(e)},o)}catch(u){o(u)}},r,o)}setDRACOLoader(e){return this.dracoLoader=e,this}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,t,r,i){let s;const a={},o={},c=new TextDecoder;if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(c.decode(new Uint8Array(e,0,4))===SM){try{a[Ct.KHR_BINARY_GLTF]=new cce(e)}catch(f){i&&i(f);return}s=JSON.parse(a[Ct.KHR_BINARY_GLTF].content)}else s=JSON.parse(c.decode(e));else s=e;if(s.asset===void 0||s.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new yce(s,{path:t||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let u=0;u<this.pluginCallbacks.length;u++){const f=this.pluginCallbacks[u](l);f.name||console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),o[f.name]=f,a[f.name]=!0}if(s.extensionsUsed)for(let u=0;u<s.extensionsUsed.length;++u){const f=s.extensionsUsed[u],d=s.extensionsRequired||[];switch(f){case Ct.KHR_MATERIALS_UNLIT:a[f]=new Woe;break;case Ct.KHR_DRACO_MESH_COMPRESSION:a[f]=new lce(s,this.dracoLoader);break;case Ct.KHR_TEXTURE_TRANSFORM:a[f]=new uce;break;case Ct.KHR_MESH_QUANTIZATION:a[f]=new fce;break;default:d.indexOf(f)>=0&&o[f]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+f+'".')}}l.setExtensions(a),l.setPlugins(o),l.parse(r,i)}parseAsync(e,t){const r=this;return new Promise(function(i,s){r.parse(e,t,i,s)})}}function Goe(){let n={};return{get:function(e){return n[e]},add:function(e,t){n[e]=t},remove:function(e){delete n[e]},removeAll:function(){n={}}}}const Ct={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_DISPERSION:"KHR_materials_dispersion",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_MATERIALS_BUMP:"EXT_materials_bump",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class Hoe{constructor(e){this.parser=e,this.name=Ct.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,t=this.parser.json.nodes||[];for(let r=0,i=t.length;r<i;r++){const s=t[r];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const t=this.parser,r="light:"+e;let i=t.cache.get(r);if(i)return i;const s=t.json,c=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let l;const u=new ht(16777215);c.color!==void 0&&u.setRGB(c.color[0],c.color[1],c.color[2],rr);const f=c.range!==void 0?c.range:0;switch(c.type){case"directional":l=new oz(u),l.target.position.set(0,0,-1),l.add(l.target);break;case"point":l=new sz(u),l.distance=f;break;case"spot":l=new rz(u),l.distance=f,c.spot=c.spot||{},c.spot.innerConeAngle=c.spot.innerConeAngle!==void 0?c.spot.innerConeAngle:0,c.spot.outerConeAngle=c.spot.outerConeAngle!==void 0?c.spot.outerConeAngle:Math.PI/4,l.angle=c.spot.outerConeAngle,l.penumbra=1-c.spot.innerConeAngle/c.spot.outerConeAngle,l.target.position.set(0,0,-1),l.add(l.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+c.type)}return l.position.set(0,0,0),l.decay=2,Ls(l,c),c.intensity!==void 0&&(l.intensity=c.intensity),l.name=t.createUniqueName(c.name||"light_"+e),i=Promise.resolve(l),t.cache.add(r,i),i}getDependency(e,t){if(e==="light")return this._loadLight(t)}createNodeAttachment(e){const t=this,r=this.parser,s=r.json.nodes[e],o=(s.extensions&&s.extensions[this.name]||{}).light;return o===void 0?null:this._loadLight(o).then(function(c){return r._getNodeRef(t.cache,o,c)})}}class Woe{constructor(){this.name=Ct.KHR_MATERIALS_UNLIT}getMaterialType(){return xa}extendParams(e,t,r){const i=[];e.color=new ht(1,1,1),e.opacity=1;const s=t.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const a=s.baseColorFactor;e.color.setRGB(a[0],a[1],a[2],rr),e.opacity=a[3]}s.baseColorTexture!==void 0&&i.push(r.assignTexture(e,"map",s.baseColorTexture,Xn))}return Promise.all(i)}}class qoe{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name].emissiveStrength;return s!==void 0&&(t.emissiveIntensity=s),Promise.resolve()}}class Xoe{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];if(a.clearcoatFactor!==void 0&&(t.clearcoat=a.clearcoatFactor),a.clearcoatTexture!==void 0&&s.push(r.assignTexture(t,"clearcoatMap",a.clearcoatTexture)),a.clearcoatRoughnessFactor!==void 0&&(t.clearcoatRoughness=a.clearcoatRoughnessFactor),a.clearcoatRoughnessTexture!==void 0&&s.push(r.assignTexture(t,"clearcoatRoughnessMap",a.clearcoatRoughnessTexture)),a.clearcoatNormalTexture!==void 0&&(s.push(r.assignTexture(t,"clearcoatNormalMap",a.clearcoatNormalTexture)),a.clearcoatNormalTexture.scale!==void 0)){const o=a.clearcoatNormalTexture.scale;t.clearcoatNormalScale=new Ye(o,o)}return Promise.all(s)}}class Koe{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_DISPERSION}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return t.dispersion=s.dispersion!==void 0?s.dispersion:0,Promise.resolve()}}class joe{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.iridescenceFactor!==void 0&&(t.iridescence=a.iridescenceFactor),a.iridescenceTexture!==void 0&&s.push(r.assignTexture(t,"iridescenceMap",a.iridescenceTexture)),a.iridescenceIor!==void 0&&(t.iridescenceIOR=a.iridescenceIor),t.iridescenceThicknessRange===void 0&&(t.iridescenceThicknessRange=[100,400]),a.iridescenceThicknessMinimum!==void 0&&(t.iridescenceThicknessRange[0]=a.iridescenceThicknessMinimum),a.iridescenceThicknessMaximum!==void 0&&(t.iridescenceThicknessRange[1]=a.iridescenceThicknessMaximum),a.iridescenceThicknessTexture!==void 0&&s.push(r.assignTexture(t,"iridescenceThicknessMap",a.iridescenceThicknessTexture)),Promise.all(s)}}class Yoe{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_SHEEN}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[];t.sheenColor=new ht(0,0,0),t.sheenRoughness=0,t.sheen=1;const a=i.extensions[this.name];if(a.sheenColorFactor!==void 0){const o=a.sheenColorFactor;t.sheenColor.setRGB(o[0],o[1],o[2],rr)}return a.sheenRoughnessFactor!==void 0&&(t.sheenRoughness=a.sheenRoughnessFactor),a.sheenColorTexture!==void 0&&s.push(r.assignTexture(t,"sheenColorMap",a.sheenColorTexture,Xn)),a.sheenRoughnessTexture!==void 0&&s.push(r.assignTexture(t,"sheenRoughnessMap",a.sheenRoughnessTexture)),Promise.all(s)}}class Zoe{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.transmissionFactor!==void 0&&(t.transmission=a.transmissionFactor),a.transmissionTexture!==void 0&&s.push(r.assignTexture(t,"transmissionMap",a.transmissionTexture)),Promise.all(s)}}class Qoe{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_VOLUME}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];t.thickness=a.thicknessFactor!==void 0?a.thicknessFactor:0,a.thicknessTexture!==void 0&&s.push(r.assignTexture(t,"thicknessMap",a.thicknessTexture)),t.attenuationDistance=a.attenuationDistance||1/0;const o=a.attenuationColor||[1,1,1];return t.attenuationColor=new ht().setRGB(o[0],o[1],o[2],rr),Promise.all(s)}}class Joe{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_IOR}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return t.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class ece{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_SPECULAR}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];t.specularIntensity=a.specularFactor!==void 0?a.specularFactor:1,a.specularTexture!==void 0&&s.push(r.assignTexture(t,"specularIntensityMap",a.specularTexture));const o=a.specularColorFactor||[1,1,1];return t.specularColor=new ht().setRGB(o[0],o[1],o[2],rr),a.specularColorTexture!==void 0&&s.push(r.assignTexture(t,"specularColorMap",a.specularColorTexture,Xn)),Promise.all(s)}}class tce{constructor(e){this.parser=e,this.name=Ct.EXT_MATERIALS_BUMP}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return t.bumpScale=a.bumpFactor!==void 0?a.bumpFactor:1,a.bumpTexture!==void 0&&s.push(r.assignTexture(t,"bumpMap",a.bumpTexture)),Promise.all(s)}}class nce{constructor(e){this.parser=e,this.name=Ct.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Es}extendMaterialParams(e,t){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],a=i.extensions[this.name];return a.anisotropyStrength!==void 0&&(t.anisotropy=a.anisotropyStrength),a.anisotropyRotation!==void 0&&(t.anisotropyRotation=a.anisotropyRotation),a.anisotropyTexture!==void 0&&s.push(r.assignTexture(t,"anisotropyMap",a.anisotropyTexture)),Promise.all(s)}}class rce{constructor(e){this.parser=e,this.name=Ct.KHR_TEXTURE_BASISU}loadTexture(e){const t=this.parser,r=t.json,i=r.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],a=t.options.ktx2Loader;if(!a){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return t.loadTextureImage(e,s.source,a)}}class ice{constructor(e){this.parser=e,this.name=Ct.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const t=this.name,r=this.parser,i=r.json,s=i.textures[e];if(!s.extensions||!s.extensions[t])return null;const a=s.extensions[t],o=i.images[a.source];let c=r.textureLoader;if(o.uri){const l=r.options.manager.getHandler(o.uri);l!==null&&(c=l)}return this.detectSupport().then(function(l){if(l)return r.loadTextureImage(e,a.source,c);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class sce{constructor(e){this.parser=e,this.name=Ct.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const t=this.name,r=this.parser,i=r.json,s=i.textures[e];if(!s.extensions||!s.extensions[t])return null;const a=s.extensions[t],o=i.images[a.source];let c=r.textureLoader;if(o.uri){const l=r.options.manager.getHandler(o.uri);l!==null&&(c=l)}return this.detectSupport().then(function(l){if(l)return r.loadTextureImage(e,a.source,c);if(i.extensionsRequired&&i.extensionsRequired.indexOf(t)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return r.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const t=new Image;t.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",t.onload=t.onerror=function(){e(t.height===1)}})),this.isSupported}}class ace{constructor(e){this.name=Ct.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const t=this.parser.json,r=t.bufferViews[e];if(r.extensions&&r.extensions[this.name]){const i=r.extensions[this.name],s=this.parser.getDependency("buffer",i.buffer),a=this.parser.options.meshoptDecoder;if(!a||!a.supported){if(t.extensionsRequired&&t.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(o){const c=i.byteOffset||0,l=i.byteLength||0,u=i.count,f=i.byteStride,d=new Uint8Array(o,c,l);return a.decodeGltfBufferAsync?a.decodeGltfBufferAsync(u,f,d,i.mode,i.filter).then(function(h){return h.buffer}):a.ready.then(function(){const h=new ArrayBuffer(u*f);return a.decodeGltfBuffer(new Uint8Array(h),u,f,d,i.mode,i.filter),h})})}else return null}}class oce{constructor(e){this.name=Ct.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const t=this.parser.json,r=t.nodes[e];if(!r.extensions||!r.extensions[this.name]||r.mesh===void 0)return null;const i=t.meshes[r.mesh];for(const l of i.primitives)if(l.mode!==di.TRIANGLES&&l.mode!==di.TRIANGLE_STRIP&&l.mode!==di.TRIANGLE_FAN&&l.mode!==void 0)return null;const a=r.extensions[this.name].attributes,o=[],c={};for(const l in a)o.push(this.parser.getDependency("accessor",a[l]).then(u=>(c[l]=u,c[l])));return o.length<1?null:(o.push(this.parser.createNodeMesh(e)),Promise.all(o).then(l=>{const u=l.pop(),f=u.isGroup?u.children:[u],d=l[0].count,h=[];for(const p of f){const g=new lt,m=new $,v=new Xi,x=new $(1,1,1),b=new $O(p.geometry,p.material,d);for(let _=0;_<d;_++)c.TRANSLATION&&m.fromBufferAttribute(c.TRANSLATION,_),c.ROTATION&&v.fromBufferAttribute(c.ROTATION,_),c.SCALE&&x.fromBufferAttribute(c.SCALE,_),b.setMatrixAt(_,g.compose(m,v,x));for(const _ in c)if(_==="_COLOR_0"){const w=c[_];b.instanceColor=new Xg(w.array,w.itemSize,w.normalized)}else _!=="TRANSLATION"&&_!=="ROTATION"&&_!=="SCALE"&&p.geometry.setAttribute(_,c[_]);mn.prototype.copy.call(b,p),this.parser.assignFinalMaterial(b),h.push(b)}return u.isGroup?(u.clear(),u.add(...h),u):h[0]}))}}const SM="glTF",au=12,Gw={JSON:1313821514,BIN:5130562};class cce{constructor(e){this.name=Ct.KHR_BINARY_GLTF,this.content=null,this.body=null;const t=new DataView(e,0,au),r=new TextDecoder;if(this.header={magic:r.decode(new Uint8Array(e.slice(0,4))),version:t.getUint32(4,!0),length:t.getUint32(8,!0)},this.header.magic!==SM)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const i=this.header.length-au,s=new DataView(e,au);let a=0;for(;a<i;){const o=s.getUint32(a,!0);a+=4;const c=s.getUint32(a,!0);if(a+=4,c===Gw.JSON){const l=new Uint8Array(e,au+a,o);this.content=r.decode(l)}else if(c===Gw.BIN){const l=au+a;this.body=e.slice(l,l+o)}a+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class lce{constructor(e,t){if(!t)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Ct.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=t,this.dracoLoader.preload()}decodePrimitive(e,t){const r=this.json,i=this.dracoLoader,s=e.extensions[this.name].bufferView,a=e.extensions[this.name].attributes,o={},c={},l={};for(const u in a){const f=Px[u]||u.toLowerCase();o[f]=a[u]}for(const u in e.attributes){const f=Px[u]||u.toLowerCase();if(a[u]!==void 0){const d=r.accessors[e.attributes[u]],h=Vc[d.componentType];l[f]=h.name,c[f]=d.normalized===!0}}return t.getDependency("bufferView",s).then(function(u){return new Promise(function(f,d){i.decodeDracoFile(u,function(h){for(const p in h.attributes){const g=h.attributes[p],m=c[p];m!==void 0&&(g.normalized=m)}f(h)},o,l,rr,d)})})}}class uce{constructor(){this.name=Ct.KHR_TEXTURE_TRANSFORM}extendTexture(e,t){return(t.texCoord===void 0||t.texCoord===e.channel)&&t.offset===void 0&&t.rotation===void 0&&t.scale===void 0||(e=e.clone(),t.texCoord!==void 0&&(e.channel=t.texCoord),t.offset!==void 0&&e.offset.fromArray(t.offset),t.rotation!==void 0&&(e.rotation=t.rotation),t.scale!==void 0&&e.repeat.fromArray(t.scale),e.needsUpdate=!0),e}}class fce{constructor(){this.name=Ct.KHR_MESH_QUANTIZATION}}class TM extends Vu{constructor(e,t,r,i){super(e,t,r,i)}copySampleValue_(e){const t=this.resultBuffer,r=this.sampleValues,i=this.valueSize,s=e*i*3+i;for(let a=0;a!==i;a++)t[a]=r[s+a];return t}interpolate_(e,t,r,i){const s=this.resultBuffer,a=this.sampleValues,o=this.valueSize,c=o*2,l=o*3,u=i-t,f=(r-t)/u,d=f*f,h=d*f,p=e*l,g=p-l,m=-2*h+3*d,v=h-d,x=1-m,b=v-d+f;for(let _=0;_!==o;_++){const w=a[g+_+o],E=a[g+_+c]*u,S=a[p+_+o],T=a[p+_]*u;s[_]=x*w+b*E+m*S+v*T}return s}}const dce=new Xi;class hce extends TM{interpolate_(e,t,r,i){const s=super.interpolate_(e,t,r,i);return dce.fromArray(s).normalize().toArray(s),s}}const di={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Vc={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},Hw={9728:cn,9729:Rn,9984:Jw,9985:uh,9986:ou,9987:$s},Ww={33071:Fs,33648:Eh,10497:qc},ng={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},Px={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3",COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},ha={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},pce={CUBICSPLINE:void 0,LINEAR:yu,STEP:_u},rg={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function mce(n){return n.DefaultMaterial===void 0&&(n.DefaultMaterial=new d0({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Ws})),n.DefaultMaterial}function so(n,e,t){for(const r in t.extensions)n[r]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[r]=t.extensions[r])}function Ls(n,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(n.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function vce(n,e,t){let r=!1,i=!1,s=!1;for(let l=0,u=e.length;l<u;l++){const f=e[l];if(f.POSITION!==void 0&&(r=!0),f.NORMAL!==void 0&&(i=!0),f.COLOR_0!==void 0&&(s=!0),r&&i&&s)break}if(!r&&!i&&!s)return Promise.resolve(n);const a=[],o=[],c=[];for(let l=0,u=e.length;l<u;l++){const f=e[l];if(r){const d=f.POSITION!==void 0?t.getDependency("accessor",f.POSITION):n.attributes.position;a.push(d)}if(i){const d=f.NORMAL!==void 0?t.getDependency("accessor",f.NORMAL):n.attributes.normal;o.push(d)}if(s){const d=f.COLOR_0!==void 0?t.getDependency("accessor",f.COLOR_0):n.attributes.color;c.push(d)}}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(c)]).then(function(l){const u=l[0],f=l[1],d=l[2];return r&&(n.morphAttributes.position=u),i&&(n.morphAttributes.normal=f),s&&(n.morphAttributes.color=d),n.morphTargetsRelative=!0,n})}function gce(n,e){if(n.updateMorphTargets(),e.weights!==void 0)for(let t=0,r=e.weights.length;t<r;t++)n.morphTargetInfluences[t]=e.weights[t];if(e.extras&&Array.isArray(e.extras.targetNames)){const t=e.extras.targetNames;if(n.morphTargetInfluences.length===t.length){n.morphTargetDictionary={};for(let r=0,i=t.length;r<i;r++)n.morphTargetDictionary[t[r]]=r}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function xce(n){let e;const t=n.extensions&&n.extensions[Ct.KHR_DRACO_MESH_COMPRESSION];if(t?e="draco:"+t.bufferView+":"+t.indices+":"+ig(t.attributes):e=n.indices+":"+ig(n.attributes)+":"+n.mode,n.targets!==void 0)for(let r=0,i=n.targets.length;r<i;r++)e+=":"+ig(n.targets[r]);return e}function ig(n){let e="";const t=Object.keys(n).sort();for(let r=0,i=t.length;r<i;r++)e+=t[r]+":"+n[t[r]]+";";return e}function Fx(n){switch(n){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function bce(n){return n.search(/\.jpe?g($|\?)/i)>0||n.search(/^data\:image\/jpeg/)===0?"image/jpeg":n.search(/\.webp($|\?)/i)>0||n.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const _ce=new lt;class yce{constructor(e={},t={}){this.json=e,this.extensions={},this.plugins={},this.options=t,this.cache=new Goe,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let r=!1,i=-1,s=!1,a=-1;if(typeof navigator<"u"){const o=navigator.userAgent;r=/^((?!chrome|android).)*safari/i.test(o)===!0;const c=o.match(/Version\/(\d+)/);i=r&&c?parseInt(c[1],10):-1,s=o.indexOf("Firefox")>-1,a=s?o.match(/Firefox\/([0-9]+)\./)[1]:-1}typeof createImageBitmap>"u"||r&&i<17||s&&a<98?this.textureLoader=new DE(this.options.manager):this.textureLoader=new cz(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new h0(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,t){const r=this,i=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(a){return a._markDefs&&a._markDefs()}),Promise.all(this._invokeAll(function(a){return a.beforeRoot&&a.beforeRoot()})).then(function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])}).then(function(a){const o={scene:a[0][i.scene||0],scenes:a[0],animations:a[1],cameras:a[2],asset:i.asset,parser:r,userData:{}};return so(s,o,i),Ls(o,i),Promise.all(r._invokeAll(function(c){return c.afterRoot&&c.afterRoot(o)})).then(function(){for(const c of o.scenes)c.updateMatrixWorld();e(o)})}).catch(t)}_markDefs(){const e=this.json.nodes||[],t=this.json.skins||[],r=this.json.meshes||[];for(let i=0,s=t.length;i<s;i++){const a=t[i].joints;for(let o=0,c=a.length;o<c;o++)e[a[o]].isBone=!0}for(let i=0,s=e.length;i<s;i++){const a=e[i];a.mesh!==void 0&&(this._addNodeRef(this.meshCache,a.mesh),a.skin!==void 0&&(r[a.mesh].isSkinnedMesh=!0)),a.camera!==void 0&&this._addNodeRef(this.cameraCache,a.camera)}}_addNodeRef(e,t){t!==void 0&&(e.refs[t]===void 0&&(e.refs[t]=e.uses[t]=0),e.refs[t]++)}_getNodeRef(e,t,r){if(e.refs[t]<=1)return r;const i=r.clone(),s=(a,o)=>{const c=this.associations.get(a);c!=null&&this.associations.set(o,c);for(const[l,u]of a.children.entries())s(u,o.children[l])};return s(r,i),i.name+="_instance_"+e.uses[t]++,i}_invokeOne(e){const t=Object.values(this.plugins);t.push(this);for(let r=0;r<t.length;r++){const i=e(t[r]);if(i)return i}return null}_invokeAll(e){const t=Object.values(this.plugins);t.unshift(this);const r=[];for(let i=0;i<t.length;i++){const s=e(t[i]);s&&r.push(s)}return r}getDependency(e,t){const r=e+":"+t;let i=this.cache.get(r);if(!i){switch(e){case"scene":i=this.loadScene(t);break;case"node":i=this._invokeOne(function(s){return s.loadNode&&s.loadNode(t)});break;case"mesh":i=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(t)});break;case"accessor":i=this.loadAccessor(t);break;case"bufferView":i=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(t)});break;case"buffer":i=this.loadBuffer(t);break;case"material":i=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(t)});break;case"texture":i=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(t)});break;case"skin":i=this.loadSkin(t);break;case"animation":i=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(t)});break;case"camera":i=this.loadCamera(t);break;default:if(i=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,t)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(r,i)}return i}getDependencies(e){let t=this.cache.get(e);if(!t){const r=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];t=Promise.all(i.map(function(s,a){return r.getDependency(e,a)})),this.cache.add(e,t)}return t}loadBuffer(e){const t=this.json.buffers[e],r=this.fileLoader;if(t.type&&t.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+t.type+" buffer type is not supported.");if(t.uri===void 0&&e===0)return Promise.resolve(this.extensions[Ct.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(s,a){r.load(gu.resolveURL(t.uri,i.path),s,void 0,function(){a(new Error('THREE.GLTFLoader: Failed to load buffer "'+t.uri+'".'))})})}loadBufferView(e){const t=this.json.bufferViews[e];return this.getDependency("buffer",t.buffer).then(function(r){const i=t.byteLength||0,s=t.byteOffset||0;return r.slice(s,s+i)})}loadAccessor(e){const t=this,r=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const a=ng[i.type],o=Vc[i.componentType],c=i.normalized===!0,l=new o(i.count*a);return Promise.resolve(new Mr(l,a,c))}const s=[];return i.bufferView!==void 0?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),i.sparse!==void 0&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then(function(a){const o=a[0],c=ng[i.type],l=Vc[i.componentType],u=l.BYTES_PER_ELEMENT,f=u*c,d=i.byteOffset||0,h=i.bufferView!==void 0?r.bufferViews[i.bufferView].byteStride:void 0,p=i.normalized===!0;let g,m;if(h&&h!==f){const v=Math.floor(d/h),x="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+v+":"+i.count;let b=t.cache.get(x);b||(g=new l(o,v*h,i.count*h/u),b=new LO(g,h/u),t.cache.add(x,b)),m=new l0(b,c,d%h/u,p)}else o===null?g=new l(i.count*c):g=new l(o,d,i.count*c),m=new Mr(g,c,p);if(i.sparse!==void 0){const v=ng.SCALAR,x=Vc[i.sparse.indices.componentType],b=i.sparse.indices.byteOffset||0,_=i.sparse.values.byteOffset||0,w=new x(a[1],b,i.sparse.count*v),E=new l(a[2],_,i.sparse.count*c);o!==null&&(m=new Mr(m.array.slice(),m.itemSize,m.normalized)),m.normalized=!1;for(let S=0,T=w.length;S<T;S++){const C=w[S];if(m.setX(C,E[S*c]),c>=2&&m.setY(C,E[S*c+1]),c>=3&&m.setZ(C,E[S*c+2]),c>=4&&m.setW(C,E[S*c+3]),c>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}m.normalized=p}return m})}loadTexture(e){const t=this.json,r=this.options,s=t.textures[e].source,a=t.images[s];let o=this.textureLoader;if(a.uri){const c=r.manager.getHandler(a.uri);c!==null&&(o=c)}return this.loadTextureImage(e,s,o)}loadTextureImage(e,t,r){const i=this,s=this.json,a=s.textures[e],o=s.images[t],c=(o.uri||o.bufferView)+":"+a.sampler;if(this.textureCache[c])return this.textureCache[c];const l=this.loadImageSource(t,r).then(function(u){u.flipY=!1,u.name=a.name||o.name||"",u.name===""&&typeof o.uri=="string"&&o.uri.startsWith("data:image/")===!1&&(u.name=o.uri);const d=(s.samplers||{})[a.sampler]||{};return u.magFilter=Hw[d.magFilter]||Rn,u.minFilter=Hw[d.minFilter]||$s,u.wrapS=Ww[d.wrapS]||qc,u.wrapT=Ww[d.wrapT]||qc,i.associations.set(u,{textures:e}),u}).catch(function(){return null});return this.textureCache[c]=l,l}loadImageSource(e,t){const r=this,i=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(f=>f.clone());const a=i.images[e],o=self.URL||self.webkitURL;let c=a.uri||"",l=!1;if(a.bufferView!==void 0)c=r.getDependency("bufferView",a.bufferView).then(function(f){l=!0;const d=new Blob([f],{type:a.mimeType});return c=o.createObjectURL(d),c});else if(a.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const u=Promise.resolve(c).then(function(f){return new Promise(function(d,h){let p=d;t.isImageBitmapLoader===!0&&(p=function(g){const m=new Vn(g);m.needsUpdate=!0,d(m)}),t.load(gu.resolveURL(f,s.path),p,void 0,h)})}).then(function(f){return l===!0&&o.revokeObjectURL(c),Ls(f,a),f.userData.mimeType=a.mimeType||bce(a.uri),f}).catch(function(f){throw console.error("THREE.GLTFLoader: Couldn't load texture",c),f});return this.sourceCache[e]=u,u}assignTexture(e,t,r,i){const s=this;return this.getDependency("texture",r.index).then(function(a){if(!a)return null;if(r.texCoord!==void 0&&r.texCoord>0&&(a=a.clone(),a.channel=r.texCoord),s.extensions[Ct.KHR_TEXTURE_TRANSFORM]){const o=r.extensions!==void 0?r.extensions[Ct.KHR_TEXTURE_TRANSFORM]:void 0;if(o){const c=s.associations.get(a);a=s.extensions[Ct.KHR_TEXTURE_TRANSFORM].extendTexture(a,o),s.associations.set(a,c)}}return i!==void 0&&(a.colorSpace=i),e[t]=a,a})}assignFinalMaterial(e){const t=e.geometry;let r=e.material;const i=t.attributes.tangent===void 0,s=t.attributes.color!==void 0,a=t.attributes.normal===void 0;if(e.isPoints){const o="PointsMaterial:"+r.uuid;let c=this.cache.get(o);c||(c=new ME,cs.prototype.copy.call(c,r),c.color.copy(r.color),c.map=r.map,c.sizeAttenuation=!1,this.cache.add(o,c)),r=c}else if(e.isLine){const o="LineBasicMaterial:"+r.uuid;let c=this.cache.get(o);c||(c=new IE,cs.prototype.copy.call(c,r),c.color.copy(r.color),c.map=r.map,this.cache.add(o,c)),r=c}if(i||s||a){let o="ClonedMaterial:"+r.uuid+":";i&&(o+="derivative-tangents:"),s&&(o+="vertex-colors:"),a&&(o+="flat-shading:");let c=this.cache.get(o);c||(c=r.clone(),s&&(c.vertexColors=!0),a&&(c.flatShading=!0),i&&(c.normalScale&&(c.normalScale.y*=-1),c.clearcoatNormalScale&&(c.clearcoatNormalScale.y*=-1)),this.cache.add(o,c),this.associations.set(c,this.associations.get(r))),r=c}e.material=r}getMaterialType(){return d0}loadMaterial(e){const t=this,r=this.json,i=this.extensions,s=r.materials[e];let a;const o={},c=s.extensions||{},l=[];if(c[Ct.KHR_MATERIALS_UNLIT]){const f=i[Ct.KHR_MATERIALS_UNLIT];a=f.getMaterialType(),l.push(f.extendParams(o,s,t))}else{const f=s.pbrMetallicRoughness||{};if(o.color=new ht(1,1,1),o.opacity=1,Array.isArray(f.baseColorFactor)){const d=f.baseColorFactor;o.color.setRGB(d[0],d[1],d[2],rr),o.opacity=d[3]}f.baseColorTexture!==void 0&&l.push(t.assignTexture(o,"map",f.baseColorTexture,Xn)),o.metalness=f.metallicFactor!==void 0?f.metallicFactor:1,o.roughness=f.roughnessFactor!==void 0?f.roughnessFactor:1,f.metallicRoughnessTexture!==void 0&&(l.push(t.assignTexture(o,"metalnessMap",f.metallicRoughnessTexture)),l.push(t.assignTexture(o,"roughnessMap",f.metallicRoughnessTexture))),a=this._invokeOne(function(d){return d.getMaterialType&&d.getMaterialType(e)}),l.push(Promise.all(this._invokeAll(function(d){return d.extendMaterialParams&&d.extendMaterialParams(e,o)})))}s.doubleSided===!0&&(o.side=$i);const u=s.alphaMode||rg.OPAQUE;if(u===rg.BLEND?(o.transparent=!0,o.depthWrite=!1):(o.transparent=!1,u===rg.MASK&&(o.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&a!==xa&&(l.push(t.assignTexture(o,"normalMap",s.normalTexture)),o.normalScale=new Ye(1,1),s.normalTexture.scale!==void 0)){const f=s.normalTexture.scale;o.normalScale.set(f,f)}if(s.occlusionTexture!==void 0&&a!==xa&&(l.push(t.assignTexture(o,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(o.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&a!==xa){const f=s.emissiveFactor;o.emissive=new ht().setRGB(f[0],f[1],f[2],rr)}return s.emissiveTexture!==void 0&&a!==xa&&l.push(t.assignTexture(o,"emissiveMap",s.emissiveTexture,Xn)),Promise.all(l).then(function(){const f=new a(o);return s.name&&(f.name=s.name),Ls(f,s),t.associations.set(f,{materials:e}),s.extensions&&so(i,f,s),f})}createUniqueName(e){const t=Kt.sanitizeNodeName(e||"");return t in this.nodeNamesUsed?t+"_"+ ++this.nodeNamesUsed[t]:(this.nodeNamesUsed[t]=0,t)}loadGeometries(e){const t=this,r=this.extensions,i=this.primitiveCache;function s(o){return r[Ct.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(o,t).then(function(c){return qw(c,o,t)})}const a=[];for(let o=0,c=e.length;o<c;o++){const l=e[o],u=xce(l),f=i[u];if(f)a.push(f.promise);else{let d;l.extensions&&l.extensions[Ct.KHR_DRACO_MESH_COMPRESSION]?d=s(l):d=qw(new ws,l,t),i[u]={primitive:l,promise:d},a.push(d)}}return Promise.all(a)}loadMesh(e){const t=this,r=this.json,i=this.extensions,s=r.meshes[e],a=s.primitives,o=[];for(let c=0,l=a.length;c<l;c++){const u=a[c].material===void 0?mce(this.cache):this.getDependency("material",a[c].material);o.push(u)}return o.push(t.loadGeometries(a)),Promise.all(o).then(function(c){const l=c.slice(0,c.length-1),u=c[c.length-1],f=[];for(let h=0,p=u.length;h<p;h++){const g=u[h],m=a[h];let v;const x=l[h];if(m.mode===di.TRIANGLES||m.mode===di.TRIANGLE_STRIP||m.mode===di.TRIANGLE_FAN||m.mode===void 0)v=s.isSkinnedMesh===!0?new zO(g,x):new gr(g,x),v.isSkinnedMesh===!0&&v.normalizeSkinWeights(),m.mode===di.TRIANGLE_STRIP?v.geometry=Vw(v.geometry,cE):m.mode===di.TRIANGLE_FAN&&(v.geometry=Vw(v.geometry,Gg));else if(m.mode===di.LINES)v=new UO(g,x);else if(m.mode===di.LINE_STRIP)v=new f0(g,x);else if(m.mode===di.LINE_LOOP)v=new BO(g,x);else if(m.mode===di.POINTS)v=new VO(g,x);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+m.mode);Object.keys(v.geometry.morphAttributes).length>0&&gce(v,s),v.name=t.createUniqueName(s.name||"mesh_"+e),Ls(v,s),m.extensions&&so(i,v,m),t.assignFinalMaterial(v),f.push(v)}for(let h=0,p=f.length;h<p;h++)t.associations.set(f[h],{meshes:e,primitives:h});if(f.length===1)return s.extensions&&so(i,f[0],s),f[0];const d=new mo;s.extensions&&so(i,d,s),t.associations.set(d,{meshes:e});for(let h=0,p=f.length;h<p;h++)d.add(f[h]);return d})}loadCamera(e){let t;const r=this.json.cameras[e],i=r[r.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return r.type==="perspective"?t=new Er(Ih.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):r.type==="orthographic"&&(t=new o0(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),r.name&&(t.name=this.createUniqueName(r.name)),Ls(t,r),Promise.resolve(t)}loadSkin(e){const t=this.json.skins[e],r=[];for(let i=0,s=t.joints.length;i<s;i++)r.push(this._loadNodeShallow(t.joints[i]));return t.inverseBindMatrices!==void 0?r.push(this.getDependency("accessor",t.inverseBindMatrices)):r.push(null),Promise.all(r).then(function(i){const s=i.pop(),a=i,o=[],c=[];for(let l=0,u=a.length;l<u;l++){const f=a[l];if(f){o.push(f);const d=new lt;s!==null&&d.fromArray(s.array,l*16),c.push(d)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',t.joints[l])}return new u0(o,c)})}loadAnimation(e){const t=this.json,r=this,i=t.animations[e],s=i.name?i.name:"animation_"+e,a=[],o=[],c=[],l=[],u=[];for(let f=0,d=i.channels.length;f<d;f++){const h=i.channels[f],p=i.samplers[h.sampler],g=h.target,m=g.node,v=i.parameters!==void 0?i.parameters[p.input]:p.input,x=i.parameters!==void 0?i.parameters[p.output]:p.output;g.node!==void 0&&(a.push(this.getDependency("node",m)),o.push(this.getDependency("accessor",v)),c.push(this.getDependency("accessor",x)),l.push(p),u.push(g))}return Promise.all([Promise.all(a),Promise.all(o),Promise.all(c),Promise.all(l),Promise.all(u)]).then(function(f){const d=f[0],h=f[1],p=f[2],g=f[3],m=f[4],v=[];for(let x=0,b=d.length;x<b;x++){const _=d[x],w=h[x],E=p[x],S=g[x],T=m[x];if(_===void 0)continue;_.updateMatrix&&_.updateMatrix();const C=r._createAnimationTracks(_,w,E,S,T);if(C)for(let y=0;y<C.length;y++)v.push(C[y])}return new jO(s,void 0,v)})}createNodeMesh(e){const t=this.json,r=this,i=t.nodes[e];return i.mesh===void 0?null:r.getDependency("mesh",i.mesh).then(function(s){const a=r._getNodeRef(r.meshCache,i.mesh,s);return i.weights!==void 0&&a.traverse(function(o){if(o.isMesh)for(let c=0,l=i.weights.length;c<l;c++)o.morphTargetInfluences[c]=i.weights[c]}),a})}loadNode(e){const t=this.json,r=this,i=t.nodes[e],s=r._loadNodeShallow(e),a=[],o=i.children||[];for(let l=0,u=o.length;l<u;l++)a.push(r.getDependency("node",o[l]));const c=i.skin===void 0?Promise.resolve(null):r.getDependency("skin",i.skin);return Promise.all([s,Promise.all(a),c]).then(function(l){const u=l[0],f=l[1],d=l[2];d!==null&&u.traverse(function(h){h.isSkinnedMesh&&h.bind(d,_ce)});for(let h=0,p=f.length;h<p;h++)u.add(f[h]);return u})}_loadNodeShallow(e){const t=this.json,r=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const s=t.nodes[e],a=s.name?i.createUniqueName(s.name):"",o=[],c=i._invokeOne(function(l){return l.createNodeMesh&&l.createNodeMesh(e)});return c&&o.push(c),s.camera!==void 0&&o.push(i.getDependency("camera",s.camera).then(function(l){return i._getNodeRef(i.cameraCache,s.camera,l)})),i._invokeAll(function(l){return l.createNodeAttachment&&l.createNodeAttachment(e)}).forEach(function(l){o.push(l)}),this.nodeCache[e]=Promise.all(o).then(function(l){let u;if(s.isBone===!0?u=new AE:l.length>1?u=new mo:l.length===1?u=l[0]:u=new mn,u!==l[0])for(let f=0,d=l.length;f<d;f++)u.add(l[f]);if(s.name&&(u.userData.name=s.name,u.name=a),Ls(u,s),s.extensions&&so(r,u,s),s.matrix!==void 0){const f=new lt;f.fromArray(s.matrix),u.applyMatrix4(f)}else s.translation!==void 0&&u.position.fromArray(s.translation),s.rotation!==void 0&&u.quaternion.fromArray(s.rotation),s.scale!==void 0&&u.scale.fromArray(s.scale);return i.associations.has(u)||i.associations.set(u,{}),i.associations.get(u).nodes=e,u}),this.nodeCache[e]}loadScene(e){const t=this.extensions,r=this.json.scenes[e],i=this,s=new mo;r.name&&(s.name=i.createUniqueName(r.name)),Ls(s,r),r.extensions&&so(t,s,r);const a=r.nodes||[],o=[];for(let c=0,l=a.length;c<l;c++)o.push(i.getDependency("node",a[c]));return Promise.all(o).then(function(c){for(let u=0,f=c.length;u<f;u++)s.add(c[u]);const l=u=>{const f=new Map;for(const[d,h]of i.associations)(d instanceof cs||d instanceof Vn)&&f.set(d,h);return u.traverse(d=>{const h=i.associations.get(d);h!=null&&f.set(d,h)}),f};return i.associations=l(s),s})}_createAnimationTracks(e,t,r,i,s){const a=[],o=e.name?e.name:e.uuid,c=[];ha[s.path]===ha.weights?e.traverse(function(d){d.morphTargetInfluences&&c.push(d.name?d.name:d.uuid)}):c.push(o);let l;switch(ha[s.path]){case ha.weights:l=Zc;break;case ha.rotation:l=Qc;break;case ha.position:case ha.scale:l=Jc;break;default:switch(r.itemSize){case 1:l=Zc;break;case 2:case 3:default:l=Jc;break}break}const u=i.interpolation!==void 0?pce[i.interpolation]:yu,f=this._getArrayFromAccessor(r);for(let d=0,h=c.length;d<h;d++){const p=new l(c[d]+"."+ha[s.path],t.array,f,u);i.interpolation==="CUBICSPLINE"&&this._createCubicSplineTrackInterpolant(p),a.push(p)}return a}_getArrayFromAccessor(e){let t=e.array;if(e.normalized){const r=Fx(t.constructor),i=new Float32Array(t.length);for(let s=0,a=t.length;s<a;s++)i[s]=t[s]*r;t=i}return t}_createCubicSplineTrackInterpolant(e){e.createInterpolant=function(r){const i=this instanceof Qc?hce:TM;return new i(this.times,this.values,this.getValueSize()/3,r)},e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0}}function wce(n,e,t){const r=e.attributes,i=new Qs;if(r.POSITION!==void 0){const o=t.json.accessors[r.POSITION],c=o.min,l=o.max;if(c!==void 0&&l!==void 0){if(i.set(new $(c[0],c[1],c[2]),new $(l[0],l[1],l[2])),o.normalized){const u=Fx(Vc[o.componentType]);i.min.multiplyScalar(u),i.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const o=new $,c=new $;for(let l=0,u=s.length;l<u;l++){const f=s[l];if(f.POSITION!==void 0){const d=t.json.accessors[f.POSITION],h=d.min,p=d.max;if(h!==void 0&&p!==void 0){if(c.setX(Math.max(Math.abs(h[0]),Math.abs(p[0]))),c.setY(Math.max(Math.abs(h[1]),Math.abs(p[1]))),c.setZ(Math.max(Math.abs(h[2]),Math.abs(p[2]))),d.normalized){const g=Fx(Vc[d.componentType]);c.multiplyScalar(g)}o.max(c)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(o)}n.boundingBox=i;const a=new ys;i.getCenter(a.center),a.radius=i.min.distanceTo(i.max)/2,n.boundingSphere=a}function qw(n,e,t){const r=e.attributes,i=[];function s(a,o){return t.getDependency("accessor",a).then(function(c){n.setAttribute(o,c)})}for(const a in r){const o=Px[a]||a.toLowerCase();o in n.attributes||i.push(s(r[a],o))}if(e.indices!==void 0&&!n.index){const a=t.getDependency("accessor",e.indices).then(function(o){n.setIndex(o)});i.push(a)}return Lt.workingColorSpace!==rr&&"COLOR_0"in r&&console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${Lt.workingColorSpace}" not supported.`),Ls(n,e),wce(n,e,t),Promise.all(i).then(function(){return e.targets!==void 0?vce(n,e.targets,t):n})}class Ece{constructor(e,t,r){const i=this;this.volume=e,t=t||0,Object.defineProperty(this,"index",{get:function(){return t},set:function(o){return t=o,i.geometryNeedsUpdate=!0,t}}),this.axis=r||"z",this.canvas=document.createElement("canvas"),this.canvasBuffer=document.createElement("canvas"),this.updateGeometry();const s=new Vn(this.canvas);s.minFilter=Rn,s.wrapS=s.wrapT=Fs,s.colorSpace=Xn;const a=new xa({map:s,side:$i,transparent:!0});this.mesh=new gr(this.geometry,a),this.mesh.matrixAutoUpdate=!1,this.geometryNeedsUpdate=!0,this.repaint()}repaint(){this.geometryNeedsUpdate&&this.updateGeometry();const e=this.iLength,t=this.jLength,r=this.sliceAccess,i=this.volume,s=this.canvasBuffer,a=this.ctxBuffer,o=a.getImageData(0,0,e,t),c=o.data,l=i.data,u=i.upperThreshold,f=i.lowerThreshold,d=i.windowLow,h=i.windowHigh;let p=0;if(i.dataType==="label")for(let g=0;g<t;g++)for(let m=0;m<e;m++){let v=l[r(m,g)];v=v>=this.colorMap.length?v%this.colorMap.length+1:v;const x=this.colorMap[v];c[4*p]=x>>24&255,c[4*p+1]=x>>16&255,c[4*p+2]=x>>8&255,c[4*p+3]=x&255,p++}else for(let g=0;g<t;g++)for(let m=0;m<e;m++){let v=l[r(m,g)],x=255;x=u>=v&&f<=v?x:0,v=Math.floor(255*(v-d)/(h-d)),v=v>255?255:v<0?0:v|0,c[4*p]=v,c[4*p+1]=v,c[4*p+2]=v,c[4*p+3]=x,p++}a.putImageData(o,0,0),this.ctx.drawImage(s,0,0,e,t,0,0,this.canvas.width,this.canvas.height),this.mesh.material.map.needsUpdate=!0}updateGeometry(){const e=this.volume.extractPerpendicularPlane(this.axis,this.index);this.sliceAccess=e.sliceAccess,this.jLength=e.jLength,this.iLength=e.iLength,this.matrix=e.matrix,this.canvas.width=e.planeWidth,this.canvas.height=e.planeHeight,this.canvasBuffer.width=this.iLength,this.canvasBuffer.height=this.jLength,this.ctx=this.canvas.getContext("2d"),this.ctxBuffer=this.canvasBuffer.getContext("2d"),this.geometry&&this.geometry.dispose(),this.geometry=new Bu(e.planeWidth,e.planeHeight),this.mesh&&(this.mesh.geometry=this.geometry,this.mesh.matrix.identity(),this.mesh.applyMatrix4(this.matrix)),this.geometryNeedsUpdate=!1}}class Sce{constructor(e,t,r,i,s){if(e!==void 0){switch(this.xLength=Number(e)||1,this.yLength=Number(t)||1,this.zLength=Number(r)||1,this.axisOrder=["x","y","z"],i){case"Uint8":case"uint8":case"uchar":case"unsigned char":case"uint8_t":this.data=new Uint8Array(s);break;case"Int8":case"int8":case"signed char":case"int8_t":this.data=new Int8Array(s);break;case"Int16":case"int16":case"short":case"short int":case"signed short":case"signed short int":case"int16_t":this.data=new Int16Array(s);break;case"Uint16":case"uint16":case"ushort":case"unsigned short":case"unsigned short int":case"uint16_t":this.data=new Uint16Array(s);break;case"Int32":case"int32":case"int":case"signed int":case"int32_t":this.data=new Int32Array(s);break;case"Uint32":case"uint32":case"uint":case"unsigned int":case"uint32_t":this.data=new Uint32Array(s);break;case"longlong":case"long long":case"long long int":case"signed long long":case"signed long long int":case"int64":case"int64_t":case"ulonglong":case"unsigned long long":case"unsigned long long int":case"uint64":case"uint64_t":throw new Error("Error in Volume constructor : this type is not supported in JavaScript");case"Float32":case"float32":case"float":this.data=new Float32Array(s);break;case"Float64":case"float64":case"double":this.data=new Float64Array(s);break;default:this.data=new Uint8Array(s)}if(this.data.length!==this.xLength*this.yLength*this.zLength)throw new Error("Error in Volume constructor, lengths are not matching arrayBuffer size")}this.spacing=[1,1,1],this.offset=[0,0,0],this.matrix=new yt,this.matrix.identity();let a=-1/0;Object.defineProperty(this,"lowerThreshold",{get:function(){return a},set:function(c){a=c,this.sliceList.forEach(function(l){l.geometryNeedsUpdate=!0})}});let o=1/0;Object.defineProperty(this,"upperThreshold",{get:function(){return o},set:function(c){o=c,this.sliceList.forEach(function(l){l.geometryNeedsUpdate=!0})}}),this.sliceList=[],this.segmentation=!1}getData(e,t,r){return this.data[r*this.xLength*this.yLength+t*this.xLength+e]}access(e,t,r){return r*this.xLength*this.yLength+t*this.xLength+e}reverseAccess(e){const t=Math.floor(e/(this.yLength*this.xLength)),r=Math.floor((e-t*this.yLength*this.xLength)/this.xLength);return[e-t*this.yLength*this.xLength-r*this.xLength,r,t]}map(e,t){const r=this.data.length;t=t||this;for(let i=0;i<r;i++)this.data[i]=e.call(t,this.data[i],i,this.data);return this}extractPerpendicularPlane(e,t){let r,i,s,a;const o=new $,c=new $,l=new $,u=new lt().identity(),f=this,d=new $(this.xLength,this.yLength,this.zLength);switch(e){case"x":o.set(1,0,0),c.set(0,0,-1),l.set(0,-1,0),r=this.spacing[this.axisOrder.indexOf("z")],i=this.spacing[this.axisOrder.indexOf("y")],a=new $(t,0,0),u.multiply(new lt().makeRotationY(Math.PI/2)),s=(f.RASDimensions[0]-1)/2,u.setPosition(new $(t-s,0,0));break;case"y":o.set(0,1,0),c.set(1,0,0),l.set(0,0,1),r=this.spacing[this.axisOrder.indexOf("x")],i=this.spacing[this.axisOrder.indexOf("z")],a=new $(0,t,0),u.multiply(new lt().makeRotationX(-Math.PI/2)),s=(f.RASDimensions[1]-1)/2,u.setPosition(new $(0,t-s,0));break;case"z":default:o.set(0,0,1),c.set(1,0,0),l.set(0,-1,0),r=this.spacing[this.axisOrder.indexOf("x")],i=this.spacing[this.axisOrder.indexOf("y")],a=new $(0,0,t),s=(f.RASDimensions[2]-1)/2,u.setPosition(new $(0,0,t-s));break}this.segmentation||(c.applyMatrix4(f.inverseMatrix).normalize(),l.applyMatrix4(f.inverseMatrix).normalize(),o.applyMatrix4(f.inverseMatrix).normalize()),c.arglet="i",l.arglet="j";const h=Math.floor(Math.abs(c.dot(d))),p=Math.floor(Math.abs(l.dot(d))),g=Math.abs(h*r),m=Math.abs(p*i);a=Math.abs(Math.round(a.applyMatrix4(f.inverseMatrix).dot(o)));const v=[new $(1,0,0),new $(0,1,0),new $(0,0,1)],x=[c,l,o].find(function(E){return Math.abs(E.dot(v[0]))>.9}),b=[c,l,o].find(function(E){return Math.abs(E.dot(v[1]))>.9}),_=[c,l,o].find(function(E){return Math.abs(E.dot(v[2]))>.9});function w(E,S){const T=x===o?a:x.arglet==="i"?E:S,C=b===o?a:b.arglet==="i"?E:S,y=_===o?a:_.arglet==="i"?E:S,A=x.dot(v[0])>0?T:f.xLength-1-T,k=b.dot(v[1])>0?C:f.yLength-1-C,M=_.dot(v[2])>0?y:f.zLength-1-y;return f.access(A,k,M)}return{iLength:h,jLength:p,sliceAccess:w,matrix:u,planeWidth:g,planeHeight:m}}extractSlice(e,t){const r=new Ece(this,t,e);return this.sliceList.push(r),r}repaintAllSlices(){return this.sliceList.forEach(function(e){e.repaint()}),this}computeMinMax(){let e=1/0,t=-1/0;const r=this.data.length;let i=0;for(i=0;i<r;i++)if(!isNaN(this.data[i])){const s=this.data[i];e=Math.min(e,s),t=Math.max(t,s)}return this.min=e,this.max=t,[e,t]}}var er={},ct={},Xw={},AM={};AM.default=function(n,e,t,r,i){var s=new Worker(Xw[e]||(Xw[e]=URL.createObjectURL(new Blob([n+';addEventListener("error",function(e){e=e.error;postMessage({$e$:[e.message,e.code,e.stack]})})'],{type:"text/javascript"}))));return s.onmessage=function(a){var o=a.data,c=o.$e$;if(c){var l=new Error(c[0]);l.code=c[1],l.stack=c[2],i(l,null)}else i(null,o)},s.postMessage(t,r),s};var xt=Uint8Array,Cr=Uint16Array,fd=Int32Array,Fl=new xt([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),$l=new xt([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),Pu=new xt([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),CM=function(n,e){for(var t=new Cr(31),r=0;r<31;++r)t[r]=e+=1<<n[r-1];for(var i=new fd(t[30]),r=1;r<30;++r)for(var s=t[r];s<t[r+1];++s)i[s]=s-t[r]<<5|r;return{b:t,r:i}},IM=CM(Fl,2),py=IM.b,sp=IM.r;py[28]=258,sp[258]=28;var MM=CM($l,0),RM=MM.b,$x=MM.r,Fu=new Cr(32768);for(var ln=0;ln<32768;++ln){var pa=(ln&43690)>>1|(ln&21845)<<1;pa=(pa&52428)>>2|(pa&13107)<<2,pa=(pa&61680)>>4|(pa&3855)<<4,Fu[ln]=((pa&65280)>>8|(pa&255)<<8)>>1}var wi=function(n,e,t){for(var r=n.length,i=0,s=new Cr(e);i<r;++i)n[i]&&++s[n[i]-1];var a=new Cr(e);for(i=1;i<e;++i)a[i]=a[i-1]+s[i-1]<<1;var o;if(t){o=new Cr(1<<e);var c=15-e;for(i=0;i<r;++i)if(n[i])for(var l=i<<4|n[i],u=e-n[i],f=a[n[i]-1]++<<u,d=f|(1<<u)-1;f<=d;++f)o[Fu[f]>>c]=l}else for(o=new Cr(r),i=0;i<r;++i)n[i]&&(o[i]=Fu[a[n[i]-1]++]>>15-n[i]);return o},Zs=new xt(288);for(var ln=0;ln<144;++ln)Zs[ln]=8;for(var ln=144;ln<256;++ln)Zs[ln]=9;for(var ln=256;ln<280;++ln)Zs[ln]=7;for(var ln=280;ln<288;++ln)Zs[ln]=8;var hl=new xt(32);for(var ln=0;ln<32;++ln)hl[ln]=5;var NM=wi(Zs,9,0),kM=wi(Zs,9,1),DM=wi(hl,5,0),LM=wi(hl,5,1),_h=function(n){for(var e=n[0],t=1;t<n.length;++t)n[t]>e&&(e=n[t]);return e},li=function(n,e,t){var r=e/8|0;return(n[r]|n[r+1]<<8)>>(e&7)&t},yh=function(n,e){var t=e/8|0;return(n[t]|n[t+1]<<8|n[t+2]<<16)>>(e&7)},Ul=function(n){return(n+7)/8|0},Ei=function(n,e,t){return(e==null||e<0)&&(e=0),(t==null||t>n.length)&&(t=n.length),new xt(n.subarray(e,t))};ct.FlateErrorCode={UnexpectedEOF:0,InvalidBlockType:1,InvalidLengthLiteral:2,InvalidDistance:3,StreamFinished:4,NoStreamHandler:5,InvalidHeader:6,NoCallback:7,InvalidUTF8:8,ExtraFieldTooLong:9,InvalidDate:10,FilenameTooLong:11,StreamFinishing:12,InvalidZipData:13,UnknownCompressionMethod:14};var OM=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Ze=function(n,e,t){var r=new Error(e||OM[n]);if(r.code=n,Error.captureStackTrace&&Error.captureStackTrace(r,Ze),!t)throw r;return r},dd=function(n,e,t,r){var i=n.length,s=r?r.length:0;if(!i||e.f&&!e.l)return t||new xt(0);var a=!t,o=a||e.i!=2,c=e.i;a&&(t=new xt(i*3));var l=function(Me){var Le=t.length;if(Me>Le){var B=new xt(Math.max(Le*2,Me));B.set(t),t=B}},u=e.f||0,f=e.p||0,d=e.b||0,h=e.l,p=e.d,g=e.m,m=e.n,v=i*8;do{if(!h){u=li(n,f,1);var x=li(n,f+1,3);if(f+=3,x)if(x==1)h=kM,p=LM,g=9,m=5;else if(x==2){var E=li(n,f,31)+257,S=li(n,f+10,15)+4,T=E+li(n,f+5,31)+1;f+=14;for(var C=new xt(T),y=new xt(19),A=0;A<S;++A)y[Pu[A]]=li(n,f+A*3,7);f+=S*3;for(var k=_h(y),M=(1<<k)-1,L=wi(y,k,1),A=0;A<T;){var z=L[li(n,f,M)];f+=z&15;var b=z>>4;if(b<16)C[A++]=b;else{var D=0,F=0;for(b==16?(F=3+li(n,f,3),f+=2,D=C[A-1]):b==17?(F=3+li(n,f,7),f+=3):b==18&&(F=11+li(n,f,127),f+=7);F--;)C[A++]=D}}var O=C.subarray(0,E),V=C.subarray(E);g=_h(O),m=_h(V),h=wi(O,g,1),p=wi(V,m,1)}else Ze(1);else{var b=Ul(f)+4,_=n[b-4]|n[b-3]<<8,w=b+_;if(w>i){c&&Ze(0);break}o&&l(d+_),t.set(n.subarray(b,w),d),e.b=d+=_,e.p=f=w*8,e.f=u;continue}if(f>v){c&&Ze(0);break}}o&&l(d+131072);for(var J=(1<<g)-1,Q=(1<<m)-1,de=f;;de=f){var D=h[yh(n,f)&J],le=D>>4;if(f+=D&15,f>v){c&&Ze(0);break}if(D||Ze(2),le<256)t[d++]=le;else if(le==256){de=f,h=null;break}else{var H=le-254;if(le>264){var A=le-257,q=Fl[A];H=li(n,f,(1<<q)-1)+py[A],f+=q}var oe=p[yh(n,f)&Q],fe=oe>>4;oe||Ze(3),f+=oe&15;var V=RM[fe];if(fe>3){var q=$l[fe];V+=yh(n,f)&(1<<q)-1,f+=q}if(f>v){c&&Ze(0);break}o&&l(d+131072);var _e=d+H;if(d<V){var xe=s-V,Se=Math.min(V,_e);for(xe+d<0&&Ze(3);d<Se;++d)t[d]=r[xe+d]}for(;d<_e;++d)t[d]=t[d-V]}}e.l=h,e.p=de,e.b=d,e.f=u,h&&(u=1,e.m=g,e.d=p,e.n=m)}while(!u);return d!=t.length&&a?Ei(t,0,d):t.subarray(0,d)},es=function(n,e,t){t<<=e&7;var r=e/8|0;n[r]|=t,n[r+1]|=t>>8},Tc=function(n,e,t){t<<=e&7;var r=e/8|0;n[r]|=t,n[r+1]|=t>>8,n[r+2]|=t>>16},wh=function(n,e){for(var t=[],r=0;r<n.length;++r)n[r]&&t.push({s:r,f:n[r]});var i=t.length,s=t.slice();if(!i)return{t:Ea,l:0};if(i==1){var a=new xt(t[0].s+1);return a[t[0].s]=1,{t:a,l:1}}t.sort(function(w,E){return w.f-E.f}),t.push({s:-1,f:25001});var o=t[0],c=t[1],l=0,u=1,f=2;for(t[0]={s:-1,f:o.f+c.f,l:o,r:c};u!=i-1;)o=t[t[l].f<t[f].f?l++:f++],c=t[l!=u&&t[l].f<t[f].f?l++:f++],t[u++]={s:-1,f:o.f+c.f,l:o,r:c};for(var d=s[0].s,r=1;r<i;++r)s[r].s>d&&(d=s[r].s);var h=new Cr(d+1),p=ap(t[u-1],h,0);if(p>e){var r=0,g=0,m=p-e,v=1<<m;for(s.sort(function(E,S){return h[S.s]-h[E.s]||E.f-S.f});r<i;++r){var x=s[r].s;if(h[x]>e)g+=v-(1<<p-h[x]),h[x]=e;else break}for(g>>=m;g>0;){var b=s[r].s;h[b]<e?g-=1<<e-h[b]++-1:++r}for(;r>=0&&g;--r){var _=s[r].s;h[_]==e&&(--h[_],++g)}p=e}return{t:new xt(h),l:p}},ap=function(n,e,t){return n.s==-1?Math.max(ap(n.l,e,t+1),ap(n.r,e,t+1)):e[n.s]=t},Ux=function(n){for(var e=n.length;e&&!n[--e];);for(var t=new Cr(++e),r=0,i=n[0],s=1,a=function(c){t[r++]=c},o=1;o<=e;++o)if(n[o]==i&&o!=e)++s;else{if(!i&&s>2){for(;s>138;s-=138)a(32754);s>2&&(a(s>10?s-11<<5|28690:s-3<<5|12305),s=0)}else if(s>3){for(a(i),--s;s>6;s-=6)a(8304);s>2&&(a(s-3<<5|8208),s=0)}for(;s--;)a(i);s=1,i=n[o]}return{c:t.subarray(0,r),n:e}},Ac=function(n,e){for(var t=0,r=0;r<e.length;++r)t+=n[r]*e[r];return t},my=function(n,e,t){var r=t.length,i=Ul(e+2);n[i]=r&255,n[i+1]=r>>8,n[i+2]=n[i]^255,n[i+3]=n[i+1]^255;for(var s=0;s<r;++s)n[i+s+4]=t[s];return(i+4+r)*8},Bx=function(n,e,t,r,i,s,a,o,c,l,u){es(e,u++,t),++i[256];for(var f=wh(i,15),d=f.t,h=f.l,p=wh(s,15),g=p.t,m=p.l,v=Ux(d),x=v.c,b=v.n,_=Ux(g),w=_.c,E=_.n,S=new Cr(19),T=0;T<x.length;++T)++S[x[T]&31];for(var T=0;T<w.length;++T)++S[w[T]&31];for(var C=wh(S,7),y=C.t,A=C.l,k=19;k>4&&!y[Pu[k-1]];--k);var M=l+5<<3,L=Ac(i,Zs)+Ac(s,hl)+a,z=Ac(i,d)+Ac(s,g)+a+14+3*k+Ac(S,y)+2*S[16]+3*S[17]+7*S[18];if(c>=0&&M<=L&&M<=z)return my(e,u,n.subarray(c,c+l));var D,F,O,V;if(es(e,u,1+(z<L)),u+=2,z<L){D=wi(d,h,0),F=d,O=wi(g,m,0),V=g;var J=wi(y,A,0);es(e,u,b-257),es(e,u+5,E-1),es(e,u+10,k-4),u+=14;for(var T=0;T<k;++T)es(e,u+3*T,y[Pu[T]]);u+=3*k;for(var Q=[x,w],de=0;de<2;++de)for(var le=Q[de],T=0;T<le.length;++T){var H=le[T]&31;es(e,u,J[H]),u+=y[H],H>15&&(es(e,u,le[T]>>5&127),u+=le[T]>>12)}}else D=NM,F=Zs,O=DM,V=hl;for(var T=0;T<o;++T){var q=r[T];if(q>255){var H=q>>18&31;Tc(e,u,D[H+257]),u+=F[H+257],H>7&&(es(e,u,q>>23&31),u+=Fl[H]);var oe=q&31;Tc(e,u,O[oe]),u+=V[oe],oe>3&&(Tc(e,u,q>>5&8191),u+=$l[oe])}else Tc(e,u,D[q]),u+=F[q]}return Tc(e,u,D[256]),u+F[256]},zM=new fd([65540,131080,131088,131104,262176,1048704,1048832,2114560,2117632]),Ea=new xt(0),PM=function(n,e,t,r,i,s){var a=s.z||n.length,o=new xt(r+a+5*(1+Math.ceil(a/7e3))+i),c=o.subarray(r,o.length-i),l=s.l,u=(s.r||0)&7;if(e){u&&(c[0]=s.r>>3);for(var f=zM[e-1],d=f>>13,h=f&8191,p=(1<<t)-1,g=s.p||new Cr(32768),m=s.h||new Cr(p+1),v=Math.ceil(t/3),x=2*v,b=function(bt){return(n[bt]^n[bt+1]<<v^n[bt+2]<<x)&p},_=new fd(25e3),w=new Cr(288),E=new Cr(32),S=0,T=0,C=s.i||0,y=0,A=s.w||0,k=0;C+2<a;++C){var M=b(C),L=C&32767,z=m[M];if(g[L]=z,m[M]=L,A<=C){var D=a-C;if((S>7e3||y>24576)&&(D>423||!l)){u=Bx(n,c,0,_,w,E,T,y,k,C-k,u),y=S=T=0,k=C;for(var F=0;F<286;++F)w[F]=0;for(var F=0;F<30;++F)E[F]=0}var O=2,V=0,J=h,Q=L-z&32767;if(D>2&&M==b(C-Q))for(var de=Math.min(d,D)-1,le=Math.min(32767,C),H=Math.min(258,D);Q<=le&&--J&&L!=z;){if(n[C+O]==n[C+O-Q]){for(var q=0;q<H&&n[C+q]==n[C+q-Q];++q);if(q>O){if(O=q,V=Q,q>de)break;for(var oe=Math.min(Q,q-2),fe=0,F=0;F<oe;++F){var _e=C-Q+F&32767,xe=g[_e],Se=_e-xe&32767;Se>fe&&(fe=Se,z=_e)}}}L=z,z=g[L],Q+=L-z&32767}if(V){_[y++]=268435456|sp[O]<<18|$x[V];var Me=sp[O]&31,Le=$x[V]&31;T+=Fl[Me]+$l[Le],++w[257+Me],++E[Le],A=C+O,++S}else _[y++]=n[C],++w[n[C]]}}for(C=Math.max(C,A);C<a;++C)_[y++]=n[C],++w[n[C]];u=Bx(n,c,l,_,w,E,T,y,k,C-k,u),l||(s.r=u&7|c[u/8|0]<<3,u-=7,s.h=m,s.p=g,s.i=C,s.w=A)}else{for(var C=s.w||0;C<a+l;C+=65535){var B=C+65535;B>=a&&(c[u/8|0]=l,B=a),u=my(c,u+1,n.subarray(C,B))}s.i=a}return Ei(o,0,r+Ul(u)+i)},FM=function(){for(var n=new Int32Array(256),e=0;e<256;++e){for(var t=e,r=9;--r;)t=(t&1&&-306674912)^t>>>1;n[e]=t}return n}(),Bl=function(){var n=-1;return{p:function(e){for(var t=n,r=0;r<e.length;++r)t=FM[t&255^e[r]]^t>>>8;n=t},d:function(){return~n}}},qm=function(){var n=1,e=0;return{p:function(t){for(var r=n,i=e,s=t.length|0,a=0;a!=s;){for(var o=Math.min(a+2655,s);a<o;++a)i+=r+=t[a];r=(r&65535)+15*(r>>16),i=(i&65535)+15*(i>>16)}n=r,e=i},d:function(){return n%=65521,e%=65521,(n&255)<<24|(n&65280)<<8|(e&255)<<8|e>>8}}},ec=function(n,e,t,r,i){if(!i&&(i={l:1},e.dictionary)){var s=e.dictionary.subarray(-32768),a=new xt(s.length+n.length);a.set(s),a.set(n,s.length),n=a,i.w=s.length}return PM(n,e.level==null?6:e.level,e.mem==null?i.l?Math.ceil(Math.max(8,Math.min(13,Math.log(n.length)))*1.5):20:12+e.mem,t,r,i)},hd=function(n,e){var t={};for(var r in n)t[r]=n[r];for(var r in e)t[r]=e[r];return t},Kw=function(n,e,t){for(var r=n(),i=n.toString(),s=i.slice(i.indexOf("[")+1,i.lastIndexOf("]")).replace(/\s+/g,"").split(","),a=0;a<r.length;++a){var o=r[a],c=s[a];if(typeof o=="function"){e+=";"+c+"=";var l=o.toString();if(o.prototype)if(l.indexOf("[native code]")!=-1){var u=l.indexOf(" ",8)+1;e+=l.slice(u,l.indexOf("(",u))}else{e+=l;for(var f in o.prototype)e+=";"+c+".prototype."+f+"="+o.prototype[f].toString()}else e+=l}else t[c]=o}return e},lh=[],Tce=function(n){var e=[];for(var t in n)n[t].buffer&&e.push((n[t]=new n[t].constructor(n[t])).buffer);return e},$M=function(n,e,t,r){if(!lh[t]){for(var i="",s={},a=n.length-1,o=0;o<a;++o)i=Kw(n[o],i,s);lh[t]={c:Kw(n[a],i,s),e:s}}var c=hd({},lh[t].e);return(0,AM.default)(lh[t].c+";onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage="+e.toString()+"}",t,c,Tce(c),r)},Vl=function(){return[xt,Cr,fd,Fl,$l,Pu,py,RM,kM,LM,Fu,OM,wi,_h,li,yh,Ul,Ei,Ze,dd,ql,ja,vy]},Gl=function(){return[xt,Cr,fd,Fl,$l,Pu,sp,$x,NM,Zs,DM,hl,Fu,zM,Ea,wi,es,Tc,wh,ap,Ux,Ac,my,Bx,Ul,Ei,PM,ec,pd,ja]},UM=function(){return[gy,by,$t,Bl,FM]},BM=function(){return[xy,HM]},VM=function(){return[_y,$t,qm]},GM=function(){return[yy]},ja=function(n){return postMessage(n,[n.buffer])},vy=function(n){return n&&{out:n.size&&new xt(n.size),dictionary:n.dictionary}},Hl=function(n,e,t,r,i,s){var a=$M(t,r,i,function(o,c){a.terminate(),s(o,c)});return a.postMessage([n,e],e.consume?[n.buffer]:[]),function(){a.terminate()}},Ci=function(n){return n.ondata=function(e,t){return postMessage([e,t],[e.buffer])},function(e){e.data.length?(n.push(e.data[0],e.data[1]),postMessage([e.data[0].length])):n.flush()}},Wl=function(n,e,t,r,i,s,a){var o,c=$M(n,r,i,function(l,u){l?(c.terminate(),e.ondata.call(e,l)):Array.isArray(u)?u.length==1?(e.queuedSize-=u[0],e.ondrain&&e.ondrain(u[0])):(u[1]&&c.terminate(),e.ondata.call(e,l,u[0],u[1])):a(u)});c.postMessage(t),e.queuedSize=0,e.push=function(l,u){e.ondata||Ze(5),o&&e.ondata(Ze(4,0,1),null,!!u),e.queuedSize+=l.length,c.postMessage([l,o=u],[l.buffer])},e.terminate=function(){c.terminate()},s&&(e.flush=function(){c.postMessage([])})},Ar=function(n,e){return n[e]|n[e+1]<<8},Tn=function(n,e){return(n[e]|n[e+1]<<8|n[e+2]<<16|n[e+3]<<24)>>>0},sg=function(n,e){return Tn(n,e)+Tn(n,e+4)*4294967296},$t=function(n,e,t){for(;t;++e)n[e]=t,t>>>=8},gy=function(n,e){var t=e.filename;if(n[0]=31,n[1]=139,n[2]=8,n[8]=e.level<2?4:e.level==9?2:0,n[9]=3,e.mtime!=0&&$t(n,4,Math.floor(new Date(e.mtime||Date.now())/1e3)),t){n[3]=8;for(var r=0;r<=t.length;++r)n[r+10]=t.charCodeAt(r)}},xy=function(n){(n[0]!=31||n[1]!=139||n[2]!=8)&&Ze(6,"invalid gzip data");var e=n[3],t=10;e&4&&(t+=(n[10]|n[11]<<8)+2);for(var r=(e>>3&1)+(e>>4&1);r>0;r-=!n[t++]);return t+(e&2)},HM=function(n){var e=n.length;return(n[e-4]|n[e-3]<<8|n[e-2]<<16|n[e-1]<<24)>>>0},by=function(n){return 10+(n.filename?n.filename.length+1:0)},_y=function(n,e){var t=e.level,r=t==0?0:t<6?1:t==9?3:2;if(n[0]=120,n[1]=r<<6|(e.dictionary&&32),n[1]|=31-(n[0]<<8|n[1])%31,e.dictionary){var i=qm();i.p(e.dictionary),$t(n,2,i.d())}},yy=function(n,e){return((n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31)&&Ze(6,"invalid zlib data"),(n[1]>>5&1)==+!e&&Ze(6,"invalid zlib data: "+(n[1]&32?"need":"unexpected")+" dictionary"),(n[1]>>3&4)+2};function tc(n,e){return typeof n=="function"&&(e=n,n={}),this.ondata=e,n}var Si=function(){function n(e,t){if(typeof e=="function"&&(t=e,e={}),this.ondata=t,this.o=e||{},this.s={l:0,i:32768,w:32768,z:32768},this.b=new xt(98304),this.o.dictionary){var r=this.o.dictionary.subarray(-32768);this.b.set(r,32768-r.length),this.s.i=32768-r.length}}return n.prototype.p=function(e,t){this.ondata(ec(e,this.o,0,0,this.s),t)},n.prototype.push=function(e,t){this.ondata||Ze(5),this.s.l&&Ze(4);var r=e.length+this.s.z;if(r>this.b.length){if(r>2*this.b.length-32768){var i=new xt(r&-32768);i.set(this.b.subarray(0,this.s.z)),this.b=i}var s=this.b.length-this.s.z;this.b.set(e.subarray(0,s),this.s.z),this.s.z=this.b.length,this.p(this.b,!1),this.b.set(this.b.subarray(-32768)),this.b.set(e.subarray(s),32768),this.s.z=e.length-s+32768,this.s.i=32766,this.s.w=32768}else this.b.set(e,this.s.z),this.s.z+=e.length;this.s.l=t&1,(this.s.z>this.s.w+8191||t)&&(this.p(this.b,t||!1),this.s.w=this.s.i,this.s.i-=2)},n.prototype.flush=function(){this.ondata||Ze(5),this.s.l&&Ze(4),this.p(this.b,!1),this.s.w=this.s.i,this.s.i-=2},n}();ct.Deflate=Si;var WM=function(){function n(e,t){Wl([Gl,function(){return[Ci,Si]}],this,tc.call(this,e,t),function(r){var i=new Si(r.data);onmessage=Ci(i)},6,1)}return n}();ct.AsyncDeflate=WM;function qM(n,e,t){return t||(t=e,e={}),typeof t!="function"&&Ze(7),Hl(n,e,[Gl],function(r){return ja(pd(r.data[0],r.data[1]))},0,t)}ct.deflate=qM;function pd(n,e){return ec(n,e||{},0,0)}ct.deflateSync=pd;var Gr=function(){function n(e,t){typeof e=="function"&&(t=e,e={}),this.ondata=t;var r=e&&e.dictionary&&e.dictionary.subarray(-32768);this.s={i:0,b:r?r.length:0},this.o=new xt(32768),this.p=new xt(0),r&&this.o.set(r)}return n.prototype.e=function(e){if(this.ondata||Ze(5),this.d&&Ze(4),!this.p.length)this.p=e;else if(e.length){var t=new xt(this.p.length+e.length);t.set(this.p),t.set(e,this.p.length),this.p=t}},n.prototype.c=function(e){this.s.i=+(this.d=e||!1);var t=this.s.b,r=dd(this.p,this.s,this.o);this.ondata(Ei(r,t,this.s.b),this.d),this.o=Ei(r,this.s.b-32768),this.s.b=this.o.length,this.p=Ei(this.p,this.s.p/8|0),this.s.p&=7},n.prototype.push=function(e,t){this.e(e),this.c(t)},n}();ct.Inflate=Gr;var wy=function(){function n(e,t){Wl([Vl,function(){return[Ci,Gr]}],this,tc.call(this,e,t),function(r){var i=new Gr(r.data);onmessage=Ci(i)},7,0)}return n}();ct.AsyncInflate=wy;function Ey(n,e,t){return t||(t=e,e={}),typeof t!="function"&&Ze(7),Hl(n,e,[Vl],function(r){return ja(ql(r.data[0],vy(r.data[1])))},1,t)}ct.inflate=Ey;function ql(n,e){return dd(n,{i:2},e&&e.out,e&&e.dictionary)}ct.inflateSync=ql;var op=function(){function n(e,t){this.c=Bl(),this.l=0,this.v=1,Si.call(this,e,t)}return n.prototype.push=function(e,t){this.c.p(e),this.l+=e.length,Si.prototype.push.call(this,e,t)},n.prototype.p=function(e,t){var r=ec(e,this.o,this.v&&by(this.o),t&&8,this.s);this.v&&(gy(r,this.o),this.v=0),t&&($t(r,r.length-8,this.c.d()),$t(r,r.length-4,this.l)),this.ondata(r,t)},n.prototype.flush=function(){Si.prototype.flush.call(this)},n}();ct.Gzip=op;ct.Compress=op;var XM=function(){function n(e,t){Wl([Gl,UM,function(){return[Ci,Si,op]}],this,tc.call(this,e,t),function(r){var i=new op(r.data);onmessage=Ci(i)},8,1)}return n}();ct.AsyncGzip=XM;ct.AsyncCompress=XM;function KM(n,e,t){return t||(t=e,e={}),typeof t!="function"&&Ze(7),Hl(n,e,[Gl,UM,function(){return[cp]}],function(r){return ja(cp(r.data[0],r.data[1]))},2,t)}ct.gzip=KM;ct.compress=KM;function cp(n,e){e||(e={});var t=Bl(),r=n.length;t.p(n);var i=ec(n,e,by(e),8),s=i.length;return gy(i,e),$t(i,s-8,t.d()),$t(i,s-4,r),i}ct.gzipSync=cp;ct.compressSync=cp;var lp=function(){function n(e,t){this.v=1,this.r=0,Gr.call(this,e,t)}return n.prototype.push=function(e,t){if(Gr.prototype.e.call(this,e),this.r+=e.length,this.v){var r=this.p.subarray(this.v-1),i=r.length>3?xy(r):4;if(i>r.length){if(!t)return}else this.v>1&&this.onmember&&this.onmember(this.r-r.length);this.p=r.subarray(i),this.v=0}Gr.prototype.c.call(this,t),this.s.f&&!this.s.l&&!t&&(this.v=Ul(this.s.p)+9,this.s={i:0},this.o=new xt(0),this.push(new xt(0),t))},n}();ct.Gunzip=lp;var jM=function(){function n(e,t){var r=this;Wl([Vl,BM,function(){return[Ci,Gr,lp]}],this,tc.call(this,e,t),function(i){var s=new lp(i.data);s.onmember=function(a){return postMessage(a)},onmessage=Ci(s)},9,0,function(i){return r.onmember&&r.onmember(i)})}return n}();ct.AsyncGunzip=jM;function YM(n,e,t){return t||(t=e,e={}),typeof t!="function"&&Ze(7),Hl(n,e,[Vl,BM,function(){return[up]}],function(r){return ja(up(r.data[0],r.data[1]))},3,t)}ct.gunzip=YM;function up(n,e){var t=xy(n);return t+8>n.length&&Ze(6,"invalid gzip data"),dd(n.subarray(t,-8),{i:2},e&&e.out||new xt(HM(n)),e&&e.dictionary)}ct.gunzipSync=up;var Vx=function(){function n(e,t){this.c=qm(),this.v=1,Si.call(this,e,t)}return n.prototype.push=function(e,t){this.c.p(e),Si.prototype.push.call(this,e,t)},n.prototype.p=function(e,t){var r=ec(e,this.o,this.v&&(this.o.dictionary?6:2),t&&4,this.s);this.v&&(_y(r,this.o),this.v=0),t&&$t(r,r.length-4,this.c.d()),this.ondata(r,t)},n.prototype.flush=function(){Si.prototype.flush.call(this)},n}();ct.Zlib=Vx;var Ace=function(){function n(e,t){Wl([Gl,VM,function(){return[Ci,Si,Vx]}],this,tc.call(this,e,t),function(r){var i=new Vx(r.data);onmessage=Ci(i)},10,1)}return n}();ct.AsyncZlib=Ace;function Cce(n,e,t){return t||(t=e,e={}),typeof t!="function"&&Ze(7),Hl(n,e,[Gl,VM,function(){return[Gx]}],function(r){return ja(Gx(r.data[0],r.data[1]))},4,t)}ct.zlib=Cce;function Gx(n,e){e||(e={});var t=qm();t.p(n);var r=ec(n,e,e.dictionary?6:2,4);return _y(r,e),$t(r,r.length-4,t.d()),r}ct.zlibSync=Gx;var fp=function(){function n(e,t){Gr.call(this,e,t),this.v=e&&e.dictionary?2:1}return n.prototype.push=function(e,t){if(Gr.prototype.e.call(this,e),this.v){if(this.p.length<6&&!t)return;this.p=this.p.subarray(yy(this.p,this.v-1)),this.v=0}t&&(this.p.length<4&&Ze(6,"invalid zlib data"),this.p=this.p.subarray(0,-4)),Gr.prototype.c.call(this,t)},n}();ct.Unzlib=fp;var ZM=function(){function n(e,t){Wl([Vl,GM,function(){return[Ci,Gr,fp]}],this,tc.call(this,e,t),function(r){var i=new fp(r.data);onmessage=Ci(i)},11,0)}return n}();ct.AsyncUnzlib=ZM;function QM(n,e,t){return t||(t=e,e={}),typeof t!="function"&&Ze(7),Hl(n,e,[Vl,GM,function(){return[dp]}],function(r){return ja(dp(r.data[0],vy(r.data[1])))},5,t)}ct.unzlib=QM;function dp(n,e){return dd(n.subarray(yy(n,e&&e.dictionary),-4),{i:2},e&&e.out,e&&e.dictionary)}ct.unzlibSync=dp;var Hx=function(){function n(e,t){this.o=tc.call(this,e,t)||{},this.G=lp,this.I=Gr,this.Z=fp}return n.prototype.i=function(){var e=this;this.s.ondata=function(t,r){e.ondata(t,r)}},n.prototype.push=function(e,t){if(this.ondata||Ze(5),this.s)this.s.push(e,t);else{if(this.p&&this.p.length){var r=new xt(this.p.length+e.length);r.set(this.p),r.set(e,this.p.length)}else this.p=e;this.p.length>2&&(this.s=this.p[0]==31&&this.p[1]==139&&this.p[2]==8?new this.G(this.o):(this.p[0]&15)!=8||this.p[0]>>4>7||(this.p[0]<<8|this.p[1])%31?new this.I(this.o):new this.Z(this.o),this.i(),this.s.push(this.p,t),this.p=null)}},n}();ct.Decompress=Hx;var Ice=function(){function n(e,t){Hx.call(this,e,t),this.queuedSize=0,this.G=jM,this.I=wy,this.Z=ZM}return n.prototype.i=function(){var e=this;this.s.ondata=function(t,r,i){e.ondata(t,r,i)},this.s.ondrain=function(t){e.queuedSize-=t,e.ondrain&&e.ondrain(t)}},n.prototype.push=function(e,t){this.queuedSize+=e.length,Hx.prototype.push.call(this,e,t)},n}();ct.AsyncDecompress=Ice;function Mce(n,e,t){return t||(t=e,e={}),typeof t!="function"&&Ze(7),n[0]==31&&n[1]==139&&n[2]==8?YM(n,e,t):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?Ey(n,e,t):QM(n,e,t)}ct.decompress=Mce;function Rce(n,e){return n[0]==31&&n[1]==139&&n[2]==8?up(n,e):(n[0]&15)!=8||n[0]>>4>7||(n[0]<<8|n[1])%31?ql(n,e):dp(n,e)}ct.decompressSync=Rce;var Sy=function(n,e,t,r){for(var i in n){var s=n[i],a=e+i,o=r;Array.isArray(s)&&(o=hd(r,s[1]),s=s[0]),s instanceof xt?t[a]=[s,o]:(t[a+="/"]=[new xt(0),o],Sy(s,a,t,r))}},jw=typeof TextEncoder<"u"&&new TextEncoder,Wx=typeof TextDecoder<"u"&&new TextDecoder,JM=0;try{Wx.decode(Ea,{stream:!0}),JM=1}catch{}var eR=function(n){for(var e="",t=0;;){var r=n[t++],i=(r>127)+(r>223)+(r>239);if(t+i>n.length)return{s:e,r:Ei(n,t-1)};i?i==3?(r=((r&15)<<18|(n[t++]&63)<<12|(n[t++]&63)<<6|n[t++]&63)-65536,e+=String.fromCharCode(55296|r>>10,56320|r&1023)):i&1?e+=String.fromCharCode((r&31)<<6|n[t++]&63):e+=String.fromCharCode((r&15)<<12|(n[t++]&63)<<6|n[t++]&63):e+=String.fromCharCode(r)}},Nce=function(){function n(e){this.ondata=e,JM?this.t=new TextDecoder:this.p=Ea}return n.prototype.push=function(e,t){if(this.ondata||Ze(5),t=!!t,this.t){this.ondata(this.t.decode(e,{stream:!0}),t),t&&(this.t.decode().length&&Ze(8),this.t=null);return}this.p||Ze(4);var r=new xt(this.p.length+e.length);r.set(this.p),r.set(e,this.p.length);var i=eR(r),s=i.s,a=i.r;t?(a.length&&Ze(8),this.p=null):this.p=a,this.ondata(s,t)},n}();ct.DecodeUTF8=Nce;var kce=function(){function n(e){this.ondata=e}return n.prototype.push=function(e,t){this.ondata||Ze(5),this.d&&Ze(4),this.ondata(Pa(e),this.d=t||!1)},n}();ct.EncodeUTF8=kce;function Pa(n,e){if(e){for(var t=new xt(n.length),r=0;r<n.length;++r)t[r]=n.charCodeAt(r);return t}if(jw)return jw.encode(n);for(var i=n.length,s=new xt(n.length+(n.length>>1)),a=0,o=function(u){s[a++]=u},r=0;r<i;++r){if(a+5>s.length){var c=new xt(a+8+(i-r<<1));c.set(s),s=c}var l=n.charCodeAt(r);l<128||e?o(l):l<2048?(o(192|l>>6),o(128|l&63)):l>55295&&l<57344?(l=65536+(l&1047552)|n.charCodeAt(++r)&1023,o(240|l>>18),o(128|l>>12&63),o(128|l>>6&63),o(128|l&63)):(o(224|l>>12),o(128|l>>6&63),o(128|l&63))}return Ei(s,0,a)}ct.strToU8=Pa;function Ty(n,e){if(e){for(var t="",r=0;r<n.length;r+=16384)t+=String.fromCharCode.apply(null,n.subarray(r,r+16384));return t}else{if(Wx)return Wx.decode(n);var i=eR(n),s=i.s,t=i.r;return t.length&&Ze(8),s}}ct.strFromU8=Ty;var tR=function(n){return n==1?3:n<6?2:n==9?1:0},nR=function(n,e){return e+30+Ar(n,e+26)+Ar(n,e+28)},rR=function(n,e,t){var r=Ar(n,e+28),i=Ty(n.subarray(e+46,e+46+r),!(Ar(n,e+8)&2048)),s=e+46+r,a=Tn(n,e+20),o=t&&a==4294967295?iR(n,s):[a,Tn(n,e+24),Tn(n,e+42)],c=o[0],l=o[1],u=o[2];return[Ar(n,e+10),c,l,i,s+Ar(n,e+30)+Ar(n,e+32),u]},iR=function(n,e){for(;Ar(n,e)!=1;e+=4+Ar(n,e+2));return[sg(n,e+12),sg(n,e+4),sg(n,e+20)]},Ra=function(n){var e=0;if(n)for(var t in n){var r=n[t].length;r>65535&&Ze(9),e+=r+4}return e},pl=function(n,e,t,r,i,s,a,o){var c=r.length,l=t.extra,u=o&&o.length,f=Ra(l);$t(n,e,a!=null?33639248:67324752),e+=4,a!=null&&(n[e++]=20,n[e++]=t.os),n[e]=20,e+=2,n[e++]=t.flag<<1|(s<0&&8),n[e++]=i&&8,n[e++]=t.compression&255,n[e++]=t.compression>>8;var d=new Date(t.mtime==null?Date.now():t.mtime),h=d.getFullYear()-1980;if((h<0||h>119)&&Ze(10),$t(n,e,h<<25|d.getMonth()+1<<21|d.getDate()<<16|d.getHours()<<11|d.getMinutes()<<5|d.getSeconds()>>1),e+=4,s!=-1&&($t(n,e,t.crc),$t(n,e+4,s<0?-s-2:s),$t(n,e+8,t.size)),$t(n,e+12,c),$t(n,e+14,f),e+=16,a!=null&&($t(n,e,u),$t(n,e+6,t.attrs),$t(n,e+10,a),e+=14),n.set(r,e),e+=c,f)for(var p in l){var g=l[p],m=g.length;$t(n,e,+p),$t(n,e+2,m),n.set(g,e+4),e+=4+m}return u&&(n.set(o,e),e+=u),e},Ay=function(n,e,t,r,i){$t(n,e,101010256),$t(n,e+8,t),$t(n,e+10,t),$t(n,e+12,r),$t(n,e+16,i)},$u=function(){function n(e){this.filename=e,this.c=Bl(),this.size=0,this.compression=0}return n.prototype.process=function(e,t){this.ondata(null,e,t)},n.prototype.push=function(e,t){this.ondata||Ze(5),this.c.p(e),this.size+=e.length,t&&(this.crc=this.c.d()),this.process(e,t||!1)},n}();ct.ZipPassThrough=$u;var Dce=function(){function n(e,t){var r=this;t||(t={}),$u.call(this,e),this.d=new Si(t,function(i,s){r.ondata(null,i,s)}),this.compression=8,this.flag=tR(t.level)}return n.prototype.process=function(e,t){try{this.d.push(e,t)}catch(r){this.ondata(r,null,t)}},n.prototype.push=function(e,t){$u.prototype.push.call(this,e,t)},n}();ct.ZipDeflate=Dce;var Lce=function(){function n(e,t){var r=this;t||(t={}),$u.call(this,e),this.d=new WM(t,function(i,s,a){r.ondata(i,s,a)}),this.compression=8,this.flag=tR(t.level),this.terminate=this.d.terminate}return n.prototype.process=function(e,t){this.d.push(e,t)},n.prototype.push=function(e,t){$u.prototype.push.call(this,e,t)},n}();ct.AsyncZipDeflate=Lce;var Oce=function(){function n(e){this.ondata=e,this.u=[],this.d=1}return n.prototype.add=function(e){var t=this;if(this.ondata||Ze(5),this.d&2)this.ondata(Ze(4+(this.d&1)*8,0,1),null,!1);else{var r=Pa(e.filename),i=r.length,s=e.comment,a=s&&Pa(s),o=i!=e.filename.length||a&&s.length!=a.length,c=i+Ra(e.extra)+30;i>65535&&this.ondata(Ze(11,0,1),null,!1);var l=new xt(c);pl(l,0,e,r,o,-1);var u=[l],f=function(){for(var m=0,v=u;m<v.length;m++){var x=v[m];t.ondata(null,x,!1)}u=[]},d=this.d;this.d=0;var h=this.u.length,p=hd(e,{f:r,u:o,o:a,t:function(){e.terminate&&e.terminate()},r:function(){if(f(),d){var m=t.u[h+1];m?m.r():t.d=1}d=1}}),g=0;e.ondata=function(m,v,x){if(m)t.ondata(m,v,x),t.terminate();else if(g+=v.length,u.push(v),x){var b=new xt(16);$t(b,0,134695760),$t(b,4,e.crc),$t(b,8,g),$t(b,12,e.size),u.push(b),p.c=g,p.b=c+g+16,p.crc=e.crc,p.size=e.size,d&&p.r(),d=1}else d&&f()},this.u.push(p)}},n.prototype.end=function(){var e=this;if(this.d&2){this.ondata(Ze(4+(this.d&1)*8,0,1),null,!0);return}this.d?this.e():this.u.push({r:function(){e.d&1&&(e.u.splice(-1,1),e.e())},t:function(){}}),this.d=3},n.prototype.e=function(){for(var e=0,t=0,r=0,i=0,s=this.u;i<s.length;i++){var a=s[i];r+=46+a.f.length+Ra(a.extra)+(a.o?a.o.length:0)}for(var o=new xt(r+22),c=0,l=this.u;c<l.length;c++){var a=l[c];pl(o,e,a,a.f,a.u,-a.c-2,t,a.o),e+=46+a.f.length+Ra(a.extra)+(a.o?a.o.length:0),t+=a.b}Ay(o,e,this.u.length,r,t),this.ondata(null,o,!0),this.d=2},n.prototype.terminate=function(){for(var e=0,t=this.u;e<t.length;e++){var r=t[e];r.t()}this.d=2},n}();ct.Zip=Oce;function zce(n,e,t){t||(t=e,e={}),typeof t!="function"&&Ze(7);var r={};Sy(n,"",r,e);var i=Object.keys(r),s=i.length,a=0,o=0,c=s,l=new Array(s),u=[],f=function(){for(var m=0;m<u.length;++m)u[m]()},d=function(m,v){hp(function(){t(m,v)})};hp(function(){d=t});var h=function(){var m=new xt(o+22),v=a,x=o-a;o=0;for(var b=0;b<c;++b){var _=l[b];try{var w=_.c.length;pl(m,o,_,_.f,_.u,w);var E=30+_.f.length+Ra(_.extra),S=o+E;m.set(_.c,S),pl(m,a,_,_.f,_.u,w,o,_.m),a+=16+E+(_.m?_.m.length:0),o=S+w}catch(T){return d(T,null)}}Ay(m,a,l.length,x,v),d(null,m)};s||h();for(var p=function(m){var v=i[m],x=r[v],b=x[0],_=x[1],w=Bl(),E=b.length;w.p(b);var S=Pa(v),T=S.length,C=_.comment,y=C&&Pa(C),A=y&&y.length,k=Ra(_.extra),M=_.level==0?0:8,L=function(z,D){if(z)f(),d(z,null);else{var F=D.length;l[m]=hd(_,{size:E,crc:w.d(),c:D,f:S,m:y,u:T!=v.length||y&&C.length!=A,compression:M}),a+=30+T+k+F,o+=76+2*(T+k)+(A||0)+F,--s||h()}};if(T>65535&&L(Ze(11,0,1),null),!M)L(null,b);else if(E<16e4)try{L(null,pd(b,_))}catch(z){L(z,null)}else u.push(qM(b,_,L))},g=0;g<c;++g)p(g);return f}ct.zip=zce;function Pce(n,e){e||(e={});var t={},r=[];Sy(n,"",t,e);var i=0,s=0;for(var a in t){var o=t[a],c=o[0],l=o[1],u=l.level==0?0:8,f=Pa(a),d=f.length,h=l.comment,p=h&&Pa(h),g=p&&p.length,m=Ra(l.extra);d>65535&&Ze(11);var v=u?pd(c,l):c,x=v.length,b=Bl();b.p(c),r.push(hd(l,{size:c.length,crc:b.d(),c:v,f,m:p,u:d!=a.length||p&&h.length!=g,o:i,compression:u})),i+=30+d+m+x,s+=76+2*(d+m)+(g||0)+x}for(var _=new xt(s+22),w=i,E=s-i,S=0;S<r.length;++S){var f=r[S];pl(_,f.o,f,f.f,f.u,f.c.length);var T=30+f.f.length+Ra(f.extra);_.set(f.c,f.o+T),pl(_,i,f,f.f,f.u,f.c.length,f.o,f.m),i+=16+T+(f.m?f.m.length:0)}return Ay(_,i,r.length,E,w),_}ct.zipSync=Pce;var sR=function(){function n(){}return n.prototype.push=function(e,t){this.ondata(null,e,t)},n.compression=0,n}();ct.UnzipPassThrough=sR;var Fce=function(){function n(){var e=this;this.i=new Gr(function(t,r){e.ondata(null,t,r)})}return n.prototype.push=function(e,t){try{this.i.push(e,t)}catch(r){this.ondata(r,null,t)}},n.compression=8,n}();ct.UnzipInflate=Fce;var $ce=function(){function n(e,t){var r=this;t<32e4?this.i=new Gr(function(i,s){r.ondata(null,i,s)}):(this.i=new wy(function(i,s,a){r.ondata(i,s,a)}),this.terminate=this.i.terminate)}return n.prototype.push=function(e,t){this.i.terminate&&(e=Ei(e,0)),this.i.push(e,t)},n.compression=8,n}();ct.AsyncUnzipInflate=$ce;var Uce=function(){function n(e){this.onfile=e,this.k=[],this.o={0:sR},this.p=Ea}return n.prototype.push=function(e,t){var r=this;if(this.onfile||Ze(5),this.p||Ze(4),this.c>0){var i=Math.min(this.c,e.length),s=e.subarray(0,i);if(this.c-=i,this.d?this.d.push(s,!this.c):this.k[0].push(s),e=e.subarray(i),e.length)return this.push(e,t)}else{var a=0,o=0,c=void 0,l=void 0;this.p.length?e.length?(l=new xt(this.p.length+e.length),l.set(this.p),l.set(e,this.p.length)):l=this.p:l=e;for(var u=l.length,f=this.c,d=f&&this.d,h=function(){var v,x=Tn(l,o);if(x==67324752){a=1,c=o,p.d=null,p.c=0;var b=Ar(l,o+6),_=Ar(l,o+8),w=b&2048,E=b&8,S=Ar(l,o+26),T=Ar(l,o+28);if(u>o+30+S+T){var C=[];p.k.unshift(C),a=2;var y=Tn(l,o+18),A=Tn(l,o+22),k=Ty(l.subarray(o+30,o+=30+S),!w);y==4294967295?(v=E?[-2]:iR(l,o),y=v[0],A=v[1]):E&&(y=-1),o+=T,p.c=y;var M,L={name:k,compression:_,start:function(){if(L.ondata||Ze(5),!y)L.ondata(null,Ea,!0);else{var z=r.o[_];z||L.ondata(Ze(14,"unknown compression type "+_,1),null,!1),M=y<0?new z(k):new z(k,y,A),M.ondata=function(V,J,Q){L.ondata(V,J,Q)};for(var D=0,F=C;D<F.length;D++){var O=F[D];M.push(O,!1)}r.k[0]==C&&r.c?r.d=M:M.push(Ea,!0)}},terminate:function(){M&&M.terminate&&M.terminate()}};y>=0&&(L.size=y,L.originalSize=A),p.onfile(L)}return"break"}else if(f){if(x==134695760)return c=o+=12+(f==-2&&8),a=3,p.c=0,"break";if(x==33639248)return c=o-=4,a=3,p.c=0,"break"}},p=this;o<u-4;++o){var g=h();if(g==="break")break}if(this.p=Ea,f<0){var m=a?l.subarray(0,c-12-(f==-2&&8)-(Tn(l,c-16)==134695760&&4)):l.subarray(0,o);d?d.push(m,!!a):this.k[+(a==2)].push(m)}if(a&2)return this.push(l.subarray(o),t);this.p=l.subarray(o)}t&&(this.c&&Ze(13),this.p=null)},n.prototype.register=function(e){this.o[e.compression]=e},n}();ct.Unzip=Uce;var hp=typeof queueMicrotask=="function"?queueMicrotask:typeof setTimeout=="function"?setTimeout:function(n){n()};function Bce(n,e,t){t||(t=e,e={}),typeof t!="function"&&Ze(7);var r=[],i=function(){for(var m=0;m<r.length;++m)r[m]()},s={},a=function(m,v){hp(function(){t(m,v)})};hp(function(){a=t});for(var o=n.length-22;Tn(n,o)!=101010256;--o)if(!o||n.length-o>65558)return a(Ze(13,0,1),null),i;var c=Ar(n,o+8);if(c){var l=c,u=Tn(n,o+16),f=u==4294967295||l==65535;if(f){var d=Tn(n,o-12);f=Tn(n,d)==101075792,f&&(l=c=Tn(n,d+32),u=Tn(n,d+48))}for(var h=e&&e.filter,p=function(m){var v=rR(n,u,f),x=v[0],b=v[1],_=v[2],w=v[3],E=v[4],S=v[5],T=nR(n,S);u=E;var C=function(A,k){A?(i(),a(A,null)):(k&&(s[w]=k),--c||a(null,s))};if(!h||h({name:w,size:b,originalSize:_,compression:x}))if(!x)C(null,Ei(n,T,T+b));else if(x==8){var y=n.subarray(T,T+b);if(_<524288||b>.8*_)try{C(null,ql(y,{out:new xt(_)}))}catch(A){C(A,null)}else r.push(Ey(y,{size:_},C))}else C(Ze(14,"unknown compression type "+x,1),null);else C(null,null)},g=0;g<l;++g)p(g)}else a(null,{});return i}ct.unzip=Bce;function Vce(n,e){for(var t={},r=n.length-22;Tn(n,r)!=101010256;--r)(!r||n.length-r>65558)&&Ze(13);var i=Ar(n,r+8);if(!i)return{};var s=Tn(n,r+16),a=s==4294967295||i==65535;if(a){var o=Tn(n,r-12);a=Tn(n,o)==101075792,a&&(i=Tn(n,o+32),s=Tn(n,o+48))}for(var c=e&&e.filter,l=0;l<i;++l){var u=rR(n,s,a),f=u[0],d=u[1],h=u[2],p=u[3],g=u[4],m=u[5],v=nR(n,m);s=g,(!c||c({name:p,size:d,originalSize:h,compression:f}))&&(f?f==8?t[p]=ql(n.subarray(v,v+d),{out:new xt(h)}):Ze(14,"unknown compression type "+f):t[p]=Ei(n,v,v+d))}return t}ct.unzipSync=Vce;var ml={},$o={},md={};Object.defineProperty(md,"__esModule",{value:!0});md.NIFTIEXTENSION=void 0;class Gce{constructor(e,t,r,i){re(this,"esize");re(this,"ecode");re(this,"edata");re(this,"littleEndian");if(e%16!=0)throw new Error("This does not appear to be a NIFTI extension");this.esize=e,this.ecode=t,this.edata=r,this.littleEndian=i}toArrayBuffer(){let e=new Uint8Array(this.esize),t=new Uint8Array(this.edata);e.set(t,8);let r=new DataView(e.buffer);return r.setInt32(0,this.esize,this.littleEndian),r.setInt32(4,this.ecode,this.littleEndian),e.buffer}}md.NIFTIEXTENSION=Gce;Object.defineProperty($o,"__esModule",{value:!0});$o.Utils=void 0;const Hce=md,dr=class dr{static getStringAt(e,t,r){var i="",s,a;for(s=t;s<r;s+=1)a=e.getUint8(s),a!==0&&(i+=String.fromCharCode(a));return i}static getIntAt(e,t,r){return e.getInt32(t,r)}static getFloatAt(e,t,r){return e.getFloat32(t,r)}static getDoubleAt(e,t,r){return e.getFloat64(t,r)}static getLongAt(e,t,r){var i,s=[],a=0;for(i=0;i<8;i+=1)s[i]=dr.getByteAt(e,t+i);for(i=s.length-1;i>=0;i--)a=a*256+s[i];return a}static getExtensionsAt(e,t,r,i){let s=[],a=t;for(;a<i;){let o=r,c=dr.getIntAt(e,a,r);if(!c)break;if(c+a>i&&(o=!o,c=dr.getIntAt(e,a,o),c+a>i))throw new Error("This does not appear to be a valid NIFTI extension");if(c%16!=0)throw new Error("This does not appear to be a NIFTI extension");let l=dr.getIntAt(e,a+4,o),u=e.buffer.slice(a+8,a+c);console.log("extensionByteIndex: "+(a+8)+" esize: "+c),console.log(u);let f=new Hce.NIFTIEXTENSION(c,l,u,o);s.push(f),a+=c}return s}static toArrayBuffer(e){var t,r,i;for(t=new ArrayBuffer(e.length),r=new Uint8Array(t),i=0;i<e.length;i+=1)r[i]=e[i];return t}static isString(e){return typeof e=="string"||e instanceof String}static formatNumber(e,t=void 0){let r;return dr.isString(e)?r=Number(e):r=e,t?r=r.toPrecision(5):r=r.toPrecision(7),parseFloat(r)}static makeCRCTable(){let e,t=[];for(var r=0;r<256;r++){e=r;for(var i=0;i<8;i++)e=e&1?3988292384^e>>>1:e>>>1;t[r]=e}return t}static crc32(e){dr.crcTable||(dr.crcTable=dr.makeCRCTable());const t=dr.crcTable;let r=-1;for(var i=0;i<e.byteLength;i++)r=r>>>8^t[(r^e.getUint8(i))&255];return(r^-1)>>>0}};re(dr,"crcTable",null),re(dr,"GUNZIP_MAGIC_COOKIE1",31),re(dr,"GUNZIP_MAGIC_COOKIE2",139),re(dr,"getByteAt",function(e,t){return e.getInt8(t)}),re(dr,"getShortAt",function(e,t,r){return e.getInt16(t,r)});let qx=dr;$o.Utils=qx;Object.defineProperty(ml,"__esModule",{value:!0});ml.NIFTI1=void 0;const mt=$o,De=class De{constructor(){re(this,"littleEndian",!1);re(this,"dim_info",0);re(this,"dims",[]);re(this,"intent_p1",0);re(this,"intent_p2",0);re(this,"intent_p3",0);re(this,"intent_code",0);re(this,"datatypeCode",0);re(this,"numBitsPerVoxel",0);re(this,"slice_start",0);re(this,"slice_end",0);re(this,"slice_code",0);re(this,"pixDims",[]);re(this,"vox_offset",0);re(this,"scl_slope",1);re(this,"scl_inter",0);re(this,"xyzt_units",0);re(this,"cal_max",0);re(this,"cal_min",0);re(this,"slice_duration",0);re(this,"toffset",0);re(this,"description","");re(this,"aux_file","");re(this,"intent_name","");re(this,"qform_code",0);re(this,"sform_code",0);re(this,"quatern_a",0);re(this,"quatern_b",0);re(this,"quatern_c",0);re(this,"quatern_d",0);re(this,"qoffset_x",0);re(this,"qoffset_y",0);re(this,"qoffset_z",0);re(this,"affine",[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]);re(this,"qfac",1);re(this,"quatern_R");re(this,"magic","0");re(this,"isHDR",!1);re(this,"extensionFlag",[0,0,0,0]);re(this,"extensionSize",0);re(this,"extensionCode",0);re(this,"extensions",[]);re(this,"getDatatypeCodeString",function(e){return e===De.TYPE_UINT8?"1-Byte Unsigned Integer":e===De.TYPE_INT16?"2-Byte Signed Integer":e===De.TYPE_INT32?"4-Byte Signed Integer":e===De.TYPE_FLOAT32?"4-Byte Float":e===De.TYPE_FLOAT64?"8-Byte Float":e===De.TYPE_RGB24?"RGB":e===De.TYPE_INT8?"1-Byte Signed Integer":e===De.TYPE_UINT16?"2-Byte Unsigned Integer":e===De.TYPE_UINT32?"4-Byte Unsigned Integer":e===De.TYPE_INT64?"8-Byte Signed Integer":e===De.TYPE_UINT64?"8-Byte Unsigned Integer":"Unknown"});re(this,"getTransformCodeString",function(e){return e===De.XFORM_SCANNER_ANAT?"Scanner":e===De.XFORM_ALIGNED_ANAT?"Aligned":e===De.XFORM_TALAIRACH?"Talairach":e===De.XFORM_MNI_152?"MNI":"Unknown"});re(this,"getUnitsCodeString",function(e){return e===De.UNITS_METER?"Meters":e===De.UNITS_MM?"Millimeters":e===De.UNITS_MICRON?"Microns":e===De.UNITS_SEC?"Seconds":e===De.UNITS_MSEC?"Milliseconds":e===De.UNITS_USEC?"Microseconds":e===De.UNITS_HZ?"Hz":e===De.UNITS_PPM?"PPM":e===De.UNITS_RADS?"Rads":"Unknown"});re(this,"nifti_mat33_mul",function(e,t){var r=[[0,0,0],[0,0,0],[0,0,0]],i,s;for(i=0;i<3;i+=1)for(s=0;s<3;s+=1)r[i][s]=e[i][0]*t[0][s]+e[i][1]*t[1][s]+e[i][2]*t[2][s];return r});re(this,"nifti_mat33_determ",function(e){var t,r,i,s,a,o,c,l,u;return t=e[0][0],r=e[0][1],i=e[0][2],s=e[1][0],a=e[1][1],o=e[1][2],c=e[2][0],l=e[2][1],u=e[2][2],t*a*u-t*l*o-s*r*u+s*l*i+c*r*o-c*a*i})}readHeader(e){var t=new DataView(e),r=mt.Utils.getIntAt(t,0,this.littleEndian),i,s,a,o;if(r!==De.MAGIC_COOKIE&&(this.littleEndian=!0,r=mt.Utils.getIntAt(t,0,this.littleEndian)),r!==De.MAGIC_COOKIE)throw new Error("This does not appear to be a NIFTI file!");for(this.dim_info=mt.Utils.getByteAt(t,39),i=0;i<8;i+=1)o=40+i*2,this.dims[i]=mt.Utils.getShortAt(t,o,this.littleEndian);for(this.intent_p1=mt.Utils.getFloatAt(t,56,this.littleEndian),this.intent_p2=mt.Utils.getFloatAt(t,60,this.littleEndian),this.intent_p3=mt.Utils.getFloatAt(t,64,this.littleEndian),this.intent_code=mt.Utils.getShortAt(t,68,this.littleEndian),this.datatypeCode=mt.Utils.getShortAt(t,70,this.littleEndian),this.numBitsPerVoxel=mt.Utils.getShortAt(t,72,this.littleEndian),this.slice_start=mt.Utils.getShortAt(t,74,this.littleEndian),i=0;i<8;i+=1)o=76+i*4,this.pixDims[i]=mt.Utils.getFloatAt(t,o,this.littleEndian);if(this.vox_offset=mt.Utils.getFloatAt(t,108,this.littleEndian),this.scl_slope=mt.Utils.getFloatAt(t,112,this.littleEndian),this.scl_inter=mt.Utils.getFloatAt(t,116,this.littleEndian),this.slice_end=mt.Utils.getShortAt(t,120,this.littleEndian),this.slice_code=mt.Utils.getByteAt(t,122),this.xyzt_units=mt.Utils.getByteAt(t,123),this.cal_max=mt.Utils.getFloatAt(t,124,this.littleEndian),this.cal_min=mt.Utils.getFloatAt(t,128,this.littleEndian),this.slice_duration=mt.Utils.getFloatAt(t,132,this.littleEndian),this.toffset=mt.Utils.getFloatAt(t,136,this.littleEndian),this.description=mt.Utils.getStringAt(t,148,228),this.aux_file=mt.Utils.getStringAt(t,228,252),this.qform_code=mt.Utils.getShortAt(t,252,this.littleEndian),this.sform_code=mt.Utils.getShortAt(t,254,this.littleEndian),this.quatern_b=mt.Utils.getFloatAt(t,256,this.littleEndian),this.quatern_c=mt.Utils.getFloatAt(t,260,this.littleEndian),this.quatern_d=mt.Utils.getFloatAt(t,264,this.littleEndian),this.quatern_a=Math.sqrt(1-(Math.pow(this.quatern_b,2)+Math.pow(this.quatern_c,2)+Math.pow(this.quatern_d,2))),this.qoffset_x=mt.Utils.getFloatAt(t,268,this.littleEndian),this.qoffset_y=mt.Utils.getFloatAt(t,272,this.littleEndian),this.qoffset_z=mt.Utils.getFloatAt(t,276,this.littleEndian),this.qform_code<1&&this.sform_code<1&&(this.affine[0][0]=this.pixDims[1],this.affine[1][1]=this.pixDims[2],this.affine[2][2]=this.pixDims[3]),this.qform_code>0&&this.sform_code<this.qform_code){const c=this.quatern_a,l=this.quatern_b,u=this.quatern_c,f=this.quatern_d;for(this.qfac=this.pixDims[0]===0?1:this.pixDims[0],this.quatern_R=[[c*c+l*l-u*u-f*f,2*l*u-2*c*f,2*l*f+2*c*u],[2*l*u+2*c*f,c*c+u*u-l*l-f*f,2*u*f-2*c*l],[2*l*f-2*c*u,2*u*f+2*c*l,c*c+f*f-u*u-l*l]],s=0;s<3;s+=1)for(a=0;a<3;a+=1)this.affine[s][a]=this.quatern_R[s][a]*this.pixDims[a+1],a===2&&(this.affine[s][a]*=this.qfac);this.affine[0][3]=this.qoffset_x,this.affine[1][3]=this.qoffset_y,this.affine[2][3]=this.qoffset_z}else if(this.sform_code>0)for(s=0;s<3;s+=1)for(a=0;a<4;a+=1)o=280+(s*4+a)*4,this.affine[s][a]=mt.Utils.getFloatAt(t,o,this.littleEndian);if(this.affine[3][0]=0,this.affine[3][1]=0,this.affine[3][2]=0,this.affine[3][3]=1,this.intent_name=mt.Utils.getStringAt(t,328,344),this.magic=mt.Utils.getStringAt(t,344,348),this.isHDR=this.magic===String.fromCharCode.apply(null,De.MAGIC_NUMBER2),t.byteLength>De.MAGIC_COOKIE){this.extensionFlag[0]=mt.Utils.getByteAt(t,348),this.extensionFlag[1]=mt.Utils.getByteAt(t,348+1),this.extensionFlag[2]=mt.Utils.getByteAt(t,348+2),this.extensionFlag[3]=mt.Utils.getByteAt(t,348+3);let c=!0;!this.isHDR&&this.vox_offset<=352&&(c=!1),t.byteLength<=352+16&&(c=!1),c&&this.extensionFlag[0]&&(this.extensions=mt.Utils.getExtensionsAt(t,this.getExtensionLocation(),this.littleEndian,this.vox_offset),this.extensionSize=this.extensions[0].esize,this.extensionCode=this.extensions[0].ecode)}}toFormattedString(){var e=mt.Utils.formatNumber,t="";return t+="Dim Info = "+this.dim_info+`
`,t+="Image Dimensions (1-8): "+this.dims[0]+", "+this.dims[1]+", "+this.dims[2]+", "+this.dims[3]+", "+this.dims[4]+", "+this.dims[5]+", "+this.dims[6]+", "+this.dims[7]+`
`,t+="Intent Parameters (1-3): "+this.intent_p1+", "+this.intent_p2+", "+this.intent_p3+`
`,t+="Intent Code = "+this.intent_code+`
`,t+="Datatype = "+this.datatypeCode+" ("+this.getDatatypeCodeString(this.datatypeCode)+`)
`,t+="Bits Per Voxel = "+this.numBitsPerVoxel+`
`,t+="Slice Start = "+this.slice_start+`
`,t+="Voxel Dimensions (1-8): "+e(this.pixDims[0])+", "+e(this.pixDims[1])+", "+e(this.pixDims[2])+", "+e(this.pixDims[3])+", "+e(this.pixDims[4])+", "+e(this.pixDims[5])+", "+e(this.pixDims[6])+", "+e(this.pixDims[7])+`
`,t+="Image Offset = "+this.vox_offset+`
`,t+="Data Scale:  Slope = "+e(this.scl_slope)+"  Intercept = "+e(this.scl_inter)+`
`,t+="Slice End = "+this.slice_end+`
`,t+="Slice Code = "+this.slice_code+`
`,t+="Units Code = "+this.xyzt_units+" ("+this.getUnitsCodeString(De.SPATIAL_UNITS_MASK&this.xyzt_units)+", "+this.getUnitsCodeString(De.TEMPORAL_UNITS_MASK&this.xyzt_units)+`)
`,t+="Display Range:  Max = "+e(this.cal_max)+"  Min = "+e(this.cal_min)+`
`,t+="Slice Duration = "+this.slice_duration+`
`,t+="Time Axis Shift = "+this.toffset+`
`,t+='Description: "'+this.description+`"
`,t+='Auxiliary File: "'+this.aux_file+`"
`,t+="Q-Form Code = "+this.qform_code+" ("+this.getTransformCodeString(this.qform_code)+`)
`,t+="S-Form Code = "+this.sform_code+" ("+this.getTransformCodeString(this.sform_code)+`)
`,t+="Quaternion Parameters:  b = "+e(this.quatern_b)+"  c = "+e(this.quatern_c)+"  d = "+e(this.quatern_d)+`
`,t+="Quaternion Offsets:  x = "+this.qoffset_x+"  y = "+this.qoffset_y+"  z = "+this.qoffset_z+`
`,t+="S-Form Parameters X: "+e(this.affine[0][0])+", "+e(this.affine[0][1])+", "+e(this.affine[0][2])+", "+e(this.affine[0][3])+`
`,t+="S-Form Parameters Y: "+e(this.affine[1][0])+", "+e(this.affine[1][1])+", "+e(this.affine[1][2])+", "+e(this.affine[1][3])+`
`,t+="S-Form Parameters Z: "+e(this.affine[2][0])+", "+e(this.affine[2][1])+", "+e(this.affine[2][2])+", "+e(this.affine[2][3])+`
`,t+='Intent Name: "'+this.intent_name+`"
`,this.extensionFlag[0]&&(t+="Extension: Size = "+this.extensionSize+"  Code = "+this.extensionCode+`
`),t}getQformMat(){return this.convertNiftiQFormToNiftiSForm(this.quatern_b,this.quatern_c,this.quatern_d,this.qoffset_x,this.qoffset_y,this.qoffset_z,this.pixDims[1],this.pixDims[2],this.pixDims[3],this.pixDims[0])}convertNiftiQFormToNiftiSForm(e,t,r,i,s,a,o,c,l,u){var f=[[0,0,0,0],[0,0,0,0],[0,0,0,0],[0,0,0,0]],d,h=e,p=t,g=r,m,v,x;return f[3][0]=f[3][1]=f[3][2]=0,f[3][3]=1,d=1-(h*h+p*p+g*g),d<1e-7?(d=1/Math.sqrt(h*h+p*p+g*g),h*=d,p*=d,g*=d,d=0):d=Math.sqrt(d),m=o>0?o:1,v=c>0?c:1,x=l>0?l:1,u<0&&(x=-x),f[0][0]=(d*d+h*h-p*p-g*g)*m,f[0][1]=2*(h*p-d*g)*v,f[0][2]=2*(h*g+d*p)*x,f[1][0]=2*(h*p+d*g)*m,f[1][1]=(d*d+p*p-h*h-g*g)*v,f[1][2]=2*(p*g-d*h)*x,f[2][0]=2*(h*g-d*p)*m,f[2][1]=2*(p*g+d*h)*v,f[2][2]=(d*d+g*g-p*p-h*h)*x,f[0][3]=i,f[1][3]=s,f[2][3]=a,f}convertNiftiSFormToNEMA(e){var t,r,i,s,a,o,c,l,u,f,d,h,p,g,m,v,x,b,_,w,E,S,T,C,y,A,k,M,L,z,D,F,O,V;if(m=0,k=[[0,0,0],[0,0,0],[0,0,0]],M=[[0,0,0],[0,0,0],[0,0,0]],t=e[0][0],r=e[0][1],i=e[0][2],s=e[1][0],a=e[1][1],o=e[1][2],c=e[2][0],l=e[2][1],u=e[2][2],f=Math.sqrt(t*t+s*s+c*c),f===0||(t/=f,s/=f,c/=f,f=Math.sqrt(r*r+a*a+l*l),f===0))return null;if(r/=f,a/=f,l/=f,f=t*r+s*a+c*l,Math.abs(f)>1e-4){if(r-=f*t,a-=f*s,l-=f*c,f=Math.sqrt(r*r+a*a+l*l),f===0)return null;r/=f,a/=f,l/=f}if(f=Math.sqrt(i*i+o*o+u*u),f===0?(i=s*l-c*a,o=c*r-l*t,u=t*a-s*r):(i/=f,o/=f,u/=f),f=t*i+s*o+c*u,Math.abs(f)>1e-4){if(i-=f*t,o-=f*s,u-=f*c,f=Math.sqrt(i*i+o*o+u*u),f===0)return null;i/=f,o/=f,u/=f}if(f=r*i+a*o+l*u,Math.abs(f)>1e-4){if(i-=f*r,o-=f*a,u-=f*l,f=Math.sqrt(i*i+o*o+u*u),f===0)return null;i/=f,o/=f,u/=f}if(k[0][0]=t,k[0][1]=r,k[0][2]=i,k[1][0]=s,k[1][1]=a,k[1][2]=o,k[2][0]=c,k[2][1]=l,k[2][2]=u,d=this.nifti_mat33_determ(k),d===0)return null;for(A=-666,_=S=T=C=1,w=2,E=3,p=1;p<=3;p+=1)for(g=1;g<=3;g+=1)if(p!==g){for(m=1;m<=3;m+=1)if(!(p===m||g===m))for(M[0][0]=M[0][1]=M[0][2]=M[1][0]=M[1][1]=M[1][2]=M[2][0]=M[2][1]=M[2][2]=0,v=-1;v<=1;v+=2)for(x=-1;x<=1;x+=2)for(b=-1;b<=1;b+=2)M[0][p-1]=v,M[1][g-1]=x,M[2][m-1]=b,h=this.nifti_mat33_determ(M),h*d>0&&(y=this.nifti_mat33_mul(M,k),f=y[0][0]+y[1][1]+y[2][2],f>A&&(A=f,_=p,w=g,E=m,S=v,T=x,C=b))}switch(L=z=D=F=O=V="",_*S){case 1:L="X",F="+";break;case-1:L="X",F="-";break;case 2:L="Y",F="+";break;case-2:L="Y",F="-";break;case 3:L="Z",F="+";break;case-3:L="Z",F="-";break}switch(w*T){case 1:z="X",O="+";break;case-1:z="X",O="-";break;case 2:z="Y",O="+";break;case-2:z="Y",O="-";break;case 3:z="Z",O="+";break;case-3:z="Z",O="-";break}switch(E*C){case 1:D="X",V="+";break;case-1:D="X",V="-";break;case 2:D="Y",V="+";break;case-2:D="Y",V="-";break;case 3:D="Z",V="+";break;case-3:D="Z",V="-";break}return L+z+D+F+O+V}getExtensionLocation(){return De.MAGIC_COOKIE+4}getExtensionSize(e){return mt.Utils.getIntAt(e,this.getExtensionLocation(),this.littleEndian)}getExtensionCode(e){return mt.Utils.getIntAt(e,this.getExtensionLocation()+4,this.littleEndian)}addExtension(e,t=-1){t==-1?this.extensions.push(e):this.extensions.splice(t,0,e),this.vox_offset+=e.esize}removeExtension(e){let t=this.extensions[e];t&&(this.vox_offset-=t.esize),this.extensions.splice(e,1)}toArrayBuffer(e=!1){let i=352;if(e)for(let c of this.extensions)i+=c.esize;let s=new Uint8Array(i),a=new DataView(s.buffer);a.setInt32(0,348,this.littleEndian),a.setUint8(39,this.dim_info);for(let c=0;c<8;c++)a.setUint16(40+2*c,this.dims[c],this.littleEndian);a.setFloat32(56,this.intent_p1,this.littleEndian),a.setFloat32(60,this.intent_p2,this.littleEndian),a.setFloat32(64,this.intent_p3,this.littleEndian),a.setInt16(68,this.intent_code,this.littleEndian),a.setInt16(70,this.datatypeCode,this.littleEndian),a.setInt16(72,this.numBitsPerVoxel,this.littleEndian),a.setInt16(74,this.slice_start,this.littleEndian);for(let c=0;c<8;c++)a.setFloat32(76+4*c,this.pixDims[c],this.littleEndian);a.setFloat32(108,this.vox_offset,this.littleEndian),a.setFloat32(112,this.scl_slope,this.littleEndian),a.setFloat32(116,this.scl_inter,this.littleEndian),a.setInt16(120,this.slice_end,this.littleEndian),a.setUint8(122,this.slice_code),a.setUint8(123,this.xyzt_units),a.setFloat32(124,this.cal_max,this.littleEndian),a.setFloat32(128,this.cal_min,this.littleEndian),a.setFloat32(132,this.slice_duration,this.littleEndian),a.setFloat32(136,this.toffset,this.littleEndian),s.set(Buffer.from(this.description),148),s.set(Buffer.from(this.aux_file),228),a.setInt16(252,this.qform_code,this.littleEndian),a.setInt16(254,this.sform_code,this.littleEndian),a.setFloat32(256,this.quatern_b,this.littleEndian),a.setFloat32(260,this.quatern_c,this.littleEndian),a.setFloat32(264,this.quatern_d,this.littleEndian),a.setFloat32(268,this.qoffset_x,this.littleEndian),a.setFloat32(272,this.qoffset_y,this.littleEndian),a.setFloat32(276,this.qoffset_z,this.littleEndian);const o=this.affine.flat();for(let c=0;c<12;c++)a.setFloat32(280+4*c,o[c],this.littleEndian);if(s.set(Buffer.from(this.intent_name),328),s.set(Buffer.from(this.magic),344),e){s.set(Uint8Array.from([1,0,0,0]),348);let c=this.getExtensionLocation();for(const l of this.extensions)a.setInt32(c,l.esize,l.littleEndian),a.setInt32(c+4,l.ecode,l.littleEndian),s.set(new Uint8Array(l.edata),c+8),c+=l.esize}else s.set(new Uint8Array(4).fill(0),348);return s.buffer}};re(De,"TYPE_NONE",0),re(De,"TYPE_BINARY",1),re(De,"TYPE_UINT8",2),re(De,"TYPE_INT16",4),re(De,"TYPE_INT32",8),re(De,"TYPE_FLOAT32",16),re(De,"TYPE_COMPLEX64",32),re(De,"TYPE_FLOAT64",64),re(De,"TYPE_RGB24",128),re(De,"TYPE_INT8",256),re(De,"TYPE_UINT16",512),re(De,"TYPE_UINT32",768),re(De,"TYPE_INT64",1024),re(De,"TYPE_UINT64",1280),re(De,"TYPE_FLOAT128",1536),re(De,"TYPE_COMPLEX128",1792),re(De,"TYPE_COMPLEX256",2048),re(De,"XFORM_UNKNOWN",0),re(De,"XFORM_SCANNER_ANAT",1),re(De,"XFORM_ALIGNED_ANAT",2),re(De,"XFORM_TALAIRACH",3),re(De,"XFORM_MNI_152",4),re(De,"SPATIAL_UNITS_MASK",7),re(De,"TEMPORAL_UNITS_MASK",56),re(De,"UNITS_UNKNOWN",0),re(De,"UNITS_METER",1),re(De,"UNITS_MM",2),re(De,"UNITS_MICRON",3),re(De,"UNITS_SEC",8),re(De,"UNITS_MSEC",16),re(De,"UNITS_USEC",24),re(De,"UNITS_HZ",32),re(De,"UNITS_PPM",40),re(De,"UNITS_RADS",48),re(De,"MAGIC_COOKIE",348),re(De,"STANDARD_HEADER_SIZE",348),re(De,"MAGIC_NUMBER_LOCATION",344),re(De,"MAGIC_NUMBER",[110,43,49]),re(De,"MAGIC_NUMBER2",[110,105,49]),re(De,"EXTENSION_HEADER_SIZE",8);let Xx=De;ml.NIFTI1=Xx;var Uu={};Object.defineProperty(Uu,"__esModule",{value:!0});Uu.NIFTI2=void 0;const Pr=ml,_t=$o,ts=class ts{constructor(){re(this,"littleEndian",!1);re(this,"dim_info",0);re(this,"dims",[]);re(this,"intent_p1",0);re(this,"intent_p2",0);re(this,"intent_p3",0);re(this,"intent_code",0);re(this,"datatypeCode",0);re(this,"numBitsPerVoxel",0);re(this,"slice_start",0);re(this,"slice_end",0);re(this,"slice_code",0);re(this,"pixDims",[]);re(this,"vox_offset",0);re(this,"scl_slope",1);re(this,"scl_inter",0);re(this,"xyzt_units",0);re(this,"cal_max",0);re(this,"cal_min",0);re(this,"slice_duration",0);re(this,"toffset",0);re(this,"description","");re(this,"aux_file","");re(this,"intent_name","");re(this,"qform_code",0);re(this,"sform_code",0);re(this,"quatern_b",0);re(this,"quatern_c",0);re(this,"quatern_d",0);re(this,"qoffset_x",0);re(this,"qoffset_y",0);re(this,"qoffset_z",0);re(this,"affine",[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]]);re(this,"magic","0");re(this,"extensionFlag",[0,0,0,0]);re(this,"extensions",[]);re(this,"extensionSize",0);re(this,"extensionCode",0);re(this,"getExtensionLocation",function(){return ts.MAGIC_COOKIE+4});re(this,"getExtensionSize",Pr.NIFTI1.prototype.getExtensionSize);re(this,"getExtensionCode",Pr.NIFTI1.prototype.getExtensionCode);re(this,"addExtension",Pr.NIFTI1.prototype.addExtension);re(this,"removeExtension",Pr.NIFTI1.prototype.removeExtension);re(this,"getDatatypeCodeString",Pr.NIFTI1.prototype.getDatatypeCodeString);re(this,"getTransformCodeString",Pr.NIFTI1.prototype.getTransformCodeString);re(this,"getUnitsCodeString",Pr.NIFTI1.prototype.getUnitsCodeString);re(this,"getQformMat",Pr.NIFTI1.prototype.getQformMat);re(this,"convertNiftiQFormToNiftiSForm",Pr.NIFTI1.prototype.convertNiftiQFormToNiftiSForm);re(this,"convertNiftiSFormToNEMA",Pr.NIFTI1.prototype.convertNiftiSFormToNEMA);re(this,"nifti_mat33_mul",Pr.NIFTI1.prototype.nifti_mat33_mul);re(this,"nifti_mat33_determ",Pr.NIFTI1.prototype.nifti_mat33_determ)}readHeader(e){var t=new DataView(e),r=_t.Utils.getIntAt(t,0,this.littleEndian),i,s,a,o;if(r!==ts.MAGIC_COOKIE&&(this.littleEndian=!0,r=_t.Utils.getIntAt(t,0,this.littleEndian)),r!==ts.MAGIC_COOKIE)throw new Error("This does not appear to be a NIFTI file!");for(this.magic=_t.Utils.getStringAt(t,4,12),this.datatypeCode=_t.Utils.getShortAt(t,12,this.littleEndian),this.numBitsPerVoxel=_t.Utils.getShortAt(t,14,this.littleEndian),i=0;i<8;i+=1)o=16+i*8,this.dims[i]=_t.Utils.getLongAt(t,o,this.littleEndian);for(this.intent_p1=_t.Utils.getDoubleAt(t,80,this.littleEndian),this.intent_p2=_t.Utils.getDoubleAt(t,88,this.littleEndian),this.intent_p3=_t.Utils.getDoubleAt(t,96,this.littleEndian),i=0;i<8;i+=1)o=104+i*8,this.pixDims[i]=_t.Utils.getDoubleAt(t,o,this.littleEndian);for(this.vox_offset=_t.Utils.getLongAt(t,168,this.littleEndian),this.scl_slope=_t.Utils.getDoubleAt(t,176,this.littleEndian),this.scl_inter=_t.Utils.getDoubleAt(t,184,this.littleEndian),this.cal_max=_t.Utils.getDoubleAt(t,192,this.littleEndian),this.cal_min=_t.Utils.getDoubleAt(t,200,this.littleEndian),this.slice_duration=_t.Utils.getDoubleAt(t,208,this.littleEndian),this.toffset=_t.Utils.getDoubleAt(t,216,this.littleEndian),this.slice_start=_t.Utils.getLongAt(t,224,this.littleEndian),this.slice_end=_t.Utils.getLongAt(t,232,this.littleEndian),this.description=_t.Utils.getStringAt(t,240,240+80),this.aux_file=_t.Utils.getStringAt(t,320,320+24),this.qform_code=_t.Utils.getIntAt(t,344,this.littleEndian),this.sform_code=_t.Utils.getIntAt(t,348,this.littleEndian),this.quatern_b=_t.Utils.getDoubleAt(t,352,this.littleEndian),this.quatern_c=_t.Utils.getDoubleAt(t,360,this.littleEndian),this.quatern_d=_t.Utils.getDoubleAt(t,368,this.littleEndian),this.qoffset_x=_t.Utils.getDoubleAt(t,376,this.littleEndian),this.qoffset_y=_t.Utils.getDoubleAt(t,384,this.littleEndian),this.qoffset_z=_t.Utils.getDoubleAt(t,392,this.littleEndian),s=0;s<3;s+=1)for(a=0;a<4;a+=1)o=400+(s*4+a)*8,this.affine[s][a]=_t.Utils.getDoubleAt(t,o,this.littleEndian);this.affine[3][0]=0,this.affine[3][1]=0,this.affine[3][2]=0,this.affine[3][3]=1,this.slice_code=_t.Utils.getIntAt(t,496,this.littleEndian),this.xyzt_units=_t.Utils.getIntAt(t,500,this.littleEndian),this.intent_code=_t.Utils.getIntAt(t,504,this.littleEndian),this.intent_name=_t.Utils.getStringAt(t,508,508+16),this.dim_info=_t.Utils.getByteAt(t,524),t.byteLength>ts.MAGIC_COOKIE&&(this.extensionFlag[0]=_t.Utils.getByteAt(t,540),this.extensionFlag[1]=_t.Utils.getByteAt(t,540+1),this.extensionFlag[2]=_t.Utils.getByteAt(t,540+2),this.extensionFlag[3]=_t.Utils.getByteAt(t,540+3),this.extensionFlag[0]&&(this.extensions=_t.Utils.getExtensionsAt(t,this.getExtensionLocation(),this.littleEndian,this.vox_offset),this.extensionSize=this.extensions[0].esize,this.extensionCode=this.extensions[0].ecode))}toFormattedString(){var e=_t.Utils.formatNumber,t="";return t+="Datatype = "+ +this.datatypeCode+" ("+this.getDatatypeCodeString(this.datatypeCode)+`)
`,t+="Bits Per Voxel =  = "+this.numBitsPerVoxel+`
`,t+="Image Dimensions (1-8): "+this.dims[0]+", "+this.dims[1]+", "+this.dims[2]+", "+this.dims[3]+", "+this.dims[4]+", "+this.dims[5]+", "+this.dims[6]+", "+this.dims[7]+`
`,t+="Intent Parameters (1-3): "+this.intent_p1+", "+this.intent_p2+", "+this.intent_p3+`
`,t+="Voxel Dimensions (1-8): "+e(this.pixDims[0])+", "+e(this.pixDims[1])+", "+e(this.pixDims[2])+", "+e(this.pixDims[3])+", "+e(this.pixDims[4])+", "+e(this.pixDims[5])+", "+e(this.pixDims[6])+", "+e(this.pixDims[7])+`
`,t+="Image Offset = "+this.vox_offset+`
`,t+="Data Scale:  Slope = "+e(this.scl_slope)+"  Intercept = "+e(this.scl_inter)+`
`,t+="Display Range:  Max = "+e(this.cal_max)+"  Min = "+e(this.cal_min)+`
`,t+="Slice Duration = "+this.slice_duration+`
`,t+="Time Axis Shift = "+this.toffset+`
`,t+="Slice Start = "+this.slice_start+`
`,t+="Slice End = "+this.slice_end+`
`,t+='Description: "'+this.description+`"
`,t+='Auxiliary File: "'+this.aux_file+`"
`,t+="Q-Form Code = "+this.qform_code+" ("+this.getTransformCodeString(this.qform_code)+`)
`,t+="S-Form Code = "+this.sform_code+" ("+this.getTransformCodeString(this.sform_code)+`)
`,t+="Quaternion Parameters:  b = "+e(this.quatern_b)+"  c = "+e(this.quatern_c)+"  d = "+e(this.quatern_d)+`
`,t+="Quaternion Offsets:  x = "+this.qoffset_x+"  y = "+this.qoffset_y+"  z = "+this.qoffset_z+`
`,t+="S-Form Parameters X: "+e(this.affine[0][0])+", "+e(this.affine[0][1])+", "+e(this.affine[0][2])+", "+e(this.affine[0][3])+`
`,t+="S-Form Parameters Y: "+e(this.affine[1][0])+", "+e(this.affine[1][1])+", "+e(this.affine[1][2])+", "+e(this.affine[1][3])+`
`,t+="S-Form Parameters Z: "+e(this.affine[2][0])+", "+e(this.affine[2][1])+", "+e(this.affine[2][2])+", "+e(this.affine[2][3])+`
`,t+="Slice Code = "+this.slice_code+`
`,t+="Units Code = "+this.xyzt_units+" ("+this.getUnitsCodeString(Pr.NIFTI1.SPATIAL_UNITS_MASK&this.xyzt_units)+", "+this.getUnitsCodeString(Pr.NIFTI1.TEMPORAL_UNITS_MASK&this.xyzt_units)+`)
`,t+="Intent Code = "+this.intent_code+`
`,t+='Intent Name: "'+this.intent_name+`"
`,t+="Dim Info = "+this.dim_info+`
`,t}toArrayBuffer(e=!1){let i=544;if(e)for(let c of this.extensions)i+=c.esize;let s=new Uint8Array(i),a=new DataView(s.buffer);a.setInt32(0,540,this.littleEndian),s.set(Buffer.from(this.magic),4),a.setInt16(12,this.datatypeCode,this.littleEndian),a.setInt16(14,this.numBitsPerVoxel,this.littleEndian);for(let c=0;c<8;c++)a.setBigInt64(16+8*c,BigInt(this.dims[c]),this.littleEndian);a.setFloat64(80,this.intent_p1,this.littleEndian),a.setFloat64(88,this.intent_p2,this.littleEndian),a.setFloat64(96,this.intent_p3,this.littleEndian);for(let c=0;c<8;c++)a.setFloat64(104+8*c,this.pixDims[c],this.littleEndian);a.setBigInt64(168,BigInt(this.vox_offset),this.littleEndian),a.setFloat64(176,this.scl_slope,this.littleEndian),a.setFloat64(184,this.scl_inter,this.littleEndian),a.setFloat64(192,this.cal_max,this.littleEndian),a.setFloat64(200,this.cal_min,this.littleEndian),a.setFloat64(208,this.slice_duration,this.littleEndian),a.setFloat64(216,this.toffset,this.littleEndian),a.setBigInt64(224,BigInt(this.slice_start),this.littleEndian),a.setBigInt64(232,BigInt(this.slice_end),this.littleEndian),s.set(Buffer.from(this.description),240),s.set(Buffer.from(this.aux_file),320),a.setInt32(344,this.qform_code,this.littleEndian),a.setInt32(348,this.sform_code,this.littleEndian),a.setFloat64(352,this.quatern_b,this.littleEndian),a.setFloat64(360,this.quatern_c,this.littleEndian),a.setFloat64(368,this.quatern_d,this.littleEndian),a.setFloat64(376,this.qoffset_x,this.littleEndian),a.setFloat64(384,this.qoffset_y,this.littleEndian),a.setFloat64(392,this.qoffset_z,this.littleEndian);const o=this.affine.flat();for(let c=0;c<12;c++)a.setFloat64(400+8*c,o[c],this.littleEndian);if(a.setInt32(496,this.slice_code,this.littleEndian),a.setInt32(500,this.xyzt_units,this.littleEndian),a.setInt32(504,this.intent_code,this.littleEndian),s.set(Buffer.from(this.intent_name),508),a.setUint8(524,this.dim_info),e){s.set(Uint8Array.from([1,0,0,0]),540);let c=this.getExtensionLocation();for(const l of this.extensions)a.setInt32(c,l.esize,l.littleEndian),a.setInt32(c+4,l.ecode,l.littleEndian),s.set(new Uint8Array(l.edata),c+8),c+=l.esize}else s.set(new Uint8Array(4).fill(0),540);return s.buffer}};re(ts,"MAGIC_COOKIE",540),re(ts,"MAGIC_NUMBER_LOCATION",4),re(ts,"MAGIC_NUMBER",[110,43,50,0,13,10,26,10]),re(ts,"MAGIC_NUMBER2",[110,105,50,0,13,10,26,10]);let Kx=ts;Uu.NIFTI2=Kx;(function(n){var e=$r&&$r.__createBinding||(Object.create?function(E,S,T,C){C===void 0&&(C=T);var y=Object.getOwnPropertyDescriptor(S,T);(!y||("get"in y?!S.__esModule:y.writable||y.configurable))&&(y={enumerable:!0,get:function(){return S[T]}}),Object.defineProperty(E,C,y)}:function(E,S,T,C){C===void 0&&(C=T),E[C]=S[T]}),t=$r&&$r.__setModuleDefault||(Object.create?function(E,S){Object.defineProperty(E,"default",{enumerable:!0,value:S})}:function(E,S){E.default=S}),r=$r&&$r.__importStar||function(E){if(E&&E.__esModule)return E;var S={};if(E!=null)for(var T in E)T!=="default"&&Object.prototype.hasOwnProperty.call(E,T)&&e(S,E,T);return t(S,E),S};Object.defineProperty(n,"__esModule",{value:!0}),n.readExtensionData=n.readExtension=n.readImage=n.hasExtension=n.readHeader=n.decompress=n.isCompressed=n.isNIFTI=n.isNIFTI2=n.isNIFTI1=n.NIFTIEXTENSION=n.Utils=n.NIFTI2=n.NIFTI1=void 0;const i=r(ct),s=ml,a=Uu,o=$o;var c=ml;Object.defineProperty(n,"NIFTI1",{enumerable:!0,get:function(){return c.NIFTI1}});var l=Uu;Object.defineProperty(n,"NIFTI2",{enumerable:!0,get:function(){return l.NIFTI2}});var u=$o;Object.defineProperty(n,"Utils",{enumerable:!0,get:function(){return u.Utils}});var f=md;Object.defineProperty(n,"NIFTIEXTENSION",{enumerable:!0,get:function(){return f.NIFTIEXTENSION}});function d(E,S=!1){var T,C,y,A;return E.byteLength<s.NIFTI1.STANDARD_HEADER_SIZE?!1:(T=new DataView(E),T&&(C=T.getUint8(s.NIFTI1.MAGIC_NUMBER_LOCATION)),y=T.getUint8(s.NIFTI1.MAGIC_NUMBER_LOCATION+1),A=T.getUint8(s.NIFTI1.MAGIC_NUMBER_LOCATION+2),S&&C===s.NIFTI1.MAGIC_NUMBER2[0]&&y===s.NIFTI1.MAGIC_NUMBER2[1]&&A===s.NIFTI1.MAGIC_NUMBER2[2]?!0:C===s.NIFTI1.MAGIC_NUMBER[0]&&y===s.NIFTI1.MAGIC_NUMBER[1]&&A===s.NIFTI1.MAGIC_NUMBER[2])}n.isNIFTI1=d;function h(E,S=!1){var T,C,y,A;return E.byteLength<s.NIFTI1.STANDARD_HEADER_SIZE?!1:(T=new DataView(E),C=T.getUint8(a.NIFTI2.MAGIC_NUMBER_LOCATION),y=T.getUint8(a.NIFTI2.MAGIC_NUMBER_LOCATION+1),A=T.getUint8(a.NIFTI2.MAGIC_NUMBER_LOCATION+2),S&&C===a.NIFTI2.MAGIC_NUMBER2[0]&&y===a.NIFTI2.MAGIC_NUMBER2[1]&&A===a.NIFTI2.MAGIC_NUMBER2[2]?!0:C===a.NIFTI2.MAGIC_NUMBER[0]&&y===a.NIFTI2.MAGIC_NUMBER[1]&&A===a.NIFTI2.MAGIC_NUMBER[2])}n.isNIFTI2=h;function p(E,S=!1){return d(E,S)||h(E,S)}n.isNIFTI=p;function g(E){var S,T,C;return!!(E&&(S=new DataView(E),T=S.getUint8(0),C=S.getUint8(1),T===o.Utils.GUNZIP_MAGIC_COOKIE1||C===o.Utils.GUNZIP_MAGIC_COOKIE2))}n.isCompressed=g;function m(E){return i.decompressSync(new Uint8Array(E)).buffer}n.decompress=m;function v(E,S=!1){var T=null;return g(E)&&(E=m(E)),d(E,S)?T=new s.NIFTI1:h(E,S)&&(T=new a.NIFTI2),T?T.readHeader(E):console.error("That file does not appear to be NIFTI!"),T}n.readHeader=v;function x(E){return E.extensionFlag[0]!=0}n.hasExtension=x;function b(E,S){var T=E.vox_offset,C=1,y=1;E.dims[4]&&(C=E.dims[4]),E.dims[5]&&(y=E.dims[5]);var A=E.dims[1]*E.dims[2]*E.dims[3]*C*y*(E.numBitsPerVoxel/8);return S.slice(T,T+A)}n.readImage=b;function _(E,S){var T=E.getExtensionLocation(),C=E.extensionSize;return S.slice(T,T+C)}n.readExtension=_;function w(E,S){var T=E.getExtensionLocation(),C=E.extensionSize;return S.slice(T+8,T+C)}n.readExtensionData=w})(er);class Wce extends Fa{constructor(e){super(e)}load(e,t,r,i){const s=this,a=new h0(s.manager);a.setPath(s.path),a.setResponseType("arraybuffer"),a.setRequestHeader(s.requestHeader),a.setWithCredentials(s.withCredentials),a.load(e,function(o){try{t(s.parse(o))}catch(c){i?i(c):console.error(c),s.manager.itemError(e)}},r,i)}parse(e){if(er.isCompressed(e)&&(e=er.decompress(e)),!er.isNIFTI(e))throw new Error("Not a NIfTI file");const t=er.readHeader(e),r=er.readImage(t,e),i=new Sce;if(i.header=t,er.hasExtension(t)&&(i.extension=er.readExtensionData(t,e)),t.datatypeCode===er.NIFTI1.TYPE_UINT8)i.data=new Uint8Array(r);else if(t.datatypeCode===er.NIFTI1.TYPE_INT16)i.data=new Int16Array(r);else if(t.datatypeCode===er.NIFTI1.TYPE_INT32)i.data=new Int32Array(r);else if(t.datatypeCode===er.NIFTI1.TYPE_FLOAT32)i.data=new Float32Array(r);else if(t.datatypeCode===er.NIFTI1.TYPE_FLOAT64)i.data=new Float64Array(r);else if(t.datatypeCode===er.NIFTI1.TYPE_INT8)i.data=new Int8Array(r);else if(t.datatypeCode===er.NIFTI1.TYPE_UINT16)i.data=new Uint16Array(r);else if(t.datatypeCode===er.NIFTI1.TYPE_UINT32)i.data=new Uint32Array(r);else throw new Error("Not recognized NIfTI data type");i.computeMinMax(),i.dimensions=[t.dims[1],t.dims[2],t.dims[3]],i.spacing=[t.pixDims[1],t.pixDims[2],t.pixDims[3]],i.xLength=i.dimensions[0],i.yLength=i.dimensions[1],i.zLength=i.dimensions[2];const s=t.getUnitsCodeString(er.NIFTI1.SPATIAL_UNITS_MASK&t.xyzt_units),a={Meters:1,Millimeters:.001,Microns:1e-6};return i.spacing=i.spacing.map(o=>o*(a[s]||1)),i.spatialUnits="Meters",i.size=[i.xLength*i.spacing[0],i.yLength*i.spacing[1],i.zLength*i.spacing[2]],i}}class qce extends Js{constructor(e){super(),this.sources=e,this.items={},this.toLoad=this.sources.length,this.loaded=0,this.setLoaders(),this.startLoading()}setLoaders(){this.loaders={},this.loaders.gltfLoader=new Voe,this.loaders.textureLoader=new DE,this.loaders.cubeTextureLoader=new tz,this.loaders.niftiLoader=new Wce}startLoading(){console.time("Resources");for(const e of this.sources)e.type==="gltfModel"?this.loaders.gltfLoader.load(e.path,t=>{this.sourceLoaded(e,t)}):e.type==="texture"?this.loaders.textureLoader.load(e.path,t=>{this.sourceLoaded(e,t)}):e.type==="cubeTexture"?this.loaders.cubeTextureLoader.load(e.path,t=>{this.sourceLoaded(e,t)}):e.type==="niftiFile"&&this.loaders.niftiLoader.load(e.path,t=>{this.sourceLoaded(e,t)})}sourceLoaded(e,t){this.items[e.name]=t,this.loaded++,this.loaded===this.toLoad&&(this.trigger("ready"),console.timeEnd("Resources"))}}const Xce=[{name:"colorMaps",type:"texture",path:"textures/colormaps/colormaps.png"},{name:"intensityMap",type:"niftiFile",path:"nifti/cardiac/ct_train_1002_image.nii.gz"}],Dc=class Dc{constructor(e,t){if(Dc.instance)return Dc.instance;Dc.instance=this,window.experience=this,this.canvas=e,this.context=t,this.config=new Yg,this.debug=new kz,this.sizes=new Dz,this.time=new Lz,this.mouse=new Oz,this.scene=new DO,this.camera=new mP,this.resources=new qce(Xce),this.renderer=new vP,this.world=new Boe,this.stats=new Fz(!0),this.sizes.on("resize",()=>{this.resize()}),this.time.on("tick",()=>{this.update()}),this.config.on("change",()=>{this.change()}),this.resources.on("ready",()=>{}),window.addEventListener("beforeunload",()=>{this.destroy()})}resize(){this.camera.resize(),this.renderer.resize()}update(){this.camera.update(),this.stats.update(),this.renderer.update()}change(){}destroy(){this.sizes.off("resize"),this.time.off("tick"),this.config.off("change"),this.config&&this.config.destroy(),this.debug&&this.debug.destroy(),this.sizes&&this.sizes.destroy(),this.time&&this.time.destroy(),this.mouse&&this.mouse.destroy(),this.world&&this.world.destroy(),this.camera&&this.camera.destroy(),this.renderer&&this.renderer.destroy(),this.config=null,this.debug=null,this.sizes=null,this.time=null,this.mouse=null,this.scene=null,this.camera=null,this.resources=null,this.renderer=null,this.world=null,this.stats=null,this.canvas=null,instance=null,console.log("Experience destroyed")}};re(Dc,"instance",null);let Uo=Dc;const aR=document.querySelector("canvas.webgl"),oR=aR.getContext("webgl2");if(!oR)throw new Error("WebGL2 not supported by your browser or device.");new Uo(aR,oR);
//# sourceMappingURL=index-3f42f189.js.map
