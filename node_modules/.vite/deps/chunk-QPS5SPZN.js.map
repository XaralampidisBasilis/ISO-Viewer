{
  "version": 3,
  "sources": ["../../three/examples/jsm/misc/VolumeSlice.js", "../../three/examples/jsm/misc/Volume.js"],
  "sourcesContent": ["import {\n\tClampToEdgeWrapping,\n\tDoubleSide,\n\tLinearFilter,\n\tMesh,\n\tMeshBasicMaterial,\n\tPlaneGeometry,\n\tTexture,\n\tSRGBColorSpace\n} from 'three';\n\n/**\n * This class has been made to hold a slice of a volume data\n * @class\n * @param   {Volume} volume    The associated volume\n * @param   {number}       [index=0] The index of the slice\n * @param   {string}       [axis='z']      For now only 'x', 'y' or 'z' but later it will change to a normal vector\n * @see Volume\n */\nclass VolumeSlice {\n\n\tconstructor( volume, index, axis ) {\n\n\t\tconst slice = this;\n\t\t/**\n\t\t * @member {Volume} volume The associated volume\n\t\t */\n\t\tthis.volume = volume;\n\t\t/**\n\t\t * @member {Number} index The index of the slice, if changed, will automatically call updateGeometry at the next repaint\n\t\t */\n\t\tindex = index || 0;\n\t\tObject.defineProperty( this, 'index', {\n\t\t\tget: function () {\n\n\t\t\t\treturn index;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tindex = value;\n\t\t\t\tslice.geometryNeedsUpdate = true;\n\t\t\t\treturn index;\n\n\t\t\t}\n\t\t} );\n\t\t/**\n\t\t * @member {String} axis The normal axis\n\t\t */\n\t\tthis.axis = axis || 'z';\n\n\t\t/**\n\t\t * @member {HTMLCanvasElement} canvas The final canvas used for the texture\n\t\t */\n\t\t/**\n\t\t * @member {CanvasRenderingContext2D} ctx Context of the canvas\n\t\t */\n\t\tthis.canvas = document.createElement( 'canvas' );\n\t\t/**\n\t\t * @member {HTMLCanvasElement} canvasBuffer The intermediary canvas used to paint the data\n\t\t */\n\t\t/**\n\t\t * @member {CanvasRenderingContext2D} ctxBuffer Context of the canvas buffer\n\t\t */\n\t\tthis.canvasBuffer = document.createElement( 'canvas' );\n\t\tthis.updateGeometry();\n\n\n\t\tconst canvasMap = new Texture( this.canvas );\n\t\tcanvasMap.minFilter = LinearFilter;\n\t\tcanvasMap.wrapS = canvasMap.wrapT = ClampToEdgeWrapping;\n\t\tcanvasMap.colorSpace = SRGBColorSpace;\n\t\tconst material = new MeshBasicMaterial( { map: canvasMap, side: DoubleSide, transparent: true } );\n\t\t/**\n\t\t * @member {Mesh} mesh The mesh ready to get used in the scene\n\t\t */\n\t\tthis.mesh = new Mesh( this.geometry, material );\n\t\tthis.mesh.matrixAutoUpdate = false;\n\t\t/**\n\t\t * @member {Boolean} geometryNeedsUpdate If set to true, updateGeometry will be triggered at the next repaint\n\t\t */\n\t\tthis.geometryNeedsUpdate = true;\n\t\tthis.repaint();\n\n\t\t/**\n\t\t * @member {Number} iLength Width of slice in the original coordinate system, corresponds to the width of the buffer canvas\n\t\t */\n\n\t\t/**\n\t\t * @member {Number} jLength Height of slice in the original coordinate system, corresponds to the height of the buffer canvas\n\t\t */\n\n\t\t/**\n\t\t * @member {Function} sliceAccess Function that allow the slice to access right data\n\t\t * @see Volume.extractPerpendicularPlane\n\t\t * @param {Number} i The first coordinate\n\t\t * @param {Number} j The second coordinate\n\t\t * @returns {Number} the index corresponding to the voxel in volume.data of the given position in the slice\n\t\t */\n\n\n\t}\n\n\t/**\n\t * @member {Function} repaint Refresh the texture and the geometry if geometryNeedsUpdate is set to true\n\t * @memberof VolumeSlice\n\t */\n\trepaint() {\n\n\t\tif ( this.geometryNeedsUpdate ) {\n\n\t\t\tthis.updateGeometry();\n\n\t\t}\n\n\t\tconst iLength = this.iLength,\n\t\t\tjLength = this.jLength,\n\t\t\tsliceAccess = this.sliceAccess,\n\t\t\tvolume = this.volume,\n\t\t\tcanvas = this.canvasBuffer,\n\t\t\tctx = this.ctxBuffer;\n\n\n\t\t// get the imageData and pixel array from the canvas\n\t\tconst imgData = ctx.getImageData( 0, 0, iLength, jLength );\n\t\tconst data = imgData.data;\n\t\tconst volumeData = volume.data;\n\t\tconst upperThreshold = volume.upperThreshold;\n\t\tconst lowerThreshold = volume.lowerThreshold;\n\t\tconst windowLow = volume.windowLow;\n\t\tconst windowHigh = volume.windowHigh;\n\n\t\t// manipulate some pixel elements\n\t\tlet pixelCount = 0;\n\n\t\tif ( volume.dataType === 'label' ) {\n\n\t\t\t//this part is currently useless but will be used when colortables will be handled\n\t\t\tfor ( let j = 0; j < jLength; j ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < iLength; i ++ ) {\n\n\t\t\t\t\tlet label = volumeData[ sliceAccess( i, j ) ];\n\t\t\t\t\tlabel = label >= this.colorMap.length ? ( label % this.colorMap.length ) + 1 : label;\n\t\t\t\t\tconst color = this.colorMap[ label ];\n\t\t\t\t\tdata[ 4 * pixelCount ] = ( color >> 24 ) & 0xff;\n\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = ( color >> 16 ) & 0xff;\n\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = ( color >> 8 ) & 0xff;\n\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = color & 0xff;\n\t\t\t\t\tpixelCount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t} else {\n\n\t\t\tfor ( let j = 0; j < jLength; j ++ ) {\n\n\t\t\t\tfor ( let i = 0; i < iLength; i ++ ) {\n\n\t\t\t\t\tlet value = volumeData[ sliceAccess( i, j ) ];\n\t\t\t\t\tlet alpha = 0xff;\n\t\t\t\t\t//apply threshold\n\t\t\t\t\talpha = upperThreshold >= value ? ( lowerThreshold <= value ? alpha : 0 ) : 0;\n\t\t\t\t\t//apply window level\n\t\t\t\t\tvalue = Math.floor( 255 * ( value - windowLow ) / ( windowHigh - windowLow ) );\n\t\t\t\t\tvalue = value > 255 ? 255 : ( value < 0 ? 0 : value | 0 );\n\n\t\t\t\t\tdata[ 4 * pixelCount ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 1 ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 2 ] = value;\n\t\t\t\t\tdata[ 4 * pixelCount + 3 ] = alpha;\n\t\t\t\t\tpixelCount ++;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tctx.putImageData( imgData, 0, 0 );\n\t\tthis.ctx.drawImage( canvas, 0, 0, iLength, jLength, 0, 0, this.canvas.width, this.canvas.height );\n\n\n\t\tthis.mesh.material.map.needsUpdate = true;\n\n\t}\n\n\t/**\n\t * @member {Function} Refresh the geometry according to axis and index\n\t * @see Volume.extractPerpendicularPlane\n\t * @memberof VolumeSlice\n\t */\n\tupdateGeometry() {\n\n\t\tconst extracted = this.volume.extractPerpendicularPlane( this.axis, this.index );\n\t\tthis.sliceAccess = extracted.sliceAccess;\n\t\tthis.jLength = extracted.jLength;\n\t\tthis.iLength = extracted.iLength;\n\t\tthis.matrix = extracted.matrix;\n\n\t\tthis.canvas.width = extracted.planeWidth;\n\t\tthis.canvas.height = extracted.planeHeight;\n\t\tthis.canvasBuffer.width = this.iLength;\n\t\tthis.canvasBuffer.height = this.jLength;\n\t\tthis.ctx = this.canvas.getContext( '2d' );\n\t\tthis.ctxBuffer = this.canvasBuffer.getContext( '2d' );\n\n\t\tif ( this.geometry ) this.geometry.dispose(); // dispose existing geometry\n\n\t\tthis.geometry = new PlaneGeometry( extracted.planeWidth, extracted.planeHeight );\n\n\t\tif ( this.mesh ) {\n\n\t\t\tthis.mesh.geometry = this.geometry;\n\t\t\t//reset mesh matrix\n\t\t\tthis.mesh.matrix.identity();\n\t\t\tthis.mesh.applyMatrix4( this.matrix );\n\n\t\t}\n\n\t\tthis.geometryNeedsUpdate = false;\n\n\t}\n\n}\n\nexport { VolumeSlice };\n", "import {\n\tMatrix3,\n\tMatrix4,\n\tVector3\n} from 'three';\nimport { VolumeSlice } from '../misc/VolumeSlice.js';\n\n/**\n * This class had been written to handle the output of the NRRD loader.\n * It contains a volume of data and informations about it.\n * For now it only handles 3 dimensional data.\n * See the webgl_loader_nrrd.html example and the loaderNRRD.js file to see how to use this class.\n * @class\n * @param   {number}        xLength         Width of the volume\n * @param   {number}        yLength         Length of the volume\n * @param   {number}        zLength         Depth of the volume\n * @param   {string}        type            The type of data (uint8, uint16, ...)\n * @param   {ArrayBuffer}   arrayBuffer     The buffer with volume data\n */\nclass Volume {\n\n\tconstructor( xLength, yLength, zLength, type, arrayBuffer ) {\n\n\t\tif ( xLength !== undefined ) {\n\n\t\t\t/**\n\t\t\t * @member {number} xLength Width of the volume in the IJK coordinate system\n\t\t\t */\n\t\t\tthis.xLength = Number( xLength ) || 1;\n\t\t\t/**\n\t\t\t * @member {number} yLength Height of the volume in the IJK coordinate system\n\t\t\t */\n\t\t\tthis.yLength = Number( yLength ) || 1;\n\t\t\t/**\n\t\t\t * @member {number} zLength Depth of the volume in the IJK coordinate system\n\t\t\t */\n\t\t\tthis.zLength = Number( zLength ) || 1;\n\t\t\t/**\n\t\t\t * @member {Array<string>} The order of the Axis dictated by the NRRD header\n\t\t\t */\n\t\t\tthis.axisOrder = [ 'x', 'y', 'z' ];\n\t\t\t/**\n\t\t\t * @member {TypedArray} data Data of the volume\n\t\t\t */\n\n\t\t\tswitch ( type ) {\n\n\t\t\t\tcase 'Uint8' :\n\t\t\t\tcase 'uint8' :\n\t\t\t\tcase 'uchar' :\n\t\t\t\tcase 'unsigned char' :\n\t\t\t\tcase 'uint8_t' :\n\t\t\t\t\tthis.data = new Uint8Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Int8' :\n\t\t\t\tcase 'int8' :\n\t\t\t\tcase 'signed char' :\n\t\t\t\tcase 'int8_t' :\n\t\t\t\t\tthis.data = new Int8Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Int16' :\n\t\t\t\tcase 'int16' :\n\t\t\t\tcase 'short' :\n\t\t\t\tcase 'short int' :\n\t\t\t\tcase 'signed short' :\n\t\t\t\tcase 'signed short int' :\n\t\t\t\tcase 'int16_t' :\n\t\t\t\t\tthis.data = new Int16Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Uint16' :\n\t\t\t\tcase 'uint16' :\n\t\t\t\tcase 'ushort' :\n\t\t\t\tcase 'unsigned short' :\n\t\t\t\tcase 'unsigned short int' :\n\t\t\t\tcase 'uint16_t' :\n\t\t\t\t\tthis.data = new Uint16Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Int32' :\n\t\t\t\tcase 'int32' :\n\t\t\t\tcase 'int' :\n\t\t\t\tcase 'signed int' :\n\t\t\t\tcase 'int32_t' :\n\t\t\t\t\tthis.data = new Int32Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Uint32' :\n\t\t\t\tcase 'uint32' :\n\t\t\t\tcase 'uint' :\n\t\t\t\tcase 'unsigned int' :\n\t\t\t\tcase 'uint32_t' :\n\t\t\t\t\tthis.data = new Uint32Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'longlong' :\n\t\t\t\tcase 'long long' :\n\t\t\t\tcase 'long long int' :\n\t\t\t\tcase 'signed long long' :\n\t\t\t\tcase 'signed long long int' :\n\t\t\t\tcase 'int64' :\n\t\t\t\tcase 'int64_t' :\n\t\t\t\tcase 'ulonglong' :\n\t\t\t\tcase 'unsigned long long' :\n\t\t\t\tcase 'unsigned long long int' :\n\t\t\t\tcase 'uint64' :\n\t\t\t\tcase 'uint64_t' :\n\t\t\t\t\tthrow new Error( 'Error in Volume constructor : this type is not supported in JavaScript' );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Float32' :\n\t\t\t\tcase 'float32' :\n\t\t\t\tcase 'float' :\n\t\t\t\t\tthis.data = new Float32Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'Float64' :\n\t\t\t\tcase 'float64' :\n\t\t\t\tcase 'double' :\n\t\t\t\t\tthis.data = new Float64Array( arrayBuffer );\n\t\t\t\t\tbreak;\n\t\t\t\tdefault :\n\t\t\t\t\tthis.data = new Uint8Array( arrayBuffer );\n\n\t\t\t}\n\n\t\t\tif ( this.data.length !== this.xLength * this.yLength * this.zLength ) {\n\n\t\t\t\tthrow new Error( 'Error in Volume constructor, lengths are not matching arrayBuffer size' );\n\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * @member {Array}  spacing Spacing to apply to the volume from IJK to RAS coordinate system\n\t\t */\n\t\tthis.spacing = [ 1, 1, 1 ];\n\t\t/**\n\t\t * @member {Array}  offset Offset of the volume in the RAS coordinate system\n\t\t */\n\t\tthis.offset = [ 0, 0, 0 ];\n\t\t/**\n\t\t * @member {Martrix3} matrix The IJK to RAS matrix\n\t\t */\n\t\tthis.matrix = new Matrix3();\n\t\tthis.matrix.identity();\n\t\t/**\n\t\t * @member {Martrix3} inverseMatrix The RAS to IJK matrix\n\t\t */\n\t\t/**\n\t\t * @member {number} lowerThreshold The voxels with values under this threshold won't appear in the slices.\n\t\t *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n\t\t */\n\t\tlet lowerThreshold = - Infinity;\n\t\tObject.defineProperty( this, 'lowerThreshold', {\n\t\t\tget: function () {\n\n\t\t\t\treturn lowerThreshold;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tlowerThreshold = value;\n\t\t\t\tthis.sliceList.forEach( function ( slice ) {\n\n\t\t\t\t\tslice.geometryNeedsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\t\t} );\n\t\t/**\n\t\t * @member {number} upperThreshold The voxels with values over this threshold won't appear in the slices.\n\t\t *                      If changed, geometryNeedsUpdate is automatically set to true on all the slices associated to this volume\n\t\t */\n\t\tlet upperThreshold = Infinity;\n\t\tObject.defineProperty( this, 'upperThreshold', {\n\t\t\tget: function () {\n\n\t\t\t\treturn upperThreshold;\n\n\t\t\t},\n\t\t\tset: function ( value ) {\n\n\t\t\t\tupperThreshold = value;\n\t\t\t\tthis.sliceList.forEach( function ( slice ) {\n\n\t\t\t\t\tslice.geometryNeedsUpdate = true;\n\n\t\t\t\t} );\n\n\t\t\t}\n\t\t} );\n\n\n\t\t/**\n\t\t * @member {Array} sliceList The list of all the slices associated to this volume\n\t\t */\n\t\tthis.sliceList = [];\n\n\n\t\t/**\n\t\t * @member {boolean} segmentation in segmentation mode, it can load 16-bits nrrds correctly\n\t\t */\n\t\tthis.segmentation = false;\n\n\n\t\t/**\n\t\t * @member {Array} RASDimensions This array holds the dimensions of the volume in the RAS space\n\t\t */\n\n\n\n\t}\n\n\t/**\n\t * @member {Function} getData Shortcut for data[access(i,j,k)]\n\t * @memberof Volume\n\t * @param {number} i    First coordinate\n\t * @param {number} j    Second coordinate\n\t * @param {number} k    Third coordinate\n\t * @returns {number}  value in the data array\n\t */\n\tgetData( i, j, k ) {\n\n\t\treturn this.data[ k * this.xLength * this.yLength + j * this.xLength + i ];\n\n\t}\n\n\t/**\n\t * @member {Function} access compute the index in the data array corresponding to the given coordinates in IJK system\n\t * @memberof Volume\n\t * @param {number} i    First coordinate\n\t * @param {number} j    Second coordinate\n\t * @param {number} k    Third coordinate\n\t * @returns {number}  index\n\t */\n\taccess( i, j, k ) {\n\n\t\treturn k * this.xLength * this.yLength + j * this.xLength + i;\n\n\t}\n\n\t/**\n\t * @member {Function} reverseAccess Retrieve the IJK coordinates of the voxel corresponding of the given index in the data\n\t * @memberof Volume\n\t * @param {number} index index of the voxel\n\t * @returns {Array}  [x,y,z]\n\t */\n\treverseAccess( index ) {\n\n\t\tconst z = Math.floor( index / ( this.yLength * this.xLength ) );\n\t\tconst y = Math.floor( ( index - z * this.yLength * this.xLength ) / this.xLength );\n\t\tconst x = index - z * this.yLength * this.xLength - y * this.xLength;\n\t\treturn [ x, y, z ];\n\n\t}\n\n\t/**\n\t * @member {Function} map Apply a function to all the voxels, be careful, the value will be replaced\n\t * @memberof Volume\n\t * @param {Function} functionToMap A function to apply to every voxel, will be called with the following parameters :\n\t *                                 value of the voxel\n\t *                                 index of the voxel\n\t *                                 the data (TypedArray)\n\t * @param {Object}   context    You can specify a context in which call the function, default if this Volume\n\t * @returns {Volume}   this\n\t */\n\tmap( functionToMap, context ) {\n\n\t\tconst length = this.data.length;\n\t\tcontext = context || this;\n\n\t\tfor ( let i = 0; i < length; i ++ ) {\n\n\t\t\tthis.data[ i ] = functionToMap.call( context, this.data[ i ], i, this.data );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @member {Function} extractPerpendicularPlane Compute the orientation of the slice and returns all the information relative to the geometry such as sliceAccess, the plane matrix (orientation and position in RAS coordinate) and the dimensions of the plane in both coordinate system.\n\t * @memberof Volume\n\t * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n\t * @param {number}            index the index of the slice\n\t * @returns {Object} an object containing all the usefull information on the geometry of the slice\n\t */\n\textractPerpendicularPlane( axis, RASIndex ) {\n\n\t\tlet firstSpacing,\n\t\t\tsecondSpacing,\n\t\t\tpositionOffset,\n\t\t\tIJKIndex;\n\n\t\tconst axisInIJK = new Vector3(),\n\t\t\tfirstDirection = new Vector3(),\n\t\t\tsecondDirection = new Vector3(),\n\t\t\tplaneMatrix = ( new Matrix4() ).identity(),\n\t\t\tvolume = this;\n\n\t\tconst dimensions = new Vector3( this.xLength, this.yLength, this.zLength );\n\n\n\t\tswitch ( axis ) {\n\n\t\t\tcase 'x' :\n\t\t\t\taxisInIJK.set( 1, 0, 0 );\n\t\t\t\tfirstDirection.set( 0, 0, - 1 );\n\t\t\t\tsecondDirection.set( 0, - 1, 0 );\n\t\t\t\tfirstSpacing = this.spacing[ this.axisOrder.indexOf( 'z' ) ];\n\t\t\t\tsecondSpacing = this.spacing[ this.axisOrder.indexOf( 'y' ) ];\n\t\t\t\tIJKIndex = new Vector3( RASIndex, 0, 0 );\n\n\t\t\t\tplaneMatrix.multiply( ( new Matrix4() ).makeRotationY( Math.PI / 2 ) );\n\t\t\t\tpositionOffset = ( volume.RASDimensions[ 0 ] - 1 ) / 2;\n\t\t\t\tplaneMatrix.setPosition( new Vector3( RASIndex - positionOffset, 0, 0 ) );\n\t\t\t\tbreak;\n\t\t\tcase 'y' :\n\t\t\t\taxisInIJK.set( 0, 1, 0 );\n\t\t\t\tfirstDirection.set( 1, 0, 0 );\n\t\t\t\tsecondDirection.set( 0, 0, 1 );\n\t\t\t\tfirstSpacing = this.spacing[ this.axisOrder.indexOf( 'x' ) ];\n\t\t\t\tsecondSpacing = this.spacing[ this.axisOrder.indexOf( 'z' ) ];\n\t\t\t\tIJKIndex = new Vector3( 0, RASIndex, 0 );\n\n\t\t\t\tplaneMatrix.multiply( ( new Matrix4() ).makeRotationX( - Math.PI / 2 ) );\n\t\t\t\tpositionOffset = ( volume.RASDimensions[ 1 ] - 1 ) / 2;\n\t\t\t\tplaneMatrix.setPosition( new Vector3( 0, RASIndex - positionOffset, 0 ) );\n\t\t\t\tbreak;\n\t\t\tcase 'z' :\n\t\t\tdefault :\n\t\t\t\taxisInIJK.set( 0, 0, 1 );\n\t\t\t\tfirstDirection.set( 1, 0, 0 );\n\t\t\t\tsecondDirection.set( 0, - 1, 0 );\n\t\t\t\tfirstSpacing = this.spacing[ this.axisOrder.indexOf( 'x' ) ];\n\t\t\t\tsecondSpacing = this.spacing[ this.axisOrder.indexOf( 'y' ) ];\n\t\t\t\tIJKIndex = new Vector3( 0, 0, RASIndex );\n\n\t\t\t\tpositionOffset = ( volume.RASDimensions[ 2 ] - 1 ) / 2;\n\t\t\t\tplaneMatrix.setPosition( new Vector3( 0, 0, RASIndex - positionOffset ) );\n\t\t\t\tbreak;\n\n\t\t}\n\n\t\tif ( ! this.segmentation ) {\n\n\t\t\tfirstDirection.applyMatrix4( volume.inverseMatrix ).normalize();\n\t\t\tsecondDirection.applyMatrix4( volume.inverseMatrix ).normalize();\n\t\t\taxisInIJK.applyMatrix4( volume.inverseMatrix ).normalize();\n\n\t\t}\n\n\t\tfirstDirection.arglet = 'i';\n\t\tsecondDirection.arglet = 'j';\n\t\tconst iLength = Math.floor( Math.abs( firstDirection.dot( dimensions ) ) );\n\t\tconst jLength = Math.floor( Math.abs( secondDirection.dot( dimensions ) ) );\n\t\tconst planeWidth = Math.abs( iLength * firstSpacing );\n\t\tconst planeHeight = Math.abs( jLength * secondSpacing );\n\n\t\tIJKIndex = Math.abs( Math.round( IJKIndex.applyMatrix4( volume.inverseMatrix ).dot( axisInIJK ) ) );\n\t\tconst base = [ new Vector3( 1, 0, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ) ];\n\t\tconst iDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {\n\n\t\t\treturn Math.abs( x.dot( base[ 0 ] ) ) > 0.9;\n\n\t\t} );\n\t\tconst jDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {\n\n\t\t\treturn Math.abs( x.dot( base[ 1 ] ) ) > 0.9;\n\n\t\t} );\n\t\tconst kDirection = [ firstDirection, secondDirection, axisInIJK ].find( function ( x ) {\n\n\t\t\treturn Math.abs( x.dot( base[ 2 ] ) ) > 0.9;\n\n\t\t} );\n\n\t\tfunction sliceAccess( i, j ) {\n\n\t\t\tconst si = ( iDirection === axisInIJK ) ? IJKIndex : ( iDirection.arglet === 'i' ? i : j );\n\t\t\tconst sj = ( jDirection === axisInIJK ) ? IJKIndex : ( jDirection.arglet === 'i' ? i : j );\n\t\t\tconst sk = ( kDirection === axisInIJK ) ? IJKIndex : ( kDirection.arglet === 'i' ? i : j );\n\n\t\t\t// invert indices if necessary\n\n\t\t\tconst accessI = ( iDirection.dot( base[ 0 ] ) > 0 ) ? si : ( volume.xLength - 1 ) - si;\n\t\t\tconst accessJ = ( jDirection.dot( base[ 1 ] ) > 0 ) ? sj : ( volume.yLength - 1 ) - sj;\n\t\t\tconst accessK = ( kDirection.dot( base[ 2 ] ) > 0 ) ? sk : ( volume.zLength - 1 ) - sk;\n\n\t\t\treturn volume.access( accessI, accessJ, accessK );\n\n\t\t}\n\n\t\treturn {\n\t\t\tiLength: iLength,\n\t\t\tjLength: jLength,\n\t\t\tsliceAccess: sliceAccess,\n\t\t\tmatrix: planeMatrix,\n\t\t\tplaneWidth: planeWidth,\n\t\t\tplaneHeight: planeHeight\n\t\t};\n\n\t}\n\n\t/**\n\t * @member {Function} extractSlice Returns a slice corresponding to the given axis and index\n\t *                        The coordinate are given in the Right Anterior Superior coordinate format\n\t * @memberof Volume\n\t * @param {string}            axis  the normal axis to the slice 'x' 'y' or 'z'\n\t * @param {number}            index the index of the slice\n\t * @returns {VolumeSlice} the extracted slice\n\t */\n\textractSlice( axis, index ) {\n\n\t\tconst slice = new VolumeSlice( this, index, axis );\n\t\tthis.sliceList.push( slice );\n\t\treturn slice;\n\n\t}\n\n\t/**\n\t * @member {Function} repaintAllSlices Call repaint on all the slices extracted from this volume\n\t * @see VolumeSlice.repaint\n\t * @memberof Volume\n\t * @returns {Volume} this\n\t */\n\trepaintAllSlices() {\n\n\t\tthis.sliceList.forEach( function ( slice ) {\n\n\t\t\tslice.repaint();\n\n\t\t} );\n\n\t\treturn this;\n\n\t}\n\n\t/**\n\t * @member {Function} computeMinMax Compute the minimum and the maximum of the data in the volume\n\t * @memberof Volume\n\t * @returns {Array} [min,max]\n\t */\n\tcomputeMinMax() {\n\n\t\tlet min = Infinity;\n\t\tlet max = - Infinity;\n\n\t\t// buffer the length\n\t\tconst datasize = this.data.length;\n\n\t\tlet i = 0;\n\n\t\tfor ( i = 0; i < datasize; i ++ ) {\n\n\t\t\tif ( ! isNaN( this.data[ i ] ) ) {\n\n\t\t\t\tconst value = this.data[ i ];\n\t\t\t\tmin = Math.min( min, value );\n\t\t\t\tmax = Math.max( max, value );\n\n\t\t\t}\n\n\t\t}\n\n\t\tthis.min = min;\n\t\tthis.max = max;\n\n\t\treturn [ min, max ];\n\n\t}\n\n}\n\nexport { Volume };\n"],
  "mappings": "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",
  "names": []
}
