\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\lstdefinelanguage{GLSL}{
  morekeywords={uniform, varying, vec3, vec4, int, float, bool, for, if, break, continue, return, include},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]",
}

\lstset{
  language=GLSL,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\bfseries,
  commentstyle=\color{gray},
  stringstyle=\color{orange},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  tabsize=2,
  breaklines=true,
  breakatwhitespace=false,
  showstringspaces=false,
  captionpos=b
}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

\title{Conference Paper Title*\\
{\footnotesize \textsuperscript{*}Note: Sub-titles are not captured in Xplore and
should not be used}
\thanks{Identify applicable funding agency here. If none, delete this.}
}

\author{
\IEEEauthorblockN{
Vasileios Lazaros Charalampidis\IEEEauthorrefmark{1},
Andreas Triantafyllidis\IEEEauthorrefmark{1},
Konstantinos Votis\IEEEauthorrefmark{1}
}
\IEEEauthorblockN{
M. Louis Handoko\IEEEauthorrefmark{2},
Eduard Ródenas-Alesinao\IEEEauthorrefmark{3},
Folkert W. Asselbergs\IEEEauthorrefmark{4}
}
\vspace{2ex} 
\IEEEauthorblockA{\IEEEauthorrefmark{1}Information Technologies Institute, CERTH, Thessaloniki, Greece\\
Emails: \{charalava, atriand, kvotis\}@iti.gr}
\vspace{1ex}
\IEEEauthorblockA{\IEEEauthorrefmark{2}Dept. of Cardiology, Transplantation Center, University Medical Center Utrecht, Utrecht, The Netherlands\\
Email: m.l.handoko@umcutrecht.nl}
\vspace{1ex}
\IEEEauthorblockA{\IEEEauthorrefmark{3}Cardiology Dept., Vall d’Hebron University Hospital, Vall d’Hebron Institut de Recerca, Barcelona, Spain\\
Email: eduard.rodenas@gmail.com}
\vspace{1ex}
\IEEEauthorblockA{\IEEEauthorrefmark{4}Institute of Health Informatics, UCL; Amsterdam UMC and NIHR UCLH BRC, London / Amsterdam, UK\\
Email: f.w.asselbergs@amsterdamumc.nl}
}


\maketitle

\begin{abstract}
This document is a model and instructions for \LaTeX.
This and the IEEEtran.cls file define the components of your paper [title, text, heads, etc.]. *CRITICAL: Do Not Use Symbols, Special Characters, Footnotes, 
or Math in Paper Title or Abstract.
\end{abstract}

\begin{IEEEkeywords}
component, formatting, style, styling, insert
\end{IEEEkeywords}

% \section{Introduction}
% Introduce the motivation for interactive isosurface rendering in medical applications, the challenges in achieving high-quality real-time performance in the web, and how your method addresses these. Mention the clinical and technical relevance.

% \section{Related Work}
% Discuss prior work on:
% \begin{itemize}
%     \item Web-based volume rendering (Three.js, VTK.js)
%     \item Isosurface visualization methods (Marching Cubes, raycasting)
%     \item Chebyshev distance maps for empty space skipping
%     \item Analytic approaches to ray-isosurface intersection
%     \item Illumination models in GPU rendering (Phong, Blinn-Phong)
% \end{itemize}

% \section{System Overview}
% Describe the architecture of your application:
% \begin{itemize}
%     \item Frontend framework (e.g., Three.js)
%     \item GPU volume loading and setup
%     \item User interaction model
% \end{itemize}

% \section{Methodology}
% \subsection{Raycasting in Volumetric Data}
% Explain ray formulation, traversal logic, and sampling schemes.


% \subsection{Cell-Based Analytic Isosurface Detection}
% Explain your cubic fitting using trilinear interpolation and how intersections are solved analytically.

% \subsection{Chebyshev Distance Maps for Empty Space Skipping}
% Detail how distance maps are computed and integrated into the rendering loop to optimize performance.

% \subsection{Illumination and Shading}
% Describe how you compute gradients and apply Blinn-Phong lighting, including edge-enhancement or gradient thresholding.

% \section{Implementation Details}
% \begin{itemize}
%     \item WebGL/Three.js shader design
%     \item Performance optimizations
%     \item Integration with user interface
% \end{itemize}

% \section{Results}
% \begin{itemize}
%     \item Rendering performance (frame rates, resolution)
%     \item Visual quality (edge clarity, lighting realism)
%     \item Sample screenshots or rendering comparisons
% \end{itemize}

% \section{Discussion}
% \begin{itemize}
%     \item Strengths of the method
%     \item Current limitations (e.g., preprocessing time, GPU requirements)
%     \item Potential applications (diagnostics, surgical planning)
% \end{itemize}

% \section{Conclusion and Future Work}
% Summarize contributions and highlight next steps:
% \begin{itemize}
%     \item Clinical trials, additional datasets
%     \item Support for segmentation overlays or annotations
%     \item Mobile or AR/VR integration
% \end{itemize}


\section{Isosurface Volumetric Rendering}

Volumetric data is represented as a scalar field sampled over a regular 3D grid and stored on the GPU as a 3D texture. Each voxel encodes a scalar value, such as density or intensity, and is accessed using normalized coordinates. This representation supports efficient memory access and enables hardware-accelerated trilinear interpolation during texture sampling.

A cell in this regular grid is defined as an axis-aligned cube formed by eight neighboring voxel values at its corners. Since the scalar field is defined only at discrete voxel positions, interpolation is required to estimate values within the cell volume. Given a sample point \((x, y, z)\) in grid coordinates, we decompose it into integer and fractional parts:
\[
x = i + \alpha, \quad y = j + \beta, \quad z = k + \gamma
\]
where \(i = \lfloor x \rfloor\), \(j = \lfloor y \rfloor\), \(k = \lfloor z \rfloor\), and \(\alpha, \beta, \gamma \in [0, 1]\) represent the relative position within the unit cell. The trilinear interpolated value is then computed as:
\begin{equation}
\begin{array}{l}
f_{\text{trilin}}(x, y, z) = f_{\text{trilin}}(i + \alpha, j + \beta, k + \gamma) =\\[2ex]
\hspace{1.5em} f[i, j, k] \cdot (1 - \alpha)(1 - \beta)(1 - \gamma) \; +\\[0.75ex]
\hspace{1.5em} f[i, j, k+1] \cdot (1 - \alpha)(1 - \beta)\gamma \; +\\[0.75ex]
\hspace{1.5em} f[i, j+1, k] \cdot (1 - \alpha)\beta(1 - \gamma) \; +\\[0.75ex]
\hspace{1.5em} f[i, j+1, k+1] \cdot (1 - \alpha)\beta\gamma \; +\\[0.75ex]
\hspace{1.5em} f[i+1, j, k] \cdot \alpha(1 - \beta)(1 - \gamma) \; +\\[0.75ex]
\hspace{1.5em} f[i+1, j, k+1] \cdot \alpha(1 - \beta)\gamma \; +\\[0.75ex]
\hspace{1.5em} f[i+1, j+1, k] \cdot \alpha\beta(1 - \gamma) \; +\\[0.75ex]
\hspace{1.5em} f[i+1, j+1, k+1] \cdot \alpha\beta\gamma
\end{array}
\end{equation}


This interpolation scheme is critical in volume rendering, where scalar values must often be retrieved at sub-voxel accuracy during ray traversal. Accurate interpolation reduces aliasing artifacts and improves surface continuity, which is essential for applications in medical imaging, where anatomical detail must be preserved.

In isosurface volume rendering, the goal is to extract and visualize a surface corresponding to a constant scalar value, referred to as the \textit{isovalue} \( f_{\text{iso}} \), embedded within the volume. This isosurface implicitly defines a 2D manifold in 3D space where the scalar field equals the isovalue. To locate this surface, a viewing ray is cast for each screen-space pixel, parameterized as \( \mathbf{r}(t) = \mathbf{c} + t\mathbf{d} \), where \( \mathbf{c} \) denotes the camera position and \( \mathbf{d} \) is a normalized direction vector. The ray traverses the volume to detect intersections with the isosurface, and determining these intersections with high accuracy is the central task of analytic reconstruction, which we discuss in the following section.

\section{Iso-surface Reconstruction}

We perform isosurface extraction by analytically computing ray–surface intersections within each cell, rather than relying on uniform sampling along the ray. Traditional approaches sample the scalar field at regular intervals and detect threshold crossings via sign changes. However, this presents a fundamental trade-off between accuracy and performance: small steps improve fidelity but increase cost, while large steps risk missing narrow features.

To address these trade-offs, we adopt a cell-based raycasting strategy with analytic isosurface detection. Rather than sampling uniformly along the ray, we traverse the volume using a discrete differential analyzer (DDA) algorithm, stepping from one intersected cell to the next. Within each cell, the scalar field is approximated using \textit{trilinear interpolation}, and the segment between the ray’s entry and exit points is sampled at four equidistant positions—the minimum required to reconstruct the scalar field along the ray. This method enables precise analytic detection of isosurface intersections, significantly enhancing anatomical accuracy while fixing the number of required samples.

To reconstruct the trilinear scalar field along the ray within a cell, we define a local parametric ray equation:
\begin{equation}
\boldsymbol{\rho}(\tau) = \mathbf{p}_{\text{entry}} (1 - \tau) + \mathbf{p}_{\text{exit}} \tau,
\label{eq:localcellray}
\end{equation}
where \( \mathbf{p}_{\text{entry}} \) and \( \mathbf{p}_{\text{exit}} \) denote the ray's entry and exit positions within the cell. Substituting \( \boldsymbol{\rho}(\tau) \) into the trilinear interpolation function yields a cubic polynomial in the ray parameter \( \tau \in [0, 1] \):
\begin{equation}
\phi_{\text{cubic}}(\tau) = f_{\text{trilin}}(\boldsymbol{\rho}(\tau)) = c_3 \tau^3 + c_2 \tau^2 + c_1 \tau + c_0.
\end{equation}

The coefficients \( c_0, c_1, c_2, c_3 \) are determined by solving a Vandermonde system based on four equidistant scalar field samples taken at \( \tau_1 = 0 \), \( \tau_2 = \tfrac{1}{3} \), \( \tau_3 = \tfrac{2}{3} \), and \( \tau_4 = 1 \):
\begin{equation}
\begin{bmatrix}
c_0 \\
c_1 \\
c_2 \\
c_3 \\
\end{bmatrix}
=
\begin{bmatrix}
1 & \tau_1 & \tau_1^2 & \tau_1^3 \\
1 & \tau_2 & \tau_2^2 & \tau_2^3 \\
1 & \tau_3 & \tau_3^2 & \tau_3^3 \\
1 & \tau_4 & \tau_4^2 & \tau_4^3 \\
\end{bmatrix}^{-1}
\begin{bmatrix}
f(\tau_1) \\
f(\tau_2) \\
f(\tau_3) \\
f(\tau_4) \\
\end{bmatrix}.
\end{equation}

This reconstructed polynomial is then solved analytically to find the smallest root \( \tau_{\text{iso}} \in [0,1] \) such that \( \phi_{\text{cubic}}(\tau_{\text{iso}}) = f_{\text{iso}} \), indicating a sub-cell isosurface intersection. The corresponding intersection point \( \mathbf{p}_{\text{iso}} \) is recovered by substituting \( \tau_{\text{iso}} \) into the local ray equation~\eqref{eq:localcellray}.

While this method provides high precision, it introduces computational overhead due to repeated cubic equation solving. To mitigate this, we first determine whether an intersection exists within the current segment by analyzing both the polynomial’s critical points—its local minima and maxima—and the equidistant scalar samples. We then apply the intermediate value theorem to check for a sign change within the interval. If a sign change is detected, a threshold crossing is guaranteed, and the full root-solving step is performed; otherwise, the segment is skipped. This reduces the task to a fast, quadratic-level check while preserving accuracy.

Additional efficiency is achieved by leveraging spatial coherence. Since adjacent cells along the ray share boundary faces, one scalar sample can be reused—reducing the number of new samples per cell to three without compromising accuracy. Moreover, the inverse Vandermonde matrix remains constant across cells and thus is computed only once, further minimizing reconstruction overhead.

Once a sign change is detected, the ray traversal is terminated to compute the precise sub-cell intersection point. One option is to use an efficient GPU implementation of \textit{Cardano’s method}, as proposed by Blinn~\cite{blinn2007solve}, followed by two Newton–Raphson refinement steps to improve numerical accuracy. While this approach performs well in general, it lacks robustness for degenerate or near-degenerate polynomials.

To address these limitations, we adopt the GPU polynomial root-finding method by Peters~\cite{peters2023ray}, which is an efficient GPU adaptation of the interval arithmetic solver introduced by Yuksel~\cite{yuksel2022fast}. This technique reliably approximates roots of high-degree polynomials, with arbitrary precision, making it particularly suitable for real-time isosurface renderings in high-precision medical visualization applications.

\section{Higher-Quality Iso-surface Reconstruction}

While trilinear interpolation offers a simple and hardware-accelerated approximation of the scalar field within a cell, it is limited in its ability to preserve smooth curvature and fine geometric detail, especially in high-gradient or thin regions. To address these limitations, we adopt a higher-order reconstruction strategy based on the method proposed by Csébfalvi~\cite{csebfalvi2019beyond}, which extends trilinear interpolation with second-order derivative corrections.

The core idea is to enhance the trilinear scalar field with three quadratic correction terms derived from the estimated second-order partial derivatives. Specifically, the scalar field is reconstructed as:
\begin{align}
\tilde{f}(x, y, z) = f_{\text{trilin}}(x, y, z)
& + s_{x}(x, y, z) \cdot (\alpha^2 - \alpha) / 2 \nonumber \\
& + s_{y}(x, y, z) \cdot (\beta^2 - \beta) / 2 \nonumber \\
& + s_{z}(x, y, z) \cdot (\gamma^2 - \gamma) / 2
\end{align}
where  \( s_{x}, s_{y}, s_{z} \) denote trilinearly interpolated second-order partial derivatives, respectively. The resulting interpolant achieves \( C^1 \) continuity and exhibits visual fidelity nearly equivalent to Catmull–Rom spline interpolation, while retaining compatibility with efficient GPU texture fetch operations.

To enable this, we preprocess the volume to compute and store the three partial second-order derivatives \( f_{xx}, f_{yy}, f_{zz} \) at each voxel center. This increases the volume’s memory footprint by a factor of four, but enables the entire reconstruction to be evaluated with a single four-component trilinear texture sample.  As a result, the corrected scalar field can be reconstructed efficiently during rendering.

As in the trilinear case, we sample the scalar field along the ray segment, now at 5 equidistant positions, to reconstruct the resulting quintic coefficients solving now a 6 degree Vandermonde system. Once the quintic polynomial is constructed, we follow the same analytic root-finding approach: we first test for the existence of an intersection using sign change analysis of the samples and critical points, and then apply the high-precision polynomial solver such as the from Peters~\cite{peters2023ray} to compute the sub-cell intersection point.

This improved reconstruction method enhances surface smoothness, reduces aliasing artifacts, and captures curvature more faithfully, particularly around complex anatomical structures. Because it maintains the same analytic framework as the trilinear method, our implementation can easily toggle between both modes depending on available memory and desired quality.


\section{Derivative Reconstruction}

\subsection{Gradient}

To compute the gradient vector $\mathbf{g}$ at the isosurface intersection, we adopt the triquadratic B-spline interpolation method proposed by Csébfalvi~\cite{csebfalvi2019beyond}, which provides a practical trade-off between accuracy and computational efficiency. The method yields smooth, analytically derived gradients that are $C^1$-continuous and requires only eight scalar samples, making it suitable for real-time rendering. The gradient is defined as:

\begin{equation}
\mathbf{g} =
\begin{bmatrix}
\frac{\partial f}{\partial x}, \;
\frac{\partial f}{\partial y}, \;
\frac{\partial f}{\partial z}
\end{bmatrix}^\top.
\end{equation}

In one dimension, the scalar field is reconstructed at a position $x = j + \beta$, where $j = \lfloor x + 0.5 \rfloor$ is the nearest voxel center and $\beta \in [-0.5, 0.5]$ is the local offset. The function value and its first derivative are computed using two linearly interpolated samples, weighted by quadratic B-spline-derived coefficients:

\begin{equation}
f_{\text{quad}}(x) = g_0(\beta) f_{\text{lin}}(x - \delta_0(\beta)) + g_1(\beta) f_{\text{lin}}(x + \delta_1(\beta)),
\label{eq:interpolation}
\end{equation}
\begin{equation}
f'_{\text{quad}}(x) = 2 \left[ f_{\text{lin}}(x + \delta_1(\beta)) - f_{\text{lin}}(x - \delta_0(\beta)) \right],
\label{eq:derivative}
\end{equation}

where
\begin{align}
\delta_0(\beta) &= 0.25 + 0.5\beta, &\quad g_0(\beta) &= 0.5 - \beta, \\
\delta_1(\beta) &= 0.25 - 0.5\beta, &\quad g_1(\beta) &= 0.5 + \beta.
\end{align}

This formulation generalizes to three dimensions via a separable tensor-product construction. Partial derivatives are computed along the axis of interest using the 1D derivative filter \eqref{eq:derivative}, while the other two axes are interpolated using quadratic B-spline weights \eqref{eq:interpolation}. This approach enables efficient reconstruction of the gradient $\mathbf{g}$ by reusing the same eight trilinear samples for the computation of each partial derivative.

\subsection{Hessian}

In addition to gradient computation, we reuse the same filtering scheme to estimate the mixed second-order partial derivatives that form the off-diagonal elements of the Hessian matrix $H$:
\begin{equation}
H =
\begin{bmatrix}
\frac{\partial^2 f}{\partial x^2} & \frac{\partial^2 f}{\partial x \partial y} & \frac{\partial^2 f}{\partial x \partial z} \\
\frac{\partial^2 f}{\partial y \partial x} & \frac{\partial^2 f}{\partial y^2} & \frac{\partial^2 f}{\partial y \partial z} \\
\frac{\partial^2 f}{\partial z \partial x} & \frac{\partial^2 f}{\partial z \partial y} & \frac{\partial^2 f}{\partial z^2}
\end{bmatrix}.
\end{equation}

The off-diagonal mixed derivatives are computed by applying the derivative filters~\eqref{eq:derivative} along two axes and the interpolation filter~\eqref{eq:interpolation} along the remaining axis, reusing the same eight trilinear samples and filter weights already employed for gradient estimation. This efficient reuse of data makes the process highly suitable for GPU implementation.

For the diagonal pure second-order derivatives of the Hessian matrix, the previously used B-spline-based approach is no longer applicable. Instead, these derivatives can be efficiently computed using a central differencing scheme applied at the isosurface intersection point $x$, using unit intervals, as described in GPUGems~\cite{engel2005gpugems2}:
\begin{equation}
f''(x) = f_{\text{lin}}(x - 1) - 2f_{\text{lin}}(x) + f_{\text{lin}}(x + 1).
\end{equation}

Together, the eight fetches used for tri-quadratic B-spline filtering of the gradient $\mathbf{g}$ and the mixed second-order derivatives, along with the six additional fetches for central differencing, enable a complete reconstruction of both $\mathbf{g}$ and the Hessian matrix $H$ at the isosurface intersection, with a total sampling cost of just 14 trilinear texture fetches.

A particularly valuable application of high-quality first- and second-order derivative information is the computation of implicit isosurface curvature. This curvature can be derived directly from the gradient $\mathbf{g}$ and the Hessian matrix $H$ of the scalar field, as described by Kindlmann et al.~\cite{kindlmann2003curvature}, The principal curvatrures can be used then for advanced shading effects.

\section{Shading}

After identifying the isosurface intersection point, we compute lighting using the Blinn-Phong model:
\[
I = k_a I_a + k_d I_l \max(\mathbf{n} \cdot \mathbf{l}, 0) + k_s I_l \max(\mathbf{n} \cdot \mathbf{h}, 0)^s
\]
where $\mathbf{n}$ is the surface normal, $\mathbf{l}$ the light vector, $\mathbf{v}$ the view vector, and $\mathbf{h}$ the halfway vector. The coefficients $k_a$, $k_d$, and $k_s$ control ambient, diffuse, and specular reflectance, with exponent $s$ controlling highlight sharpness.

To enhance structure perception, we suppress lighting in regions with low gradient magnitude and darken surfaces aligned with the view direction, emphasizing silhouette edges. These enhancements improve depth cues and help highlight anatomical boundaries for clinical interpretation.

\section{Illumination}

Once the intersection point on the isosurface is identified, we apply an illumination model to approximate the reflected light intensity. We use the Blinn-Phong local illumination model, which expresses the outgoing light as a combination of ambient, diffuse, and specular components. The illumination is computed as:
\[
I = k_a I_a + k_d I_l \max(\mathbf{n} \cdot \mathbf{l}, 0) + k_s I_l \max(\mathbf{n} \cdot \mathbf{h}, 0)^s
\]
where $\mathbf{n}$ is the surface normal, $\mathbf{l}$ the light vector, $\mathbf{v}$ the view vector, and $\mathbf{h}$ the halfway vector. The coefficients $k_a$, $k_d$, and $k_s$ control ambient, diffuse, and specular reflectance, with exponent $s$ controlling highlight sharpness.

The surface normal is estimated from the normalized gradient of the volume at the intersection point. If the dot product between the gradient and view direction is negative, the normal is inverted to ensure it consistently faces the viewer. Since gradients are unreliable in homogeneous regions, we suppress diffuse and specular lighting contributions where the gradient magnitude falls below a defined threshold (Kniss et al. 2002b), effectively enhancing contrast around anatomically relevant structures.

In addition, to improve shape perception, we darken regions where the surface normal aligns with the view direction, emphasizing silhouette edges. This accentuates anatomical features and boundaries, making the visualization more interpretable in clinical and research contexts.


\section{Empty Space Skipping}

To further accelerate ray traversal in sparse volumetric data, we employ an empty space skipping framework built upon two key acceleration structures: the \textit{occupancy map} and the \textit{distance map}. These structures enable rays to efficiently bypass empty regions by directing them toward potentially occupied areas, thus avoiding unnecessary analytic reconstructions and intersections in every cell along the way.

\subsection{Occupancy Map}

The occupancy map is a coarse binary volume that partitions the dataset into uniform blocks, each consisting of $B^3$ individual \textit{cells}. A block is marked as \textit{occupied} if the isovalue lies between the minimum and maximum voxel values within the block and its boundary. This condition is based on the continuity of trilinear interpolation, which computes convex combinations of the voxel values at cell corners. Due to this convexity, the extrema of the interpolated field are guaranteed to occur at the corners. Although these block extrema may belong to different cells, the scalar field remains continuous across cell boundaries. Therefore, if the isovalue lies within the block’s scalar range, it must be crossed somewhere inside the block, signaling the presence of an isosurface.

The occupancy map functions as a binary mask, enabling rays to efficiently bypass regions that are guaranteed not to contain any part of the isosurface. Additionally, it serves as the foundation for constructing more advanced acceleration structures that further optimize ray traversal. Because occupancy is defined relative to a specific isovalue, the map must be recomputed whenever the isovalue changes to maintain the accuracy of empty space skipping.

% To further constrain traversal to the relevant volume region, an axis-aligned bounding box (AABB) is extracted from the occupancy map. This bounding box defines the spatial extent of occupied regions, minimizing memory usage and avoiding unnecessary traversal outside the active dataset.

\subsection{Chebyshev Distance Maps}
The Chebyshev distance is a discrete metric defined as the maximum absolute difference between the coordinates of two points. For points $\mathbf{p}_1 = (x_1, y_1, z_1)$ and $\mathbf{p}_2 = (x_2, y_2, z_2)$, it is computed as:

\begin{equation}
D_{\text{Chebyshev}}(\mathbf{p}_1, \mathbf{p}_2) = \max \left( |x_1 - x_2|,\; |y_1 - y_2|,\; |z_1 - z_2| \right).
\end{equation}

This metric represents the minimum number of axis-aligned steps required to reach $\mathbf{p}_2$ from $\mathbf{p}_1$ on a uniform grid.

After constructing the occupancy map, we derive Chebyshev distance maps, which record, for each block, the distance to the nearest occupied block based on the Chebyshev metric. These maps enable rays to skip over multiple empty blocks efficiently, minimizing redundant computations while ensuring accurate isosurface detection.

We explore three variants of Chebyshev distance maps, each progressively increasing in spatial selectivity and memory usage:

\begin{itemize}
  \item \textbf{Isotropic Distance Map:} 
  Stores a single scalar per block, representing the maximum safe skip distance in all directions. This method is simple and compact but may be overly conservative in regions with directional sparsity.

 \item \textbf{Anisotropic Distance Map:} 
 Stores separate skip distances for each of the eight octants of 3D space. This directional awareness enables rays to advance more aggressively in sparse regions while avoiding premature exits in denser ones, offering a balanced trade-off between accuracy and overhead.
 
\item \textbf{Extended Anisotropic Distance Map:} 
Further refines spatial control by storing individual skip distances along the $x$, $y$, and $z$ axes for each octant. This approach allows for fine-grained, axis-specific traversal optimizations in highly anisotropic volumes. While the memory cost can reach up to 24 times that of the isotropic map, bit-packing strategies can reduce this overhead to approximately 16 times.

\end{itemize}

\subsection{Computation}

All acceleration structures are computed directly on the GPU using TensorFlow.js with WebGL support, enabling real-time performance in a browser-based environment. The input volume is first normalized to the range $[0,1]$ and reshaped into a 4D tensor suitable for TensorFlow operations. To balance memory efficiency with rendering performance, the volume is partitioned into blocks of size $B = 4$ cells. Each block is reduced to two 4D tensors that store its minimum and maximum voxel values. After this reduction, the original volume tensor is released from GPU memory to optimize resource usage. The resulting extrema tensors are reused for efficient, dynamic computation of occupancy and distance maps whenever the isovalue threshold changes.

\vspace{0.5em}
\noindent\textbf{Occupancy Map:} \\
The occupancy map is computed by evaluating whether the isovalue lies within the scalar range defined by each block’s minimum and maximum values. Blocks satisfying this condition are marked as occupied; others are considered empty. The result is a binary mask tensor that serves as the basis for subsequent distance map computations.

\vspace{0.5em}
\noindent\textbf{Distance Maps:}
\begin{itemize}
\item \textit{Isotropic:} 
Constructed via iterative wavefront propagation starting from occupied blocks initialized at distance zero. The binary frontier is expanded at each step using 3D max pooling with a \(3 \times 3 \times 3\) kernel. Newly reached empty blocks are assigned incrementally increasing distances, up to a maximum of 255 blocks. The final scalar field encodes the shortest isotropic distance to the nearest occupied block and is uploaded as a 3D texture in unsigned byte format.

\item \textit{Anisotropic:} 
Built using the same wavefront propagation strategy, but computed independently for each of the eight principal ray directions (octants). Each direction employs \(2 \times 2 \times 2\) max pooling to capture direction-specific skip distances. The resulting eight maps are concatenated along the depth axis to form a unified anisotropic distance tensor, uploaded as a direction-aware 3D texture in unsigned byte format.

\item \textit{Extended Anisotropic:} 
This variant extends the anisotropic approach by computing independent skip distances along the $x$, $y$, and $z$ axes for each of the eight ray octants. Wavefront expansion is carried out separately for each direction using custom $2 \times 2 \times 2$ convolution kernels tailored for axis-specific propagation. Each octant yields three scalar fields representing the number of empty blocks a ray can skip along each axis. These distances are then compactly encoded into a 16-bit format using a $5\text{-}5\text{-}5\text{-}1$ layout, where 5 bits per axis allow for a maximum skip distance of 31 blocks—more than sufficient for the chosen block size of $B = 4$ cells. The remaining bit is used as an occupancy flag. The packed distance fields are concatenated along the depth axis to produce a unified 3D texture in unsigned short format.

\end{itemize}

\section{Iso-surface Reconstruction With Empty Space Skipping}

To accelerate performance beyond analytic raymarching, we introduce a hierarchical traversal strategy guided by precomputed Chebyshev distance maps to enable efficient empty space skipping.

The ray traversal proceeds in fixed-size iterations, alternating between two stages: block skipping and cell traversal. Each iteration begins by sampling the distance map to retrieve axis-aligned skip distances, which define a conservative bounding box around a candidate block. A ray–box intersection test determines the block's entry and exit points, and the ray then advances accordingly. If no potentially occupied block is encountered, the cell traversal stage is skipped, and the next iteration begins.

When the ray intersects a potentially occupied block, it transitions to cell traversal, using the previously described analytic reconstruction method. The ray marches through the block’s individual cells, reconstructing the scalar field and testing for isosurface intersections. If a crossing is detected, the marching terminates; otherwise, the loop proceeds to the next iteration, starting again with block skipping.

This distance map–driven hierarchical traversal significantly reduces redundant sampling, preserves precise surface localization, and ensures coherent control flow—well-suited for GPU execution. By minimizing divergence and enabling early exits, it yields a scalable, real-time rendering pipeline optimized for both sparse and anatomically detailed volumetric datasets.

\begin{lstlisting}[
  language=GLSL,
  caption={Compact hierarchical ray traversal pseudocode using distance-guided skipping and cell-level marching.},
  label=lst:raymarch,
  basicstyle=\ttfamily\footnotesize,
  lineskip=-1pt,
  numbers=none
]
for (int i = 0; i < MAX_ITERS; i++) 
{
  // Block-level skipping using distance map
  for (int b = 0; b < MAX_BLOCKS; b++) 
  {
    // Sample distance map, skip empty blocks
    updateBlock();  
    if (block.occupied || block.terminated)
      break;
  }

  // Skip to next iteration if no hit
  if (!block.occupied && !block.terminated)
    continue;

  // Begin marching at occupied block
  beginCell();

  // Analytic cell-level traversal
  for (int c = 0; c < MAX_CELLS; c++) 
  {
    // Reconstruct scalar field, test intersection
    updateCell();  
    if (cell.hit || cell.terminated || 
        cell.exit > block.exit)
      break;
  }

  // Terminate if surface hit or aborted
  if (cell.hit || cell.terminated)
    break;
}
\end{lstlisting}

\section*{ACKNOWLEDGMENT}

This work has received funding from the European Union's Horizon Research and Innovation Programme under Grant Agreement No 101080430 "AI4HF". We would like to thank the "AI4HF" consortium members for supporting this work. 

% References
\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
